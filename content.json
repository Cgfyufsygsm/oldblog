{"meta":{"title":"YangTY's Blog","subtitle":null,"description":null,"author":"YangTY","url":"https://old.blog.imyangty.com","root":"/"},"pages":[{"title":"","date":"2022-03-22T13:43:27.150Z","updated":"2022-03-22T13:43:27.150Z","comments":true,"path":"404.html","permalink":"https://old.blog.imyangty.com/404.html","excerpt":"","text":"很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-03-19T23:49:32.746Z","updated":"2022-03-19T23:49:32.746Z","comments":true,"path":"about/index.html","permalink":"https://old.blog.imyangty.com/about/index.html","excerpt":"","text":"个人资料 姓名：Taoyu Yang 学校：贵阳市第一中学 年级：高二 职业：半退役 OIer QQ：375836877 洛谷：U212488 Codeforces： AtCoder：YangTY 其他乱七八糟的 菜的一批（（（ 本 blog 主要记录一些算法竞赛相关的东西（暂时的）。关于一些零零碎碎的杂七杂八的东西可以访问主站。 本 blog 托管在 Github Pages，使用 hexo 搭建；主站托管在老薛主机上，平台为 Wordpress。 将本站迁移到了虚拟主机的子空间，提升访问速度以及 SEO。"},{"title":"所有分类","date":"2021-12-15T15:26:03.834Z","updated":"2021-12-15T15:26:03.834Z","comments":true,"path":"categories/index.html","permalink":"https://old.blog.imyangty.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-12-15T15:26:03.835Z","updated":"2021-12-15T15:26:03.835Z","comments":true,"path":"tags/index.html","permalink":"https://old.blog.imyangty.com/tags/index.html","excerpt":"","text":""},{"title":"Friend Links","date":"2021-12-15T15:26:03.835Z","updated":"2021-12-15T15:26:03.835Z","comments":true,"path":"friends/index.html","permalink":"https://old.blog.imyangty.com/friends/index.html","excerpt":"","text":"欢迎加友链qwq"}],"posts":[{"title":"本站导航","slug":"idx","date":"2022-06-12T04:33:24.000Z","updated":"2022-03-23T04:06:59.123Z","comments":true,"path":"idx/","link":"","permalink":"https://old.blog.imyangty.com/idx/","excerpt":"","text":"前言 你好，陌生人，这里是菜鸡 OIer YangTY。详细资料可以看关于页面。 该页面将列出一些比较值得看的文章（雾）。可能会出现写作时间跨度过大以至码风不一样的情况，但不影响阅读。 学习笔记 如果发现有什么错误，欢迎在 QQ 上爆 D 我/kk。 2022 省选 / NOI 复习笔记 持续更新中，如果没进省队这部分就烂尾。 数据结构 数据结构复习 0 （基础数据结构） 数据结构复习 1 （简单树形数据结构） 数据结构复习 2 （高维问题） 数据结构复习 3（树上信息维护） 数据结构复习 4（根号数据结构） 数学 组合数学复习笔记 数论复习笔记 线性代数复习笔记 没写 计算几何 没学 字符串 没写 动态规划 没写 图论与网络流 图论复习 1（图论基础知识） 图论复习 2（高级图论） 图论复习 3（二分图与网络流） 图论复习 4（图论与线性代数） 数据结构 我的数据结构学的可烂了/kk。 新学算法笔记： 平衡树笔记：写了三种主流平衡树的写法以及详细实现。 李超树：基本更新完毕。 Link-Cut Tree：LCT，实现已更新完，目前施工应用中。 DP 根本不会 dp，下面的看看就行。 斜率优化：基本完结。 动态 dp：动态 dp 的入门教程。 决策单调性 DP：还没学懂，日。 数学 数学推导能力=0。 大型总结类文章： 组合数学：正在更新。 线性代数：填。 简单数论：正在更新。 多项式合集：多项式全家桶，目前基本施工完毕。 新学算法笔记： Lucas 定理学习笔记：已投稿洛谷日报，Lucas 定理相关。 类欧几里得算法：类欧，基本施工完毕。 群计数相关：基本完结。 图论 二分图/网络流：意识流。 连通性相关：圆方树没补完。 字符串 后缀数组：后缀数组的实现已经更完，目前施工应用中。 后缀自动机：更新应用中。 杂项 STL：咕咕咕。 计算几何：新坑。 套题题解 Codeforces 比赛日记：比赛/VP 记录。 AtCoder 比赛日记：比赛/VP 记录。 CSP-J 2019：CSP-J 2019 题解。 CSP-S 2019：CSP-S 2019 题解。 CSP-J 2020：CSP-J 2020 题解。 施工中 CSP-S 2020：CSP-S 2020 题解。 施工中 NOIP2020：NOIP2020 题解。 施工中 联合省选 2020：省选 2020 题解。 施工中 联合省选 2021：省选 2021 题解。 施工中 历年 NOIP 真题选做：补题。 施工中 NOI Online 选做：补题。 一些碎碎念 都是游记之类的吧，写的挺不好的（语文很差）。 NOIOL 2020 2 初三的时候写的奇奇怪怪的东西吧。 中考 唯一稍微成功上岸的考试吧。 CSP-S2020 第一次提高组的 CSP，失败。 NOIP2020 第一次 NOIP，十分失败。 WC2021 第一次 WC，线上的，仍是失败，但是居然有 Cu GZOI2021 第一次省选，失败，去世。 CSP-S2021 取消了（笑）。","categories":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/categories/site-issue/"}],"tags":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/tags/site-issue/"}]},{"title":"P3211 [HNOI2011]XOR和路径","slug":"sol-luogu-p3211","date":"2022-04-13T01:35:03.000Z","updated":"2022-04-13T02:50:09.631Z","comments":true,"path":"sol-luogu-p3211/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3211/","excerpt":"","text":"Description 边带权 n\\le 100 无向图，从 1 开始随机游走，问走到 n 的路径的 xor 和的期望，有自环重边。 Solution 根据期望的线性性，然后又有个异或，所以可以拆位做。 然后现在假设考虑第 k 位，那么就编一个状态： f_{i, 0/1} 表示到达点 i 时这一位有/无贡献的期望经过次数。那么有转移： f_{u, j} = \\sum_{(u,v)\\in E}\\frac{1}{d_v}f_{v, w(u,v) - j} f_{1, 0} 的最后加一个常数项 1 因为一开始就在 1 。 那么 \\sum 2^k f_{n, 1} 即为答案。 Implementation 需要注意， n 不能往别的节点贡献，建矩阵的时候需要判定好。 以及，自环对度数的贡献是 1 （虽然我也不知道为什么，可以参考样例），也要特判。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using db = long double;const int maxn = 105;int n, m, deg[maxn];vector&lt;pair&lt;int, int&gt;&gt; G[maxn];db a[maxn &lt;&lt; 1][maxn &lt;&lt; 1];void gauss(int n) { FOR(i, 1, n) { int r = i; FOR(j, i, n) if (fabs(a[j][i]) &gt; fabs(a[r][i])) r = j; swap(a[r], a[i]); FOR(j, 1, n) if (i != j) { db div = a[j][i] / a[i][i]; FOR(k, i + 1, n + 1) a[j][k] -= div * a[i][k]; } } FOR(i, 1, n) a[i][n + 1] /= a[i][i]; return;}void build(int k) { memset(a, 0, sizeof a); static auto f = [](int i, int j) {return i + j * n;}; FOR(i, 1, n) FOR(j, 0, 1) { a[f(i, j)][f(i, j)] = -1; for (auto &amp;e : G[i]) if (e.first != n) { int c = (e.second &gt;&gt; k) &amp; 1; a[f(i, j)][f(e.first, j ^ c)] += 1.0 / deg[e.first]; } } a[f(1, 0)][n &lt;&lt; 1 | 1] = -1; return;}int main() { cin &gt;&gt; n &gt;&gt; m; FOR(i, 1, m) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; if (u == v &amp;&amp; u == n) continue; else if (u == v) G[u].push_back({u, w}), ++deg[u]; else ++deg[u], ++deg[v], G[u].push_back({v, w}), G[v].push_back({u, w}); } db ans = 0; FOR(k, 0, 30) { build(k); gauss(n &lt;&lt; 1); ans += (1 &lt;&lt; k) * a[n &lt;&lt; 1][n &lt;&lt; 1 | 1]; } cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"高斯消元","slug":"gauss-elimination","permalink":"https://old.blog.imyangty.com/tags/gauss-elimination/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF113D Museum","slug":"sol-cf113d","date":"2022-04-13T00:32:14.000Z","updated":"2022-04-13T01:34:10.993Z","comments":true,"path":"sol-cf113d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf113d/","excerpt":"","text":"Description n\\le 22 个点的无向图，两人初始分别位于点 a 和 b 。两人随机游走，每个单位时间，在每个点处有 p_i 的概率停留，有 1 - p_i 的概率随机前往相邻点。两者在同一个点相遇时结束。 对每个点询问其停在对应房间的概率。 Solution 回顾当只有一个人的时候，求停在每个点的概率相当于是求每个点的期望次数。 回到本题，由于点数很小，所以可以考虑将两个人的状态同时考虑进去，设 f_{i,j} 表示两人分别位于 (i, j) 状态的期望经过次数。则由于 (i, i) 至多经过一次，所以 f_{i,i} 即为答案。 可以写出转移方程： f_{i,j} = \\sum_{(i,a)\\in E}\\sum_{(j,b)\\in E} \\frac{(1 - p_a)}{d_a}\\frac{(1 - p_b)}{d_b}f_{a,b} + \\sum_{(i,a)\\in E}\\frac{1-p_a}{d_a}p_jf_{a,j} + \\sum_{(j,b)\\in E} \\frac{1-p_b}{d_b}p_if_{i,b} + p_ip_jf_{i,j} 对于初始的 f_{a,b} 还需要加一个常数 1 。 于是直接高斯消元即可，时间复杂度 O(n^6) 。 Implementation 在处理转移的时候一定要注意细节。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using db = long double;db p[25], f[505][505];int deg[25], G[25][25], n, m, sa, sb;inline int encode(int i, int j) {return (i - 1) * n + j;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; sa &gt;&gt; sb; FOR(i, 1, m) { int u, v; cin &gt;&gt; u &gt;&gt; v; ++deg[u], ++deg[v], G[u][v] = G[v][u] = 1; } FOR(i, 1, n) cin &gt;&gt; p[i]; FOR(i, 1, n) { FOR(j, 1, n) { f[encode(i, j)][encode(i, j)] = -1; if (i != j) f[encode(i, j)][encode(i, j)] += p[i] * p[j]; FOR(a, 1, n) if (G[a][i]) { FOR(b, 1, n) if (G[b][j] &amp;&amp; a != b) { f[encode(i, j)][encode(a, b)] += (1 - p[a]) * (1 - p[b]) / deg[a] / deg[b]; } } FOR(a, 1, n) if (a != j &amp;&amp; G[a][i]) f[encode(i, j)][encode(a, j)] += (1 - p[a]) / deg[a] * p[j]; FOR(b, 1, n) if (b != i &amp;&amp; G[b][j]) f[encode(i, j)][encode(i, b)] += (1 - p[b]) / deg[b] * p[i]; } } int tot = encode(n, n); f[encode(sa, sb)][tot + 1] = -1; FOR(i, 1, tot) { int r = i; FOR(j, i + 1, tot) if (fabs(f[j][i]) &gt; fabs(f[r][i])) r = j; swap(f[i], f[r]); FOR(j, 1, tot) if (j != i) { db div = f[j][i] / f[i][i]; FOR(k, i + 1, tot + 1) f[j][k] -= div * f[i][k]; } } cout &lt;&lt; fixed &lt;&lt; setprecision(12); FOR(i, 1, n) cout &lt;&lt; f[encode(i, i)][tot + 1] / f[encode(i, i)][encode(i, i)] &lt;&lt; ' '; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"高斯消元","slug":"gauss-elimination","permalink":"https://old.blog.imyangty.com/tags/gauss-elimination/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"线性基学习笔记","slug":"note-linear-basis","date":"2022-04-10T11:29:14.000Z","updated":"2022-04-13T03:51:21.017Z","comments":true,"path":"note-linear-basis/","link":"","permalink":"https://old.blog.imyangty.com/note-linear-basis/","excerpt":"","text":"前言 由于快要省选了但还是不会线性基所以来紧急营业了（悲） OI 中线性基用来处理一类和异或有关的问题。 线代基础 向量空间：给定域 F ， F 上的向量空间 V 是一个集合，上定义了数乘和加法运算： +:V+V\\to V ，将 V 中的一个元素 \\mathbf u 和一个元素 \\mathbf v 映射到 V 中另一个元素，记作 \\mathbf u + \\mathbf v 。 \\cdot: F\\times V\\to V ，将 F 中一个元素 a 和 V 中一个元素 \\mathbf v 变成 V 中另一个元素，记作 a\\cdot \\mathbf v 。 F 的元素称为标量， V 中的元素称为向量。且 + 和 \\cdot 运算需满足八条公理。 对于向量空间 V 上的 n 个元素的向量组 S=(\\mathbf v_1, \\cdots, \\mathbf v_n) ，其线性组合是如下形式的向量： a_1\\mathbf v_1 + \\cdots + a_n\\mathbf v_n 其中 a_i\\in F 。 若存在不全为 0 的 a_i 使得 a_1\\mathbf v_1 + \\cdots + a_n\\mathbf v_n = 0 ，则称该向量组线性相关，否则线性无关。 最直观的理解就是线性相关即为各个向量不“独立”， \\mathbf v_i 可以通过 S 去掉 \\mathbf v_i 后剩余的向量线性组合得到。 对于向量组 (\\mathbf v_1,\\cdots,\\mathbf v_n) ，其所有线性组合构成的集合被称为 (\\mathbf v_1,\\cdots, \\mathbf v_n) 的张成，记作 \\operatorname{span}(\\mathbf v_1,\\cdots \\mathbf v_n) 。 注意到一组线性相关的向量，去掉一个后张成空间不变。 若 V 中的向量组 \\mathfrak B 既线性无关又能张成 V ，则称其为 V 的一组基底。 基有如下性质： V 是 \\mathfrak B 的极小生成集，就是说只有 \\mathfrak B 能生成 V ，而它的任何真子集都不能生成全部的向量空间。 \\mathfrak B 是 V 中线性无关向量的极大集合，就是说 \\mathfrak B 在 V 中是线性无关集合，而且 V 中没有其他线性无关集合包含它作为真子集。 V 中所有的向量都可以按唯一的方式表达为 \\mathfrak B 中向量的线性组合。如果基是有序的，则在这个线性组合中的系数提供了这个向量关于这个基的坐标。 线性相关性引理：若 V 中的向量组 (\\mathbf v_1,\\cdots,\\mathbf v_n) 线性相关，且 \\mathbf v_1\\ne \\mathbf 0 ，则至少有一个 j\\in\\{2,\\cdots, n\\} 使得下列成立： \\mathbf v_j\\in \\mathrm{span}(\\mathbf v_1,\\cdots, \\mathbf v_{j - 1}) 。 若去掉 \\mathbf v_j ，则剩余向量的张成仍为 V 。 简证：考虑到其线性相关且 \\mathbf v_1\\ne \\mathbf 0 ，故存在 a_i\\in F 使得 \\sum \\mathbf a_iv_i = \\mathbf 0 ，并且 a_2,\\cdots a_n 不全为 0 ，设 j 为 \\{2,\\cdots, n\\} 中最大的满足 a_j\\ne 0 的 j ，则一定有 \\mathbf v_j = -\\displaystyle\\sum_{k=0}^{j - 1}\\frac{a_k}{a_j}\\mathbf v_k ，第一条得证。设 \\mathbf u\\in \\mathrm{span}(\\mathbf v_1,\\cdots v_n) ，那么一定有 a_i\\in F 使得 \\mathbf u = \\sum a_i\\mathbf v_i ，将该式中的 v_j 替换掉即证明了第二条。 OI 中的线性基 简介 对于一个数 a_i ，我们将其二进制表示 \\left(\\overline{b_m\\cdots b_1b_0}\\right)_2 看作一个向量 \\mathbf a_i = (b_m,\\cdots, b_0) 。而若此处我们定义的“加法”运算为异或运算，则这些 \\mathbf a_i 可以张成一个向量空间 V = (\\{0, 1\\}, \\mathrm{span}\\mathbf a_1,\\cdots \\mathbf a_n), \\oplus, \\cdot) 。OI 中的线性基一般就指 V 的基。 求法 我们考虑从 \\mathfrak B = (\\mathbf a_1,\\cdots, \\mathbf a_n) 开始。 首先去掉 \\mathfrak B 中所有的 \\mathbf 0 。 然后依次枚举 j ，若 \\mathbf a_j\\in \\mathrm{span}(\\mathbf a_1,\\cdots \\mathbf a_{j - 1}) 则删去 \\mathbf a_j 。 由于每次去掉的都是包含于前面向量的张成，所以最后的 \\mathfrak B 仍然可以张成 V ，并且其确保了 \\mathfrak B 中任意向量不包含于前面诸向量的张成，故根据线性相关性引理， \\mathfrak B 线性无关。所以 \\mathfrak B 为 V 的一组基。 判断一个向量能不能被前面诸向量张成的过程可以使用高斯消元。来看下人类智慧程序： 12345678910111213141516void solve() { FOR(i, 0, n - 1) { DEC(j, LG, 0) { if ((a[i] &gt;&gt; j) &amp; 1) { if (b[j]) a[i] ^= b[j]; // 1 else { b[j] = a[i]; DEC(k, j - 1, 0) if (b[k] &amp;&amp; ((b[j] &gt;&gt; k) &amp; 1)) b[j] ^= b[k]; FOR(k, j + 1, LG) if ((b[k] &gt;&gt; j) &amp; 1) b[k] ^= b[j]; break; } } } }} 他是非常巧妙的。我们相当于维护对角矩阵。执行到第 i 步的时候： 首先从高到低枚举 a_i 的二进制位 j ，当这一位为 1 时考虑这一行： 若 j 这行的对角线处元素已经为 1 了，相当于我们不能在这里加入，同时为了维护三角性质，需要将第 j 行的向量异或给 \\mathbf a_i ，见代码的第 1 处注释。 若 j 这行的对角线处为 0 ，那么就可以将 \\mathbf a_i 添加到这一行，为了维护对角矩阵，需要拿下面的行消自己，然后拿自己消上面的行。 若 \\mathbf a_i 能被某些已有向量张成，则其最后一定会被消成 0 ，反之其一定找得到一行加进去。 我们举个例子：设 n = 5 ， A = (7, 1, 6, 2, 3) ，一开始的矩阵是这样的： \\begin{bmatrix} 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 \\end{bmatrix} 加入 7 = (111)_2 ，发现第 2 位为最高的有值的位： \\begin{bmatrix} 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix} 加入 1 = (001)_2 ，发现第 0 位为最高的有值的位，同时要将 1 异或给 7 ： \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 1 \\end{bmatrix} 尝试加入 6 = (110)_2 ，发现在第二行就被消成 0 了，加不进去。 加入 2 = (010)_2 ，发现第 1 位为最高位，加进去并消元： \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} 剩下的数字都加不上了。 这就是 OI 中的“线性基”，即上述过程高斯消元消出的对角阵的非 0 行构成的向量组，下面讨论其性质和应用。 性质 如果第 i 位对应的行的对角线元素为 1 ，则称第 i 位存在于线性基中。对于存在于线性基中的每个位，有如下性质： 至多只有一个 \\mathbf b_j 满足第 i 位为 1 。 证明：高消的过程中 \\mathbf b_j 一定将其他行的第 i 位消去。 所以对于不在线性基中的位 i ，那么第 i 行主对角上方一定全为 0 ，而下方有可能有若干 1 （参见上例）。 线性基不支持删除操作。 仔细想想构造过程就知道这个东西很不好删除元素。但是可以利用线段树分治之类的离线方法来处理带删除的情况。 市面上常见的另一种构造方法 123456789void insert(ll x) { DEC(i, LG, 0) { if (!(x &gt;&gt; (ll)i)) continue; if (!a[i]) a[i] = x; x ^= a[i]; } return;} 啊，注意到这样消出来的矩阵会是个三角矩阵而不是对角矩阵。所以某些对角矩阵的性质其是不满足的，下面遇到例题的时候讲解。 应用 P3265 [JLOI2015]装备购买 传送门，本题不是异或线性基而是普通的实数线性基。给定 n 个实数向量和其价格，求一个总价最小的基。 先将所有向量按照价格排序，然后依次插入即可。用高斯消元判断当前向量能否被之前的张成。 P3857 [TJOI2008]彩灯 传送门，题意转化后发现灯的状态可以看作一个二进制整数，而一个开关相当于是将状态异或上另一个二进制数，问最后能达到多少种状态。 板的不能再板，注意到包含 m 个元素的线性基能异或出来 2^m - 1 个数，但是不包括 0 ，算上 0 就是 2^m -1 ，注意取模即可。 P4301 [CQOI2013] 新Nim游戏 传送门，Nim 游戏，但是正式开始前先手先取走任意堆，后手再取走任意堆（注意不能取完），求一个先手必胜的策略并满足开始前先手取的石子总个数尽量小。 Nim 游戏要求的必胜策略是 \\bigoplus a_i\\ne 0 ，而先手要干的实际就是构造出一个局面使得剩下的 a_i 异或不出 0 。这个过程可以用线性基来做，即插入元素的时候若插入不成功（最后变成 0 ），则这个数就是要被选走的。 具体地，从大到小贪心插入元素，因为可以尽可能让小的元素被选。贪心的正确性证明可以使用拟阵（我不会，咕）。 洛谷 P3812 【模板】线性基 传送门，题意是给定 n 个 &lt; 2^{50} 的整数，求其能异或出来的最大值。 若我们是消出的对角矩阵，则直接将线性基内每个元素异或起来即可。简证：最高的二进制位只存在于最大的基向量上，然后归纳证明：假设前 i 大的都要选，考虑第 i + 1 大的选不选。首先显然根据对角阵的性质，第 i + 1 大的一定能贡献其最高的二进制位 j ，而若不选的话之后的数肯定都不能给第 j 位贡献，所以一定要选。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;using ll = long long;const int LG = 53;ll a[LG + 5];void insert(ll x) { DEC(j, LG, 0) { if ((x &gt;&gt; j) &amp; 1) { if (a[j]) x ^= a[j]; else { a[j] = x; DEC(k, j - 1, 0) if (a[k] &amp;&amp; ((a[j] &gt;&gt; k) &amp; 1)) a[j] ^= a[k]; FOR(k, j + 1, LG) if ((a[k] &gt;&gt; j) &amp; 1) a[k] ^= a[j]; break; } } } return;}int main() { int n; cin &gt;&gt; n; FOR(i, 1, n) { ll x; cin &gt;&gt; x; insert(x); } ll ans = 0; FOR(i, 0, LG) ans ^= a[i]; cout &lt;&lt; ans &lt;&lt; endl; return 0;} 但若是用另一种消成三角阵的写法的话就不能简单将全部元素异或起来了。因为不能保证第 i 大的向量一定能对其最高位贡献（最高位可能在前面 i - 1 大的向量中被贡献到），但是仍然可以通过一个简单的贪心来实现： 123456789101112131415161718192021ll n, a[maxk];void insert(ll x) { DEC(i, 53, 0) { if (!(x &gt;&gt; (ll)i)) continue; if (!a[i]) a[i] = x; x ^= a[i]; } return;}int main() { n = read(); FOR(i, 1, n) insert(read()); ll ans = 0; DEC(i, 53, 0) if ((ans ^ a[i]) &gt; ans) ans ^= a[i]; // 简单小贪心 printf(\"%lld\\n\", ans); return 0;} HDU3949 XOR 多测 T\\le 30 。给定 n\\le 10000 个数 1\\le a_i\\le 10^{18} ， q 次查询 k 小异或和。 首先是特判 0 ，由于我们线性基定义的“能异或出的数中”不包含 0 ，所以需要在插入的时候特判一下能否异或出 0 （实际上若最后基的元素个数 \\ne n 也相当于是能异或出 0 ）。然后若线性基内含 m 个元素，根据 V 任意一个向量都能用基底唯一线性组合出来的性质，能异或出来的数一共有 2^{|m|} - 1 种，依据此判断无解。 那么实际上，若将基向量从小到大记为 \\mathfrak B = (\\mathbf v_0,\\cdots \\mathbf v_{m - 1}) ，则第 k = \\left(\\overline{b_x\\cdots b_0}\\right)_2 小的异或和（假定存在）即为 \\bigoplus_{i=0}^xb_i\\cdot \\mathbf v_i 用二进制思想不难证明。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;using ll = long long;const int LG = 62;ll a[LG + 5];int cnt;void insert(ll x) { DEC(j, LG, 0) { if ((x &gt;&gt; j) &amp; 1) { if (a[j]) x ^= a[j]; else { a[j] = x; DEC(k, j - 1, 0) if (a[k] &amp;&amp; ((a[j] &gt;&gt; k) &amp; 1)) a[j] ^= a[k]; FOR(k, j + 1, LG) if ((a[k] &gt;&gt; j) &amp; 1) a[k] ^= a[j]; break; } } } return;}ll kth(ll k) { if (k &gt;= (1ll &lt;&lt; cnt)) return -1; ll ans = 0; FOR(i, 0, LG) if (k &amp; (1ll &lt;&lt; i)) ans ^= a[i]; return ans;}int main() { int T; cin &gt;&gt; T; FOR(kase, 1, T) { cout &lt;&lt; \"Case #\" &lt;&lt; kase &lt;&lt; \":\\n\"; int n; cin &gt;&gt; n; cnt = 0, memset(a, 0, sizeof a); FOR(i, 1, n) { ll x; cin &gt;&gt; x; insert(x); } FOR(i, 0, LG) if (a[i]) a[cnt++] = a[i]; int q; cin &gt;&gt; q; while (q--) { ll k; cin &gt;&gt; k; cout &lt;&lt; kth(k - (cnt != n)) &lt;&lt; endl; } } return 0;} 洛谷 P4151 [WC2011]最大XOR和路径 传送门，给定 n\\le 50000 点 m\\le 10^5 边无向边带 \\le 10^{18} 权图，求一条从 1 到 n 的最大 xor 和路径，一条边可以经过多次，相应地，也要多次被异或起来。 比较牛逼的思路。首先我们可以考虑到，每个环的贡献是可以单独累加的，因为可以从 1 出发，走到环上，绕一圈，再原路返回，所以我们可以看作先绕若干环再从 1 走一条链到 n 。 而实际上随便找一条 1 到 n 的路径就行了，因为若其不是最优的，那么最优路径和他一定形成有环，这部分贡献一样能被统计。 处理环，然后将环的异或和插入线性基，相当于是拿 s 然后问异或 s 出来的最大异或和，直接按位贪心。 但是需要注意我们肯定不是暴力找所有的环，而是利用 dfs 树，注意到若干树边和一条返祖边构成的环可以形成“环的基底”，一个复杂环可以通过这些简单环的“异或”（即取边集并再去掉边集交）得到。 洛谷 P3292 [SCOI2016]幸运数字 传送门， n\\le 2\\times 10^4 个点的树，点带权 \\le 2^{60} ， q\\le 2\\times 10^5 次询问 (x,y) 路径上点权的最大异或和。 首先我们需要知道，单次线性基的合并是 O(\\log^2V) 的 第一眼可以树剖， O((n+q)\\log^2n\\log^2V) ，有点紧而且没必要。 然后可以倍增， O((n+q)\\log n\\log^2V) ，但是仍然不是最优秀的做法。 路径问题考虑点分治，在每个根节点处合并 LCA 为根的答案，这样就只会将两个线性基合并。在这之前需要 O(n\\log V) 将根到子树中每一个点的线性基求出来，所以时间复杂度为 O(n\\log n\\log V + q\\log^2V) ，应该是最优秀的复杂度。 洛谷 P4869 albus就是要第一个出场 传送门，给定正整数序列 A ，令 S = \\{x\\mid 1\\le x\\le n\\} ，定义 S 的幂集 2^S 为 S 的所有子集的集合。定义映射 f:2^S\\to \\mathbb Z ，其中 f(\\varnothing) = 0 ， f(T) = \\bigoplus_{t\\in T}A_t 。 将 2^S 中每个集合的 f 值计算起来并从小到大排序，记为序列 B ，问整数 Q 第一次在 B 中出现的下标。 首先把所有数字塞进线性基是可以得到 2^{|\\mathfrak B|} 个不同数字的，现在压力给到如何求出每个数的出现次数。 结论：每个数字会出现 2^{n - |\\mathfrak B|} 次。简证：考虑每个能被异或出来的数 v ，对于不在线性基内的 n - |\\mathfrak B| 个元素，有 2^{n - |\\mathfrak B|} 种选法，而我们总可以通过在 \\mathfrak B 中选数来摆平他，得证。 所以这题就解决啦： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;const int LG = 30, mod = 10086;int p[LG + 5], n, cnt, rnk, q;void insert(int x) { DEC(j, LG, 0) if ((x &gt;&gt; j) &amp; 1) { if (!p[j]) { p[j] = x, ++cnt; break; } else x ^= p[j]; } return;}int qPow(int base, int exp) { int ret = 1; for (; exp; base = 1ll * base * base % mod, exp &gt;&gt;= 1) if (exp &amp; 1) ret = 1ll * ret * base % mod; return ret;}int main() { cin &gt;&gt; n; FOR(i, 1, n) { int x; cin &gt;&gt; x; insert(x); } cin &gt;&gt; q; vector&lt;int&gt; vec; FOR(i, 0, LG) if (p[i]) vec.push_back(i); FOR(i, 0, (int)vec.size() - 1) if ((q &gt;&gt; vec[i]) &amp; 1) rnk += (1 &lt;&lt; i); cout &lt;&lt; (rnk % mod * qPow(2, n - cnt) % mod + 1) % mod &lt;&lt; endl; return 0;} 总结 OI 中的线性基一般指向量空间 V = (\\{0, 1\\}, \\mathrm{span}\\mathbf a_1,\\cdots \\mathbf a_n), \\oplus, \\cdot) 的基，我们可以通过模拟高斯消元得到对角矩阵或三角矩阵。 线性基的元素个数为 O(\\log V) 级别。 若线性基中有 m 个元素，则其能异或出来 2^{|m|} - 1 个数，注意 0 不算能异或出来的数。 可以在线性基上按位贪心。 线性基不支持删除，但可以 O(\\log^2V) 合并。 一般来说，看到： 最大异或和 k 大异或和 异或和之和 异或和为 0 的问题都可以往线性基的方向想。 References 线性基学习笔记 by Sengxian 纯正的线代味道开始讲起。 【基础操作】线性基详解 by Kaori","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"高斯消元","slug":"gauss-elimination","permalink":"https://old.blog.imyangty.com/tags/gauss-elimination/"},{"name":"线性基","slug":"linear-basis","permalink":"https://old.blog.imyangty.com/tags/linear-basis/"}]},{"title":"QOJ2812 [RMI 2021 Day 2] Paths","slug":"sol-qoj2812","date":"2022-04-08T02:11:11.000Z","updated":"2022-04-08T08:48:56.222Z","comments":true,"path":"sol-qoj2812/","link":"","permalink":"https://old.blog.imyangty.com/sol-qoj2812/","excerpt":"","text":"Description 给定 n\\le 10^5 个节点的无根边带权树。对于根在 r 的情况，可以选择 k 个点（ k 初始给定），然后将每个点到 r 的路径上的边打上标记，收益为所有带标记的边权和。 对每个 r\\in[1,n] 求出答案。 Solution 首先最显然的贪心策略很好想： 选择贡献最大的叶子 u 并统计贡献。 将根到 u 的路径上的点打上标记，更新那些子树内的点的贡献。 回到第一步。 然后会发现“动态更新”这个有点难搞，不妨先考虑 r = 1 的情况，然后发现一个叶子的贡献一定是他到某个祖先的一条链。 若我们设 \\mathrm{down}_i 为 i 子树内距 i 最远的点， a_x 是满足 \\mathrm{down}_v\\ne x 的最深的祖先（若不存在则为 1 ）则叶子 x 的贡献为 a_x 到 x 的路径。 那么对于 r 固定的情况，我们就有了 O(n) （也许吧）做法，现在考虑 r 变动的情况，换根。 再维护 \\mathrm{up}_i 表示 i 子树外距 i 最远的点。考虑当 r 移动到自己的儿子 q 时，发生的变化：手玩发现所有的 a 中，只有 a_{\\mathrm{up}_q} 和 a_{\\mathrm{down}_q} 会从 r 变成 q ，其他的均是不变的。 于是先以 1 为根跑一遍 dfs 预处理信息，然后再 dfs 枚举 r 换根，维护支持单点修改，前 k 大查询的可重集即可。 考场上贪心策略马上就想到了，可惜被限制了思维没有往移动换根的方向想。还是菜。 Implementation","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"QOJ","slug":"QOJ","permalink":"https://old.blog.imyangty.com/tags/QOJ/"}]},{"title":"QOJ1825 [NAC2021 I] The King's Guards","slug":"sol-qoj1825","date":"2022-04-08T00:05:35.000Z","updated":"2022-04-08T02:05:49.858Z","comments":true,"path":"sol-qoj1825/","link":"","permalink":"https://old.blog.imyangty.com/sol-qoj1825/","excerpt":"","text":"Description n 个点， m 条待修建的边 (u_i, v_i, w_i) 。 k 个守卫，每个守卫进驻一个村子，第 i 个能进驻的集合为 S_i 。要求每个点都能恰好被一个守卫通过若干条边到达。 若存在修建边和放置守卫的方案，输出建边的最小代价，否则报告无解。 1\\le k\\le n\\le 300 ， 1\\le w_i\\le 100 。 Solution 拟阵贪心属实有点神仙了，这里写写清新费用流做法。 对于这种类型的题，可以想到答案一定会在最小生成森林上面产生，否则总可以删掉那条不在最小生成森林上的边来获取一个不更劣的结果。所以先求出其最小生成森林。 那么问题就变成了树上的了。 而注意到，我们分配守卫这个事情可以看作将守卫匹配给连通块。而一个连通块肯定是一棵树，那么不妨认为每个守卫可以干碎其对应连通块里面的某条边。那么就可以考虑费用流了。 拆每个原图的点为入点和出点，连边 (u_{\\mathrm{in}},u_{\\mathrm{out}}, 1, 0) 。 对于每个生成森林中的边 (\\mathrm{fa}_u, u, w) 连边 (u_{\\mathrm{out}}, T, 1, w) 和 (u_{\\mathrm{out}},{\\mathrm{fa}_u}_{\\mathrm{in}}, 1, 0) 。 特别的，对于每个生成森林的根，连边 (u_{\\mathrm{out}}, T, 1, +\\inf) 。 对于每个守卫 i ，连边 (S, i, 1, 0) 。 对于守卫 i 守卫的点 u ，连边 (i, u_{\\mathrm{in}}, 1, 0) 。 即，一个守卫对应一个流，每棵生成树的根的守卫产生的贡献单独处理（即 \\inf 边），剩下的守卫考虑干碎一条自己所在连通块连向祖先的边（即断边）。对上面这个图跑最大费用流即可。 对于无解的情况，判断最大流是否为 k 以及 \\inf 边是否满流即可。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134using ll = long long;const int maxn = 1505, maxm = 3e5 + 5;int S, T;class MCMF { private: int head[maxn], cur[maxn], cnte = 1; struct Edge { int to, nxt, w; ll cost; } e[maxm]; ll dis[maxn], maxCost; int pre[maxn], inq[maxn], flow[maxn], maxFlow; bool SPFA() { memset(dis, 0x80, sizeof dis); memset(inq, 0, sizeof inq); queue&lt;int&gt; q; q.push(S); inq[S] = 1, dis[S] = 0, flow[S] = numeric_limits&lt;int&gt;::max(); while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; for (int i = head[u]; i; i = e[i].nxt) { int &amp;v = e[i].to; if (e[i].w &amp;&amp; dis[v] &lt; dis[u] + e[i].cost) { dis[v] = dis[u] + e[i].cost; flow[v] = min(flow[u], e[i].w); pre[v] = i; if (!inq[v]) q.push(v), inq[v] = 1; } } } return dis[T] &gt; static_cast&lt;int&gt;(0x80808080); } void update() { int u = T; while (u != S) { int i = pre[u]; e[i].w -= flow[T], e[i ^ 1].w += flow[T]; u = e[i ^ 1].to; } maxCost += flow[T] * dis[T]; maxFlow += flow[T]; return; } public: il void addEdge(int u, int v, int w, int c) { e[++cnte] = {v, head[u], w, c}, head[u] = cnte; e[++cnte] = {u, head[v], 0, -c}, head[v] = cnte; return; } pair&lt;int, ll&gt; work() { while (SPFA()) update(); return {maxFlow, maxCost}; }} flow;class UnionFind { private: int fa[maxn]; int find(int u) {return u == fa[u] ? u : fa[u] = find(fa[u]);} public: il bool query(int u, int v) {return find(u) == find(v);} il bool uni(int u, int v) { u = find(u), v = find(v); if (u == v) return false; fa[u] = v; return true; } UnionFind() { FOR(i, 1, maxn - 5) fa[i] = i; return; }} ufs;struct Edge { int u, v, w; il bool operator&lt;(const Edge &amp;rhs) const {return w &lt; rhs.w;}} e[maxm];vector&lt;pair&lt;int, int&gt;&gt; tree[maxn];int fap[maxn], fa[maxn], n, m, k, vis[maxn];ll totw;void dfs(int u, int pre) { if (pre == -1) fap[u] = 1e7; vis[u] = true, fa[u] = pre; for (auto &amp;p : tree[u]) { int &amp;v = p.first; if (vis[v]) continue; fap[v] = p.second, dfs(v, u); } return;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; FOR(i, 1, m) cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w; sort(e + 1, e + m + 1); FOR(i, 1, m) if (ufs.uni(e[i].u, e[i].v)) { totw += e[i].w; tree[e[i].u].push_back({e[i].v, e[i].w}); tree[e[i].v].push_back({e[i].u, e[i].w}); } S = 2 * n + k + 1, T = S + 1; FOR(i, 1, n) flow.addEdge(i, n + i, 1, 0); FOR(i, 1, k) { flow.addEdge(S, 2 * n + i, 1, 0); int s; cin &gt;&gt; s; while (s--) { int v; cin &gt;&gt; v; flow.addEdge(2 * n + i, v, 1, 0); } } FOR(i, 1, n) if (!vis[i]) dfs(i, -1), totw += 1e7; FOR(i, 1, n) { flow.addEdge(n + i, T, 1, fap[i]); if (~fa[i]) flow.addEdge(n + i, fa[i], 1, 0); } auto ret = flow.work(); ll ans = totw - ret.second; cout &lt;&lt; ((ans &gt;= 1e7 || ret.first &lt; k) ? -1 : ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"费用流","slug":"mincostflow","permalink":"https://old.blog.imyangty.com/tags/mincostflow/"},{"name":"QOJ","slug":"QOJ","permalink":"https://old.blog.imyangty.com/tags/QOJ/"}]},{"title":"AGC009D - Uninity","slug":"sol-agc009d","date":"2022-04-07T12:03:45.000Z","updated":"2022-04-07T23:42:17.769Z","comments":true,"path":"sol-agc009d/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc009d/","excerpt":"","text":"Description 递归定义一棵树的 Uninity： 一个单独的节点为一棵 Uninity 0 的树。 将 x\\ge 0 棵 Uninity k 的树全部连到一个节点上形成的树，称为一棵 Uninity k+1 的树。 于是我们知道一棵 Uninity k 的树一定也是 Uninity k+1,k+2,\\cdots 的树。 给定一个 n\\le 10^5 个节点的树，找到这个最小的 k 。 Solution Uninity 的定义非常绕，可能需要画图来辅助理解一下。发现我们实际上就是将若干个 Uninity k_i 的树接到一个根节点上形成一个 Uninity \\max k_i + 1 的树。 然后便会发现我们肯定尽量找“最中间”的那个点来作为“接到的那个节点”，然后剩余的连通块递归求解。可以猜想“最中间的那个节点”取重心是最优的。 于是最矮的点分树树高减一即为答案，这告诉我们答案是 O(\\log n) 级别的。 现在最关键的问题就在于当一个连通块有 2 个重心的时候，如何确定选哪个重心，注意到手玩玩出来发现选的不对的话可能会使得答案变大。所以使用重心来思考不太可能处理，换思路。 为每个点设置一个“深度”，即子树的 Uninity 值（相当于点分树的高度减深度 + 1 ）。则根据点分树的性质，对于 \\forall x\\ne y, d_x = d_y 都满足从 x 到 y 的路径上存在点 k 使得 d_k &gt; d_x 。注意到这个条件是充要的，即只要满足条件的 d 我们都可以反向构造出一棵合法的点分树。 考虑从叶子到根逐个贪心地确定每个点 u 的最小 d_u 。记一个 f_{i} 表示 i 子树内未被“匹配”的 d 值集合。注意到上文我们提到了答案为 O(\\log n) 级别，所以总状态数量是 O(n\\log n) 的。然后就可以从下到上维护 d 和 f 了： 具体地，若有两个子树内存在同一个未被匹配的 d_x 值，则当前我们填的 d_u 必须大于他。因为他们间的路径上还没有大于 d_x 的 d 值，需要我们在最后一个点（就是 u ）处将其填上。 且若有子树内存在一个未被匹配的 d_x 值，则我们当前也不能填这个 d_x ，因为 u 到 x 中间没有大于这个 d_x 的值。 于是就有了 O(n\\log n) 的做法。 而由于状态可以压缩，用 __builtin 系列的位运算优化一下就变成 O(n) 了。 Implementation 12345678910111213141516171819202122232425262728293031const int maxn = 1e5 + 5;vector&lt;int&gt; G[maxn];int a[maxn], f[maxn], n;void dfs(int u, int fa) { int t = 0; // 维护子树中出现多于一次出现的 d 值 for (auto &amp;v : G[u]) { if (v == fa) continue; dfs(v, u); t |= (f[u] &amp; f[v]); f[u] |= f[v]; // 维护 f_ } int k = t ? 32 - __builtin_clz(unsigned(t)) : 0; a[u] = __builtin_ctz(unsigned((f[u] | ((1 &lt;&lt; k) - 1)) + 1)); // orz 楼上 f[u] = ((f[u] &gt;&gt; a[u]) | 1) &lt;&lt; a[u]; // 因为 &lt; a_u 的能匹配了，所以要记得将低位清空 return;}int main() { cin &gt;&gt; n; FOR(i, 2, n) { int u, v; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v), G[v].push_back(u); } dfs(1, 0); int ans = 0; FOR(i, 1, n) chkmax(ans, a[i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"}]},{"title":"ABC239Ex - Dice Product 2","slug":"sol-abc239h","date":"2022-04-07T05:42:55.000Z","updated":"2022-04-07T08:28:03.858Z","comments":true,"path":"sol-abc239h/","link":"","permalink":"https://old.blog.imyangty.com/sol-abc239h/","excerpt":"","text":"Description 初始拥有一个数 M = 1 ，每次从 [1, n] 中随一个整数 x 出来然后让 M\\leftarrow M \\times x ，当 M &gt; m 时停止操作。 求期望进行的操作次数，答案对 998244353 取模。 n,m\\le 10^9 。 Solution 首先 dp 式子很好想，令 f_i 为当前 M = i 的剩余期望步数，则显然 f_i = \\frac{n}{n - 1}\\left(1 + \\frac1n\\sum_{j=2}^nf_{ij}\\right) 时间复杂度 O(m\\log m) ，过不去，考虑优化。 打表发现对于 \\lfloor m / i\\rfloor 相同的 i ，其 dp 值是一样的，所以一共有 O(\\sqrt m) 段有意义的 dp 值，直接缩连续段的化可以优化到 O(n\\sqrt m\\log m) （对于 n 较小的情况）。 那么不妨将 \\lfloor m / i\\rfloor 作为下标，设出 dp 状态 g_i ，那么根据 \\displaystyle\\left\\lfloor\\frac{m}{ik}\\right\\rfloor = \\left\\lfloor\\frac{\\lfloor m / i\\rfloor}{k}\\right\\rfloor ，则我们可以知道 g_i 的转移： g_i = \\frac{n}{n - 1}\\left(1 + \\frac1n\\sum_{j=2}^ng_{\\left\\lfloor \\frac ij\\right\\rfloor}\\right) 这个东西类似杜教筛那样处理就可以了，时间复杂度 \\displaystyle\\int_2^{\\sqrt m}\\left(\\sqrt x +\\sqrt{\\frac mx}\\right)\\mathrm{d}x = O\\left(m^{\\frac34}\\right) 。 Implementation 注意细节，边界，边界！！！！ \\lfloor m / l\\rfloor = 0 的时候不特判会去世！ 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;using namespace std;using mint = atcoder::modint1000000007;unordered_map&lt;int, mint&gt; F;int n, m;mint inv;mint getF(int m) { if (F.count(m)) return F[m]; mint ret = n; for (int l = 2, r; l &lt;= n; l = r + 1) { if (m / l == 0) break; r = min(n, m / (m / l)); ret += getF(m / l) * (r - l + 1); } return F[m] = ret * inv;}int main() { cin &gt;&gt; n &gt;&gt; m; F[0] = 1, inv = mint(n - 1).inv(); cout &lt;&lt; getF(m).val() &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"}]},{"title":"【IZhO 2022 Day 1 A】 Where is the legend?","slug":"sol-gym369641a","date":"2022-04-06T23:57:57.000Z","updated":"2022-04-07T11:54:48.386Z","comments":true,"path":"sol-gym369641a/","link":"","permalink":"https://old.blog.imyangty.com/sol-gym369641a/","excerpt":"","text":"Description 传送门。 多测，给定长为 n 的序列 a_i ，每次操作可以将满足 a_i = \\dfrac{a_{i-1} + a_{i +1}}{2} 的 a_i 删去，剩余数依次补位。问能达到的最小长度。 \\sum n\\le 3\\times 10^5 ， 1\\le a_i\\le 10^9 。 Solution 首先考虑差分数组，问题变为将两个相邻的相同数合并为原来的二倍。 而且考虑到能够合并的 x 肯定都满足正负性相同且 x / \\mathrm{lowbit}(x) 相同。所以按此分段来做。 那么不妨设朴素的 dp： f_i 表示考虑前 i 个数的答案，则我们一定有 f_i = 1 ，且对于一个 r 来说，若 [l, r] 能被合并，则 f_r 可以由 f_{l - 1} + 1 转移而来。 所以类似倍增地预处理一个节点能跳到哪里，然后顺带更新 dp 值即可。 Implementation 123456789101112131415161718192021222324252627const int maxn = 3e5 + 5;int f[maxn], a[maxn], d[maxn], n;map&lt;int, int&gt; g[maxn];int main() { int T; cin &gt;&gt; T; while (T--) { cin &gt;&gt; n; FOR(i, 1, n) { cin &gt;&gt; a[i]; g[i].clear(); } FOR(i, 1, n - 1) d[i] = a[i + 1] - a[i]; f[0] = 1; FOR(i, 1, n - 1) { g[i][d[i]] = i - 1; f[i] = f[i - 1] + 1; for (int x = d[i]; g[g[i][x]].count(x); x &lt;&lt;= 1) { g[i][x &lt;&lt; 1] = g[g[i][x]][x]; chkmin(f[i], f[g[i][x &lt;&lt; 1]] + 1); } } cout &lt;&lt; f[n - 1] &lt;&lt; endl; } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"倍增","slug":"binary-lifting","permalink":"https://old.blog.imyangty.com/tags/binary-lifting/"}]},{"title":"AGC013C - Ants on a Circle","slug":"sol-agc013c","date":"2022-04-06T12:04:35.000Z","updated":"2022-04-06T13:00:11.025Z","comments":true,"path":"sol-agc013c/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc013c/","excerpt":"","text":"Description 给定一个长度为 L 的圆环，上面有 N 个蚂蚁，位置分别 x_i ，运动方向为 d_i ， 1 为 CW， 2 为 CCW。每只蚂蚁会以单位速度运动，若两只蚂蚁相遇他们会同时掉头继续运动，保证 x_i 初始单调。 问 T 秒后各个蚂蚁的坐标。 1\\le N\\le 10^5 ， 1\\le L, T\\le 10^9 。 Solution 首先有个经典的想法：两只蚂蚁相遇的时候看作他们“灵魂”交换，但肉体还是继续走下去。 那么现在的问题就转化成了如何求出最后每个蚂蚁的标号。 蚂蚁的相对位置是不会改变的，或者说，答案和 (x_i + T)\\bmod L 有“循环移位”的关系。因为若我们考虑蚂蚁之间创来创去，相对位置是不会发生改变的。 当然我是通过大力观察样例发现的这个性质。 那么我们就可以考虑直接求一个蚂蚁的编号，然后依此还原出剩下所有的蚂蚁。 假设我们求第一个蚂蚁的编号，若将环看作双端队列，则若有蚂蚁从 0\\to L - 1 ，则相当于队首元素跑到队尾去了，所以队首序号 +1 ，否则若是有蚂蚁从 L - 1\\to 0 ，则队首编号 -1 。 Implementation 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;const int maxn = 1e5 + 5;int T, L, N, x[maxn], d[maxn], cnt;int main() { cin &gt;&gt; N &gt;&gt; L &gt;&gt; T; FOR(i, 0, N - 1) { cin &gt;&gt; x[i] &gt;&gt; d[i]; x[i] += (d[i] == 1 ? T : -T); cnt = (cnt + (int)floor(1.0 * x[i] / L) % N + N) % N; x[i] = (x[i] % L + L) % L; } sort(x, x + N); FOR(i, 0, N - 1) cout &lt;&lt; x[(i + cnt) % N] &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"ARC064D - Rotated Palindromes","slug":"sol-arc064d","date":"2022-03-31T13:10:34.000Z","updated":"2022-04-01T14:21:53.228Z","comments":true,"path":"sol-arc064d/","link":"","permalink":"https://old.blog.imyangty.com/sol-arc064d/","excerpt":"","text":"Description 按如下要求构造序列 a ：长为 n ，值域 [1, k] 的整数序列 a ，初始为回文，然后可以 shift 任意次。问最后能构造出多少种本质不同的 a 。 1\\le n,k\\le 10^9 ，答案对 10^9 + 7 取模。 Solution 数据范围有点哈人。那应该就是申必计数题。 不妨考虑对所有回文串计数其能变形成多少不同的串。但是由于一个串可能形成若个相同的循环移位，且多个串可能循环移位后等价，所以需要认真考虑如何去重。 一般地，对一个串而言，其能形成的循环移位个数即为其循环节的长度。忽略后面那个问题的话，枚举所有循环节长度 d 对应的方案数 f(d) ，最后的答案即为 \\displaystyle\\sum_{d\\mid n}df(d) 。而且通过观察发现，循环节也必定是回文串。 现在考虑多个串循环移位后可能等价的问题。如何判断？手玩发现只有长为偶数的回文串有一个循环同构：1221 和 2112，而长度为奇数的 AcA^r 型是不会有循环同构的。于是最后的答案 \\frac12\\sum_{2\\mid d,d\\mid n} df(d) + \\sum_{2\\not\\mid d, d\\mid n}df(d) 现在考虑求 f(d) ，因为是回文的，所以显然为 k^{\\lceil d / 2\\rceil} ，但是可能会和循环节更小的串算重，那就容斥掉即可，即： f(d) = k^{\\lceil d / 2\\rceil} - \\sum_{g\\mid d}f(d) 写了个比较劣的 O(\\sqrt n + d^2(n)\\log n) 做法。 Implementation 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/all&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using mint = atcoder::modint1000000007;const int mod = mint().mod(), maxn = 1e7 + 5;const mint inv2 = mint(2).inv();int n, k, d[maxn], tot;mint f[maxn], ans;int main() { cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i * i &lt;= n; ++i) { if (n % i) continue; d[++tot] = i; if (i * i != n) d[++tot] = n / i; } sort(&amp;d[1], &amp;d[tot] + 1); FOR(i, 1, tot) { f[i] = atcoder::pow_mod(k, (d[i] + 1) &gt;&gt; 1, mod); FOR(j, 1, i - 1) if (!(d[i] % d[j])) f[i] -= f[j]; ans += (d[i] &amp; 1) ? d[i] * f[i] : d[i] * f[i] * inv2; } cout &lt;&lt; ans.val() &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"AGC002E - Candy Piles","slug":"sol-agc002e","date":"2022-03-31T11:11:06.000Z","updated":"2022-03-31T12:57:11.481Z","comments":true,"path":"sol-agc002e/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc002e/","excerpt":"","text":"Description n 堆糖果 a_{1,\\cdots, n} ，轮流吃。要么将最大一堆吃掉，要么将每堆吃掉一个。吃完的人输，假设两人绝顶聪明，问谁必胜。 n\\le 10^5 ， a_i\\le 10^9 。 Solution 巧妙的模型转化，想不到就寄，而且也没做博弈论的题的经验。 考虑将每堆糖果排好序后化成阶梯形状： 1234560000000000000000000000000000 则一次操作等价于删掉当前第一行或第一列。再将其转化为网格图后发现边是从左下角每次往上或是往右走，边界点为必胜态（因为你注意到是做最后一步的人寄而不是无法操作的人寄）。 博弈论的经典结论（我不会，哈哈哈） 一个态为必胜态当且仅当其能转移到的态中有一个为必败态。 一个态为必败态当且仅当其能转移到的态中全部为必胜态。 于是本题的 O(n^2) 做法就有了，直接从边界开始转移即可。 但是时间复杂度很显然是寄的，但是由于我们只需要知道左下角的态，所以可以考虑找规律优化一下。 我们惊奇的发现，除了边界，同一对角线上都是同类型的点。具体证明考虑反证，会发现若对角线上不是同一类型的点的话会无法继续扩展。 那么我们就只需要知道整个网格图最左下角的极大正方形的右上顶点是什么态就可以了。 Implementation 12345678910111213141516171819const int maxn = 2e5 + 5;int a[maxn], n;int main() { cin &gt;&gt; n; FOR(i, 1, n) cin &gt;&gt; a[i]; sort(a + 1, a + n + 1, greater&lt;int&gt;()); FOR(i, 1, n) { if (i + 1 &gt; a[i + 1]) { bool ans = 0; for (int j = i + 1; a[j] == i; ++j) ans ^= 1; // 向右走的情况 ans |= (a[i] - i) &amp; 1; // 向上走的情况 puts(ans ? \"First\" : \"Second\"); return 0; } } return 0;} 但是自己写的时候还是遇到了困难。。。。。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"博弈论","slug":"game-theory","permalink":"https://old.blog.imyangty.com/tags/game-theory/"}]},{"title":"AGC001E - BBQ Hard","slug":"sol-agc001e","date":"2022-03-30T02:43:46.000Z","updated":"2022-03-30T03:15:31.595Z","comments":true,"path":"sol-agc001e/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc001e/","excerpt":"","text":"Description 给定 a_{1,\\cdots, n} 和 b_{1,\\cdots n} ，求 \\sum_{i=1}^n\\sum_{j=i+1}^n\\binom{a_i + b_i + a_j + b_j}{a_i + a_j} 答案对 10^9 + 7 取模。 n\\le 2\\times 10^5 ， a_i,b_i\\le 2000 。 Solution 回忆 \\dbinom{n + m}{n} 的组合意义：棋盘上从 (0, 0) 走到 (n, m) 的路径方案数。 那么 \\dbinom{a_i + b_i + a_j + b_j}{a_i + a_j} 的组合意义即为从 (-a_i,-b_i) 走到 (a_j, b_j) 的路径方案数。 然后现在要求出每一对 (i,j) 从 (-a_i, -b_i) 到 (a_j, b_j) 的路径方案数。 这个东西可以放在棋盘上一起 dp，时间复杂度 O(\\max^2 v) 。 注意最后要把所有的从 (-a_i,-b_i) 走到 (a_i, b_i) 的方案数去重掉，减去 \\dbinom{2a_i+2b_i}{2a_i} 即可。然后因为题目里面钦定 j &gt; i ，所以最后要除以二。 Implementation 1234567891011121314151617181920212223242526272829303132using mint = atcoder::modint1000000007;using fastIO::is;using fastIO::os;const int maxn = 2e5 + 5, maxm = 4e3 + 5, shift = 2001;mint f[maxm][maxm], fac[maxm &lt;&lt; 1], ifac[maxm &lt;&lt; 1];int n, a[maxn], b[maxn];int main() { is &gt;&gt; n; FOR(i, 1, n) { is &gt;&gt; a[i] &gt;&gt; b[i]; ++f[-a[i] + shift][-b[i] + shift]; } FOR(i, -2000, 2000) { FOR(j, -2000, 2000) { const int &amp;x = i + shift, &amp;y = j + shift; f[x][y] += f[x - 1][y] + f[x][y - 1]; } } fac[0] = 1; FOR(i, 1, 8000) fac[i] = fac[i - 1] * i; ifac[8000] = fac[8000].inv(); DEC(i, 8000 - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; auto binom = [](const int &amp;n, const int &amp;m) {return fac[n] * ifac[m] * ifac[n - m];}; mint ans = 0; FOR(i, 1, n) ans += f[a[i] + shift][b[i] + shift] - binom(2 * a[i] + 2 * b[i], 2 * b[i]); ans /= 2; os &lt;&lt; ans.val(); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"AGC012F - Prefix Median","slug":"sol-agc012f","date":"2022-03-30T00:51:12.000Z","updated":"2022-03-30T02:43:18.329Z","comments":true,"path":"sol-agc012f/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc012f/","excerpt":"","text":"Description 给定一个长度为 2n - 1 的序列 a ，可以随意排列 a 中的元素，请求出能构造出多少种不同的序列 b ，满足 b 的长度为 n ，且 b_i = \\mathrm{median}\\{a_1, \\cdots, a_{2i - 1}\\} 。 n\\le 50 ，答案对 10^9 + 7 取模。 Solution 还是很牛逼的题。 首先肯定考虑直接对 b 序列计数。 Key Point 1 ： b_n 是 a 的中位数，是确定的值。 那么我们不妨倒序构造答案，先将 a 从小到大排序，然后每次删两个数来构造对应的 b_i 。 而且我们手玩一下可以发现另一个性质： Key Point 2：每次删两个数后， b_i 在 a 中的位置至多移动 1 。 考虑每次删大于中位数的两个数，小于中位数的两个数或者分居两侧的两个数。 由此可以推出第一个关键结论： Lemma 1：一个 b 序列合法的必要条件是 a_i\\le b_i\\le a_{2n - i} 。 考虑其往两侧的最大移动距离。 但是有了这个条件还是不够，继续思考。我们注意到， b_i 每次的移动有可能跨过被删除的数，但是这些数一定就不会出现在剩下的 b 中了，所以结合 Key Point 2 推出如下结论： Lemma 2：一个合法的序列中，不存在 i &lt; j 使得 b_j&lt;b_i&lt;b_{j+1} 或 b_j &gt; b_i &gt; b_{j+ 1} 。 因为 b_j 和 b_{j + 1} 中间跨过的数不可能再在 b_i 出现了。 这两个条件结合在一起就变成充要的了，因为对于满足上述性质的 b ，我们一定能构造出一个符合条件的 a 的删除序列出来。 而且注意到，构造 b 的过程中，我们只需要知道最左边剩下多少可选数，以及最右边剩下多少可选数。 剩下的问题就是 dp 计数。倒着 dp，设 f_{i,j,k} 为考虑 b_i ，比他小的可选数有 j 种，比他大的可选数有 k 种的方案数。先考虑设 l = [a_i\\ne a_{i - 1}] ， r = [a_{2n - i}\\ne a_{2n - i + 1}] 。表示当前转移能否新增加能填的数（需要考虑有些数是一样的）。 f_{i - 1, j + l, k + r}\\leftarrow f_{i-1,j+l,k+r} + f_{i,j,k} ，即当前还是填上次的数，但是两边会多出 l 或 r 个可以填。 f_{i - 1, t, k + r + 1} \\leftarrow f_{i-1,t,k+r+1} + f_{i,j,k}(t&lt;j + l) ，表示将填一个更小的数，左边还剩下 t 个可以填，之前本来填的变到右边。 f_{i-1,j+l+1, t}\\leftarrow f_{i-1,j+l+1,t} + f_{i,j,k}(t&lt;k + r) ，同理。 初始化 f_{n, 0, 0} = 1 。状态 O(n^3) ，转移 O(n) ，总时间 O(n^4) 。 Implementation 123456789101112131415161718192021222324252627282930using fastIO::is;using fastIO::os;using mint = atcoder::modint1000000007;const int maxn = 105;int n, a[maxn];mint f[maxn][maxn][maxn];int main() { is &gt;&gt; n; int m = 2 * n - 1; FOR(i, 1, m) is &gt;&gt; a[i]; sort(a + 1, a + m + 1); f[n][0][0] = 1; DEC(i, n, 2) { const int &amp;l = (a[i] != a[i - 1]), &amp;r = (a[m - i + 1] != a[m - i + 2]); FOR(j, 0, m) { FOR(k, 0, m) { if (!f[i][j][k].val()) continue; f[i - 1][j + l][k + r] += f[i][j][k]; FOR(t, 0, j + l - 1) f[i - 1][t][k + r + 1] += f[i][j][k]; FOR(t, 0, k + r - 1) f[i - 1][j + l + 1][t] += f[i][j][k]; } } } mint ans = 0; FOR(i, 0, m) FOR(j, 0, m) ans += f[1][i][j]; os &lt;&lt; ans.val(); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"CF961F k-substrings","slug":"sol-cf961f","date":"2022-03-28T09:14:30.000Z","updated":"2022-03-31T04:17:07.525Z","comments":true,"path":"sol-cf961f/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf961f/","excerpt":"","text":"Description 给定长为 n 的字符串 S ，定义 k 子串表示 S_{k,k+1,\\cdots, n - k + 1} ，显然 S 有 \\lceil n / 2\\rceil 个 k 子串。 对每个 k = 1,2,\\cdots, \\lceil n / 2\\rceil ，求出 S 的 k 子串最长的奇数长 border 的长度。 n\\le 10^6 。 Solution 手玩半天也只发现了 ans_i\\ge ans_{i -1} - 2 ，呜。 移项发现 ans_{i}\\le ans_{i + 1} + 2 ，那么就从最中间的子串开始搞，对于每个目标子串，从 ans_{i+1} - 2 到 -1 间的奇数全部枚举一遍即可，判 Border 使用 hash 判断即可。 复杂度分析：枚举的指针 j 最多进行 \\dfrac n 2 次 j\\leftarrow j - 2 。于是复杂度为 O(n) 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051constexpr int maxn = 1e6 + 5;constexpr int base = 37;constexpr int mod[2] = {998244353, (int)1e9 + 7};int n, pw[2][maxn], sum[2][maxn], ans[maxn];char s[maxn];void hash(const int&amp; k) { int *sum = YangTY::sum[k], *pw = YangTY::pw[k]; const int mod = YangTY::mod[k]; pw[0] = 1; FOR(i, 1, n) { pw[i] = 1ll * pw[i - 1] * base % mod; sum[i] = (1ll * sum[i - 1] * base % mod + s[i] - 'a' + 1) % mod; } return;}il int getHash(int l, int r, int k) { int *sum = YangTY::sum[k], *pw = YangTY::pw[k]; const int mod = YangTY::mod[k]; return (sum[r] - 1ll * sum[l - 1] * pw[r - l + 1] % mod + mod) % mod;}il bool check(int l1, int r1, int l2, int r2) { return getHash(l1, r1, 0) == getHash(l2, r2, 0) &amp;&amp; getHash(l1, r1, 1) == getHash(l2, r2, 1);}int main() { cin &gt;&gt; n &gt;&gt; s + 1; hash(0), hash(1); int cnt = (n + 1) &gt;&gt; 1, l, r; if (n &amp; 1) ans[cnt] = -1, l = r = cnt; else { l = n &gt;&gt; 1, r = l + 1; if (s[l] == s[r]) ans[cnt] = 1; else ans[cnt] = -1; } DEC(i, cnt - 1, 1) { --l, ++r; for (int j = ans[i + 1] + 2; j &gt;= -1; j -= 2) { if (check(l, l + j - 1, r - j + 1, r) || j == -1) { ans[i] = j; break; } } } FOR(i, 1, cnt) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"字符串哈希","slug":"hash","permalink":"https://old.blog.imyangty.com/tags/hash/"},{"name":"字符串","slug":"string","permalink":"https://old.blog.imyangty.com/tags/string/"}]},{"title":"wqs 二分学习笔记","slug":"note-wqs","date":"2022-03-28T07:27:49.000Z","updated":"2022-03-31T07:27:29.055Z","comments":true,"path":"note-wqs/","link":"","permalink":"https://old.blog.imyangty.com/note-wqs/","excerpt":"","text":"前言 wqs 二分，又称带权二分，DP 凸优化，是一种求解带凸性且钦定选择个数的问题的二分方法，由王钦石大佬于 2012 年于其集训队论文中提出。 若遇到一类形如“钦定选择物品个数，而不钦定的话很好做，并且感性理解答案关于物品个数有凸性”的问题，则可以考虑使用 wqs 二分进行求解。 算法流程 考虑一道经典例题： 典例： n 个数，要求分成 m 段，求每段平方之和的最小值。 m\\le n\\le 10^5 。 发现可以设计一个很裸的 dp： f_{i,j} 表示 [1, i] 划分成 j 段的答案。直接做是 O(n^2m) 的，套上斜率优化还是 O(nm) 的，没有办法丢掉 m 。但是如果不要求分成 m 段的话会发现直接斜率优化可以 O(n) 。即，钦定不好做，不钦定很好做。 复杂度/维数和选的个数有关的可以考虑其凸性。 而注意到 打表知 猜测 f_{n, i} 是关于 i 的凸函数，故考虑 wqs 二分把这一维丢掉。 具体地，感性理解一下，发现我们若是去掉钦定段数的限制，则 dp 一定会尽可能让他分成 n 段。 那么我们考虑给每一段加上附加权值 c ，这样 dp 算法就能从“分的段数多权值小”和“分的段数少权值小”中间进行取舍，找到一个“平衡点”。继续感性理解一下发现 c 越大分段越少， c 越小分段越多。 那么通过二分这个权值，我们就能让分的段数恰好 \\le m ，这样的解减去加上的附加权值就是最优解。 上面是感性理解，下面我们来理性思考一下。上面的说明有两个问题： 有可能我们无法通过“改变权值”来使得分段数恰好 = k ，即函数可能“不连续”。 没有说明这样的解一定是最优解。 那么首先建立 f_{n, i} 关于 i 的函数 y = f(x) ，打表发现其下凸。具有凸性才能二分权值，原因下面会说明。 然后加上附加权值之后变为 y = f(x) + cx ，根据简单的导数知识发现其仍然下凸，然后我们带上附加权后求的 dp 最值对应的分段数（注意 dp 是需要同时求出这个分段数的）即为 f(x) + cs 的最小值点的横坐标，并且同时为 y = cx + b 与 y = f(x) 的切点横坐标。 可以参考这个 geogebra 实例辅助理解，如果显示效果不佳/无法加载可以访问这里。（先点击一下“代数区”按钮以收起）其中 c 滑杆控制附加权值 c ， b' 滑杆控制 y = cx + b 以观察其相切。 那么我们来解决上面两个问题： 事实证明，若 y = f(x) 存在三点共线的情况而且中间的点为我们要钦定的段数，那么根据相切的性质，那个点永远取不到，不过我们若是能找到两边的点那也能根据两边的点推出中间的答案。关于三点共线的特殊情况后文还会进一步说明。 由于函数具有凸性，所以斜率单调，我们二分的这个附加权值 c 实际上就是斜率。那么找到的点减去附加权必然就能对应到原来的函数上面去了。 其他细节 一般来说，dp 值是整数，所以 \\displaystyle c = \\frac{f(i + 1) - f(i)}{i + 1 - i} 也是整数，因此不需要实数二分，但若是 dp 值为小数，则需要进行小数二分。 并且，有一部分费用流问题可以使用 wqs 二分求解： 多次增广的费用流模型中，费用一定是关于流量的凸函数。 因为增广肯定是沿着最短路增广，后面增广的费用肯定会更大。 说白了就是“限制卡的越来越死”，这种类型的问题都可以考虑 wqs 二分。 三点共线的情况较为不好处理，在保证解最优的情况下使得选择物品的数量最多/最少会很大程度上影响三点共线的判断我们不妨考虑如下情况，假设最后要求的物品个数对应的为 C 点。 若 dp 在值最优的情况下求出的是物品数量 p 的最大值，则相当于我们最后二分斜率到 k_2 的时候碰到的是 D 点。 则若是二分到 k_1 ，截到了 B ，发现 x_B &lt; x_C ，故 k_1 一定不会是我们要的斜率。 若是二分到 k_2 ，截到了 C ，发现 x_C &lt; x_D ， k_2 可能是我们要的斜率。 对于 dp 出来的是 p 的最小值的情况， x &gt; x_C 则一定不是要的斜率， x &lt; x_C 可能是我们要的斜率。 实战的时候，如果想避免 不等号 带不带等号的问题，可以在找到解的时候直接退出，剩下的情况按照上面画图处理，具体问题具体分析，详见下文代码部分。 另外，整数二分中，写左闭右开的形式可以有效避免 l 要不要加一， r 要不要减一的问题。 而且注意不要搞形如 chkmax(ans, ...) 的代码，在还没二分到底前之前的都可能不是答案，要覆盖掉。 应用 例题 1 ：P2619 [国家集训队]Tree I 给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有 k 条白色边的生成树，保证有解。 n\\le 5\\times 10^4 ， m\\le 10^5 ，边权 \\in[-100, 100] 。 wqs 论文里面的例题，虽然和 dp 没有什么关系。 注意到这种问题是典型的钦定个数不好解，但不钦定个数非常好解（直接 Kruskal）的问题，所以可以思考其凸性。 分黑白考虑，先假设生成树全由黑边构成（没边连的强行连 +\\infty 的黑边），然后每次加白边都是加入最小白边，去掉能去掉的最大黑边，可以感受到限制在慢慢卡死，所以最小生成树权值关于选的白边个数的函数是凸的，可以使用 wqs 二分。 由于斜率在 [-100, 100] 中间，所以在这个区间内二分附加权值 c ，分开存储黑白边然后类似归并地使用 Kruskal，在这里， c 越大则选的白边会越少。我的写法是优先选白边，那么二分的时候就需要注意， p &gt; k 的时候可能是答案， p&lt;k 的时候绝对不会是答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using fastIO::is;using fastIO::os;const int maxn = 5e4 + 5, maxm = 1e5 + 5;struct Edge { int u, v, w, c; il bool operator&lt;(const Edge &amp;rhs) const {return w &lt; rhs.w;}} e[maxm];int n, m, need, cntw = 1, fa[maxn];int find(int u) {return fa[u] == u ? u : fa[u] = find(fa[u]);}bool add(int i) { int u = find(e[i].u), v = find(e[i].v); if (u == v) return false; else return fa[u] = v, true;}int main() { is &gt;&gt; n &gt;&gt; m &gt;&gt; need; FOR(i, 1, m) { is &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w &gt;&gt; e[i].c; ++e[i].u, ++e[i].v; // 注意原题点从 0 开始标号 if (!e[i].c) swap(e[cntw++], e[i]); // 将白点集中在数组前部 } sort(e + 1, e + cntw), sort(e + cntw, e + m + 1); int l = -100, r = 101, ans = 0; while (l + 1 &lt; r) { int mid = (l + r) &gt;&gt; 1; FOR(i, 1, n) fa[i] = i; int chosen = 0, val = 0; int i = 1, j = cntw; while (i &lt; cntw &amp;&amp; j &lt;= m) { if (e[i].w + mid &lt;= e[j].w) { // 同权优先选白点，相当于保证最优解同时物品数最大 if (add(i)) val += e[i].w + mid, ++chosen; ++i; } else val += e[j].w * add(j), ++j; } for (; i &lt; cntw; ++i) if (add(i)) val += (e[i].w + mid), ++chosen; for (; j &lt;= m; ++j) val += add(j) * e[j].w; if (chosen &gt;= need) ans = val - mid * need, l = mid; // 可能搜到解 else r = mid; // 不可能是解 } os &lt;&lt; ans &lt;&lt; '\\n'; return 0;} 例题 2 ：CF739E Gosha is hunting 要抓 n 只宝可梦，有 a 个 Poke Ball 和 b 个 Ultra Ball。Poke Ball 抓到第 i 只宝可梦的概率为 p_i ，Ultra Ball 抓到第 j 只宝可梦的概率为 q_i ，不能重复用一种球抓一个宝可梦，但是可以用两种球抓一个宝可梦（都抓到算一个）。求最优策略下期望抓到的宝可梦个数。 a,b\\le n\\le 2000 。 费用流可以解本题，但不在本文讨论范围内。 考虑一个 O(n^3) 的 naive dp： f_{i,j,k} 表示前 i 个宝可梦，用 j 个 Poke Ball 和 k 个 Ultra Ball，期望抓到的宝可梦个数。则有转移： \\begin{cases} f_{i,j,k} \\leftarrow \\max\\{f_{i,j,k}, f_{i - 1, j - 1, k} + p_i\\}\\\\ f_{i,j,k} \\leftarrow \\max\\{f_{i,j,k}, f_{i - 1, j, k - 1} + q_i\\}\\\\ f_{i,j,k} \\leftarrow \\max\\{f_{i,j,k}, f_{i - 1, j - 1, k - 1} + p_i + q_i - p_iq_i\\} \\end{cases} 考虑优化。第一，发现最优策略一定会用完所有的球，即我们现在钦定要用 a 个 Poke Ball 和 b 个 Ultra Ball。 第二，发现若不考虑 b 的限制，我们的 dp 就是比较简单的二维 dp 了，所以思考是不是可以用 wqs 二分干掉这一维。 第三，考虑 f_{n, a, j} 关于 j 的函数 f(x) ，发现（打表，猜测）其为凸函数（事实上感性理解一下，多加一个 Ultra Ball 能带来的期望增加值肯定越少），所以可以 wqs 二分，直接上就行了。 注意本题为实数二分，时间复杂度为 O(n^2\\log\\epsilon^{-1}) 。注：对两维都进行 wqs 二分的 O(n\\log^2\\epsilon^{-1}) 做法疑似被证伪，故此处不展开。 这里再提一下实现细节，由于我们多加一个 Ultra Ball，至多期望新抓到 1 个宝可梦，所以在 [0, 1] 间二分斜率，而且需要注意的是这个函数是上凸的，切不可生搬硬套，需要现场分析。 Trick：可以将 dp 值和选的物品个数打包成一个类，详见代码。 只是这样似乎是会贡献大常数（笑） 12345678910111213141516171819202122232425262728293031323334353637383940414243using db = double;const int maxn = 2005;int n, a, b;db p[maxn], q[maxn];struct DP { db dp; int cnt; DP(db _dp = 0, int _cnt = 0) : dp(_dp), cnt(_cnt) {} il bool operator&gt;(const DP &amp;rhs) const { return (myabs(dp - rhs.dp) &lt; 1e-7) ? (cnt &lt; rhs.cnt) : (dp &gt; rhs.dp); } il DP operator+(const DP &amp;rhs) const { return DP(dp + rhs.dp, cnt + rhs.cnt); }} f[maxn][maxn];int main() { ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; FOR(i, 1, n) cin &gt;&gt; p[i]; FOR(i, 1, n) cin &gt;&gt; q[i]; db l = 0, r = 1, ans = 0; for (int kase = 1; kase &lt;= 30; ++kase) { db mid = (l + r) / 2; memset(f, 0, sizeof f); FOR(i, 1, n) FOR(j, 0, a) { chkmax(f[i][j], f[i - 1][j] + DP(0, 0)); chkmax(f[i][j], f[i - 1][j] + DP(q[i] - mid, 1)); if (j) { chkmax(f[i][j], f[i - 1][j - 1] + DP(p[i], 0)); chkmax(f[i][j], f[i - 1][j - 1] + DP(p[i] + q[i] - p[i] * q[i] - mid, 1)); } } DP mx; FOR(j, 0, a) chkmax(mx, f[n][j]); if (mx.cnt &lt;= b) ans = mx.dp + mid * b, r = mid; else l = mid; } cout &lt;&lt; ans &lt;&lt; endl; return 0;} Reference DP 优化方法大杂烩 I. by Alex Wei wqs二分 学习笔记 by 小跳蛙 决策单调性&amp;wqs二分 by tzc_wk 【算法】带权二分 by boshi 感谢以上文章的作者以及伟大的 Asd_Okuu，没有您们我永远学不懂 wqs 二分/kk。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"wqs二分","slug":"wqs-binary-search","permalink":"https://old.blog.imyangty.com/tags/wqs-binary-search/"}]},{"title":"ARC068D - Solitaire","slug":"sol-arc068d","date":"2022-03-23T00:37:10.000Z","updated":"2022-03-30T00:38:48.250Z","comments":true,"path":"sol-arc068d/","link":"","permalink":"https://old.blog.imyangty.com/sol-arc068d/","excerpt":"","text":"Description 将 1\\sim n 依次加入双端队列，再双端删除，问有多少种删除序列满足 1 是第 k 个被删。原题 1\\le k\\le n \\le 3\\times 10^5 ，加强要求 O(n) 。 Solution 首先这个双端队列在删除之前一定是一个 V 字形，所以取出 1 之后双端队列内的元素是单调的，假设取出 1 之后的 n - m - 1 个元素也是被从一端单调地取出来的，然后我们去统计满足该性质的删除序列的数量，最后再乘上 2^{n - m - 1} 。而显然满足该性质的删除序列 p 满足能被划分为两个单调递减子序列（考虑删除序列是如何被构造出来的）。根据 Dilworth 引理，删除序列 p 中不存在顺次递增的三项。 所以我们要计数的就是满足 p_k = 1 的序列个数。然而这个限制看上去就很拉跨，所以考虑其逆排列 q_{p_i} = i ，发现若 p 满足上述性质，则 q 也会满足。 现在问题就变成了对 q_1 = k 的 q 计数。考虑一个 dp。令 f_{n,i} 为长度为 n 且第一项为 j 的排列数。 考虑转移： i = n ，则其不可能出现在长度为 3 的上升子序列中，可以直接删掉，所以 f_{n,i} = \\displaystyle\\sum_{1\\le j&lt; i}f_{n -1, j} 。 i &lt; n ，则考虑 q_2 ： q_2 = n ，则可以直接不管， f_{n, i}\\leftarrow f_{n,i} + f_{n - 1, i} 。 i &lt; q_2 &lt; n ，其不合法。 q_2 &lt; i ，若 i 在某个长为 3 的上升子序列中，则将 i 替换为 q_2 仍然可以满足条件，那就是说，删掉 i 后，序列仍合法。所以 f_{n, i}\\leftarrow f_{n, i} + \\displaystyle\\sum_{1\\le j &lt; i}f_{n - 1, j} 。 综上， f_{n, i} = f_{n - 1, i} + \\displaystyle\\sum_{1\\le j&lt;i}f_{n - 1, j} = f_{n- 1, i} +f_{n, i - 1} ， f_{n,1} = f_{n-1,1} ， f_{n,n} = f_{n,n - 1} 。（ n&gt;1 ） 会发现这是个很经典的走格子 dp，从 (2,1) 开始（因为上式成立的条件为 n &gt; 1 ），每次可以向右/向上走一格，然后不能碰到 i = n + 1 这条线，最后走到 (n, k) 的方案数。 首先总方案数是 \\dbinom{n + k - 3}{n - 2} ，然后用类似卡特兰数的处理方法发现将第一次碰到 i = n+ 1 之后的路径翻折可以发现其唯一对应从 (2,1) 到 (k - 1, n + 1) 的路径，故减掉不合法方案数 \\dbinom{n + k - 3}{n} 。 所以对于 n &gt; 1 的情况，答案为 \\displaystyle 2^{n - k - 1}\\times\\left(\\binom{n + k - 3}{n - 2} - \\dbinom{n + k - 3}{n} \\right ) ，否则有 f_{1,1} = 1 。 Implementation 公式已推出，实现略去。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"BZOJ#4767. 两双手","slug":"sol-bzoj4767","date":"2022-03-22T01:58:30.000Z","updated":"2022-03-23T23:53:44.265Z","comments":true,"path":"sol-bzoj4767/","link":"","permalink":"https://old.blog.imyangty.com/sol-bzoj4767/","excerpt":"","text":"Description 从 (0, 0) 要走到 (E_x, E_y) ，每次能从 (x, y) 走到 (x + A_x, y + A_y) 或 (x + B_x, y + B_y) 。中间有 k 个不能走的点，问方案数。 原题保证 A_xB_y - A_yB_x\\ne 0 。 0\\le n,m,k, |A_x|,|A_y|,|B_x|,|B_y|\\le 500 。 Solution 先考虑 A_xB_y-A_yB_x\\ne 0 的情况，注意到这两个向量构成平面内的一组基，所以任意的点 (x, y) 都可以被表示为 cA + dB ，将所有点 (x,y) 转为 (c, d) 。问题于是转化为带障碍的网格路径计数。 设换了坐标系后终点为 (n, m) ，则若没有障碍，答案显然为 \\dbinom{n + m}{m} 。 有障碍则需要考虑容斥。 将所有的障碍点以及 (n, m) 视为关键点，排个序，然后便令 f_i 为从 (0, 0) 出发，不经过障碍点，走到第 i 个关键点的方案数，则 f_i = \\binom{x_i + y_i}{x_i}- \\sum_{x_j\\le x_i\\land y_j\\le y_i}f_j\\times\\binom{(x_i - x_j) + (y_i - y_j)}{x_i - x_j} 于是时间复杂度为 O(k^2) 。 Implementation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using Point = pair&lt;int, int&gt;;Point p[505];const int maxn = 1e7 + 5, N = 1e7;int Ax, Ay, Bx, By, Ex, Ey, K, tot;modint fac[maxn], ifac[maxn], f[505];modint binom(int n, int m) {return n &lt; m ? 0 : fac[n] * ifac[m] * ifac[n - m];}bool convert(int &amp;x, int &amp;y) { int rx, ry; if ((x * Ay - y * Ax) % (Bx * Ay - Ax * By)) return false; else ry = (x * Ay - y * Ax) / (Bx * Ay - Ax * By); if ((x * By - y * Bx) % (Ax * By - Bx * Ay)) return false; else rx = (x * By - y * Bx) / (Ax * By - Bx * Ay); return x = rx, y = ry, true;}int main() { fac[0] = 1; FOR(i, 1, N) fac[i] = i * fac[i - 1]; ifac[N] = qPow(fac[N], mod - 2); DEC(i, N - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; read(Ex, Ey, K, Ax, Ay, Bx, By); if (!convert(Ex, Ey)) { print(0); } else { p[tot = 1] = {Ex, Ey}; FOR(i, 1, K) { int x, y; read(x, y); if (convert(x, y)) p[++tot] = {x, y}; } sort(p + 1, p + tot + 1); FOR(i, 1, tot) { f[i] = binom(p[i].first + p[i].second, p[i].second); FOR(j, 1, i - 1) if (p[j].first &lt;= p[i].first &amp;&amp; p[j].second &lt;= p[i].second) f[i] -= f[j] * binom(p[i].first - p[j].first + p[i].second - p[j].second, p[i].first - p[j].first); } FOR(i, 1, tot) if (p[i].first == Ex &amp;&amp; p[i].second == Ey) { print(f[i]); break; } } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://old.blog.imyangty.com/tags/BZOJ/"},{"name":"向量","slug":"vector","permalink":"https://old.blog.imyangty.com/tags/vector/"}]},{"title":"AGC007E - Shik and Travel","slug":"sol-agc007e","date":"2022-03-17T01:52:22.000Z","updated":"2022-03-30T00:43:45.711Z","comments":true,"path":"sol-agc007e/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc007e/","excerpt":"","text":"Description 给定一棵二叉树，每个非叶子节点一定有两个儿子，点数 n\\le 2^{17} 。从根 1 开始，欧拉序遍历这棵树。走过边会消耗边长的体力。到达叶子节点的时候体力回满，一开始从根下来的过程和最后回根的过程不消耗体力。问最小的体力。 Solution O(n^3) 的 dp 平凡，注意到问题实际上说的是求一个树的遍历序，使得所有遍历序中相邻的叶子之间的距离的最大值最小。所以二分答案。 继承 dp 的想法，考虑一个子树内 u 合法的进点/出点点对集合 S_u ，令其到 u 的距离对为 (a, b) 。那么叶子节点显然只有 (0, 0) 。对于非叶子节点，设其到左儿子的距离为 x ，到右儿子的距离为 y ，则左儿子的 (a,b) 能和右儿子的 (c,d) 合并当且仅当 b + x + y + c \\le mid ，合并可以得到 (a + x, d + y) 。 然后注意到对于子树 u ，若 (a_1,b_1) 和 (a_2, b_2) 满足 a_1\\le a_2\\land b_1\\le b_2 ，则 (a_2, b_2) 是没有用的，可以丢掉。所以 S_u 就变成了关于 a_i 递增， b_i 递减的序列。 然后就可以用双指针合并两个儿子的答案。下面给出时间复杂度的证明。 因为对于 S_u 而言，其不同取值一定不会超过其轻子树内的叶子节点个数的 2 倍（考虑合并的过程），一个叶子节点均摊合并 O(\\log n) 次，所以 O(n\\log n\\log{An}) 解决了。 Implementation 合并的过程实现起来还是略为复杂。但是我没想到二分答案也是纯傻逼了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using ll = long long;const int maxn = (1 &lt;&lt; 17) | 500;int fa[maxn], ch[maxn][2], len[maxn][2], n;using pll = pair&lt;ll, ll&gt;;vector&lt;pll&gt; S[maxn], Sl[maxn], Sr[maxn];#define fi first#define se secondbool check(ll mid) { DEC(u, n, 1) { S[u].clear(), Sl[u].clear(), Sr[u].clear(); if (!ch[u][0]) { S[u].emplace_back(pll(0ll, 0ll)); continue; } ll w = mid - len[u][0] - len[u][1]; vector&lt;pll&gt; &amp;L = S[ch[u][0]], &amp;R = S[ch[u][1]], &amp;lres = Sl[u], &amp;rres = Sr[u], &amp;res = S[u]; if (L.empty() || R.empty()) return false; for (auto itL = L.begin(), itR = R.begin(); itL != L.end(); ++itL) { while (next(itR) != R.end() &amp;&amp; next(itR)-&gt;fi + itL-&gt;se &lt;= w) ++itR; if (itR-&gt;fi + itL-&gt;se &gt; w) continue; lres.emplace_back(pll(itL-&gt;fi + len[u][0], itR-&gt;se + len[u][1])); } for (auto itL = L.begin(), itR = R.begin(); itR != R.end(); ++itR) { while (next(itL) != L.end() &amp;&amp; next(itL)-&gt;fi + itR-&gt;se &lt;= w) ++itL; if (itL-&gt;fi + itR-&gt;se &gt; w) continue; rres.emplace_back(pll(itR-&gt;fi + len[u][1], itL-&gt;se + len[u][0])); } for (auto itL = lres.begin(), itR = rres.begin(); itL != lres.end() || itR != rres.end();) { if (itR == rres.end() || (itL != lres.end() &amp;&amp; itL-&gt;fi &lt;= itR-&gt;fi)) { while (!res.empty() &amp;&amp; res.back().fi == itL-&gt;fi &amp;&amp; res.back().se &gt;= itL-&gt;se) res.pop_back(); if (res.empty() || res.back().se &gt; itL-&gt;se) res.emplace_back(*itL); ++itL; } else { while (!res.empty() &amp;&amp; res.back().fi == itR-&gt;fi &amp;&amp; res.back().se &gt;= itR-&gt;se) res.pop_back(); if (res.empty() || res.back().se &gt; itR-&gt;se) res.emplace_back(*itR); ++itR; } } } return !S[1].empty();}int main() { read(n); if (n == 1) { print(0); return output(), 0; } FOR(i, 2, n) { int p, l; read(p, l); if (ch[p][0]) ch[p][1] = i, len[p][1] = l; else ch[p][0] = i, len[p][0] = l; fa[i] = p; } ll l = 0, r = (1ll &lt;&lt; 17) * 2 * n + 1, ans = r; while (l &lt; r) { ll mid = (l + r &gt;&gt; 1); if (check(mid)) ans = mid, r = mid; else l = mid + 1; } print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"双指针","slug":"two-pointers","permalink":"https://old.blog.imyangty.com/tags/two-pointers/"}]},{"title":"SPOJ GSS 系列题解","slug":"sol-sp-gss","date":"2022-03-16T06:50:21.000Z","updated":"2022-03-23T04:18:31.092Z","comments":true,"path":"sol-sp-gss/","link":"","permalink":"https://old.blog.imyangty.com/sol-sp-gss/","excerpt":"","text":"前言 GSS 系列真的是十分经典的题。开个坑做做。 GSS1 &amp; GSS3 Description 给定序列 A_{1,\\cdots ,n} ，求区间最大子段和。GSS1 不带修，GSS3 单点修改。 Solution 1 用线段树维护最大子段和的常见套路：维护当前区间最大前缀，最大后缀和最大子段和。合并的时候简单维护。 Solution 2 动态 dp。考虑这样定义 dp 状态：设 f_i 为以 i 结尾的最大子段和， g_i 为 [1,i] 的最大子段和，则方程易得 \\begin{cases} f_i = \\max\\{f_{i - 1} + a_i, a_i\\}\\\\ g_i = \\max\\{f_i, g_{i - 1}\\} \\end{cases} 将 dp 方程写成 \\max,+ 矩阵乘法的形式： \\begin{bmatrix} a_i &amp; -\\infty &amp; a_i\\\\ a_i &amp; 0 &amp; a_i\\\\ -\\infty &amp; -\\infty &amp; 0 &amp; \\end{bmatrix} \\otimes \\begin{bmatrix} f_{i - 1}\\\\ g_{i - 1}\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} f_{i}\\\\ g_i\\\\ 0 \\end{bmatrix} 于是我们就用线段树来维护转移矩阵 \\begin{bmatrix}a_i &amp; -\\infty &amp; a_i\\\\a_i &amp; 0 &amp; a_i\\\\-\\infty &amp; -\\infty &amp; 0 &amp;\\end{bmatrix} 的连乘积（但是一定要注意是从右往左乘），对于 GSS3 的修改操作就修改矩阵就可以了。查询操作就初始化一下 ，最右边的矩阵肯定是 \\begin{bmatrix}a_l\\\\a_l\\\\0\\end{bmatrix} ，查询出 [l + 1, r] 的连乘积再左乘给初始矩阵就得解了。容易发现单位矩阵为 \\begin{bmatrix}0 &amp; -\\infty &amp; -\\infty\\\\-\\infty &amp; 0 &amp; -\\infty\\\\-\\infty &amp; -\\infty &amp; 0\\end{bmatrix} 。 GSS2 Description 不带修，区间查询最大子段和，但相同的数只贡献一次。 Solution GSS4 区间开方区间求和，初始时 \\sum A_i\\le 10^{18} 。 注意到一个数被开方的次数其实很小，顶多 6 次就会变成 1 。所以不妨维护区间最大值，若区间最大值不为 1 则递归暴力修改，若为 1 说明不用修改。 势能分析可得其复杂度的正确性。 GSS6 维护整数序列，支持单点插入，单点删除，单点修改值，区间最大子段和。 发现拿个平衡树像 GSS3 那样维护就可以了。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"平衡树","slug":"balanced-bst","permalink":"https://old.blog.imyangty.com/tags/balanced-bst/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://old.blog.imyangty.com/tags/SPOJ/"}]},{"title":"AGC010E - Rearranging","slug":"sol-agc010e","date":"2022-03-15T11:52:00.000Z","updated":"2022-03-30T00:49:41.603Z","comments":true,"path":"sol-agc010e/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc010e/","excerpt":"","text":"Description 题意：给定 N\\le 2000 个整数 A_i 。先手将其任意打乱，后手可以任意次交换任意两个相邻的互质的数。先手想最小化字典序，后手想最大化字典序，双方绝顶聪明，问最后结果。 Solution 关键性质：先手打乱数列之后，任意两个不互质的数对之间的相对位置都不会发生改变。那么我们不妨将所有不互质的数对连边，然后先手做的事情就是给其定向（显然会形成个 DAG），而后手做的事情就是找到这个 DAG 的最大字典序的拓扑序。 为了让字典序尽可能小，我们先将 A_i 排序，然后贪心地 dfs 给边定向。然后再随便找找其最大拓扑序即可。 Implementation 1234567891011121314151617181920212223242526272829303132333435const int maxn = 2005;int a[maxn], n, mp[maxn][maxn], vis[maxn], ind[maxn];vector&lt;int&gt; G[maxn];void dfs(int u) { vis[u] = 1; FOR(v, 1, n) { if (vis[v] || !mp[u][v]) continue; G[u].push_back(v), ++ind[v]; dfs(v); } return;}void toposort() { priority_queue&lt;int&gt; q; FOR(i, 1, n) if (!ind[i]) q.push(i); while (!q.empty()) { int u = q.top(); q.pop(); print(a[u], ' '); for (auto &amp;v : G[u]) if (!--ind[v]) q.push(v); } return;}int main() { read(n); FOR(i, 1, n) read(a[i]); sort(a + 1, a + n + 1); FOR(i, 1, n) FOR(j, 1, n) if (__gcd(a[i], a[j]) &gt; 1) mp[i][j] = mp[j][i] = 1; FOR(i, 1, n) if (!vis[i]) dfs(i); toposort(); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"博弈论","slug":"game-theory","permalink":"https://old.blog.imyangty.com/tags/game-theory/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"拓扑排序","slug":"toposort","permalink":"https://old.blog.imyangty.com/tags/toposort/"}]},{"title":"BZOJ#3864. Hero meet devil","slug":"sol-bzoj3864","date":"2022-03-09T12:03:00.000Z","updated":"2022-03-23T04:18:30.663Z","comments":true,"path":"sol-bzoj3864/","link":"","permalink":"https://old.blog.imyangty.com/sol-bzoj3864/","excerpt":"","text":"Description 令字符集为 \\{\\texttt{A},\\texttt{T},\\texttt{C},\\texttt{G}\\} ，给定一个长度为 n 的字符串 S ，问有多少长度为 m 的字符串 T 与 S 的 LCS 为 i ，对所有 i\\in[0,n] 输出答案。 n\\le 15 ， m\\le 1000 ，答案对 10^9 + 7 取模。 Solution 据说是很牛逼的叫做“dp 套 dp”的科技。 回顾经典的 LCS 的 dp，令 g_{i,j} 为 T 的前 i 位与 S 的前 j 位的 LCS，则有转移： g_{i,j} = \\begin{cases} g_{i - 1, j - 1} + 1 &amp;T_i = S_j\\\\ \\max\\{g_{i - 1, j}, g_{i, j - 1}\\}&amp;\\text{otherwise} \\end{cases} 于是有一个 dp 方法：一边 O(4^m) 枚举 T 的每一位一边做 dp，并将当前的一行 g_i 作为参数传入 dfs 函数里面。 然后注意到 g_{i,j} 与 g_{i, j - 1} 至多相差 1 ，所以考虑将这个差分数组状压起来成一个整数 s 。 然后你发现转移只跟 T_i 是啥有关，所以不妨处理一下当前是 s 的话， T_i = c 能转移到哪里去（ \\operatorname{trans}(s, c) ）处理方法就跟上面的暴力差不多。 于是就设 f_{i, s} 为 T 的前 i 位，dp 数组为 s ，方案数，时间复杂度 O(2^nm|\\Sigma|) 。 回顾一下会发现 dp 套 dp 实际上就是将内层 dp 的结果作为外层的状态，然后内层 dp 是一个类似自动机的状态转移。 Implementation 常数似乎有点大。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int maxn = 16, maxm = 1005, maxS = 1 &lt;&lt; 15;int n, m, nxt[maxS][4], g[maxn], nxtg[maxn];char str[maxn];modint f[2][maxS], ans[maxn];void initNxt() { FOR(i, 1, n) { if (str[i] == 'A') str[i] = 0; else if (str[i] == 'T') str[i] = 1; else if (str[i] == 'G') str[i] = 2; else if (str[i] == 'C') str[i] = 3; } FOR(S0, 0, (1 &lt;&lt; n) - 1) { for (int j = 1, i = S0; j &lt;= n; ++j, i &gt;&gt;= 1) g[j] = (i &amp; 1) + g[j - 1]; FOR(c, 0, 3) { int newS = 0; FOR(i, 1, n) { if (c == str[i]) nxtg[i] = g[i - 1] + 1; else nxtg[i] = max(nxtg[i - 1], g[i]); newS += (nxtg[i] - nxtg[i - 1]) * (1 &lt;&lt; (i - 1)); } nxt[S0][c] = newS; } } return;}int main() { int T; cin &gt;&gt; T; while (T--) { cin &gt;&gt; str + 1 &gt;&gt; m; n = strlen(str + 1); initNxt(); memset(f, 0, sizeof f); f[0][0] = 1; FOR(i, 0, m - 1) { memset(f[(i &amp; 1) ^ 1], 0, sizeof f[(i &amp; 1) ^ 1]); FOR(c, 0, 3) FOR(j, 0, (1 &lt;&lt; n) - 1) f[(i &amp; 1) ^ 1][nxt[j][c]] += f[i &amp; 1][j]; } memset(ans, 0, sizeof ans); FOR(j, 0, (1 &lt;&lt; n) - 1) ans[__builtin_popcount(j)] += f[(m &amp; 1)][j]; FOR(i, 0, n) cout &lt;&lt; ans[i].val &lt;&lt; '\\n'; } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://old.blog.imyangty.com/tags/BZOJ/"},{"name":"dp套dp","slug":"dp-in-dp","permalink":"https://old.blog.imyangty.com/tags/dp-in-dp/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"}]},{"title":"P6453 [COCI2008-2009#4] PERIODNI","slug":"sol-luogu-p6453","date":"2022-03-08T08:20:53.000Z","updated":"2022-03-23T04:18:31.043Z","comments":true,"path":"sol-luogu-p6453/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p6453/","excerpt":"","text":"Description 给一个 n 列组成的表格，每一列底部对齐，每列的高度分别为 a_i 。 要在里面填 k 个相同的数，但不得有两个数在同一行或者同一列。特别地，若两数在同一行而中间没有连通，则不算。 求方案数模 10^9 + 7 ， 1\\le n,k\\le 500 ，层高不超过 10^6 。 Solution 显然每列最多就填一个数。所以我们需要考虑的无非是放在哪里罢了。 然后你注意到只要中间有一个矮的，两边就可以同时放高的。 于是考虑建出序列的笛卡尔树，令一个节点管辖的区域为以 h_x - h_{fa_x} 为高，区间长度 size_x 为长的矩形，于是设 f_{i, j} 为子树 i 内，填了 j 个数（注意到这些数字的高均 &gt; h_{fa_x} ）的答案。那么转移要么是合并两个子树的答案，要么是在自己代表的矩形里面填数。 合并两个子树的答案不难，略过， O(n^2) 可以完成。 然后就考虑在当前矩形里面填多少数字。若我们填 y 个，则方案数是 \\binom{size_x}{y}\\times\\binom{h_x - h_{fa_x}}{y}\\times y! 然后考虑到子树和其会产生影响，故我们卷一下，和上面的结果联系起来就是： f_{i,j} = \\sum_{l+r\\le j}f_{lson, l}\\times f_{rson, r}\\times \\binom{size_x - (l + r)}{j - (l + r)}\\times\\binom{h_x - h_{fa_x}}{j - (l + r)}\\times (j - l - r)! 变换一下式子： f_{i,j} = \\sum_{y}\\binom{size_x - y}{j - y}\\times\\binom{h_x - h_{fa_x}}{j -y}\\times (j - y)!\\times \\sum_{l+r=y}f_{lson, l}f_{rson, r} 把后面的那个东西预处理一下，总时间复杂度就为 O(nk^2) 。 Implementation 1234567891011121314151617181920212223242526272829303132333435const int maxn = 505, N = 1e6;int n, K, a[maxn], ls[maxn], rs[maxn], size[maxn], stk[maxn], top;modint f[maxn][maxn], fac[N + 5], ifac[N + 5], tmp[maxn];modint binom(int n, int m) {return n &lt; m ? 0 : fac[n] * ifac[m] * ifac[n - m];}void dfs(int u, int fa) { size[u] = 1; if (ls[u]) dfs(ls[u], u), size[u] += size[ls[u]]; if (rs[u]) dfs(rs[u], u), size[u] += size[rs[u]]; FOR(i, 0, size[u]) tmp[i] = 0; FOR(i, 0, size[ls[u]]) FOR(j, 0, size[rs[u]]) tmp[i + j] += f[ls[u]][i] * f[rs[u]][j]; FOR(j, 0, size[u]) FOR(y, 0, j) f[u][j] += tmp[y] * fac[j - y] * binom(size[u] - y, j - y) * binom(a[u] - a[fa], j - y); return;}int main() { fac[0] = 1, f[0][0] = 1; FOR(i, 1, N) fac[i] = i * fac[i - 1]; ifac[N] = qPow(fac[N], mod - 2); DEC(i, N - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; read(n, K); FOR(i, 1, n) read(a[i]); stk[top = 1] = 1; FOR(i, 2, n) { while (top &amp;&amp; a[stk[top]] &gt; a[i]) --top; if (!top) ls[i] = stk[top + 1]; else ls[i] = rs[stk[top]], rs[stk[top]] = i; stk[++top] = i; } dfs(stk[1], 0); print(f[stk[1]][K]); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"笛卡尔树","slug":"cartesian-tree","permalink":"https://old.blog.imyangty.com/tags/cartesian-tree/"}]},{"title":"P2144 [FJOI2007]轮状病毒","slug":"sol-luogu-p2144","date":"2022-02-19T04:20:49.000Z","updated":"2022-03-23T04:18:30.881Z","comments":true,"path":"sol-luogu-p2144/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2144/","excerpt":"","text":"Description 轮状病毒有很多变种。许多轮状病毒都是由一个轮状基产生。一个n轮状基由圆环上n个不同的基原子和圆心的一个核原子构成。2个原子之间的边表示这2个原子之间的信息通道，如图1。 n轮状病毒的产生规律是在n轮状基中删除若干边，使各原子之间有唯一一条信息通道。例如，共有16个不同的3轮状病毒，入图2所示。 给定n(N&lt;=100)，编程计算有多少个不同的n轮状病毒。 Solution 一看就是统计生成树个数，上矩阵树定理。 n 轮状病毒的 n + 1 阶 Kirchhoff 矩阵应为 \\begin{bmatrix} n &amp; -1 &amp; -1 &amp; -1 &amp; \\cdots &amp; -1 &amp; -1\\\\ -1 &amp; 3 &amp; -1 &amp; 0 &amp; \\cdots &amp; 0 &amp; -1\\\\ -1 &amp; -1 &amp; 3 &amp; -1 &amp; \\cdots &amp; 0 &amp; 0\\\\ -1 &amp; 0 &amp; -1 &amp; 3 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp;\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots\\\\ -1 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; -1\\\\ -1 &amp; -1 &amp; 0 &amp; 0 &amp; \\cdots &amp; -1 &amp; 3 \\end{bmatrix} 但是这个矩阵不是很好直接高斯消元求 n 阶子式的值，因为高精度运算比较麻烦，我们尝试观察性质。 发现第一行和第一列删掉之后长得很漂亮： \\boldsymbol M _n = \\begin{bmatrix} 3 &amp; -1 &amp; 0 &amp; \\cdots &amp; 0 &amp; -1\\\\ -1 &amp; 3 &amp; -1 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 3 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots\\\\ 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; -1\\\\ -1 &amp; 0 &amp; 0 &amp; \\cdots &amp; -1 &amp; 3 \\end{bmatrix} 把他按照第一列展开之后可以得到 \\det\\boldsymbol M_n = 3\\det\\begin{bmatrix} 3 &amp; -1 &amp; \\cdots &amp; 0 &amp; 0\\\\ -1 &amp; 3 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots\\\\ 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; -1\\\\ 0 &amp; 0 &amp; \\cdots &amp; -1 &amp; 3 \\end{bmatrix} + \\det\\begin{bmatrix} -1 &amp; 0 &amp; \\cdots &amp; 0 &amp; -1\\\\ -1 &amp; 3 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots\\\\ 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; -1\\\\ 0 &amp; 0 &amp; \\cdots &amp; -1 &amp; 3 \\end{bmatrix} \\\\+ (-1)^n\\det\\begin{bmatrix} -1 &amp; 0 &amp; \\cdots &amp; 0 &amp; -1\\\\ 3 &amp; -1 &amp; \\cdots &amp; 0 &amp; 0\\\\ -1 &amp; 3 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots\\\\ 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; -1\\\\ \\end{bmatrix} 将其记作 \\det\\boldsymbol M_n = 3d_{n - 1} + a_{n - 1} + (-1)^nb_{n-1} 由于 d_{n} 是三对角行列式，所以展开 d_{n} 可以得到 d_{n} = 3d_{n - 1} - d_{n - 2} 。展开 a_n 可以得到 a_n = -d_{n - 1} -1 ，按第一行展开 b_n 可得到 (-1)^nb_{n} = -d_{n - 1} - 1 。代入上面公式可得到 \\det\\boldsymbol M_n = 3d_{n - 1} - 2d_{n - 2} - 2 而 d_n = 3d_{n - 1} - d_{n - 2} ，所以待定系数法一波可以推出 \\det\\boldsymbol M_n = 3\\det\\boldsymbol M_{n - 1} - \\det\\boldsymbol M_{n - 2} + 2 可以直接递推也可以直接矩阵快速幂。 需要高精度，不放代码了。 过程：设 \\det\\boldsymbol M_n = f_n ，则设 f_n = \\alpha f_{n - 1} + \\beta f_{n - 2} + \\gamma ，有 \\begin{cases} 3d_{n - 1} - 2d_{n - 2} - 2 = \\alpha(3d_{n - 2} - 2d_{n - 3} - 2) + \\beta(3d_{n - 3} - 2d_{n - 4} - 2) + \\gamma\\\\ d_n = 3d_{n - 1} - d_{n - 2} \\end{cases} 化简一下左侧 \\begin{aligned} 3d_{n-1}-2d_{n-2}-2&amp;=3(3d_{n-2}-d_{n-3}) - 2(3d_{n-3} - d_{n - 4})-2\\\\ &amp;= 3(3(3d_{n - 3} - d_{n - 4}) - d_{n - 3}) - 2(3d_{n - 3} - d_{n - 4})-2\\\\ &amp;= 7(3d_{n-3} -d_{n - 4}) -3d_{n-3}-2\\\\ &amp;= 18d_{n-3} - 7d_{n-4}-2 \\end{aligned} 化简右侧： \\begin{aligned} &amp;\\alpha(3d_{n - 2} - 2d_{n - 3} - 2) + \\beta(3d_{n - 3} - 2d_{n - 4} - 2) + \\gamma\\\\ =&amp;\\alpha(7d_{n-3} - 3d_{n-4} - 2) + \\beta(3d_{n - 3} - 2d_{n - 4} - 2) + \\gamma\\\\ =&amp;(7\\alpha + 3\\beta)d_{n - 3} - (3\\alpha + 2\\beta)d_{n - 4} - 2\\alpha - 2\\beta + \\gamma \\end{aligned} 于是有了 \\begin{cases} 7\\alpha + 3\\beta = 18\\\\ 3\\alpha + 2\\beta = 7\\\\ 2\\alpha + 2\\beta - \\gamma = 2 \\end{cases} 解出来 \\begin{cases} \\alpha = 3\\\\ \\beta = -1\\\\ \\gamma = 2 \\end{cases} 真恶心。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"矩阵树定理","slug":"matrix-tree","permalink":"https://old.blog.imyangty.com/tags/matrix-tree/"},{"name":"行列式","slug":"det","permalink":"https://old.blog.imyangty.com/tags/det/"}]},{"title":"P5631 最小mex生成树","slug":"sol-luogu-p5631","date":"2022-02-18T04:40:18.000Z","updated":"2022-03-23T04:18:31.024Z","comments":true,"path":"sol-luogu-p5631/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5631/","excerpt":"","text":"Description 给定一张无向连通带权图，问其最小 mex 生成树。即要求生成树的所有边权的 mex 最小。 1\\le n\\le 10^6 ， 1\\le m\\le 2\\times 10^6 ， 0\\le w\\le 10^5 。 Solution orz，为啥俩 \\log 能过。 首先可以考虑枚举答案，即枚举这个 mex，然后就只需要将图中边权等于这个 mex 的边全部删掉再看图是否连通。 但是这样做是 O(wm\\log n) 的，铁定过不去，考虑能否优化“判断图是否连通”这个过程。 由于 w 较小，所以考虑一个线段树分治，将边权为 x 的边挂在线段树 [1, x - 1] 和 [x + 1, \\max] 的区间上。然后递归进线段树，进一个节点就加上这些节点的边，然后到了叶子节点后自然除了边权为 x 的边外其他都加上了，直接判断就可以了。 复杂度为 O(m\\log n\\log w) 。 Implementation 空间需要卡一卡。。。还有注意线段树下标区间应为 [0, \\max w + 1] ，保证搜得到解。 然后需要加剪枝不然很容易寄。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using pii = pair&lt;int, int&gt;;const int maxn = 1e6 + 5, maxm = 2e6 + 5, maxw = 1e5 + 5;int n, m, W;struct Edge { int u, v, w;} e[maxm];vector&lt;int&gt; t[maxw &lt;&lt; 2];struct UnionFind { int top, fa[maxn], sz[maxn], tot, stk[maxn]; void init() { FOR(i, 1, n) fa[i] = i, sz[i] = 1; top = 0, tot = n; } int find(int x) {return fa[x] == x ? x : find(fa[x]);} il bool ask(int x, int y) {return find(x) == find(y);} void merge(int x, int y) { x = find(x), y = find(y); if (x == y) return; if (sz[x] &gt; sz[y]) swap(x, y); fa[x] = y, sz[y] += sz[x], --tot; stk[++top] = x; return; } void undo(int tar) { while (top &gt; tar) { int &amp;x = stk[top--]; sz[fa[x]] -= sz[x]; fa[x] = x; ++tot; } return; }} ufs;#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void insert(int i, int j, int k, int x, int y, int id) { if (x &gt; y) return; if (x &lt;= i &amp;&amp; y &gt;= j) return t[k].push_back(id); if (x &lt;= M) insert(i, M, L, x, y, id); if (y &gt; M) insert(M + 1, j, R, x, y, id); return;}void dfs(int i, int j, int k) { int now = ufs.top; for (int id : t[k]) ufs.merge(e[id].u, e[id].v); if (i == j) { if (ufs.tot == 1) return print(i), output(), exit(0); else return ufs.undo(now); } dfs(i, M, L), dfs(M + 1, j, R); return ufs.undo(now);}int main() { read(n, m); FOR(i, 1, m) read(e[i].u, e[i].v, e[i].w), chkmax(W, e[i].w); FOR(i, 1, m) { insert(0, W + 1, 1, 0, e[i].w - 1, i); insert(0, W + 1, 1, e[i].w + 1, W, i); } ufs.init(); dfs(0, W + 1, 1); print(W + 1); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"线段树分治","slug":"segtree-division","permalink":"https://old.blog.imyangty.com/tags/segtree-division/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"并查集","slug":"dsu","permalink":"https://old.blog.imyangty.com/tags/dsu/"}]},{"title":"图论复习 1（图论基础知识）","slug":"summary-graph1","date":"2022-02-18T03:03:52.000Z","updated":"2022-03-31T02:13:07.166Z","comments":true,"path":"summary-graph1/","link":"","permalink":"https://old.blog.imyangty.com/summary-graph1/","excerpt":"","text":"前言 省选 + NOI 复习。 全凭个人喜好来搞。 不会写的很严谨，实战导向型。 本文内容概览： 最小生成树（不含矩阵树，LCT 维护，Kruskal 重构树） 最短路与差分约束 连通性相关（BCC，SCC，不含圆方树）与 2 - SAT 最小生成树 全是基于贪心的算法。 求解算法 Prim 算法是一种最小生成树算法，思想比较类似于 Dijkstra，实战中用的较少。 从一个点开始，每次将离当前点集中距离最小的点加入生成树（很类似 Dijkstra 算法）。 这个算法的时间复杂度为 O(n^2) ，一般用于稠密图上的最小生成树，跑的会比 Kruskal 快。但是稀疏图上一般使用 Kruskal。 Kruskal 算法是另一种最小生成树算法，实战中较为常用（实际上就没写过几次另外两个）。 将所有的边按照权值从小到大排序，每次贪心地选最小的边，若两端点已经连通则舍去，未连通则将其连上并将该边加入最小生成树。 需要前置知识并查集来维护连通性，时间复杂度 O(m\\log n) 。在稀疏图上跑的很快。 Boruvka 算法是第三种最小生成树算法，较为少见，但是一些题目中用该算法的思想来思考会有奇效。 主要思想是合并连通块（即多路增广的 Prim）。我们每次都遍历所有的边，对每个连通块都找到一个不在最小生成树中的，连向其他连通块的最短边（代码中的 best[] 数组），需要按照编号严格排序，避免两个连通块互连成环。然后将这些连通块两两合并。 每次合并后，连通块的个数都减少一半，所以时间复杂度为 O(m\\log n) 。实战中并不常用，而是借用其合并连通块的思想来解决问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int n, m;int u[maxm], v[maxm], w[maxm];int fa[maxn], best[maxn];bool used[maxm];inline int find(int u) { return u == fa[u] ? u : fa[u] = find(fa[u]);}inline bool better(int i, int j) { if (!j) return 1; if (w[i] != w[j]) return w[i] &lt; w[j]; return i &lt; j;}int main() { n = read(), m = read(); FOR(i, 1, m) u[i] = read(), v[i] = read(), w[i] = read(); FOR(i, 1, n) fa[i] = i; int merged = 0, ans = 0; bool update = 1; while (update) { update = 0; memset(best, 0, sizeof best); FOR(i, 1, m) { if (used[i]) continue; int p = find(u[i]), q = find(v[i]); if (p == q) continue; if (better(i, best[p])) best[p] = i; if (better(i, best[q])) best[q] = i; } FOR(i, 1, n) if (best[i] &amp;&amp; !used[best[i]]) { update = 1; ++merged, ans += w[best[i]]; used[best[i]] = 1; fa[find(u[best[i]])] = find(v[best[i]]); } } if (merged == n - 1) printf(\"%d\\n\", ans); else puts(\"orz\"); return 0;} 应用 生成树的一些高阶应用如 LCT 维护最小生成树、生成树计数（Matrix-Tree 定理）和 Kruskal 重构树不会放在本 blog 中。 例题 1：P4180 [BJWC2010]严格次小生成树 如题，注意严格次小生成树的边权和要严格大于最小生成树的边权和。 我们注意到，肯定只换掉原来最小生成树的一条边是最优的，因为换更多的一定不会更优。 然后，我们可以枚举所有的边 (u, v) ，然后换掉的边一定就是树链 (u, v) 上的边。由一个很简单的贪心可知，换掉树链上的最大边是最优的（因为根据 Kruskal，要加的边肯定不小于树边），但是若树链上的最大边与待加边相等则不满足严格次小，所以就需要拿树链上的严格次大边来替换。 所以一个树剖 + 最大值/严格次大值查询（可以 ST 表也可以线段树）就完事了， O(m\\log^2n) 。 例题 2：CF888G Xor-MST 给定 n 个带权点，定义 i 和 j 的连边权值为 a_i\\oplus a_j ，求这张完全图的最小生成树。 用类似 Boruvka 算法的思想，考虑 O(\\log n) 次合并连通块。 考虑将所有的数字按照最高位划分为两个集合，由异或的性质知道这两个集合中间只连一条边肯定最优，所以暴力拿 0-1 Trie 来找这两个集合间的最小连边。然后递归处理这两个集合，详见 我的题解。 最短路 Floyd 一种全源最短路（求两两点对之间的最短路）算法，时间复杂度 O(n^3) 。 具体地，考虑一个 dp：设 f_{k, i, j} 表示只允许经过编号为 [1, k] 的点， (i, j) 间的最短路。然后答案显然为 f_{n, i, j} 。 初始化： f_{0, i, j} = \\begin{cases} w(i, j)&amp;\\text{there is an edge between } i \\text{ and } j\\\\+\\infty&amp;\\text{otherwise}\\end{cases} 。转移的时候我们从小到大枚举 k ，然后有 f_{k, i, j} = \\min(f_{k - 1, i, j}, f_{k, i, k} + f_{k, k, j}) ，具体意义为将 k 作为新的转移点来更新 (i,j) 的最短路。 时间复杂度 O(n^2) ，第一维可以滚动掉。 其中，由于 f_{i,j} = \\min_k \\{f_{i,k} + f_{k,j}\\} 的形式是 \\min,+ 型矩阵乘法，其满足结合律，所以有些题目中可以结合上矩阵快速幂。 另外，将所有边权视作 1 或 0 ，就等价于求图的传递闭包，用 bitset 优化可以做到 O(n^3/w) 。 Floyd 支持负权图，但是需要保证最短路存在（没有负环）。判断负环的方法即看迭代了 n 轮后最短路是否已经被确定，若还有能更新的值说明存在负环。 Bellman-Ford 和 SPFA Bellman-Ford 算法是一种单源最短路（求给定源点到剩下所有点的最短路）算法。它的想法是，每轮都枚举所有边进行松弛操作，最多进行 n-1 轮，时间复杂度 O(nm) 。Bellman-Ford 算法支持求负权图的最短路或者判断负环。 其中，松弛操作即指 \\mathrm{dis}_v = \\min(\\mathrm{dis}_v, \\mathrm{dis}_u + w(u,v)) 。我们这样做的目的是尝试用 S\\to u\\to v 这条路径来更新 \\mathrm{dis}_v 。每轮松弛操作会使得最短路条数 +1 ，最短路存在时长度最大为 n - 1 ，所以松弛最多进行 n - 1 次。 当然，如果进入了一个负环，最短路就不存在了，所以第 n 轮循环时若存在能松弛的边，说明从 S 出发能到达负环。 从 S 出发找不到负环不代表图中没有负环，真要找负环的话请建超级源点并向所有点连 0 权边。 队列优化：SPFA： Shortest Path Faster Algorithm，其想法是基于只有上一次被成功松弛的点所连接的边才有机会引起下一次松弛操作，所以每次松弛成功后将被松弛的点加入队列（如果没被加入队列的话）。 123456789101112131415161718void SPFA(int s) { memset(dis, 0x3f, sizeof dis); queue&lt;int&gt; q; dis[s] = 0, inq[s] = 1; q.push(s); while (!q.empty()) { int u = q.front(); inq[u] = 0, q.pop(); for (auto &amp;e : G[u]) { int &amp;v = e.to; if (dis[u] + e.w &lt; dis[v]) { dis[v] = dis[u] + e.w; if (!inq[v]) inq[v] = 1, q.push(v); } } }} SPFA 在随机数据下表现极其优秀，但是基本都会被出题人卡成最坏复杂度 O(nm) 。图中没有负权边时，请使用 Dijkstra，否则题目中要么会隐式给出点的势能（见 Johnson 算法）要么不会卡 SPFA（比如大多数费用流题目）。 SPFA 同样可以判断负环，但是不能用松弛操作次数来判断，见洛谷负环模板题解，hack 的原理就是对 n 号节点进行 n - 1 轮松弛，这样能产生 O(n^2) 级别的松弛次数，但是可以使用入队次数判断，因为一轮松弛中一个节点只会入队一次。当然使用最短路边数判断是最稳妥也是最快速的。 Dijkstra Dijkstra 算法是一种常见的非负权图单源最短路算法，是一种基于贪心的算法。实战中常用优先队列优化，其复杂度为 O(m\\log m) ，由于 SPFA 复杂度上界为 O(nm) ，建议实战中使用 Dijkstra 算法。 其流程是，将所有点划分为 S 和 T 两个点集，分别表示其最短路长度有没有被确定。初始化 \\mathrm{dis}_s = 0 ，其他 \\mathrm{dis}_i = +\\infty ，然后重复如下流程： 从 T 集合中选取一个最短路最短的点移到 S 集合中。 对刚才那个点的所有出边进行松弛操作。 T 集合为空时，算法结束。选取最短路最短的点的过程可以使用数据结构优化，实战中使用优先队列，时间复杂度 O(m\\log m) 。稠密图上暴力算法有更优秀的表现， O(n^2) 。 12345678910111213141516171819202122vector&lt;edge&gt; G[maxn];int dis[maxn], vis[maxn];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;p&gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; q;void dijkstra (int s) { memset(dis, 0x3f, sizeof dis); dis[1] = 0, q.push({0, s}); while (!q.empty()) { int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = 1; for (auto &amp;e : G[u]) { int &amp;v = e.to; if (dis[v] &gt; dis[u] + e.w) { dis[v] = dis[u] + e.w; q.push({dis[v], v}); } } } return;} 注意到，该算法的正确性基于所有边权非负，即 \\mathrm{dis}_v\\ge \\mathrm{dis}_u ，所以无法处理负权边的图。 Johnson 全源最短路 可以求出带负权边（不能有负环）的图的全源最短路。其能做到 O(nm + nf(n,m)) 的时间复杂度，其中 f(n, m) 为 Dijkstra 算法的复杂度。实战中的 Johnson 算法复杂度一般为 O(nm\\log m) 。 我们的思路是，想求出全源最短路，可以枚举起点跑 n 次 Bellman-Ford 算法，时间复杂度是 O(n^2m) 的，而如若我们能跑 n 次堆优化 Dijkstra，那么就能跑出 O(nm\\log m) 的优秀时间复杂度。 由于原图有负权边，所以需要对边进行处理，注意到同时加上一个正数的做法显然错误。Johnson 使用给点求势能的方法来标注边权：建超级源点 0 ，向所有点连 0 权边，求出 0 到所有点的最短路（即势能） h_i ，然后将边 (u, v, w) 的边权设为 w + h_u - h_v ，接下来每条边权值非负，Dijkstra 解决。 注意到，物理中的势能满足如下性质：两点间的势能差只与相对位置有关，我们可以发现从 s 走到 t 的路径，化简后可以得到 w(s, p_1) + \\cdots+ w(p_k, t) + h_s - h_t ，无论走哪条路径， h_s - h_t 都是不变的。前面的 w 加起来是路径长，后面是两点间势能差，所以原图中最短路能够对应新图中的最短路。 在跑第一轮 Bellman-Ford 的时候，根据三角形不等式， h_v\\le h_u + w(u, v) ，所以 w(u, v) + h_u - h_v\\ge 0 ​，新图边权非负，该算法正确性得到了证明。 最短路树 应用 例题 1：P1119 灾后重建 给定 n 个点和 m 条边的长度。给出第 i 个点可用的时间 t_i ，之后有 q 个询问 (x, y, t) ，即询问时间 t 时 (x, y) 的最短路，要求只能经过 t_i &lt; t 的点 i 。 n\\le 200 。 一道考察了 Floyd 本质的好题。离线所有询问并按时间顺序排序，将所有点按时间顺序排序。数据范围暗示我们考虑 Floyd。发现 Floyd 的本质就是枚举转移点，那么我们不妨就按照恢复时间的顺序来枚举这个转移点，并在对应的时间回答询问。 例题 2：P1144 最短路计数 对每个 t 求 s 到其最短路的条数。 n = 10^6, m = 2\\times 10^6 。 可以直接在做 Dijkstra 的时候 DP，对于一次松弛操作，若三角形不等式取到等号，则对最短路条数进行累加，否则直接覆盖掉。 例题 3：P1629 邮递员送信 有一个邮递员要送东西，邮局在节点 1 。他总共要送 n-1 样东西，其目的地分别是节点 2 到节点 n 。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有 m 条道路。这个邮递员每次只能带一样东西，并且运送每件物品过后必须返回邮局。求送完这 n-1 样东西并且最终回到邮局最少需要的时间。保证图强连通， n=10^3 ， m=10^5 。 有一个很重要的思想叫做建反图，上题中我们要求所有的点到 1 的距离，那么建出反图之后就又变回了 1 到所有点的距离。因此跑正反两次 Dijkstra 就解决了上题。 例题 4：P5304 [GXOI/GZOI2019]旅行者 T 组数据，给定一张带权有向图，求给定的大小为 k 的点集中，两两之间最短路。 k\\le n=10^5 ， m=5\\times 10^5 ，5s。 技巧：二进制分组，发现点集中的每个点对至少会有一个二进制位不一样，因此考虑枚举不同的这一位，将点集按这一位是 0 还是 1 划分为两组，然后建超级源汇点跑最短路。时间复杂度 O(Tm\\log m\\log k) 。 当然本题还有更优秀的 O(Tm\\log m) 做法，考虑做正反两次 Dijkstra，求出 f_u 表示 u 到任意特殊点的最短距离和 g_u 表示任意特殊点到 u 的最短距离，并记录下对应的特殊点，然后枚举所有的中转点/中转边即可计算答案。 例题 5：P4568 [JLOI2011]飞行路线 n 点 m 边有向带权图，要从 s 到 t ，可以指定最多 k 条边的边权为 0 ，求最短路。 2\\le n\\le 10^4 ， 1\\le m\\le 5\\times 10^5 ， 0\\le k\\le 10 。 技巧：分层图，考虑到 k 很小，因此暴力将整张图变成 k + 1 层，对每层内的点连边以及从上层点向下一层点连 0 权边，这样每次从上层到下层都表示指定一条边的边权为 0 。然后直接从最上层的起点跑最短路即可，答案一定在最下层的终点。 当然若是像 P6190 [NOI Online #1 入门组] 魔法 这样的点数很小而“看上去的层数”极大的题，请考虑使用 Floyd + 矩阵快速幂。 例题 6：ABC237E - Skiing 滑雪场有 n 个空地，空地之间有 m 条赛道。每个空地有海拔 h_i ，高桥君从点 1 开始滑雪。假设滑的赛道为 x\\to y ： 若 h_x &gt; h_y ，愉悦指数增加 h_x - h_y 。 若 h_x\\le h_y ，愉悦指数减少 2(h_y - h_x) 。 求能获得的最大愉悦指数。 2\\le n\\le 2\\times 10^5 ， n-1\\le m\\le \\min(2\\times 10^5, n(n-1)/2) 。 建出图来发现是个带负权边的最长路，虽然说出题人不讲武德放 SPFA 过了，但是考虑复杂度正确的方法。 发现如果将所有的边权取负值，则 h 天然满足势能的性质，所以修改边权之后跑 Dijkstra 即可。 差分约束 问题描述 差分约束系统是一个特殊的 n 元一次不等式组，其包含 n 个变量 x_1,\\cdots,x_n 以及 m 个形如 x_i - x_j\\le c_k 的约束条件，其中 c_k\\in\\mathbb R 。现在要求求出一组解或者判断无解。 我们发现，每个约束条件可以变为 x_i\\le x_j + c_k ，这个形式类似于单源最短路中的三角形不等式 \\mathrm{dis}_v\\le \\mathrm{dis}_u+w(u,v) 。因此对于上面的约束条件，不妨连边 (j,i,c_k) 。 然后从超级源点 S 向每个点连 0 权边，跑单源最短路。若遇到了负环，则无解，否则 \\mathrm{dis} 数组就是合法的一组解。 由于 c_k 常常可以为负，所以解决这个问题的上界为 O(nm) 。 性质及应用 对于不等号为大于等于号的情况，可以考虑不等式两边同乘 -1 。 对于 x_i = x_j 的限制可以转化为 x_i - x_j\\le 0\\land x_j - x_i\\le 0 。 对于一组解 \\boldsymbol x = (a_1, a_2,\\cdots, a_n) ， \\boldsymbol x' = (a_1 + d,\\cdots, a_n + d) 也肯定是一组解，其中 d 为任意常数。因为不等式两边同时加/减并不影响。 例题 1：P1993 小 K 的农场 求解差分约束系统，每条约束形如 x_i - x_j\\le c ， x_i - x_j\\ge c ， x_i = x_j 。判断有解性。 我们可以进行如下转化： x_i-x_j\\ge c\\iff x_j - x_i\\le -c ， x_i = x_j\\iff x_i - x_j\\le 0\\land x_i - x_j\\ge 0 。于是所有的约束条件都能归约到最基本的上面，跑个 SPFA 判负环即可。 例题 2：P4926 倍杀测量者 给定一个约束系统，求一个最大正实数 T 使得下面约束系统无解： x_a&gt; (k_i-T)x_b x_a(k_i+T)&gt;x_b x_a=c_i 首先 T 肯定满足单调性，可以二分。若 T = 0 时该系统仍然有解则输出 -1 即可。 然后考虑这种不等式怎么进行求解，发现我们对不等号两边取对数之后有 \\begin{aligned} x_a&gt;(k_i-T)x_b&amp;\\iff \\log x_a\\ge \\log(k_i - T) + \\log x_b\\\\ x_a(k_i-T)x_b&amp;\\iff \\log x_a\\ge \\log x_b - \\log(k_i - T)\\\\ x_a=c_i&amp;\\iff\\log x_a - \\log x_S\\ge \\log c_i\\land \\log x_S - \\log x_a\\ge -\\log c_i \\end{aligned} 然后就变成了一个正常的差分约束系统，直接跑 SPFA 最长路即可，有正环则说明有人女装系统无解。 例题 3：P2474 [SCOI2008]天平 n 个砝码，重量 \\in\\{1,2,3\\} 。清楚部分砝码间的重量大小关系。现已知砝码 A 和 B 放在天平左边，现在要挑出一对砝码 C 和 D 放在天平右边。问分别有多少种选法能使得左边重/一样重/右边重。要求 O(n^3) 。 注意到这些砝码可能是没有办法求出一个确切的重量值的，所以只能考虑其相对关系。先考虑 A+B&gt;C+D 的情况，其可以转化为 A-C&gt;D-B\\lor A-D&gt;C-B 。判断其成立就考虑 \\min\\{A-C\\}&gt;\\max\\{B-D\\} 之类的即可。用 f_{i,j} 维护一下 \\max\\{i-j\\} ，用 g_{i,j} 维护一下 \\min\\{i - j\\} 。剩余情况同理。 初始化：对于 i&gt;j ， f_{i,j} = 2 ， g_{i,j} = 1 。对于 i &lt; j ， f_{i,j} = -1 ， g_{i,j} = -2 。对于 i=j ， f_{i,j} = g_{i,j}=0 ，对于问号， f_{i,j} = 2 ， g_{i,j} = -2 。 求 f_{i,j} 和 g_{i,j} 可以使用 Floyd。注意 \\begin{aligned} f_{i,j} = \\min_k\\{f_{i,k} + f_{k,j} \\}\\\\ g_{i,j} = \\max_k\\{g_{i,k} + g_{k,j}\\} \\end{aligned} 理解：其实写出 x_i - x_j\\le c 和 x_i - x_j\\ge c 后发现就是最短路和最长路的模型。 C 和 D 暴力枚举即可。时间复杂度 O(n^3) 。 例题 4：P5590 赛车游戏 n 点 m 边有向图，要求给所有边赋权 [1, 9] 间的整数使得 1 到 n 的所有路径等长。要求 O(nm) 。 结论题。 1 到 n 的所有路径要等长那就只能等于最短路。所以一定有 d_v = d_u + w 。这个东西我们可以建出形如 1\\le d_v - d_u\\le 9 的不等式组。所以可以差分约束一波。注意去掉多余的边（不在 1\\to n 路径上的）。 例题 5：咕咕。 k 短路 问题描述：给定一张有向图，求从 s 到 t 的路径中第 k 短的那条的长度。 A-star 算法 A* 算法是一种启发式搜索，其定义了当前态 x 的估价函数 f(x) = g(x) + h(x) ，其中 g(x) 是从初态到当前态的距离函数， h(x) 是从当前态到终点的估计距离函数。 我们的操作流程是，每次取出最优的 f(x) （用优先队列实现），然后扩展其所有的子状态。 在 k 短路问题中，令 h(x) 为当前点到终点的最短路，这个可以通过建反图然后从 t 做 Dijkstra 实现。 然后一个状态显然需要定义为 (x, g(x)) ，维护当前点和已经走过的路。 开始时，将 (s, 0) 加入优先队列，然后每次取出 f(x) 最小的状态，然后对其进行扩展。当经过 t 第 k 次时，其必为最短路。 该做法的时间复杂度为最坏 O(nk\\log n) ，当图为 n 元环的时候达到上界。 可持久化可并堆做法 可以做到 O((n+m)\\log m + k\\log k) 。 首先在反图上从 t 点开始跑单源最短路，建立出任意一棵最短路树 T 。 性质 1：对于一条 s 到 t 的路径边集 P ，去掉 P 中和 T 的交集，记为 P' 。那么 P' 中任意相邻的两条边 e 和 f 一定满足 f 的起点在 T 中为 e 的终点的祖先或者为相同点。因为 P 中 e ， f 之间由树边相连或者直接相连。 性质 2：对于不在 T 中的边 e = (u,v,w) ，定义 \\Delta_e = \\mathrm{dis}_v + w - \\mathrm{dis}_u ，即选这条边的路径与最短路的差。设 L_P 为路径长度，则有 L_P = \\mathrm{dis}_s + \\sum_{e\\in P'}\\Delta e 性质 3：对于一个合法的 P' ，其能唯一对应一个 P ，因为 T 上两点间的路径是唯一的。 性质 1 告诉了我们生成所有合法 P' 的方法。 性质 2 告诉了我们已知 P' 后求出 L_P 的方法。 性质 3 告诉了我们 P 和 P' 是唯一对应的。 所以我们要求的就是 L_P 的值第 k 小的集合 P' 。考虑使用一个小根堆来维护所有的边集 P' ，具体地，考虑维护边集 P' 的最后一个条边的编号以及其 \\sum\\Delta e ，以 \\sum\\Delta e 为关键字。 初始时 P' 为空集，即表示我们取的是最短路。 每次取出最小 \\sum\\Delta e 的边集 P' ，设最后一条边的起点为 x ，则我们可以这样进行扩展： 替换以 x 为起点的这条边为一条刚好大于等于他的非树边。 尾部接上一条起点为 x 的边的终点在 T 中的祖先（或者自己）连出去的所有非树边中的最小边。 维护祖先出去的所有非树边的最小边可以考虑使用可并堆，然后由于需要保存所有节点的信息，故考虑可持久化，然后本题完结。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"最小生成树","slug":"mst","permalink":"https://old.blog.imyangty.com/tags/mst/"},{"name":"最短路","slug":"shortest-path","permalink":"https://old.blog.imyangty.com/tags/shortest-path/"}]},{"title":"P6773 [NOI2020] 命运","slug":"sol-luogu-p6773","date":"2022-02-16T05:44:01.000Z","updated":"2022-03-23T04:18:31.045Z","comments":true,"path":"sol-luogu-p6773/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p6773/","excerpt":"","text":"Description 给定 n 个点的树， m 条祖先到后代的链，问有多少种给树边黑白染色的方案使得每条给定的链上都至少有一条黑边，答案模 998244353 。 1\\le n,m\\le 5\\times 10^5 。 部分分： 32pts： n\\le10^5 ， m\\le 16 。 64pts： n\\le5\\times10^5 ， m\\le2\\times10^3 。 Solution 首先考虑一个简单的容斥。枚举链的子集然后覆盖掉，乘上个容斥系数啥的，复杂度 O(m2^m\\log n) ，32pts。 然后这个问题长得就很像个 dp，我们考虑一下如何定义状态。 第一个想法：我们每次转移的时候从子节点转移向父节点，考虑一条边染色/不染色。 第二个想法：当一条链包含另一条时，只有被包含的那个链是关键的。 而定义 dp 状态的时候，我们肯定考虑 f_{u,\\cdots} 表示 u 子树内所有限制均得到满足的方案数，但是这样肯定是不够的，没办法进行转移。对于 u 点来说，重要的无非就是跨越 u 点的限制和在 u 子树内的限制。 而对于那些 (x, y) 限制，其中 y 在 u 子树内（可以为 u ）， (x, y) 相当于跨越 u ，可以发现 x 一定是 u 的祖先，而为了尽量完成这些限制，肯定得给深度最深的 (x_\\max, ?) 染色，如果不给染，则 (x_\\max, y) 永远无法满足。 那么就可以定义状态为 f_{u, i} 表示 u 子树内的限制已完成，未完成的跨越 u 的限制的最大深度为 i ，的方案数。 考虑设 anc_y 为限制所有限制 (x,y) 中，深度最大的 x （因为只有这个限制有用）。 好，现在开始考虑儿子 v\\to u 的转移。 如果染色 (u,v) ，则所有端点在 v 子树内的限制都能得到满足，即 f_{u,i}\\times \\sum_{dep_{anc_v} j&lt; dep_v}f_{v,j} 不妨记录一个前缀和啥的， g_{v, j} ，因为 &lt;dep_{anc_v} 的部分都是 0 所以无关紧要。 如果不染，则若 v 中最深的限制 \\le i ，则合并后子树的最深限制仍为 i ，即 f_{u,i}\\times g_{v, i} 若 v 中最深的限制 &gt;i ，那么其是可以由更浅的限制转移而来的，贡献为 g_{u,i-1}\\times f_{v, i} 整理后可以得到 f_{u,i}\\leftarrow f_{u,i}\\times(g_{v, dep_v - 1} + g_{v, i}) + g_{u, i - 1}\\times f_{v, i}, dep_{anc_{x}}\\le i &lt; dep_x O(n^2) 的 dp 就有了，可以获得 64pts。 然后这个东西看着就很线段树合并，于是维护一个支持乘法标记的线段树，即可。一开始进节点的时候设 f_{u,dep_{anc_u}} = 1 。合并的时候类似 PKUWC minimax 一样转移。 具体地，遇到 u = 0\\land v \\ne 0 的情况，显然是将 f_{v, i} 乘上 g_{u, i - 1} ，而遇到 u\\ne 0\\land v = 0 的情况则是给 f_{u, i} 乘上 (g_{v, {dep_v - 1}} + g_{v,i}) 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const int maxn = 5e5 + 5;int n, m, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte, anc[maxn], dep[maxn];il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void dfs0(int u, int fa) { dep[u] = dep[fa] + 1; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs0(v, u); } return;}struct node { modint sum, mul; int ch[2]; node() : mul(1) {}} t[maxn * 50];int root[maxn], tot;#define ls(u) t[u].ch[0]#define rs(u) t[u].ch[1]#define M ((i + j) &gt;&gt; 1)int insert(int u, int i, int j, int x) { if (!u) u = ++tot; ++t[u].sum; if (i == j) return u; if (x &lt;= M) ls(u) = insert(ls(u), i, M, x); else rs(u) = insert(rs(u), M + 1, j, x); return u;}il void pushup(int u) { t[u].sum = t[ls(u)].sum + t[rs(u)].sum; return;}il void pushtag(int u, modint x) { t[u].sum *= x, t[u].mul *= x; return;}il void pushdown(int u) { if (t[u].mul == 1) return; pushtag(ls(u), t[u].mul), pushtag(rs(u), t[u].mul); t[u].mul = 1;}int merge(int x, int y, int i, int j, modint &amp;sumx, modint &amp;sumy) { if (!x &amp;&amp; !y) return 0; if (!x &amp;&amp; y) { sumy += t[y].sum; pushtag(y, sumx); return y; } if (x &amp;&amp; !y) { sumx += t[x].sum; pushtag(x, sumy); return x; } if (i == j) { sumx += t[x].sum; t[x].sum = t[x].sum * sumy + t[y].sum * sumx; sumy += t[y].sum; return x; } pushdown(x), pushdown(y); ls(x) = merge(ls(x), ls(y), i, M, sumx, sumy); rs(x) = merge(rs(x), rs(y), M + 1, j, sumx, sumy); return pushup(x), x;}modint query(int u, int i, int j, int x, int y) { if (x &lt;= i &amp;&amp; y &gt;= j) return t[u].sum; pushdown(u); modint ret = 0; if (x &lt;= M) ret += query(ls(u), i, M, x, y); if (y &gt; M) ret += query(rs(u), M + 1, j, x, y); return ret;}void dfs(int u, int fa) { root[u] = insert(root[u], 0, n, dep[anc[u]]); for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs(v, u); modint sumx = 0, sumy = query(root[v], 0, n, 0, dep[v] - 1); root[u] = merge(root[u], root[v], 0, n, sumx, sumy); } return;}int main() { read(n); FOR(i, 1, n - 1) { int u, v; read(u, v); add(u, v), add(v, u); } dfs0(1, 0); read(m); FOR(i, 1, m) { int u, v; read(u, v); if (dep[u] &gt; dep[anc[v]]) anc[v] = u; } dfs(1, 0); print(query(root[1], 0, n, 0, 0)); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"线段树合并","slug":"segtree-merge","permalink":"https://old.blog.imyangty.com/tags/segtree-merge/"}]},{"title":"P5298 [PKUWC2018]Minimax","slug":"sol-luogu-p5298","date":"2022-02-14T10:11:27.000Z","updated":"2022-03-23T04:18:31.012Z","comments":true,"path":"sol-luogu-p5298/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5298/","excerpt":"","text":"Description n 个节点的二叉树，根为 1 ，每个节点最多两个儿子。 定义 x 的权值为： x 没有子节点，则输入给出其权值，保证所有权值互不相同。 若 x 有子节点，则其权值有 p_x 的概率为子节点权值的最大值， 1 - p_x 的概率为子节点权值的最小值。 假设 1 号节点的权值有 m 种可能性，权值第 i 小的可能性的权值为 V_i ，概率为 D_i ，求 \\sum_{i=1}^mi\\times V_i\\times D_i^2 答案模 998244353 。 1\\le n\\le 3\\times 10^5 ，权值范围 [1, 10^9] ，概率 \\in(0,1) 。 Solution 神仙题，orz。 首先离散化掉所有的权值。显然，根节点的权值一定从叶子节点中产生。 考虑一个 DP，令 P(u, i) 为“节点 u 的权值是 i ”的概率。 对于叶子节点， P(u, k) = 1 （ k 为权值）； 对于只有一个儿子的节点， P(u, *) 直接继承儿子即可； 对于有两个儿子的节点，情况会稍微复杂些： P(u, i) = P(v_1, i)P(v_2, i) + p_u\\left(\\sum_{j &lt; i}P(v_1, i)P(v_2, j) + P(v_1, j)P(v_2, i)\\right)\\\\ + (1-p_u)\\left(\\sum_{j&gt; i}P(v_1, i)P(v_2, j)+P(v_1, j)P(v_2, i)\\right) 而 P(v_1,i) 和 P(v_2, i) 必有一方是 0 ，因为没有相等的权值，假设 P(v_2, i) = 0 ，所以 P(u, i) = p_uP(v_1, i)\\sum_{j&lt;i}P(v_2, j) + (1 - p_u)P(v_1, i)\\sum_{j&gt;i}P(v_2, j) 然后就是要维护这个傻逼东西的转移了，考虑线段树合并，合并的过程中若遇到两个节点均不为空，则直接递归，否则若有一方为空，则我们就利用上式，给另一方的区间打个乘法标记。 具体地，线段树合并的过程中在 merge 里面动态维护一下两方的前/后缀和。 Implementation 本题好像有点卡常（恼） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103const int maxn = 3e5 + 5;const modint inv10000 = qPow(10000, mod - 2);int n, son[maxn][2], root[maxn], tot;int v0[maxn], v[maxn], vtot;modint p[maxn], d[maxn];struct node { modint mul, sum; int ch[2]; node() : mul(1) {}} t[maxn * 50];#define ls(k) t[k].ch[0]#define rs(k) t[k].ch[1]#define M ((i + j) &gt;&gt; 1)il void pushup(int u) { t[u].sum = t[ls(u)].sum + t[rs(u)].sum; return;}il void pushtag(int u, modint x) { t[u].sum *= x, t[u].mul *= x; return;}il void pushdown(int u) { if (t[u].mul == 1) return; pushtag(ls(u), t[u].mul), pushtag(rs(u), t[u].mul); t[u].mul = 1; return;}int init(int u, int i, int j, int x) { if (!u) u = ++tot; t[u].sum += 1; if (i == j) return u; if (x &lt;= M) ls(u) = init(ls(u), i, M, x); else rs(u) = init(rs(u), M + 1, j, x); return u;}int merge(int x, int y, modint lx, modint rx, modint ly, modint ry, modint p) { if (!x &amp;&amp; !y) return 0; pushdown(x), pushdown(y); if ((x &amp;&amp; !y) || (!x &amp;&amp; y)) { if (!x &amp;&amp; y) swap(x, y), swap(lx, ly), swap(rx, ry); pushtag(x, p * ly + (1 - p) * ry); return x; } modint px = t[ls(x)].sum, py = t[ls(y)].sum, sx = t[rs(x)].sum, sy = t[rs(y)].sum; ls(x) = merge(ls(x), ls(y), lx, rx + sx, ly, ry + sy, p); rs(x) = merge(rs(x), rs(y), lx + px, rx, ly + py, ry, p); return pushup(x), x;}void dfs(int u) { if (!son[u][0]) { root[u] = init(root[u], 1, vtot, lower_bound(v0 + 1, v0 + vtot + 1, v[u]) - v0); return; } else if (!son[u][1]) { dfs(son[u][0]); root[u] = root[son[u][0]]; return; } dfs(son[u][0]), dfs(son[u][1]); root[u] = merge(root[son[u][0]], root[son[u][1]], 0, 0, 0, 0, p[u]); return;}void query(int u, int i, int j) { if (i == j) { d[i] = t[u].sum; return; } pushdown(u); query(ls(u), i, M); query(rs(u), M + 1, j); return;}int main() { read(n); FOR(i, 1, n) { int fa; read(fa); if (fa) { if (!son[fa][0]) son[fa][0] = i; else son[fa][1] = i; } } FOR(i, 1, n) { int tmp; read(tmp); if (!son[i][0]) v0[++vtot] = v[i] = tmp; else p[i] = tmp * inv10000; } sort(v0 + 1, v0 + vtot + 1); dfs(1), query(root[1], 1, vtot); modint ans = 0; FOR(i, 1, vtot) ans += v0[i] * d[i] * d[i] * i; print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"线段树合并","slug":"segtree-merge","permalink":"https://old.blog.imyangty.com/tags/segtree-merge/"}]},{"title":"CF1140F Extending Set of Points","slug":"sol-cf1140f","date":"2022-02-12T08:47:22.000Z","updated":"2022-03-23T04:18:30.673Z","comments":true,"path":"sol-cf1140f/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1140f/","excerpt":"","text":"Description 给定二维平面上的整点集 S ，定义其“扩展点集” E(S) 为反复执行以下操作的结果： 定义集合 R 初始与 S 相等。 若存在 4 个数字 x_1, y_1, x_2,y_2 满足 (x_1, y_1)\\in R ， (x_1, y_2)\\in R ， (x_2, y_1)\\in R 而 (x_2, y_2)\\notin R ，则将 (x_2, y_2) 加入点集 R 。 反复执行直到不存在为止。 现在， S 初始为空，每一步操作会加点/删点，在每次操作结束后输出 E(S) 的大小。 所有数字 \\le3\\times10^5 。 Solution 所有数字 \\le 3\\times 10^5 这个限制比较奇特，这启发我们往点的坐标上去想。 我们不妨建出一张二分图，左部点代表横坐标，右部点代表纵坐标，连边即代表 S 中的点。然后我们会发现一次操作即将一个“之”字形的补满，进一步发现一个连通块补满之后的边数就是左部点数乘上右部点数。 所以我们需要维护连通块左部和右部的大小，这个可以使用一个带权并查集啥的维护。然后一条边的存在是一个时间区间，所以考虑使用线段树分治维护。 Implementation 还是比较好写的。并查集维护一下连通块中左部点的个数和右部点的个数就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879using ll = long long;using pii = pair&lt;int, int&gt;;const int maxn = 3e5 + 5, N = 3e5;ll ans[maxn], nowAns;struct UnionFind { int fa[maxn &lt;&lt; 1], top; ll cntl[maxn &lt;&lt; 1], cntr[maxn &lt;&lt; 1]; pii stk[maxn &lt;&lt; 1]; UnionFind() { FOR(i, 1, N &lt;&lt; 1) fa[i] = i; FOR(i, 1, N) cntl[i] = cntr[i + N] = 1; } int find(int x) {return x == fa[x] ? x : find(fa[x]);} void merge(int x, int y) { x = find(x), y = find(y); if (x == y) return; if (cntl[x] + cntr[x] &gt; cntl[y] + cntr[y]) swap(x, y); nowAns -= cntl[x] * cntr[x] + cntl[y] * cntr[y]; fa[x] = y, cntl[y] += cntl[x], cntr[y] += cntr[x]; nowAns += cntl[y] * cntr[y]; stk[++top] = {x, y}; return; } void undo(int tar) { while (top &gt; tar) { int x = stk[top].first, y = stk[top].second; --top; nowAns -= cntl[y] * cntr[y]; fa[x] = x, cntl[y] -= cntl[x], cntr[y] -= cntr[x]; nowAns += cntl[x] * cntr[x] + cntl[y] * cntr[y]; } return; }} ufs;map&lt;int, int&gt; exist[maxn];vector&lt;pii&gt; t[maxn &lt;&lt; 2];#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void modify(int i, int j, int k, int x, int y, pii p) { if (x &lt;= i &amp;&amp; y &gt;= j) { t[k].push_back(p); return; } if (x &lt;= M) modify(i, M, L, x, y, p); if (y &gt; M) modify(M + 1, j, R, x, y, p); return;}void dfs(int i, int j, int k) { int now = ufs.top; for (auto &amp;p : t[k]) ufs.merge(p.first, p.second + N); if (i == j) { ans[i] = nowAns; ufs.undo(now); return; } dfs(i, M, L), dfs(M + 1, j, R); ufs.undo(now); return;}int main() { int T; read(T); FOR(i, 1, T) { int x, y; read(x, y); if (exist[x].count(y)) modify(1, T, 1, exist[x][y], i - 1, {x, y}), exist[x].erase(y); else exist[x][y] = i; } FOR(x, 1, N) for (auto &amp;p : exist[x]) modify(1, T, 1, p.second, T, {x, p.first}); dfs(1, T, 1); FOR(i, 1, T) print(ans[i], ' '); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"线段树分治","slug":"segtree-division","permalink":"https://old.blog.imyangty.com/tags/segtree-division/"}]},{"title":"P5884 [IOI2014]game 游戏","slug":"sol-luogu-p5884","date":"2022-01-30T10:04:55.000Z","updated":"2022-03-23T04:18:31.034Z","comments":true,"path":"sol-luogu-p5884/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5884/","excerpt":"","text":"Description 交互题。 TW 有航空网，可抽象为 0,\\cdots, n - 1 编号点的无向图，A 问 B 这张图是否连通，B 想做游戏来回答他。 A 可以问 (u,v) 边是否存在，B 会立刻回答这个问题。A 一共会问 n(n - 1)/2 个问题，可以知道的是在问完最后一个问题后 A 就会知道其是否连通。B 的目标是动态构造这张图，让 A 在问最后一个问题之前还不知道整张图是否连通。 具体地，实现 void initialize(int n) 和 int hasEdge(int u, int v) 两个函数帮助 B 获胜。 Solution 在询问最后一条边之前图应该是形成了两个连通块，而且两个连通块之间的点都没有任何连边。那么对于非强制在线的情况，只需要构造一张完全图然后把最后一个点抠掉即可。然后这题就做完了。 但是对于原题，我们是不知道他最后一个询问会是什么的，所以上面这个做法明显行不通。 我们考虑将这个图构造成一棵树，并且在最后的询问再给出树边。 也就是说，一个点到其他点中的最后一条边的时候再连上。 Implementation 12345678910#include \"game.h\"const int maxn = 1505;int cnt[maxn];int max(int a, int b) {return a &gt; b ? a : b;}void initialize(int n) {}int hasEdge(int u, int v) {return ++cnt[max(u, v)] == max(u, v);}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"交互题","slug":"interactive-problem","permalink":"https://old.blog.imyangty.com/tags/interactive-problem/"}]},{"title":"天下一プログラマーコンテスト2014 本戦 D 高橋君","slug":"sol-tenka1-2014-final-d","date":"2022-01-30T09:32:15.000Z","updated":"2022-03-30T00:07:01.840Z","comments":true,"path":"sol-tenka1-2014-final-d/","link":"","permalink":"https://old.blog.imyangty.com/sol-tenka1-2014-final-d/","excerpt":"","text":"Description T 组询问（ T\\le 10^5 ），每次给定 1\\le k\\le n\\le 10^5 ，求 \\sum_{i = 0}^k\\binom n i 模 10^9 + 7 。 Solution 这个东西看着是很不好处理的，所以考虑离线下来使用莫队来做。 设要求的这个东西为 f_{n, k} ，则我们需要在已知 f_{n,k} 的情况下， O(1) 求出 f_{n\\pm 1, k} 和 f_{n, k\\pm 1} 。 考虑在棋盘上的一系列点，类似 ABC235G 的思想： 所以我们可以推出： \\begin{aligned} f_{n + 1, k} &amp;= 2f_{n, k} - \\binom nk\\\\ f_{n - 1, k} &amp;= \\frac12\\left(f_{n, k} + \\binom{n-1}{k} \\right)\\\\ f_{n, k + 1} &amp;= f_{n, k} + \\binom{n}{k + 1}\\\\ f_{n, k - 1} &amp;= f_{n, k} - \\binom nk \\end{aligned} 处理一下 [1, 10^5] 的阶乘和阶乘逆，整个问题就可以 O(n\\sqrt n) 解决了（ T 和 n 同阶），莫队就按照一般的方法莫队就可以了。 Implementation 1234567891011121314151617181920212223242526272829303132333435const int maxn = 1e5 + 5, N = 1e5, block = 316;modint fac[maxn], ifac[maxn], ans[maxn], cur = 1, inv2 = qPow(2, mod - 2);int T;struct node { int n, k, id; il friend bool operator&lt;(const node &amp;a, const node &amp;b) {return ((a.n / block) ^ (b.n / block)) ? a.n &lt; b.n : a.k &lt; b.k;}} q[maxn];modint binom(int n, int m) { if (n &lt; m) return 0; return fac[n] * ifac[m] * ifac[n - m];}int main() { fac[0] = 1; FOR(i, 1, N) fac[i] = fac[i - 1] * i; ifac[N] = qPow(fac[N], mod - 2); DEC(i, N - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; read(T); FOR(i, 1, T) read(q[i].n, q[i].k), q[i].id = i; sort(q + 1, q + T + 1); int n = 1, k = 0; FOR(i, 1, T) { while (n &gt; q[i].n) cur = inv2 * (cur + binom(--n, k)); while (k &lt; q[i].k) cur += binom(n, ++k); while (n &lt; q[i].n) cur = 2 * cur - binom(n++, k); while (k &gt; q[i].k) cur -= binom(n, k--); ans[q[i].id] = cur; } FOR(i, 1, T) print(ans[i]); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"莫队","slug":"mo-algo","permalink":"https://old.blog.imyangty.com/tags/mo-algo/"}]},{"title":"LOJ#3600. 「PA 2021」Od deski do deski","slug":"sol-loj3600","date":"2022-01-27T12:03:28.000Z","updated":"2022-03-23T04:18:30.792Z","comments":true,"path":"sol-loj3600/","link":"","permalink":"https://old.blog.imyangty.com/sol-loj3600/","excerpt":"","text":"Description 给定 n,m ，求满足以下限制的长度为 n 的序列数目： 每个元素在 [1, m] 之间； 一次操作定义为删除一个长度至少为 2 且区间两端相等的区间，该序列需要能在若干次操作内被删空。 答案对 10^9 + 7 取模。 1\\le n\\le 3000 ， 1\\le m\\le 10^9 。 Solution Orz Dmy。WC 的例题。 首先思考如何判断一个序列是否可行。显然是判其能不能划分为若干个首尾相连的合法区间，这个过程可以用一个 DP 来做，令 f_i 表示 [1, i] 是否可行，则 f_i = \\operatorname{OR}_{j&lt; i}\\{f_{j - 1}\\land a_j = a_i\\} 。 然后，考虑一下当 a_{1}, \\cdots, a_{i - 1} 已经被确定时， a_i 取什么值可以使得 f_i = 1 ，显然为那些 f_{j - 1} = 1 的 a_j 构成的集合。那么有后效性的无非就是集合的大小以及前一个位置的 DP 值。 那么不妨设 g_{i, j, k} 表示使得 f_{i - 1} = k ，当前集合大小为 j 的方案数。 则有转移 \\begin{cases} g_{i + 1, j, 1} \\leftarrow j\\times g_{i, j, k}\\\\ g_{i + 1, j + k, 0} \\leftarrow (m - j)\\times g_{i, j, k} \\end{cases} 其意义为，想要 f_i = 1 ，则我们需要从这个集合里面选一个数来充当 a_{i} ，有 j 种方案；而若想要 f_i = 0 ，那么无非就是从剩下的所有数里面选一个来充当 a_{i} ，然而需要注意的是如果 f_i = 1 ，要转移到 g_{i + 1, ?, 0} 的话“使得 f_{k - 1}=1 的 a_k 的集合是需要加入选的这个数的。这就是第二行为什么要转移到 g_{i + 1, j + k, 0} 。 Implementation 答案即为 \\sum_{j = 1}^ng_{n + 1, j, 1} 。 123456789101112131415161718192021const int maxn = 3005;int n, m;modint f[maxn][maxn][2];int main() { read(n, m); f[1][0][1] = 1; FOR(i, 1, n) { FOR(j, 0, i) { FOR(k, 0, 1) { f[i + 1][j][1] += j * f[i][j][k]; f[i + 1][j + k][0] += (m - j) * f[i][j][k]; } } } modint ans = 0; FOR(j, 0, n) ans += f[n + 1][j][1]; print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"LOJ","slug":"LOJ","permalink":"https://old.blog.imyangty.com/tags/LOJ/"}]},{"title":"NOIP 2021 题解","slug":"sol-noip2021","date":"2022-01-26T05:35:32.000Z","updated":"2022-03-23T04:18:31.068Z","comments":true,"path":"sol-noip2021/","link":"","permalink":"https://old.blog.imyangty.com/sol-noip2021/","excerpt":"","text":"前言 打的跟 shit 一样的 NOIP。 按照自己的实力，理应拿到 240+ 。 可是。。 感觉打了场 CF，前三题码量都巨小无比。。 T1 报数 很简单的筛法，类埃筛优化。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;const int maxx = 1e7 + 5, N = 1e7;bool ok[maxx];int id[maxx], num[maxx];bool check(int x) { bool ret = 0; while (x) ret |= (x % 10 == 7), x /= 10; return ret;}int main() { FOR(i, 1, N) { if (ok[i] || !check(i)) continue; for (int j = i; j &lt;= N; j += i) ok[j] = 1; } int cnt = 0; FOR(i, 1, N) if (!ok[i]) num[id[i] = ++cnt] = i; num[id[N + 1] = ++cnt] = N + 1; int T; scanf(\"%d\", &amp;T); while (T--) { int n; scanf(\"%d\", &amp;n); if (ok[n]) puts(\"-1\"); else printf(\"%d\\n\", num[id[n] + 1]); } return 0;} T2 数列 Description 给定 n,m,k 和一个长度为 m + 1 的正整数数组 v_0, v_1,\\cdots, v_m 。 对于一个长度为 n ，下标从 1 开始且满足每个元素都处于 [0, m] 的整数数列 \\{a_i\\} ，定义其权值为 \\prod v_{a_i} 。 当这样的序列 \\{a_i\\} 满足 \\operatorname{popcount}\\left(\\sum 2^{a_i}\\right)\\le K 时，认为 a_i 是一个合法序列。 求所有合法序列的权值和对 998244353 取模的结果。 1\\le k\\le n\\le 30, 0\\le m\\le 100, 1\\le v_i&lt; 998244353 。 Solution 放弃这题去刚 T3 的随机化是一个非常不明智的决定。。计数问题，数据范围这么小，直接考虑 DP，先无序化 a 数组，发现 S = \\sum 2^{a_i} 的位数是一个很重要的限制条件，所以我们不妨设状态 f_{i, j, k, p} 表示考虑 S 从低到高前 i 位，确定了 j 个 a 的值， S 的前 i 位有 k 个 1 ，要往第 k + 1 位进位 p ，的贡献和，拿着 然后考虑转移。发现往后填会更加好填一点，我们枚举当前填的东西，发现若我们选择填 t 个 a_i ，则 f_{i,j,k,p} 将会对下面的状态产生影响： f(i + 1, j + t, k + (t + p)\\bmod 2, \\left\\lfloor\\frac{t + p}{2} \\right\\rfloor) 贡献应该为 f(i, j, k, p)\\times v_i^t\\times\\binom{n - j}{t} 然后会发现，答案应该为 \\sum_{\\operatorname{popcount}(p) + k \\le K} f(m + 1, n, k, p) 需要与处理一下 v_i 的 [1, n] 次方， [1, n] 的阶乘/阶乘逆以及 [1, n] 的 popcount。 Implementation 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;const int maxn = 35, maxm = 105, mod = 998244353;int n, m, K, v[maxm][maxn], f[maxm][maxn][maxn][maxn], binom[maxn][maxn];int main() { scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;K); binom[0][0] = binom[1][0] = binom[1][1] = 1; FOR(i, 2, n) { binom[i][0] = 1; FOR(j, 1, i) binom[i][j] = (binom[i - 1][j] + binom[i - 1][j - 1]) % mod; } FOR(i, 0, m) { scanf(\"%d\", v[i] + 1), v[i][0] = 1; FOR(j, 2, n) v[i][j] = 1ll * v[i][j - 1] * v[i][1] % mod; } f[0][0][0][0] = 1; FOR(i, 0, m) FOR(j, 0, n) FOR(k, 0, K) FOR(p, 0, n &gt;&gt; 1) FOR(t, 0, n - j) { f[i + 1][j + t][k + ((t + p) &amp; 1)][(t + p) &gt;&gt; 1] += 1ll * f[i][j][k][p] * v[i][t] % mod * binom[n - j][t] % mod; f[i + 1][j + t][k + ((t + p) &amp; 1)][(t + p) &gt;&gt; 1] %= mod; } int ans = 0; FOR(k, 0, K) FOR(p, 0, n &gt;&gt; 1) if (__builtin_popcount(p) + k &lt;= K) ans = (ans + f[m + 1][n][k][p]) % mod; printf(\"%d\\n\", ans); return (0 - 0);} T3 方差 Description 给定长度为 n 的非严格递增正整数序列 1\\le a_1\\le a_2\\le\\cdots\\le a_n ，每次的操作是选择任意 1 &lt; i &lt; n ，然后 a_i:= a_{i - 1} + a_{i + 1} - a_i 。在若干次操作后求出最小方差乘上 n^2 的结果。 1\\le n\\le 10^4 ， 1\\le a_i\\le 600 。 Solution 非常好的观察性质题。。在考场上反正我没观察到这个奇特的性质。。 第一，我们假设在操作 a, b, c 这个序列，操作完后会变成 a, a + c - b, c 。原来的差分数组是 b - a, c - b ，操作后就变成了 c - b, b - a 。发现一次操作等价于交换差分数组。 所以我们直接钦定 a_1 = 0 ，反正对最后方差没有影响。现在问题就变为将这个差分数组任意重排，使得整个的方差最小。根据数据越集中方差越小的原理，可以感性理解一下，差分数组 d 一定是大-小-大的单谷型。 然后 O(n2^n ) 做法就来了：将差分数组 sort 一下之后从小到大的填最左边和最右边，但既然想到这一步了那还是继续做下去比较好。既然值域这么小，尝试 DP？ 先化简方差的式子，“平方的期望减期望的平方”： \\begin{aligned} n^2\\sigma^2 &amp;= n^2\\times\\left(\\frac 1n\\sum_{i = 1}^na_i^2 - \\overline a^2 \\right)\\\\ &amp;= n\\sum_{i = 1}^na_i^2 - \\left(\\sum_{i = 1}^na_i\\right)^2 \\end{aligned} 第二项和的平方是固定的，所以考虑最小化第一项平方和。 不妨设 f_{i, j} 表示考虑了前 i 个差分，当前数列和为 j 的最小 \\sum_{k = 1}^ia_i^2 。决策就考虑插在最左边还是最右边，依然考虑刷表，令差分的前缀和为 s ，则插在右边的情况： f(i - 1, j) + s_i^2 \\to f(i, j + s_i) 插在左边的情况相对复杂一些，考虑一下平方和的变化： (a_x + d_i)^2 - a_x^2 = 2a_xd_i + d_i^2 ，所以总的来说平方和增加 2jd_i + id_i^2 。所以 f(i - 1, j) + 2jd_i + id_i^2\\to f(i - 1, j + id_i) O(n^2\\max a) 状态， O(1) 转移，看似是跑不过去的。 然而，需要注意到的是，值域很小，所以有很多的 d_i 是 0 ，不会产生任何贡献，这一部分是完全可以直接跳过的。 所以复杂度变为 O(n\\max^2a) ，可以通过。 Implementation 可以使用滚动数组，倒序 DP（类比 0-1 背包）。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;using ll = long long;const int maxn = 10005, maxa = 605;const ll INF = 1e18;ll d[maxn], s[maxn], f[maxn * maxa];int n, mx, a[maxn];template&lt;typename T&gt; il T chkmax(T &amp;a, const T &amp;b) {return a = (b &gt; a ? b : a);}template&lt;typename T&gt; il T chkmin(T &amp;a, const T &amp;b) {return a = (b &lt; a ? b : a);}int main() { scanf(\"%d\", &amp;n); FOR(i, 0, n - 1) scanf(\"%d\", a + i), chkmax(mx, a[i]); FOR(i, 1, n - 1) d[i] = a[i] - a[i - 1]; sort(d + 1, d + n); FOR(i, 1, n * mx) f[i] = INF; f[0] = s[0] = 0; FOR(i, 1, n - 1) { s[i] = s[i - 1] + d[i]; if (!d[i]) continue; DEC(j, n * mx, 0) { if (f[j] &gt;= INF) continue; chkmin(f[j + s[i]], f[j] + s[i] * s[i]); chkmin(f[j + i * d[i]], f[j] + 2ll * d[i] * j + 1ll * d[i] * d[i] * i); f[j] = INF; } } ll ans = INF; FOR(j, 0, n * mx) if (f[j] &lt; INF) chkmin(ans, f[j] * n - 1ll * j * j); printf(\"%lld\\n\", ans); return (0 ^ 0);}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"}]},{"title":"UOJ#604. 【UER 9】赶路","slug":"sol-uoj604","date":"2022-01-26T05:24:23.000Z","updated":"2022-03-23T04:18:31.097Z","comments":true,"path":"sol-uoj604/","link":"","permalink":"https://old.blog.imyangty.com/sol-uoj604/","excerpt":"","text":"Description 给定二维平面上的 n 个点（ 2\\le n\\le 500 ），要求构造一条从 1 到 n 的不自交的路径。 Solution 我们不妨考虑分治。考虑 \\operatorname{solve}(s, t, A) 表示当前要解决从 s 到 t ，经过的点集为 A 。 随便从 A 中挑一个点 p 出来，然后从 s 到 p 连一条直线，然后将 A 中剩下的点按在直线的左侧/右侧划分到 A_1 和 A_2 中。这里假设 t 在直线右侧，反之同理。然后递归求解 \\operatorname{solve}(s, p, A_1) ，即我们先走左侧的点，中途要经过 p ，之后再走右侧的点，即 \\operatorname{solve}(p, t, A_2) 。 这个过程中， A_1 和 A_2 中的路径是一定不会有交的，根据我们的构造，发现其一定有解。 于是就这样做，用叉积判一下方向啥的，就搞定了。 Implementation 1234567891011121314151617181920212223242526272829303132333435using ll = long long;const int maxn = 505;int n;struct Point { int x, y; Point() {} Point(int _x, int _y) : x(_x), y(_y) {} friend Point operator-(const Point &amp;a, const Point &amp;b) {return Point(a.x - b.x, a.y - b.y);} friend ll operator^(const Point &amp;a, const Point &amp;b) {return 1ll * a.x * b.y - 1ll * a.y * b.x;}} p[maxn];bool check(int a, int b, int c) {return ((p[b] - p[a]) ^ (p[c] - p[a])) &gt; 0;}void solve(int s, int t, vector&lt;int&gt; v) { vector&lt;int&gt; a[2]; for (int i = 1; i &lt; (int)v.size(); ++i) a[check(s, v[0], v[i])].push_back(v[i]); int k = check(s, v[0], t); if (a[k ^ 1].size()) solve(s, v[0], a[k ^ 1]); print(v[0], ' '); if (a[k].size()) solve(v[0], t, a[k]); return;}int main() { int T; read(T); while (T--) { read(n); FOR(i, 1, n) read(p[i].x, p[i].y); vector&lt;int&gt; tmp; FOR(i, 2, n - 1) tmp.push_back(i); print(1, ' '), solve(1, n, tmp), print(n, ' '); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"计算几何","slug":"computational-geometry","permalink":"https://old.blog.imyangty.com/tags/computational-geometry/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"UOJ","slug":"UOJ","permalink":"https://old.blog.imyangty.com/tags/UOJ/"}]},{"title":"GYM103495D. Pattern Lock","slug":"sol-gym103495d","date":"2022-01-25T12:50:33.000Z","updated":"2022-03-23T04:18:30.759Z","comments":true,"path":"sol-gym103495d/","link":"","permalink":"https://old.blog.imyangty.com/sol-gym103495d/","excerpt":"","text":"Description 给定 n\\times m 的点阵， 2\\le n,m\\le 500 ，要求构造一条哈密顿链，使得形成的角都是锐角且边和点仅在端点处相交。 Solution 这题搞了好久错误答案。。。 需要注意到的是，两列之间的大跨线只能跨一列，不然总有机会碰到中间的点，寄。 事实就是，如果 n 和 m 不同时为奇数，则可以令 m 为偶数，然后两两分组这样来做。 对于 n 和 m 同时为奇数的就把上面那个魔改一下： Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using pii = pair&lt;int, int&gt;;vector&lt;pii&gt; ans;int n, m;vector&lt;pii&gt; calc() { vector&lt;pii&gt; ret; ret.push_back({1, 1}); ret.push_back({3, 2}); ret.push_back({1, 3}); ret.push_back({2, 1}); ret.push_back({3, 3}); ret.push_back({1, 2}); ret.push_back({3, 1}); ret.push_back({2, 3}); ret.push_back({2, 2}); for (int i = 4; i &lt;= n; i += 2) { ret.push_back({i + 1, 3}); ret.push_back({i, 3}); ret.push_back({i + 1, 2}); ret.push_back({i, 2}); ret.push_back({i + 1, 1}); ret.push_back({i, 1}); } return ret;}int main() { read(n, m); bool flg = 0; if ((m &amp; 1) &amp;&amp; !(n &amp; 1)) swap(n, m), flg = 1; if (n == 2) swap(n, m), flg = 1; FOR(j, 1, (m &amp; 1) ? m / 2 - 1 : m / 2) { if (j &amp; 1) { ans.push_back({n, 2 * j - 1}); DEC(i, n - 1, 1) { ans.push_back({i, 2 * j}); ans.push_back({i, 2 * j - 1}); } ans.push_back({n, 2 * j}); } else { ans.push_back({1, 2 * j - 1}); FOR(i, 2, n) { ans.push_back({i, 2 * j}); ans.push_back({i, 2 * j - 1}); } ans.push_back({1, 2 * j}); } } if (m &amp; 1) { vector&lt;pii&gt; tmp = calc(); for (auto &amp;p : tmp) { if (m % 4 == 3) p.first = n - p.first + 1; p.second += m - 3; ans.push_back(p); } } for (auto &amp;p : ans) { if (!flg) print(p.first, p.second); else print(p.second, p.first); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"}]},{"title":"AtCoder 杂题选做","slug":"sol-atcoder-misc","date":"2022-01-07T14:20:51.000Z","updated":"2022-04-07T13:58:06.498Z","comments":true,"path":"sol-atcoder-misc/","link":"","permalink":"https://old.blog.imyangty.com/sol-atcoder-misc/","excerpt":"","text":"前言 新坑。各个难度都有，随缘做做 🤣代表套路题，但我仍旧玩不熟练的那种。 😅代表比较无聊的题。 😀代表比较中等一般的题。 😘代表思维难度较高并且相对对胃口的题。 😭代表神仙题。 1600-1999 不要问我为什么要做这个难度区间的，问就是我 rating 还在这个区间。 🤣AGC005B - Minimum Sum \\color{blue}{\\text{*1828}} 单调栈裸应用。 🤣ABC110D Factorization \\color{blue}{\\text{*1695}} 题意：给定 n 和 m ，其中 1\\le n\\le 10^5 ， 1\\le m\\le 10^9 ，问长度为 n 且满足 \\prod a_i = m 的序列 a 的个数。答案模 10^9 + 7 输出。 将 m 分解为 \\prod p_i^{k_i} 的形式之后，考虑给每一个 a_i 分配质因子。对于 p_i ，由插板法可知其分配方案数为 \\dbinom{k_i + n - 1}{n - 1} 。那么算出每个 p_i 对应的方案数然后乘在一起就可以了。时间复杂度 O(n + \\sqrt m) 。 😀ABC143E Travel by Car \\color{blue}{\\text{*1695}} 题意： n 个小镇， m 条双向道路。第 i 条道路从 a_i 通向 b_i ，长度为 c_i 。车的油箱容量为 L 升，当行驶到一个镇上时可以选择加满油或者什么都不做。行驶单位长度的距离消耗一升油。 现在回答 Q 次询问：假设油箱现在为满，从 s_i 出发，行驶到 t_i ，最少需要加油多少次，无法到达则输出 -1 。 2\\le n\\le 300 ， 0\\le m\\le n(n - 1)/2 ，无重边，无自环。 1\\le c_i, L\\le 10^9 。 我们注意到，加一次油之后，最多可以行驶 L 的距离，这与中间具体走了多少个点是没有关系的。 而且 n\\le 300 ，所以我们不妨先用 Floyd 求出两两之间的最短路。对于一对点对 (u,v) ，发现只有当 d_{u, v}\\le L 时，其能用一次加油来搞定。那么我们既然要求最少加多少次油，又知道了 (u, v) 能否用一次加油搞定，那么就不妨建新图， d_{u,v}\\le L 时建新边 (u, v) ，边权为 1 。然后在新图上跑最短路。跑出来的结果减 1 即为答案，因为初始油箱为满，要扣除一次“加油”。 综上，跑两次 Floyd 就搞定了。时间复杂度为 O(n^3 + n^2 + Q) 。建图还是有点不太好想。 😅ARC061B すぬけ君の塗り絵 / Snuke's Coloring \\color{blue}{\\text{*1682}} 暴力考虑增量。对于每个黑格子考虑他影响的 9 个 3\\times 3 即可。 🤣CODE FESTIVAL 2016 qual B C Gr-idian MST \\color{blue}{\\text{*1688}} 题意： H \\times W 的二维平面， \\forall 0\\le i\\le H, 0\\le j\\le W 有一个点。连接 (i, j) 到 (i + 1, j) 的边权为 p_i （ 0\\le j\\le W ），连接 (i, j) 到 (i, j + 1) 的边权为 q_j 。求这张 (H + 1)\\times (W + 1) 个点的图的最小生成树的边权和。 1\\le H, W\\le 10^5 ， 1\\le p_i,q_j\\le 10^8 。 注意到，连接 (i, j) 到 (i, j + 1) 可以视为合并 j 和 j + 1 ，连接 (i,j) 和 (i + 1, j) 同理。所以我们维护一下横方向和纵方向上还有多少坐标未被合并，假设还有 a 个横坐标未被合并， b 个纵坐标未被合并，则我们连 a 条 (i,j) 到 (i, j + 1) 的边就能使得 b 减一，反之同理。 根据排序不等式，我们从小的 p_i/q_j 开始选，连完为止就是最优的。网格图 MST 合并行/列的 trick。 🤣ABC162E - Sum of gcd of Tuples (Hard) \\color{blue}{\\text{*1662}} 题意：给定 2\\le N\\le 10^5 ， 1\\le K\\le 10^5 ，求 \\sum_{a_1 = 1}^K\\sum_{a_2 = 1}^K\\cdots\\sum_{a_N = 1}^K\\gcd_{i = 1}^N\\{a_i\\}\\bmod {10^9 + 7} 第一反应是，由于 \\gcd_{i=1}^N\\{a_i\\}\\in[1, K] ，那么我们就考虑对于 [1, K] 里面的每一个数字，其作为了多少次 \\gcd 。 然后发现， 若 \\gcd_{i = 1}^N\\{a_i\\} = X ，则 a_i 一定都是 X 的倍数，这样的方案数有 \\lfloor K / X\\rfloor^N 种，但是要抠掉 \\gcd\\{a_i\\} = 2X, 3X,\\cdots 的情况。所以我们倒序枚举统计答案，复杂度调和 \\log 。反演做法和加强见数论笔记。 😀AGC022B - GCD Sequence \\color{blue}{\\text{*1645}} 题意：给定 3\\le N\\le 20000 ，构造集合 \\{a_1,\\cdots, a_N\\} ，令 S = \\sum_{i =1}^Na_i ，要求： \\forall i\\le [1, n] ，有 1\\le N\\le 30000 且 \\gcd(a_i, S - a_i) \\ne 1 。 \\displaystyle\\gcd_{i = 1}^N\\{a_i\\} = 1 。 a_i 互不相同。 转化一下变成了 \\gcd(a_i, S)\\ne 1 。随便构造以下序列的头两个元素为 2 和 3 ，于是 6\\mid S ，然后加一个 30000 -5 ，这样就能满足 S 的限制了。剩下的数字就拿 2k 和 30000 - 2k ， 3k 和 30000 - 3k 来一个个凑，凑不成一对就单走一个 30000 。最后还剩的话走一个 25 和 30000 - 25 即可。 😅ARC088B - Wide Flip \\color{blue}{\\text{*1646}} 给定一个长度 \\le 10^5 的 01 串 S ，每次操作可以选择一段长度 \\ge K 的连续段然后 01 互换，求一个最大的 K 使得若干次操作之后 S 能变成全 0 串。 我们从左往右枚举，假设 S_i\\ne S_{i + 1} ，那么显然答案就要和 \\max(i, n - i) 取 \\min 。因为假设前 i 位都相同了，那么肯定要么翻转前面 i 位，要么翻转后面 n - i 位。 2000-2399 🤣AGC020C - Median Sum \\color{yellow}{\\text{*2259}} bitset 优化 0-1 背包。 😀AGC010C - Cleaning \\color{yellow}{\\text{*2346}} 题解链接。奇怪的树上贪心分析。 😅ARC100C - Or Plus Max \\color{yellow}{\\text{*2111}} 高维前缀和，维护最大值/次大值即可。 2400-2799 😀AGC037E - Reversing and Concatenating \\color{orange}{\\text{*2667}} 比较简单的直接字符串硬贪心。 ARC066C - Addition and Subtraction Hard \\color{orange}{\\text{*2709}} 😘AGC013C - Ants on a Circle \\color{orange}{\\text{*2462}} 题解链接。比较牛逼的观察性质题。 😘ABC239Ex - Dice Product 2 \\color{orange}{\\text{*2686}} 题解链接。发现 dp 按照 \\lfloor m / i\\rfloor 分段后换下标来做到类杜教筛的记忆化搜索。 2800+ 😀ARC069D - Flags \\color{red}{\\text{*3200}} 先二分答案之后使用线段树优化建图跑 2-SAT。 😭ARC096D - Sweet Alchemy \\color{red}{\\text{*3896}} 树上差分之后变为价值很小，体积很大的多重背包，使用大范围贪心，小范围多重背包求解。 😭AGC032E - Modulo Pairing \\color{red}{\\text{*3302}} 考虑二分“分界点”，调整法证明贪心正确性。 🤣M-SOLUTIONS2019F - Random Tournament \\color{red}{\\text{*2986}} 题解链接，bitset 优化区间 dp。 😭AGC039D - Incenters \\color{red}{\\text{*3118}} 题解链接。平面几何 + 期望的牛逼题。能考平几也是真的很出乎意料。 😘ABC202F - Integer Convex Hull \\color{red}{\\text{*2905}} 题解链接。神仙构造凸包 dp。 😘AGC007E - Shik and Travel \\color{red}{\\text{*3906}} 题解链接。先考虑二分答案，然后在每个节点合并 dp 状态，奇妙复杂度分析，较难实现。 😘AGC010E - Rearranging \\color{red}{\\text{*3887}} 题解链接。特别巧妙的建图 + 贪心拓扑序。 😭ARC068D - Solitaire \\color{red}{\\text{*3042}} 题解链接。神仙题，观察双端队列的性质，然后对合法的删除序列 dp 计数。之后根据 dp 的组合意义推出通项公式。 😀AGC002E - Candy Piles \\color{red}{\\text{*2889}} 题解链接。神仙模型转化，然后考虑必胜态和必败态的转移，实际上非常简单。。。。 😘ARC064D - Rotated Palindromes \\color{red}{\\text{*2949}} 题解链接。没往正解上靠边属于是。考虑对回文串计数，然后再从循环节开始想一步步去重，最后再容斥。 😘AGC009D - Uninity \\color{red}{\\text{*3404}} 题解链接。想到了点分树，这是好的。但是被重心限制住了思维而没有想到直接贪心求答案。 Difficulty unavailable 🤣天下一プログラマーコンテスト2014 本戦 D 高橋君 \\color{purple}{\\text{*???}} 题解链接。考虑多次类似区间询问，用莫队。单次移动端点产生的贡献用网格图考虑。 😘AGC012F - Prefix Median \\color{purple}{\\text{*???}} 题解链接。观察中位数的奇妙性质，倒序构造 dp。 🤣AGC001E - BBQ Hard \\color{purple}{\\text{*???}} 题解链接。考虑 \\dbinom{n + m}{n} 的实际意义。然后整体在棋盘上 dp，最后记得去重，较水。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"}]},{"title":"P3293 [SCOI2016]美味","slug":"sol-luogu-p3293","date":"2022-01-07T13:45:25.000Z","updated":"2022-03-23T04:18:30.939Z","comments":true,"path":"sol-luogu-p3293/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3293/","excerpt":"","text":"Description 给定长度为 n 的序列 a_i 和长度为 m 的序列 (b_i, x_i) 。对于每个 i ，求 \\max_{l_i\\le j\\le r_i}\\{b_i\\oplus (a_j + x_i)\\} 。 2\\times 10^5 范围。 Solution 由于是异或问题，所以考虑从高到低按位贪心。考虑贪到了第 k 位，当前答案为 t 。假设 b_i 的第 k 位为 1 ，则我们尽可能贪这一位是 0 ，找到的 a_j + x_i 一定是在 [t, t + 2^k - 1] 里面的。 所以 a_j\\in [t - x, t + 2^k - 1 - x] ，我们需要知道 [l_i, r_i] 里面是否存在这样的 a_j ，这个问题可以用主席树来求解。 所以这题就做完了。 b_i 的第 k 位为 0 的情况， a_j\\in[t + 2^k - x, t + 2^{k + 1} - 1 - x] 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const int maxn = 2e5 + 5, N = 1e5;struct node { int ch[2], sum;} t[maxn * 50];int root[maxn], tot, n, m;#define ls(u) t[u].ch[0]#define rs(u) t[u].ch[1]#define M ((i + j) &gt;&gt; 1)int clone(int u) { t[++tot] = t[u]; return tot;}int build(int u, int i, int j) { u = ++tot; if (i == j) return u; ls(u) = build(ls(u), i, M); rs(u) = build(rs(u), M + 1, j); return u;}int insert(int u, int i, int j, int x) { u = clone(u); ++t[u].sum; if (i == j) return u; if (x &lt;= M) ls(u) = insert(ls(u), i, M, x); else rs(u) = insert(rs(u), M + 1, j, x); return u;}int query(int u1, int u2, int i, int j, int x, int y) { if (x &lt;= i &amp;&amp; y &gt;= j) return t[u2].sum - t[u1].sum; int ret = 0; if (x &lt;= M) ret += query(ls(u1), ls(u2), i, M, x, y); if (y &gt; M) ret += query(rs(u1), rs(u2), M + 1, j, x, y); return ret;}int main() { read(n, m); root[0] = build(root[0], 1, n); FOR(i, 1, n) { int x; read(x); root[i] = insert(root[i - 1], 0, N, x); } while (m--) { int b, x, l, r; read(b, x, l, r); int ans = 0; DEC(k, 17, 0) { if ((((b &gt;&gt; k) &amp; 1) &amp;&amp; !query(root[l - 1], root[r], 0, N, max(ans - x, 0), min(ans + (1 &lt;&lt; k) - 1 - x, N))) || ((!((b &gt;&gt; k) &amp; 1)) &amp;&amp; (query(root[l - 1], root[r], 0, N, max(ans + (1 &lt;&lt; k) - x, 0), min(ans + (1 &lt;&lt; (k + 1)) - 1 - x, N))))) ans += (1 &lt;&lt; k); } print(ans ^ b); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"主席树","slug":"persistent-segtree","permalink":"https://old.blog.imyangty.com/tags/persistent-segtree/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P5283 [十二省联考 2019] 异或粽子","slug":"sol-luogu-p5283","date":"2022-01-07T02:37:40.000Z","updated":"2022-03-23T04:18:31.009Z","comments":true,"path":"sol-luogu-p5283/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5283/","excerpt":"","text":"Description 给定 a_1,\\cdots, a_n 。现要求找 k 个不同数对 (l, r) ，要求 l\\le r ，并且使得 \\sum_{i = 1}^k\\bigoplus_{j = l_i}^{r_i}a_j 最大。求出这个最大值。 0\\le a_i&lt; 2^{32} ， 1\\le n\\le 5\\times 10^5 ， 1\\le k\\le 2\\times 10^5 。 Solution 首先给他做一个前缀和，现在问题就变成了求最大的 \\displaystyle\\sum_{i = 1,0\\le l_i &lt; n, 1\\le r_i \\le n}^k (s_{l_i}\\oplus s_{r_i}) 。简化一下写法变为 \\displaystyle\\sum_{i = 1, 0\\le l_i\\le r_i\\le n}^k(s_{l_i}\\oplus s_{r_i}) 。 我们不妨先考虑枚举每个 1\\le r\\le n ，然后在 [0, r] 里面找一个 s_l 使得 s_r 与之异或上后最大。得到的结果插入一个大根堆中。然后从堆中取 k 次元素，每取一个 s_l\\oplus s_r 之后，在 [0, l - 1] 和 [l + 1, r] 里面各找一个 s_l' 使得 s_r 异或上其之后最大，再插入进堆里面。 在区间内找数这个过程用可持久化 Trie 可以实现。于是这题就做完了。复杂度为 O((n + k)\\log a) 。 具体地，堆中维护一个五元组 (v, l, r, x, y) ，表示当前区间为 [l, r] ， s_x\\oplus s_y = v 。然后每次取的时候判一下两边的区间能不能加进去就 OK 了。 Implementation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using uint = unsigned;const int LG = 31;const int maxn = 5e5 + 5;uint s[maxn];int n, K;struct node { int ch[2], latest; node() {ch[0] = ch[1] = 0, latest = -1;}} t[maxn * 60];int tot, root[maxn];int clone(int u) { t[++tot] = t[u]; return tot;}int insert(int u, uint val, int k, int id) { u = clone(u); if (k &lt; 0) return t[u].latest = id, u; int c = (val &gt;&gt; (uint)k) &amp; 1; t[u].ch[c] = insert(t[u].ch[c], val, k - 1, id); t[u].latest = max(t[t[u].ch[0]].latest, t[t[u].ch[1]].latest); return u;}int query(int u, int l, uint val, int k) { if (k &lt; 0) return t[u].latest; int c = (val &gt;&gt; (uint)k) &amp; 1; return query(t[u].ch[c ^ (t[t[u].ch[c ^ 1]].latest &gt;= l)], l, val, k - 1);}struct node2 { uint val; int l, r, pos1, pos2; node2(uint v, int _l, int _r, int p1, int p2) : val(v), l(_l), r(_r), pos1(p1), pos2(p2) {}};il bool operator&lt;(const node2 &amp;a, const node2 &amp;b) {return a.val &lt; b.val;}int main() { read(n, K); FOR(i, 1, n) read(s[i]), s[i] ^= s[i - 1]; FOR(i, 0, n) root[i] = insert(i ? root[i - 1] : 0, s[i], LG, i); priority_queue&lt;node2&gt; q; FOR(i, 1, n) { int j = query(root[i], 0, s[i], LG); q.push(node2(s[i] ^ s[j], 0, i - 1, j, i)); } long long ans = 0; FOR(iii, 1, K) { node2 now = q.top(); q.pop(); ans += now.val; int p = now.pos1, i = now.pos2; if (p != now.r) { int j = query(root[now.r], p + 1, s[i], LG); q.push(node2(s[i] ^ s[j], p + 1, now.r, j, i)); } if (p != now.l) { int j = query(root[p - 1], now.l, s[i], LG); q.push(node2(s[i] ^ s[j], now.l, p - 1, j, i)); } } print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"可持久化Trie","slug":"persistent-01trie","permalink":"https://old.blog.imyangty.com/tags/persistent-01trie/"}]},{"title":"P4735 最大异或和","slug":"sol-luogu-p4735","date":"2022-01-06T11:40:11.000Z","updated":"2022-03-23T04:18:30.995Z","comments":true,"path":"sol-luogu-p4735/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4735/","excerpt":"","text":"Description 维护一个初始长度为 m 的整数序列 a ，支持如下操作： 在序列尾部添加 x 。 给定 l, r 和 x ，找到一个 p\\in[l, r] ，使得 x\\oplus\\left(\\bigoplus_p^Na_p\\right) 最大。 值域 10^7 ，操作次数 \\le 6\\times 10^5 。 Solution 可持久化 Trie 的板子。 考虑异或前缀和，则问题变为给定 x'\\oplus s_n ，找一个 p\\in[l - 1, r - 1] 使得 s_p 异或上 x' 最大。 异或上最大这个问题其实很好解决：只需要考虑在 Trie 上按位贪心反着取即可。 然而 p 有一个 \\in[l - 1, r - 1] 的限制。我们不妨考虑可持久化，对每个下标维护一个版本的 Trie，然后查询的时候从版本 r- 1 开始取便能满足 p\\le r - 1 的限制。对于 p\\ge l - 1 ，对于每个节点维护一个 latest 值，表示其子树内维护的值中，最大的版本号。查询时只访问 latest 值 \\ge l - 1 的节点即可。 Implementation 平时主席树怎么写的，这个就怎么写。 我是sb，变量重名调了好久。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const int maxn = 6e5 + 5;int n, m, tot, root[maxn];int s[maxn];struct node { int ch[2], latest; node() {ch[0] = ch[1] = 0, latest = -1;}} t[maxn * 25];int clone(int u) { t[++tot] = t[u]; return tot;}int insert(int u, int id, int k, int val) { u = clone(u); if (k &lt; 0) return t[u].latest = id, u; int c = (val &gt;&gt; k) &amp; 1; t[u].ch[c] = insert(t[u].ch[c], id, k - 1, val); t[u].latest = max(t[t[u].ch[0]].latest, t[t[u].ch[1]].latest); return u;}int query(int u, int val, int k, int l) { if (k &lt; 0) return s[t[u].latest] ^ val; int c = (val &gt;&gt; k) &amp; 1; if (t[t[u].ch[c ^ 1]].latest &gt;= l) return query(t[u].ch[c ^ 1], val, k - 1, l); else return query(t[u].ch[c], val, k - 1, l);}int main() { read(n, m); root[0] = insert(0, 0, 23, 0); FOR(i, 1, n) { read(s[i]), s[i] ^= s[i - 1]; root[i] = insert(root[i - 1], i, 23, s[i]); } while (m--) { char str[2]; read(str); if (str[0] == 'A') { ++n, read(s[n]), s[n] ^= s[n - 1]; root[n] = insert(root[n - 1], n, 23, s[n]); } else { int l, r, x; read(l, r, x); print(query(root[r - 1], s[n] ^ x, 23, l - 1)); } } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"可持久化Trie","slug":"persistent-01trie","permalink":"https://old.blog.imyangty.com/tags/persistent-01trie/"}]},{"title":"P5323 [BJOI2019]光线","slug":"sol-luogu-p5323","date":"2021-12-23T13:22:12.000Z","updated":"2022-03-23T04:18:31.014Z","comments":true,"path":"sol-luogu-p5323/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5323/","excerpt":"","text":"Description n 层玻璃。每层玻璃的透光率为 a_i\\% ，反射率为 b_i\\% 。一开始有 1 单位光从第一层射入，问有多少光能从第 n 层射出，答案对 10^9 + 7 取模。 1\\le n\\le 5\\times 10^5 。 Solution 考虑只有两层玻璃的情况，经过手推我们可以发现答案即为 a_1a_2 + a_1a_2b_1b_2 + a_1a_2(b_1b_2)^2 + \\cdots = \\frac{a_1a_2}{1 - b_1b_2} 现在我们不妨思考一下，如果我们将前 i 层玻璃等效成一层玻璃，我们会得到什么式子？类比上面，我们设 F_i 表示前 i 层玻璃，光从第 1 层玻璃射入，整体的透光率， G_i 表示光从第 i 层玻璃射入，整体的反射率，则 F_n = \\frac{a_nF_{n - 1}}{1 - G_{n - 1}b_n} 然后我们需要 G_i 才能递推 F_i 。我们可以发现，用类似的方式，可以得到 G_n = b_n + a_n^2b_nG_{n - 1} + a_n^3b_nG_{n - 1}^2 + \\cdots = b_n + \\frac{a_n^2G_{n - 1}}{1 - b_nG_{n - 1}} 然后我们就可以 O(n\\log \\bmod) 计算答案了。等效法是很重要的，我们解决一般性的问题的时候可以先考虑退化了的情况，然后可以考虑等效，然后递推。 Implementation 123456789101112131415161718const modint inv100 = qPow(100, mod - 2);const int maxn = 5e5 + 5;int n;il modint inv(modint n) {return qPow(n, mod - 2);}int main() { read(n); modint f, g; read(f, g), f *= inv100, g *= inv100; FOR(i, 2, n) { modint a, b; read(a, b), a *= inv100, b *= inv100; f = a * f * inv(1 - g * b); g = b + a * a * g * inv(1 - b * g); } print(f); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF1334E Divisor Paths","slug":"sol-cf1334e","date":"2021-12-20T13:05:21.000Z","updated":"2022-03-23T06:40:10.515Z","comments":true,"path":"sol-cf1334e/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1334e/","excerpt":"","text":"Description 一个无向带权图，所有的点为 D 的约数（ 1\\le D\\le 10^{15} ）， x 和 y 有连边当且仅当存在质数 p 使得 x\\cdot p = y ，边权为 d(y) - d(x) ，其中 d(x) 为约数个数函数。 q 个询问，问 u 和 v 间最短路条数，答案对 998244353 取模。 Solution 还是一道很牛逼的性质题。。 首先注意到，每走一条边，都是变动一个质因子，而且边权是变动的因数个数。所以，若 a\\mid b ，走一个递减的路径一定就是最短路，边权是 d(a) - d(b) ，如若走了一个非递减的路径，就会产生多余的贡献，这应该是好理解的。所以说，其实从 a 到 b ，怎么走都是 OK 的，只要是递减。 猜一个结论： u\\to \\gcd(u, v)\\to v 是最优的，这样的话变动的因子个数是最少的，走任意其他的路线都是不优的。 为甚么走 \\operatorname {lcm} 不优可以看洛谷题解区。 现在回到这道题，先分解 D ，然后我们单独考虑 u\\to \\gcd(u, v) 的做法。我们考虑分解 \\dfrac{u}{\\gcd(u, v)} ，然后统计一下每个质因子的个数，根据多重组合数，答案就为 \\frac{(\\sum cnt_p)!}{\\prod cnt_p!} \\gcd(u, v)\\to v 同理，两个算完再乘起来即可。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142using ll = long long;ll D, p[105];modint fac[105], ifac[105];int q, cnt;il ll gcd(ll a, ll b) {return !b ? a : gcd(b, a % b);}modint calc(ll x) { vector&lt;ll&gt; v; int sum = 0; FOR(i, 1, cnt) { if (x % p[i]) continue; int tmp = 0; while (x % p[i] == 0) x /= p[i], ++tmp; sum += tmp, v.push_back(tmp); } modint ans = fac[sum]; for (auto y : v) ans *= ifac[y]; return ans;}int main() { read(D); fac[0] = 1; FOR(i, 1, 100) fac[i] = i * fac[i - 1]; ifac[100] = qPow(fac[100], mod - 2); DEC(i, 100 - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; for (int i = 2; 1ll * i * i &lt;= D; ++i) { if (D % i) continue; p[++cnt] = i; while (D % i == 0) D /= i; } if (D &gt; 1) p[++cnt] = D; read(q); while (q--) { ll u, v; read(u, v); ll g = gcd(u, v); print(calc(u / g) * calc(v / g)); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"}]},{"title":"P7706 「Wdsr-2.7」文文的摄影布置","slug":"sol-luogu-p7706","date":"2021-12-18T13:38:32.000Z","updated":"2022-03-23T04:18:31.053Z","comments":true,"path":"sol-luogu-p7706/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p7706/","excerpt":"","text":"Description 二元序列 (A_i, B_i) ，定义 \\psi(i, k) = A_i + A_k - \\min_{i &lt; j &lt; k}B_j ，维护该序列，支持： 单点修改 A_i ； 单点修改 B_i ； 给定 l, r ，询问 \\max_{l\\le x &lt; x + 1&lt;y\\le r}\\psi(x, y) 。 5\\times 10^5 数据范围，2s。 Solution 肯定考虑使用线段树进行维护。我们考虑合并左右儿子的信息时，需要多维护一些什么东西。合并 l 和 r 的时候，如果 (i, j, k) 都在同一边，显然可以直接继承上来。 考虑 i, j 在左边， k 在右边和 i 在左边， j,k 在右边的情况。有个巧妙的维护方式是维护子树内的 \\max A_i ， \\min B_i ， \\max_{i &lt; j}\\{A_i - B_j\\} 和 \\max_{i &gt; j}\\{A_i - B_j\\} 。 上面这个东西应该挺好维护。然后就可以直接进行信息合并了。有点巧妙，说实话。 将线段树封成结构体，询问的时候将区间合并起来得到答案。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081const int maxn = 5e5 + 5;int a[maxn], b[maxn];struct node { int maxa, minb, val1, val2, ans; node() {maxa = val1 = val2 = ans = -1e9, minb = 1e9;}} t[maxn &lt;&lt; 2];//val1 : max(ai - bj) i &lt; j// val2 : max(ai - bj) i &gt; j#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)node operator+(const node &amp;a, const node &amp;b) { node res; res.maxa = max(a.maxa, b.maxa); res.minb = min(a.minb, b.minb); res.val1 = max(a.val1, b.val1, a.maxa - b.minb); res.val2 = max(a.val2, b.val2, b.maxa - a.minb); res.ans = max(a.ans, b.ans, a.maxa + b.val2, b.maxa + a.val1); return res;}void build(int i, int j, int k) { if (i == j) { t[k].maxa = a[i], t[k].minb = b[i]; return; } build(i, M, L), build(M + 1, j, R); t[k] = t[L] + t[R]; return;}void modify1(int i, int j, int k, int x, int v) { if (i == j) { t[k].maxa = v; return; } if (x &lt;= M) modify1(i, M, L, x, v); else modify1(M + 1, j, R, x, v); t[k] = t[L] + t[R]; return;}void modify2(int i, int j, int k, int x, int v) { if (i == j) { t[k].minb = v; return; } if (x &lt;= M) modify2(i, M, L, x, v); else modify2(M + 1, j, R, x, v); t[k] = t[L] + t[R]; return;}node query(int i, int j, int k, int x, int y) { if (x &lt;= i &amp;&amp; y &gt;= j) { return t[k]; } if (y &lt;= M) return query(i, M, L, x, y); if (x &gt; M) return query(M + 1, j, R, x, y); return query(i, M, L, x, y) + query(M + 1, j, R, x, y);}int main() { int n, m; read(n, m); FOR(i, 1, n) read(a[i]); FOR(i, 1, n) read(b[i]); build(1, n, 1); while (m--) { int op, x, y; read(op, x, y); if (op == 1) modify1(1, n, 1, x, y); else if (op == 2) modify2(1, n, 1, x, y); else print(query(1, n, 1, x, y).ans); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4036 [JSOI2008]火星人","slug":"sol-luogu-p4036","date":"2021-12-18T09:59:59.000Z","updated":"2022-03-23T04:18:30.968Z","comments":true,"path":"sol-luogu-p4036/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4036/","excerpt":"","text":"Description 维护一个字符串序列，要求支持： 单点插入 单点修改 询问两个字串的 LCP 长度 数据范围常规 1-2log 级别。 Solution 若不带修，则显然 SA 碾过去了，问题是它带修，并且还是需要支持插入。 我们除了 SA，还有什么方法呢？当然是二分+哈希了。 那么我们考虑使用平衡树进行维护，在合并区间的过程中维护哈希值，然后便可做了。 哈希如是进行维护： hash(u) = hash(ls(u)) + val(u) \\times base^{size(ls(u))} + hash(rs(u))\\times base^{size(ls(u)) + 1} 正确性应该是比较显然的。 写着有点烦而已。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using uint = unsigned;const int maxn = 1e5 + 5;const uint base = 31;char s0[maxn];uint p[maxn];struct node { int key, size, ch[2], val; uint hash;} t[maxn];int cnt, root;#define ls(u) t[u].ch[0]#define rs(u) t[u].ch[1]void pushup(int u) { t[u].size = t[ls(u)].size + t[rs(u)].size + 1; t[u].hash = t[ls(u)].hash + t[u].val * p[t[ls(u)].size] + t[rs(u)].hash * p[t[ls(u)].size + 1]; return;}void split(int u, int sz, int &amp;x, int &amp;y) { if (!u) return x = y = 0, void(); if (t[ls(u)].size &lt; sz) x = u, split(rs(u), sz - t[ls(u)].size - 1, rs(u), y); else y = u, split(ls(u), sz, x, ls(u)); return pushup(u), void();}int merge(int x, int y) { if (!x || !y) return x + y; if (t[x].key &lt; t[y].key) return t[x].ch[1] = merge(t[x].ch[1], y), pushup(x), x; else return t[y].ch[0] = merge(x, t[y].ch[0]), pushup(y), y;}void insert(int pos, char c) { int x, y; split(root, pos, x, y); ++cnt; t[cnt].val = t[cnt].hash = c - 'a' + 1, t[cnt].size = 1, t[cnt].key = rand(); root = merge(x, merge(cnt, y)); return;}void modify(int pos, char c) { int x, y, z; split(root, pos - 1, x, y), split(y, 1, y, z); t[y].val = t[y].hash = c - 'a' + 1; root = merge(x, merge(y, z)); return;}void build() { int n = strlen(s0 + 1); FOR(i, 1, n) insert(i - 1, s0[i]); return;}uint gethash(int l, int r) { int x, y, z; split(root, l - 1, x, y), split(y, r - l + 1, y, z); uint res = t[y].hash; root = merge(x, merge(y, z)); return res;}int solve(int pos1, int pos2) { int l = 0, r = min(t[root].size - pos2 + 1, t[root].size - pos1 + 1) + 1, res = 0; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; uint h1 = gethash(pos1, pos1 + mid - 1), h2 = gethash(pos2, pos2 + mid - 1); if (h1 == h2) res = mid, l = mid + 1; else r = mid; } return res;}int main() { p[0] = 1; FOR(i, 1, maxn - 1) p[i] = p[i - 1] * base; read(s0 + 1); build(); int m; read(m); while (m--) { char s[2], d[2]; read(s); int x, y; if (s[0] == 'Q') { read(x, y); print(solve(x, y)); } else if (s[0] == 'R') { read(x, d); modify(x, d[0]); } else if (s[0] == 'I') { read(x, d); insert(x, d[0]); } } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"字符串哈希","slug":"hash","permalink":"https://old.blog.imyangty.com/tags/hash/"},{"name":"平衡树","slug":"balanced-bst","permalink":"https://old.blog.imyangty.com/tags/balanced-bst/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4093 [HEOI2016/TJOI2016]序列","slug":"sol-luogu-p4093","date":"2021-12-05T05:51:54.000Z","updated":"2022-03-23T04:18:30.974Z","comments":true,"path":"sol-luogu-p4093/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4093/","excerpt":"","text":"Description 给定一个序列，数列中某些项的值可能变化，同一时刻只可能变化一个值。给出所有可能变化的值，问一个最长子序列的长度，使得这个子序列在任意一种变化情况中都是不降的。 题目中所有数字不超过 10^5 。 Solution","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"cdq分治","slug":"cdq","permalink":"https://old.blog.imyangty.com/tags/cdq/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P2717 寒假作业","slug":"sol-luogu-p2717","date":"2021-12-04T10:48:46.000Z","updated":"2022-03-23T04:18:30.913Z","comments":true,"path":"sol-luogu-p2717/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2717/","excerpt":"","text":"Description 给定序列 \\{a_i\\} ，问有多少个连续子段满足其平均值大于等于 k 。 1\\le n\\le 10^5 ， 1\\le a_i,k\\le 10^4 。 Solution 平均值大于等于 k 这个限制不太好处理，不妨转化一下：将所有的 a_i 减去 k ，此时问题变为有多少个连续子段满足和大于等于 0 。 考虑前缀和，一个连续子段 [l, r] 和大于等于 0 等价于 s_r - s_{l-1} \\ge 0 ，即为 s_{l - 1} 和 s_r 的对应关系，在此基础上考虑 cdq 分治，每次分治过程中处理跨越分治中心的 (l, r) 点对关系。 然后发现是个弱智逆序对，直接归并排序带走即可。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"cdq分治","slug":"cdq","permalink":"https://old.blog.imyangty.com/tags/cdq/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF932F Escape Through Leaf","slug":"sol-cf932f","date":"2021-12-02T12:58:55.000Z","updated":"2022-03-23T04:18:30.740Z","comments":true,"path":"sol-cf932f/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf932f/","excerpt":"","text":"Description n 个点的树，每个点有点权 (a_i, b_i) 。每次可以从 u 跳到 u 子树的任意一个子节点 v 上，费用为 a_u\\times b_v 。问每个节点跳跃到每个叶子节点的费用最小值。 2\\le n\\le 10^5 ， 0\\le |a_i|, |b_i|\\le 10^5 。 Solution 容易设计出一个 dp 状态 f_u 表示节点 u 的答案。然后即有如下转移： f_u = \\min_v\\{f_v + a_ub_v\\} 特别地，若 u 为叶子节点，则 f_u = 0 。 然而这样做是 O(n^3) 的，考虑优化。 不难发现，如果我们将 a_u 看作一个变量，则 f_v + a_ub_v 就是一个关于 a_u 的一次函数，维护一车一次函数的最值——李超树。（回忆 0\\le |a_i|\\le 10^5 ） 于是，线段树合并维护一下即可。 注意，李超树写动态开点的时候是无需平移下标的。 Implementation 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using ll = long long;const int maxn = 2e5 + 5, N = 1e5;const ll INF = 0x7fffffffffffffff;int n, root[maxn];ll a[maxn], b[maxn], f[maxn];vector&lt;int&gt; G[maxn];int tot = 0, ls[maxn &lt;&lt; 5], rs[maxn &lt;&lt; 5], t[maxn &lt;&lt; 5];il ll calc(ll x, int u) {return b[u] * x + f[u];}#define M ((i + j) &gt;&gt; 1)void insert(int &amp;k, int i, int j, int u) { if (!k) return k = ++tot, t[k] = u, void(); if (calc(M, t[k]) &gt; calc(M, u)) swap(u, t[k]); if (calc(i, t[k]) &lt;= calc(i, u) &amp;&amp; calc(j, t[k]) &lt;= calc(j, u)) return; if (calc(i, t[k]) &gt; calc(i, u)) insert(ls[k], i, M, u); else insert(rs[k], M + 1, j, u); return;}int merge(int x, int y, int i, int j) { if (!x || !y) return x + y; insert(x, i, j, t[y]); ls[x] = merge(ls[x], ls[y], i, M); rs[x] = merge(rs[x], rs[y], M + 1, j); return x;}ll query(int k, int i, int j, ll x) { if (!k) return INF; return min(calc(x, t[k]), x &lt;= M ? query(ls[k], i, M, x) : query(rs[k], M + 1, j, x));}void dfs(int u, int fa) { for (auto v : G[u]) { if (v == fa) continue; dfs(v, u); root[u] = merge(root[u], root[v], -N, N); } f[u] = query(root[u], -N, N, a[u]); if (f[u] == INF) f[u] = 0; insert(root[u], -N, N, u); return;}int main() { read(n); FOR(i, 1, n) read(a[i]); FOR(i, 1, n) read(b[i]); FOR(i, 1, n - 1) { int u, v; read(u, v); G[u].push_back(v), G[v].push_back(u); } dfs(1, 0); FOR(i, 1, n) print(f[i], ' '); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"cdq分治","slug":"cdq","permalink":"https://old.blog.imyangty.com/tags/cdq/"}]},{"title":"LOJ#2838. 「JOISC 2018 Day 3」比太郎的聚会","slug":"sol-loj2838","date":"2021-11-11T10:23:08.000Z","updated":"2022-03-23T04:18:30.774Z","comments":true,"path":"sol-loj2838/","link":"","permalink":"https://old.blog.imyangty.com/sol-loj2838/","excerpt":"","text":"Description 给定一张 n 个点的边带权的 DAG，每次选定一个点 u 和一个 ban 点集 S ，问能到达 u 且没有被 ban 掉的点中到 u 的最大距离。 1\\le n\\le 10^5 ， \\sum|S|\\le 10^5 。 Solution 首先对于每次询问，都可以做一次 O(n) 的 dp。然后复杂度就爆炸了。但是有一点非常关键： \\sum|S|\\le 10^5 ，所以 \\ge \\sqrt n 的 |S| 最多不超过 \\sqrt n 个。所以对于 |S|\\ge \\sqrt n ，我们就 O(n) 暴力 dp。但是剩下的点需要预处理。 其实也很简单，因为 |S|&lt;\\sqrt n 性质的存在，我们只要知道能到达 u 的前 \\sqrt n 个最大距离就可以了。这个东西是可以拓扑排序的时候归并一下 dp 数组得到的。于是这题就别我们以 O(n\\sqrt n) 的复杂度解决掉了。 Implementation 归并的时候需要注意同一个点的 dp 值需要去重。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;namespace YangTY {namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}template&lt;typename T&gt; il void print(const T &amp;x, const char &amp;c) {print(x), putchar(c);}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T chkmax(T &amp;a, const T &amp;b) {return a = max(a, b);}template&lt;typename T&gt; il T chkmin(T &amp;a, const T &amp;b) {return a = min(a, b);}template&lt;typename T&gt; il T myabs(const T &amp;a) {return a &gt;= 0 ? a : -a;}template&lt;typename T&gt; il void myswap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}const int maxn = 1e5 + 3, maxm = 2e5 + 5, sqrt = 250;int n, m, Q;int head[maxn], cnte, to[maxm], nxt[maxm];il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}struct node { int u, w; node() {} node(int _u, int _w) : u(_u), w(_w) {} il bool operator&lt;(const node &amp;b) const {return w &lt; b.w;} il node operator+(const int &amp;x) {return node(u, w + x);}} f0[maxn][sqrt + 3], tmp[sqrt + 5];int cnt[maxn];int c[maxn], f[maxn], vis[maxn];int main() { read(n), read(m), read(Q); while (m--) { int s, t; read(s), read(t); add(s, t); } FOR(i, 1, n) f0[i][cnt[i] = 1] = node(i, 0); FOR(u, 1, n) { for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; int p1 = 1, p2 = 1, j = 1; while (j &lt;= sqrt &amp;&amp; p1 &lt;= cnt[u] &amp;&amp; p2 &lt;= cnt[v]) { while (p1 &lt;= cnt[u] &amp;&amp; vis[f0[u][p1].u]) ++p1; while (p2 &lt;= cnt[v] &amp;&amp; vis[f0[v][p2].u]) ++p2; if (p1 &lt;= cnt[u] &amp;&amp; f0[u][p1] + 1 &lt; f0[v][p2]) vis[f0[v][p2].u] = 1, tmp[j++] = f0[v][p2++]; else if (p2 &lt;= cnt[v]) vis[f0[u][p1].u] = 1, tmp[j++] = f0[u][p1++] + 1; } while (j &lt;= sqrt &amp;&amp; p1 &lt;= cnt[u]) { while (p1 &lt;= cnt[u] &amp;&amp; vis[f0[u][p1].u]) ++p1; if (p1 &lt;= cnt[u]) vis[f0[u][p1].u] = 1, tmp[j++] = f0[u][p1++] + 1; } while (j &lt;= sqrt &amp;&amp; p2 &lt;= cnt[v]) { while (p2 &lt;= cnt[v] &amp;&amp; vis[f0[v][p2].u]) ++p2; if (p2 &lt;= cnt[v]) vis[f0[v][p2].u] = 1, tmp[j++] = f0[v][p2++]; } FOR(k, 1, j - 1) f0[v][k] = tmp[k], vis[f0[v][k].u] = 0; cnt[v] = j - 1; } } FOR(kase, 1, Q) { int t, y; read(t), read(y); FOR(i, 1, y) { int c; read(c); vis[c] = kase; } if (y &lt; sqrt) { int ans = -1; FOR(i, 1, cnt[t]) if (vis[f0[t][i].u] != kase) { ans = f0[t][i].w; break; } print(ans, '\\n'); } else { memset(f, -1, sizeof f); FOR(u, 1, n) { if (vis[u] != kase) chkmax(f[u], 0); if (f[u] &lt; 0) continue; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; chkmax(f[v], f[u] + 1); } } print(f[t], '\\n'); } } return output(), 0;}} // namespace YangTYint main() { YangTY::main(); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"拓扑排序","slug":"toposort","permalink":"https://old.blog.imyangty.com/tags/toposort/"},{"name":"根号分治","slug":"sqrt-division","permalink":"https://old.blog.imyangty.com/tags/sqrt-division/"},{"name":"LOJ","slug":"LOJ","permalink":"https://old.blog.imyangty.com/tags/LOJ/"}]},{"title":"__builtin 系列函数总结","slug":"note-builtin","date":"2021-11-09T08:56:14.000Z","updated":"2022-03-23T04:17:42.163Z","comments":true,"path":"note-builtin/","link":"","permalink":"https://old.blog.imyangty.com/note-builtin/","excerpt":"","text":"前言 CCF 解禁双下划线函数后实战中有较为强大的运用。 GCC 编译器提供的内建函数，以 __builtin_ 开头，开头为双下划线。 定义 主要有用的是针对位运算的这几个函数。 __builtin_popcount(unsigned x)：popcount 函数，基本上比手写的快。 __builtin_popcountll(unsigned long long x)：对于 long long 类型的需使用这个函数。 即，一般，我们是对 unsigned 进行操作，有符号数会自动转为无符号，对于 long long 则需要在后面加上 ll 的后缀。 __builtin_ffs(unsigned x)：相当于 lowbit(x)，两者效率差别不大。 __builtin_ctz(unsigned x)：返回末尾 0 的个数，相当于 lowbit(x) - 1，对 0 未定义。 __builtin_clz(unsigned x)：返回前导 0 的个数，对 0 未定义。上面两个的记忆方法：count leading/trailing zeros。 一般有用的就这几个。 应用 部分应用场景下可以减少状压 dp 的实现难度。 而且其效率高（尤其是 popcount），基本不会被卡常。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"位运算","slug":"bitmask","permalink":"https://old.blog.imyangty.com/tags/bitmask/"}]},{"title":"CSP-S 2021 题解","slug":"sol-csps2021","date":"2021-11-06T12:21:50.000Z","updated":"2022-03-23T04:18:30.754Z","comments":true,"path":"sol-csps2021/","link":"","permalink":"https://old.blog.imyangty.com/sol-csps2021/","excerpt":"","text":"前言 没打成，VP。 感觉今年的 T1 比儒略历阳间不少，但比动物园要难。 T1 廊桥分配 Description n 个廊桥， m_1 架国内航班， m_2 架国际航班。要求将 n 个廊桥分配到国内和国际区，使得能停留在廊桥的飞机数量最多。求能停留廊桥的飞机的最大数量。不存在两架航班到达时间相同。 先来先得，如果有空闲廊桥肯定来停廊桥。 1\\le n\\le 10^5 。 Solution 首先一秒钟想出 O(n^2) 的暴力做法：维护两个 dp 数组 f_i 和 g_i ，分别表示 i 个廊桥分配给国内/国外能停留的最大飞机数量，然后就随便转移一下即可。可以通过 40pts 的数据。 然后 f_i + g_{n - i} 不一定是单峰的，所以不能使用三分。 然后考虑到， f_i 必然是单调不减的，且 f_i 里面分配好的飞机不会对 f_{i + 1} 产生影响，所以我们可以考虑维护一个 set 存储未被分配到的飞机，然后加入一个廊桥的时候就可以将 set 里面最小的飞机取出来，然后依次取可以添加的飞机，这样子就可以 O(n\\log m) 求出 f 和 g 两个数组。 做完了。 Implementation 12345678910111213141516171819202122232425262728293031323334353637383940struct node { int id, t; node(int i, int _t) : id(i), t(_t) {} friend il bool operator&lt;(const node &amp;a, const node &amp;b) {return a.t &lt; b.t;} friend il bool operator==(const node &amp;a, const node &amp;b) {return a.id == b.id &amp;&amp; a.t == b.t;}};const int maxn = 1e5 + 5;int a[3][maxn], b[3][maxn], n, m1, m2, f[maxn], g[maxn];std::set&lt;node&gt; s1, s2;void solve(int *a, int *b, int m, int *f) { s1.clear(), s2.clear(); FOR(i, 1, m) s1.insert(node(i, a[i])), s2.insert(node(i, b[i])); FOR(i, 1, n) { f[i] = f[i - 1]; int now = 0; std::set&lt;node&gt;::iterator it; while ((it = s1.lower_bound(node(1, now))) != s1.end()) { ++f[i]; int id = it-&gt;id; now = b[id]; s1.erase(node(id, a[id])), s2.erase(node(id, b[id])); } } return;}int main() { read(n), read(m1), read(m2); FOR(i, 1, m1) read(a[1][i]), read(b[1][i]); FOR(i, 1, m2) read(a[2][i]), read(b[2][i]); solve(a[1], b[1], m1, f); solve(a[2], b[2], m2, g); int ans = 0; FOR(i, 0, n) chkmax(ans, f[i] + g[n - i]); print(ans, '\\n'); return output(), 0;} T2 括号序列 Description 给定常数 k ，定义超级括号序列为由字符 (、) 和 * 组成的满足如下要求的字符串： ()、(S) 均为合法串，其中 S 表示仅由不超过 k 个字符 * 组成的非空串（以下的 S 均由此定义）； 若 A 和 B 为合法串，则 AB 和 ASB 也为合法串； 若 A 为合法串，则 (A)，(SA)，(ASA) 也为合法串。 现给定一长度为 n 的串，其中有些字符未被确定，求有多少种合法方案使得其为合法串，答案模 10^9 + 7 。 1\\le k\\le n\\le 500 。1s，512MB。 Solution 暴力是很好打的。 500 的数据范围让我们不禁思考能否区间 dp。 T3 回文 Description 给定 n 和 \\{a_{2n}\\} ，其中 1,2,\\cdots, n 各出现 2 次。先从前往后构造 \\{b_{2n}\\} ，具体方法为从 a 的首端或者末端取出一个元素然后加到 b 的末端，不难发现其可以用一个长度为 2n 形如 LRLRR.. 的操作序列描述。 求一个字典序最小的操作序列使得 \\{b_{2n}\\} 回文，或者输出无解。 多测， 1\\le T\\le 100 ， 1\\le n\\le\\sum n\\le 5\\times 10^5 。 Solution 暴力是很好打的。36pts 到手了。 然后分析一下这道题目的性质。下面假设第一步操作为 L，令 a_1 = a_p 。 则我们会发现， a_{2, \\cdots, p - 1} 和 a_{p + 1, \\cdots, 2n} 两个序列就被划分出来了，不难发现其为两个栈。然后我们需要依次从这两个栈顶取元素使得 b 回文，然后操作序列的字典序尽可能小。 既然要回文，那么显然这个数字要同时出现在栈顶和栈底（任意一个栈就行）。所以我们删除这个数，然后更新操作序列。 O(n) 。 Implementation 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int maxn = 1e6 + 5;int a[maxn], n;char ans[maxn];std::deque&lt;int&gt; q1, q2;bool solve() { int cnt = 1; while (!q1.empty() || !q2.empty()) { ++cnt; if (q1.size() &gt;= 2 &amp;&amp; q1.back() == q1.front()) { ans[cnt] = 'L', ans[2 * n - cnt + 1] = 'L'; q1.pop_back(), q1.pop_front(); } else if (!q1.empty() &amp;&amp; !q2.empty() &amp;&amp; q1.back() == q2.front()) { ans[cnt] = 'L', ans[2 * n - cnt + 1] = 'R'; q1.pop_back(), q2.pop_front(); } else if (!q1.empty() &amp;&amp; !q2.empty() &amp;&amp; q2.back() == q1.front()) { ans[cnt] = 'R', ans[2 * n - cnt + 1] = 'L'; q1.pop_front(), q2.pop_back(); } else if (q2.size() &gt;= 2 &amp;&amp; q2.back() == q2.front()) { ans[cnt] = 'R', ans[2 * n - cnt + 1] = 'R'; q2.pop_back(), q2.pop_front(); } else return false; } return true;}int main() { int T; read(T); while (T--) { read(n); FOR(i, 1, 2 * n) read(a[i]); bool flag = 0; ans[1] = ans[2 * n] = 'L'; int p = 0; q1.clear(), q2.clear(); FOR(i, 2, 2 * n) { if (a[i] == a[1]) p = i; else if (p) q2.push_back(a[i]); else q1.push_front(a[i]); } if (solve()) flag = 1; else { q1.clear(), q2.clear(); ans[1] = 'R', ans[2 * n] = 'L'; p = 0; FOR(i, 1, 2 * n - 1) { if (a[i] == a[2 * n]) p = i; else if (p) q2.push_back(a[i]); else q1.push_front(a[i]); } if (solve()) flag = 1; } if (flag) FOR(i, 1, 2 * n) putchar(ans[i]); else printf(\"-1\"); puts(\"\"); } return 0;} T4 交通规划","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"}]},{"title":"P5039 [SHOI2010]最小生成树","slug":"sol-luogu-p5039","date":"2021-11-01T14:27:26.000Z","updated":"2022-03-23T04:18:31.006Z","comments":true,"path":"sol-luogu-p5039/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5039/","excerpt":"","text":"Description 给定一张图，指定一条边，要求在进行下面操作若干次之后该边一定在最小生成树中： 一次操作可以选定一条边，然后将除了这条边之外所有的边的边权减一。 问最小的操作次数。 Solution 转化一下，除了它减一相当于就是它自己加一。 然后我们考虑这条指定的边 (u, v) 何时会在最小生成树上。考虑如果 u 和 v 能形成环，则环上的最大边权不能 \\le (u, v) 的边权。 所以我们考虑跑一个 u 到 v 的最小割，把除了 (u, v) 外，边权 \\le (u, v) 边权的边放进一张图里面跑。 就能得到答案了。 Implementation 123456789101112131415161718struct edge0 { int u, v, w;} e0[maxm];int main() { int lab; read(n), read(m), read(lab); FOR(i, 1, m) read(e0[i].u), read(e0[i].v), read(e0[i].w); FOR(i, 1, m) { if (i == lab || e0[i].w &gt; e0[lab].w) continue; add(e0[i].u, e0[i].v, e0[lab].w - e0[i].w + 1); add(e0[i].v, e0[i].u, e0[lab].w - e0[i].w + 1); } s = e0[lab].u, t = e0[lab].v; print(dinic()); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"最小生成树","slug":"mst","permalink":"https://old.blog.imyangty.com/tags/mst/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最小割","slug":"mincut","permalink":"https://old.blog.imyangty.com/tags/mincut/"}]},{"title":"ICPC Shanghai 2019 D Spanning Tree Removal","slug":"sol-nc202122","date":"2021-11-01T02:29:16.000Z","updated":"2022-03-23T04:18:31.060Z","comments":true,"path":"sol-nc202122/","link":"","permalink":"https://old.blog.imyangty.com/sol-nc202122/","excerpt":"","text":"Description 牛客传送门。给定一张完全图，每次操作可以选择一棵生成树然后从图中删除。问最多能进行几次这样的操作，并输出方案。 Solution 操作次数显然为 n / 2 。 考虑构造出 n / 2 条边不相交的链。 发现可以 \\{x, x + 1, x - 1, x + 2, x - 2, x + 3,\\cdots\\} 这样构造。循环移位 n / 2 次就可以构造出所有需要的生成树。具体可以看代码。 Implementation 1234567891011121314151617int main() { int T; scanf(\"%d\", &amp;T); FOR(kase, 1, T) { int n; scanf(\"%d\", &amp;n); printf(\"Case #%d: %d\\n\", kase, n &gt;&gt; 1); FOR(i, 1, n &gt;&gt; 1) { int now = i, sgn = 1; FOR(j, 1, n - 1) { int nxt = (now + sgn * j - 1 + n) % n + 1; printf(\"%d %d\\n\", now, nxt); sgn = -sgn, now = nxt; } } } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"ICPC","slug":"ICPC","permalink":"https://old.blog.imyangty.com/tags/ICPC/"}]},{"title":"M-SOLUTIONS2019F - Random Tournament","slug":"sol-msolutions2019f","date":"2021-10-31T10:18:07.000Z","updated":"2022-03-30T00:06:04.446Z","comments":true,"path":"sol-msolutions2019f/","link":"","permalink":"https://old.blog.imyangty.com/sol-msolutions2019f/","excerpt":"","text":"Description 给定一张竞赛图， i\\to j 有连边表示 i 能打败 j 。将 1,2,\\cdots,n 排成一排，每次可以选相邻两个人干架留下胜者，问最后有多少人可能赢。 ZR 加强版要求输出方案。 Solution 可以设计出一个比较 naive 的 dp： f_{i, j, k} 表示 [i, j] 中 k 能否胜出。然后这个东西可以 O(n^4) 或者 O(n^5) 随便转移一下，无法通过。 然后考虑优化状态：发现我们没有必要设计出这一个多余的 k ，因为 k 能在 [l, r] 中胜出当且仅当 k 能赢了 [l, k -1] 中的人且能赢 [k + 1, r] 中的人。两边的这些人是独立的，所以可以设计出一个 f_{i, j, 0/1} 表示 i/j 能否赢 [i, j] 中的所有人。状态瞬间变为 O(n^2) 级别。 下面为了好看一点，我们令 L_{i, j} 为上文的 f_{i, j, 0} ， R_{i, j} 为上文的 f_{i, j ,1} 。 于是转移就来了： \\begin{aligned} L_{i, j} &amp;= \\max_{i &lt; k \\le j}\\{L_{k, j}\\land R_{i + 1, k}\\land a_{i, k}\\}\\\\ R_{i, j} &amp;= \\max_{i &lt; k \\le j}\\{L_{k, j - 1}\\land R_{i, k}\\land a_{j, k}\\} \\end{aligned} 这个是 O(n^3) 的。然后呢所有的 dp 状态都是 bool 型的，bitset 碾过去复杂度就是 O\\left(\\dfrac{n^3}{w}\\right) 的，可以通过此题。 Implementation 实现的时候需要注意一下 L_{i, j} 的定义需要改一下， 改成 L_{j, i} 表示 i 能否赢 [i, j] 中的所有人。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;bitset&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;const int maxn = 2005;bitset&lt;maxn&gt; L[maxn], R[maxn], a[maxn];int n;int main() { cin &gt;&gt; n; FOR(i, 1, n) { FOR(j, 1, i - 1) { char ch; cin &gt;&gt; ch; if (ch == '1') a[i][j] = 1; a[j][i] = a[i][j] ^ 1; } } FOR(i, 1, n) L[i][i] = R[i][i] = 1; FOR(len, 2, n) { FOR(i, 1, n - len + 1) { int j = i + len - 1; L[j][i] = (L[j] &amp; R[i + 1] &amp; a[i]).count() &gt; 0; R[i][j] = (L[j - 1] &amp; R[i] &amp; a[j]).count() &gt; 0; } } int ans = 0; FOR(i, 1, n) ans += (L[n][i] &amp; R[1][i]); cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"区间dp","slug":"interval-dp","permalink":"https://old.blog.imyangty.com/tags/interval-dp/"},{"name":"bitset","slug":"bitset","permalink":"https://old.blog.imyangty.com/tags/bitset/"}]},{"title":"CF431D Random Task","slug":"sol-cf431d","date":"2021-10-31T09:21:37.000Z","updated":"2022-03-23T04:18:30.709Z","comments":true,"path":"sol-cf431d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf431d/","excerpt":"","text":"Description 给定 m 和 k （ 0\\le m\\le 10^{18} ， 1\\le k\\le 64 ），求任意一个 n 满足 [n + 1, 2n] 中恰有 m 个数 x 满足 \\operatorname{popcount}(x) = k 。 Solution 研究一下性质，令 S(n) = \\{n + 1, n + 2, \\cdots, 2n\\} ， f(n) = \\sum_{x\\in S(n)}[\\operatorname{popcount}(x) = k] 。然后由于 S(n) - S(n - 1) = \\{2n - 1, 2n\\} - \\{n\\} ，而 \\operatorname{popcount}(n) = \\operatorname{popcount}(2n) 。因此这个 f(n) 是非严格递增的，具有可二分性。 现在的问题变为给定 n 如何求 f(n) 。 貌似可以数位 dp。 于是这题就解决了。复杂度两个 \\log 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839ll m, k;ll f[80][80], a[80];ll solve(int now, int cnt, int lim) { if (!now) return (cnt == k); if (~f[now][cnt] &amp;&amp; !lim) return f[now][cnt]; int up = lim ? a[now] : 1; ll res = 0; FOR(i, 0, up) if (cnt + (i == 1) &lt;= k) res += solve(now - 1, cnt + (i == 1), lim &amp;&amp; (i == up)); if (!lim) f[now][cnt] = res; return res;}ll check(ll mid) { a[0] = 0; for (ll x = mid &lt;&lt; 1ll; x; x &gt;&gt;= 1) a[++a[0]] = (x &amp; 1); ll ret = solve(a[0], 0, 1); a[0] = 0; for (ll x = mid; x; x &gt;&gt;= 1) a[++a[0]] = (x &amp; 1); ret -= solve(a[0], 0, 1); return ret;}int main() { scanf(\"%lld %lld\", &amp;m, &amp;k); memset(f, -1, sizeof f); ll l = 1, r = (ll)1e18 + 1; while (l &lt; r) { ll mid = (l + r) &gt;&gt; 1, tmp = check(mid); if (tmp == m) return printf(\"%lld\\n\", mid), 0; else if (tmp &lt; m) l = mid + 1; else r = mid; } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"数位dp","slug":"digit-dp","permalink":"https://old.blog.imyangty.com/tags/digit-dp/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"}]},{"title":"AGC039D Incenters","slug":"sol-agc039d","date":"2021-10-30T07:02:00.000Z","updated":"2022-03-30T00:04:32.054Z","comments":true,"path":"sol-agc039d/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc039d/","excerpt":"","text":"Description 给定 n 个单位圆上的点，坐标形如 \\left(\\cos\\dfrac{2\\pi T_i}{L}, \\sin\\dfrac{2\\pi T_i}{L}\\right) ，等概率随机选 3 个点，问内心坐标的期望。 3\\le n\\le 3000 。 Solution 平面几何的推导题。mark 住说不定以后有用。 Lemma 1：对于 \\triangle ABC ，在外接圆上取 \\overset{\\frown}{BC} 的中点 A' ， B' 和 C' 同理，则 \\triangle ABC 的内心 I 与 \\triangle A'B'C' 的垂心 H 重合。 证明：考虑下面的 \\triangle ABC 和 \\triangle A'B'C' ： 首先我们由初中平几知识知道 A ， I 和 A' 是共线的，然后我们就可以进行角度的转化，随便转几下就可以发现 AA'\\perp BC ，依次类推，故内心与垂心重合。 Lemma 2（欧拉线定理）： \\triangle ABC 的垂心 H ，重心 G 和外心 O 共线，且 GH = 2GO 。 证明：考虑下图的 \\triangle ABC ： 证明的话考虑 \\overrightarrow{OH} = \\overrightarrow{OA}+ \\overrightarrow{OB} + \\overrightarrow{OC} ，而 \\overrightarrow{OG} = \\dfrac13\\left(\\overrightarrow{OA}+ \\overrightarrow{OB} + \\overrightarrow{OC}\\right) 。证毕。 回到本题，原来三角形的内心就被我们转化成功了。然后由于 \\overrightarrow{OH} = 3\\overrightarrow{OG} ，所以要求的点的坐标即为 A' ， B' 和 C' 的坐标之和。接下来就是枚举三角形然后计算了。可是， O(n^3) 是过不去的，怎么办？ 不妨考虑枚举点 A 和 B ，然后 C' 自然就出来了（取角度的平均数），每个都这样子枚举一遍，统计 C' 的贡献，就可以了。 Implementation 123456789101112131415161718192021using db = long double;const db PI = acos(-1.0);const int maxn = 3005;int n, L, t[maxn];int main() { read(n), read(L); FOR(i, 1, n) read(t[i]); db ansx = 0, ansy = 0; FOR(i, 1, n) { FOR(j, i + 1, n) { ansx += (n - 2 * (j - i)) * cos(PI * (t[i] + t[j]) / L); ansy += (n - 2 * (j - i)) * sin(PI * (t[i] + t[j]) / L); } } db cnt = 1.0 * n * (n - 1) * (n - 2) / 6; printf(\"%.12Lf %.12Lf\\n\", ansx / cnt, ansy / cnt); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"平面几何","slug":"平面几何","permalink":"https://old.blog.imyangty.com/tags/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/"}]},{"title":"P1989 无向图三元环计数","slug":"sol-luogu-p1989","date":"2021-10-30T06:22:45.000Z","updated":"2022-03-23T04:18:30.870Z","comments":true,"path":"sol-luogu-p1989/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1989/","excerpt":"","text":"Description 给定 n 点 m 边的无向图 G ，求三元环个数。 1\\le n\\le 10^5 ， 1\\le m\\le 2\\times 10^5 。 Solution 很绝绝子的思路。按照点度进行根号分治是一个经典的套路。 无向图不好考虑，考虑给边定向。定向方式是： 若 \\deg u &lt; \\deg v ，则连边 (u, v) 。 若 \\deg u = \\deg v\\land u &lt; v ，则连边 (u, v) 。 显然，每对点对都能严格比出大小，因此这是一个 DAG。 原图中的三元环必然会与新图中 (u, v) ， (u, w) 和 (v, w) 对应。所以枚举 u 的出边，再枚举 v 的出边，再判断 w 是不是 u 指向的点。 这样看似很暴力，但实际上复杂度是 O(m\\sqrt m) 的，下面给出分析： 一条边 (u, v) 会产生 \\operatorname{out}(v) 的贡献，其中 \\operatorname{out}(v) 为 v 的出度。总复杂度即为 \\sum_{(u, v)\\in E}\\operatorname{out}(v) 。 分情况讨论： 原图中度数不大于 \\sqrt m 的点，新图中出度必然是 O(\\sqrt m) 的。 原图中度数大于 \\sqrt m 的点，因为度数大于 \\sqrt m 的点只有 O(\\sqrt m) 个，所以新图中出度也是 O(\\sqrt m) 的。 总复杂度即为 O(m\\sqrt m) 。 Implementation 12345678910111213141516171819202122232425262728const int maxn = 1e5 + 5, maxm = 2e5 + 5;int n, m;int u0[maxm], v0[maxm], deg[maxn], tag[maxn];std::vector&lt;int&gt; G[maxn];il bool cmp(int u, int v) { return deg[u] != deg[v] ? deg[u] &lt; deg[v] : u &lt; v;}int main() { read(n), read(m); FOR(i, 1, m) { read(u0[i]), read(v0[i]); ++deg[u0[i]], ++deg[v0[i]]; } FOR(i, 1, m) { if (cmp(u0[i], v0[i])) G[u0[i]].push_back(v0[i]); else G[v0[i]].push_back(u0[i]); } int ans = 0; FOR(u, 1, n) { for (auto &amp;v : G[u]) tag[v] = u; for (auto &amp;v : G[u]) for (auto &amp;w : G[v]) if (tag[w] == u) ++ans; } print(ans, '\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"根号分治","slug":"sqrt-division","permalink":"https://old.blog.imyangty.com/tags/sqrt-division/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4169 [Violet]天使玩偶/SJY摆棋子","slug":"sol-luogu-p4169","date":"2021-10-29T09:04:28.000Z","updated":"2022-03-23T04:18:30.980Z","comments":true,"path":"sol-luogu-p4169/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4169/","excerpt":"","text":"Description 二维平面上，两种操作： 加入点 (x_i, y_i) ； 给定 (x_i, y_i) ，求已经加入的点中，曼哈顿距离最小的点，输出这个距离。 坐标范围 [0, 10^6] ， 1\\le n,m\\le 3\\times 10^5 。 Solution |x - x_i| + |y - y_i| 这个式子比较难处理，不妨假设 x_i \\le x, y_i\\le y ，拆开成 (x + y) - (x_i + y_i) 。 相当于我们需要对于一个 (x,y) ，求 x_i + y_i 的最大值，其中 (x_i,y_i) 满足 x_i\\le x\\land y_i\\le y 且在 (x, y) 之前插入。 三维偏序问题，cdq 解决，使用树状数组维护最大值。 然后对于其他的情况，变换一下坐标系，一共做 4 次 cdq 分治就可以了。 Implementation 这题卡常，需要注意下三维偏序的写法，实测这种归并排序式而不是每次 sort 两个区间的写法相当的快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const int maxn = 3e5 + 5, maxx = 1e6 + 5, INF = 1e9;struct node { int x, y, t, op;} q[maxn &lt;&lt; 1], a[maxn &lt;&lt; 1], tmp[maxn &lt;&lt; 1];int n, m, tot, ans[maxn &lt;&lt; 1], t[maxx &lt;&lt; 1];void insert(int x, int val) { for (; x &lt; maxx; x += lowbit(x)) chkmax(t[x], val); return;}void clear(int x) { for (; x &lt; maxx; x += lowbit(x)) t[x] = -INF; return;}int query(int x) { int ret = -INF; for (; x; x -= lowbit(x)) chkmax(ret, t[x]); return ret;}void solve(int l, int r) { if (l == r) return; int mid = (l + r) &gt;&gt; 1; solve(l, mid), solve(mid + 1, r); int i, j, k = l; for (i = l, j = mid + 1; j &lt;= r;) { while (q[i].x &lt;= q[j].x &amp;&amp; i &lt;= mid) { if (q[i].op == 1) insert(q[i].y, q[i].x + q[i].y); tmp[k++] = q[i++]; } if (q[j].op == 2) chkmin(ans[q[j].t], q[j].x + q[j].y - query(q[j].y)); tmp[k++] = q[j++]; } for (j = l; j &lt; i; ++j) clear(q[j].y); while (i &lt;= mid) tmp[k++] = q[i++]; FOR(i, l, r) q[i] = tmp[i]; return;}int main() { read(n), read(m); FOR(i, 1, n) { ++tot, read(q[tot].x), read(q[tot].y); ++q[tot].x, ++q[tot].y, q[tot].t = 0, q[tot].op = 1; ans[tot] = INF; } FOR(i, 1, m) { ++tot, read(q[tot].op), read(q[tot].x), read(q[tot].y); ++q[tot].x, ++q[tot].y, q[tot].t = i; ans[tot] = INF; } FOR(i, 0, maxx - 1) t[i] = -INF; FOR(i, 1, tot) a[i] = q[i]; solve(1, tot); FOR(i, 1, tot) q[i] = a[i], q[i].x = maxx - a[i].y, q[i].y = a[i].x; solve(1, tot); FOR(i, 1, tot) q[i] = a[i], q[i].x = maxx - a[i].x, q[i].y = maxx - a[i].y; solve(1, tot); FOR(i, 1, tot) q[i] = a[i], q[i].x = a[i].y, q[i].y = maxx - a[i].x; solve(1, tot); FOR(i, 1, tot) if (ans[i] != INF) print(ans[i], '\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"cdq分治","slug":"cdq","permalink":"https://old.blog.imyangty.com/tags/cdq/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF187D BRT Contract","slug":"sol-cf187d","date":"2021-10-28T07:47:47.000Z","updated":"2022-03-23T04:18:30.694Z","comments":true,"path":"sol-cf187d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf187d/","excerpt":"","text":"Description 一条马路被 n 个红绿灯分为 n + 1 段，走过每段的时间为 l_i 。红绿灯的周期为 r + g ， [0, g) 为绿灯， [g, g + r) 为红灯。红灯时要等。同一时刻每个灯的状态相同。 q 次询问， t_i 时刻出发，问何时到达。 n,q\\le 10^5 ， 2\\le g,r\\le 10^9 。 Solution 首先我们可以处理一下每个红绿灯从 0 时刻（因为模了 g + r 之后必然是 0 时刻）到终点要多久，这样子我们找到每次出发时第一个拦下他的红绿灯就能得到答案。 设第 i 个红绿灯变成绿灯后到终点需要 f_i 的时间，则我们需要找的是从他出发后遇到的第一个红灯 k ，然后加上 f_k 。如何找？对路程做一个前缀和得到 s_i ，令 r + g = p ，则 g\\le(s_k - s_i)\\bmod p &lt; g + r 动态开点线段树维护一下最小值就行了。 然后对于每个出发的时间也是一个道理，查最小值即可。 Implementation 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using ll = long long;const int maxn = 1e5 + 5;struct Node { int ch[2], mn; Node() {mn = 1e9;}} t[maxn * 50];int n, tot, root;ll g, r, s[maxn], f[maxn];#define ls(u) t[u].ch[0]#define rs(u) t[u].ch[1]#define M ((i + j) &gt;&gt; 1)void modify(int &amp;k, int i, int j, int x, int v) { if (!k) k = ++tot; if (i == j) return t[k].mn = v, void(); if (x &lt;= M) modify(ls(k), i, M, x, v); else modify(rs(k), M + 1, j, x, v); t[k].mn = min(t[ls(k)].mn, t[rs(k)].mn); return;}int query(int k, int i, int j, int x, int y) { if (!k) return 1e9; if (x &lt;= i &amp;&amp; y &gt;= j) return t[k].mn; int ret = 1e9; if (x &lt;= M) chkmin(ret, query(ls(k), i, M, x, y)); if (y &gt; M) chkmin(ret, query(rs(k), M + 1, j, x, y)); return ret;}int main() { read(n, g, r); FOR(i, 1, n + 1) read(s[i]), s[i] += s[i - 1]; ll p = (g + r); DEC(i, n, 1) { int l = (g + s[i]) % p, r = (p - 1 + s[i]) % p; int k = 1e9; if (l &lt;= r) chkmin(k, query(root, 0, p - 1, l, r)); else chkmin(k, min(query(root, 0, p - 1, 0, r), query(root, 0, p - 1, l, p - 1))); if (k &gt; n) f[i] = s[n + 1] - s[i]; else f[i] = s[k] - s[i] + (p - (s[k] - s[i]) % p) + f[k]; modify(root, 0, p - 1, s[i] % p, i); } int q; read(q); while (q--) { ll t0, ans; read(t0); int t = t0 % p; int l = (g - t + p) % p, r = (p - t - 1 + p) % p, k = 1e9; if (l &lt;= r) chkmin(k, query(root, 0, p - 1, l, r)); else chkmin(k, min(query(root, 0, p - 1, 0, r), query(root, 0, p - 1, l, p - 1))); if (k &gt; n) ans = s[n + 1] + t0; else ans = f[k] + t0 + s[k] + (p - (s[k] + t0) % p); print(ans); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"}]},{"title":"GYM102412D The Jump from Height of Self-importance to Height of IQ Level","slug":"sol-gym102412d","date":"2021-10-26T11:14:08.000Z","updated":"2022-03-23T04:18:30.756Z","comments":true,"path":"sol-gym102412d/","link":"","permalink":"https://old.blog.imyangty.com/sol-gym102412d/","excerpt":"","text":"Description 长度为 n 的序列（ 3\\le n\\le 1.2\\times10^5 ）， q 次操作，每次操作选定 [l, r] 并向右 shift k 位。每次操作后回答排列中是否存在长度为 3 的上升子序列。 Solution shift 这种操作可以抽象为将一段区间取出来然后塞到另外两段区间的中间，所以考虑使用平衡树来维护这个序列。 最关键的事情就变为了维护区间的信息。考虑我们维护一个区间里面是否存在需要的三元组。为了从左右儿子合并得到当前的信息，我们需要知道： 左/右儿子中是否已经存在该三元组； 该三元组从左儿子中抽两个加上右儿子中的一个组成； 该三元组从右儿子中抽两个加上左儿子中的一个组成。 所以我们需要维护 (x_1, x_2) （ x_1 &lt; x_2 ）中，最小的 x_2 ，这样更容易在右儿子中找到比 x_2 大的 x_3 。同理维护一个最大的 x_1 。这样的话，如果右儿子的最大值 x_3 大于左儿子的 x_2 ；或者左儿子的最小值 x_3 小于右儿子的 x_1 ，都视为找到合法的解。 答案，最小值，最大值都很好维护，现在主要矛盾是如何维护 x_1 和 x_2 。首先显然可以从子节点继承过来，然后考虑 x_1 和 x_2 分别在左右子树的情况，以维护 x_2 为例。一个很强的 x_2 是将最小值作为 x_1 然后在右子树中递归找 x_1 的后继。 Implementation 咕。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"平衡树","slug":"balanced-bst","permalink":"https://old.blog.imyangty.com/tags/balanced-bst/"}]},{"title":"CF486D Valid Sets","slug":"sol-cf486d","date":"2021-10-24T08:49:15.000Z","updated":"2022-03-23T04:18:30.717Z","comments":true,"path":"sol-cf486d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf486d/","excerpt":"","text":"Description 给定一棵带点权的树，问极差小于 d 的连通子图的个数。 n,d,a_i\\le 2000 。答案模 10^9 + 7 。 Solution 由于是极差，所以考虑枚举最小的点然后以其为根进行 dp。但是会有个问题：当最小值重复时，贡献会算重。解决这个问题的方法很简单，只需要给相同点权的排个序然后 ban 掉之前的就行了。 dp 就是 f_u = \\prod(f_v + 1) 其中 f_u 为 u 子树内形成与根相连的连通块的方案数。意义即为还有一种方案是不选这个儿子 v 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)const int mod = 1e9 + 7;struct modint { typedef int INT; static const INT mod = ::mod; INT val; il void check() { val &gt;= mod ? val %= mod : true; val &lt; 0 ? (val %= mod) += mod : true; return; } modint(INT v = 0) : val(v) {check();} il modint &amp;operator=(INT v) {return val = v, *this;} il modint &amp;operator+=(modint rhs) {return val = val + rhs.val &gt;= mod ? val + rhs.val - mod : val + rhs.val, *this;} il modint &amp;operator-=(modint rhs) {return val = val - rhs.val &lt; 0 ? val - rhs.val + mod : val - rhs.val, *this;} il modint &amp;operator*=(modint rhs) {return val = 1ll * val * rhs.val % mod, *this;} il friend modint operator+(const modint &amp;lhs, const modint &amp;rhs) {return modint(lhs) += rhs;} il friend modint operator-(const modint &amp;lhs, const modint &amp;rhs) {return modint(lhs) -= rhs;} il friend modint operator*(const modint &amp;lhs, const modint &amp;rhs) {return modint(lhs) *= rhs;} il friend bool operator==(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val == rhs.val;} il friend bool operator!=(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val != rhs.val;} il friend bool operator&gt;(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &gt; rhs.val;} il friend bool operator&lt;(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &lt; rhs.val;} il friend bool operator&gt;=(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &gt;= rhs.val;} il friend bool operator&lt;=(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &lt;= rhs.val;} il modint &amp;operator++() { ++val; if (val == mod) val = 0; return *this; } il modint &amp;operator--() { if (val == 0) val = mod; --val; return *this; } il modint operator++(int) { modint ret = *this; ++*this; return ret; } il modint operator--(int) { modint ret = *this; --*this; return ret; } il modint operator+() const {return *this;} il modint operator-() const {return modint() - *this;}};modint qPow(modint base, modint exp) { base.check(); modint ret = 1; for (auto p = exp.val; p; p &gt;&gt;= 1, base *= base) if (p &amp; 1) ret *= base; return ret;}namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void print(modint x) { print(x.val);}template&lt;typename T&gt; il void print(const T &amp;x, const char &amp;c) {print(x), putchar(c);}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}}using namespace fastIO;template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T chkmax(T &amp;a, const T &amp;b) {return a = max(a, b);}template&lt;typename T&gt; il T chkmin(T &amp;a, const T &amp;b) {return a = min(a, b);}template&lt;typename T&gt; il T myabs(const T &amp;a) {return a &gt;= 0 ? a : -a;}template&lt;typename T&gt; il void myswap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}const int maxn = 2005;int n, d, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;modint f[maxn], ans;struct node { int val, id; il bool operator&lt;(const node &amp;rhs) {return val == rhs.val ? id &lt; rhs.id : val &lt; rhs.val;}} a[maxn];il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void dfs(int u, int fa, node rt) { f[u] = 1; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa || a[v] &lt; rt || rt.val + d &lt; a[v].val) continue; dfs(v, u, rt); f[u] *= (f[v] + 1); } return;}int main() { read(d), read(n); FOR(i, 1, n) read(a[i].val), a[i].id = i; FOR(i, 1, n - 1) { int u, v; read(u), read(v); add(u, v), add(v, u); } FOR(i, 1, n) { FOR(j, 1, n) f[i] = 0; dfs(i, 0, a[i]); ans += f[i]; } print(ans, '\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"}]},{"title":"CF1408D Searchlights","slug":"sol-cf1408d","date":"2021-10-24T06:42:18.000Z","updated":"2022-03-23T04:18:30.688Z","comments":true,"path":"sol-cf1408d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1408d/","excerpt":"","text":"Description 给定 n 个点 (a_i, b_i) ，和 m 个探照灯 (c_i, d_i) 。探照灯 j 能看到点 i 当且仅当 a_i\\le c_j\\land b_i\\le d_j 。一次操作可以将所有的 (a_i, b_i) 平移一个单位（沿 x 轴或 y 轴），问最少几次操作后能使得所有的点都不被探照灯发现。 1\\le n,m\\le 2000 ， 0\\le a_i,b_i,c_i,d_i\\le 10^6 。 Solution 我们不妨分开考虑 x 轴和 y 轴，令 f_i 为 x 轴方向上移动 i 格后， y 轴方向上需要的最小移动次数。 然后就 O(nm) 枚举每个点和探照灯，对 f 取后缀 \\max 的同时统计答案即可。 Implementation 1234567891011121314const int maxn = 2005;int a[maxn], b[maxn], c[maxn], d[maxn], n, m, f[1000005];int main() { read(n), read(m); FOR(i, 1, n) read(a[i]), read(b[i]); FOR(i, 1, m) read(c[i]), read(d[i]); FOR(i, 1, n) FOR(j, 1, m) if (c[j] &gt;= a[i]) chkmax(f[c[j] - a[i]], d[j] - b[i] + 1); int ans = 1000001, cur = 0; DEC(i, 1000001, 0) chkmax(cur, f[i]), chkmin(ans, cur + i); print(ans, '\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"P2157 [SDOI2009]学校食堂","slug":"sol-luogu-p2157","date":"2021-10-24T03:03:55.000Z","updated":"2022-03-23T04:18:30.886Z","comments":true,"path":"sol-luogu-p2157/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2157/","excerpt":"","text":"Description 一个打饭队伍，每个人都有一个口味 T_i 和容忍度 B_i ，食堂上一道做 a 口味的饭再做 b 口味的饭的时间是 a\\lor b - a\\land b 。一个同学最多允许紧跟其后的 B_i 个人先拿到饭菜，问最小的做饭时间。 0\\le T_i\\le 1000 ， 1\\le n\\le 1000 ， 0\\le B_i\\le 7 ，最多 5 组数据。 Solution 注意到 7 个人这个神奇的性质，考虑一个状压 f_{i, S, k} 表示 [1, i - 1] 都打完饭了，从当前开始往后最多 7 个人的状态为 S ，最后一个做了 i + k 的饭的最小时间花费。 发现这个状态还是比较靠谱的，因为做饭的间隔绝对不会超过 7 。 然后就要考虑转移了。不妨考虑从 f_{i, S, k} 能转移到的状态： 若 S 中， i 这一位为 1 ，说明这个状态可以直接转移到 f_{i + 1, S &gt;&gt; 1, k - 1} 。 否则我们可以枚举转移的位，然后就可以转移到 f_{i, S', k'} ，时间贡献上去一下。 状态数 1000\\times7\\times2^7 ，转移为 O(B_i) ，毛估估一下可以过。 Implementation 实现的时候需要注意， k\\in[-8, 7] ，所以需要平移一下再存储。 答案为 \\min_k f_{n + 1, 0, k} 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}template&lt;typename T&gt; il void print(const T &amp;x, const char &amp;c) {print(x), putchar(c);}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T myabs(const T &amp;a) {return a &gt;= 0 ? a : -a;}template&lt;typename T&gt; il void myswap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}const int maxn = 1005, INF = 0x3f3f3f3f;int a[maxn], b[maxn], n;int f[maxn][(1 &lt;&lt; 8) | 50][20];il int cost(int i, int j) { if (!i) return 0; else return a[i] ^ a[j];}il void tomin(int &amp;a, int b) { a = min(a, b); return;}void solve() { read(n); FOR(i, 1, n) read(a[i]), read(b[i]); memset(f, 0x3f, sizeof f); f[1][0][7] = 0; FOR(i, 1, n) { FOR(S, 0, (1 &lt;&lt; 8) - 1) { FOR(k, -8, 7) { if (i + k &lt; 0 || i + k &gt; n) continue; if (f[i][S][8 + k] &gt;= INF) continue; int lim = INF; if (S &amp; 1) tomin(f[i + 1][S &gt;&gt; 1][7 + k], f[i][S][8 + k]); else FOR(j, 0, 7) { if (i + j &gt; n || i + j &gt; lim) break; if (S &amp; (1 &lt;&lt; j)) continue; lim = min(lim, i + j + b[i + j]); tomin(f[i][S | (1 &lt;&lt; j)][8 + j], f[i][S][8 + k] + cost(i + k, i + j)); } } } } int ans = INF; FOR(k, -8, 7) tomin(ans, f[n + 1][0][8 + k]); print(ans, '\\n'); return;}int main() { int T; read(T); while (T--) solve(); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4284 [SHOI2014]概率充电器","slug":"sol-luogu-p4284","date":"2021-10-21T13:40:31.000Z","updated":"2022-03-23T04:18:30.984Z","comments":true,"path":"sol-luogu-p4284/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4284/","excerpt":"","text":"Description 一棵树，节点为电子元件，边为导线。每个电子元件有 p_i 的概率自己被充电，每个导线有 q_i 的概率连通。一个元件被充电当且仅当自己被充电或者通过相邻的导线充电。求期望充电的元件个数。 要求 O(n) 。 Solution 相当于求所有元件被充电的概率之和。可惜不能高斯消元，考虑 dp。 既然是个树形 dp，那就先考虑子树内贡献上来的情况。设 f_u 为 u 能被子树中的点充电或者自己被充电的情况。但是会发现不太好转移，那就容斥一下变为不会被点亮的方案，则需要： 儿子节点自身不被充电 或者边是断的 再容斥一下，就得到： f_u = (1 - p_u)\\prod_{(u, v):q}\\left(f_v + (1 - f_v)(1 - q)\\right) 当然这里只考虑了从子树节点贡献上来的情况，我们还有从父亲节点贡献的情况，这个时候只能考虑换根。令 g_u 为 u 的父亲没电传到 u 的概率，则我们有 g_v = h_u + (1 - h_u)\\left(1 - q\\right) 其中， h_u 为 u 不考虑 v 子树的贡献时，没电的概率。由 f 的公式不难得到 h_u = g_u\\times \\frac{f_u}{f_v + (1 - f_v)(1 - q)} 其意义为，首先 u 的父亲不能有电，然后不能考虑 v 的贡献。当分母为 0 时需要特判 h_u = 0 。 最后对于点 u ，其答案就为 1 - f_uh_u 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}template&lt;typename T&gt; il void print(const T &amp;x, const char &amp;c) {print(x), putchar(c);}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T myabs(const T &amp;a) {return a &gt;= 0 ? a : -a;}template&lt;typename T&gt; il void myswap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}using db = double;const int maxn = 5e5 + 5;int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;db q[maxn &lt;&lt; 1], p[maxn];db f[maxn], g[maxn], h[maxn], ans;il void add(int u, int v, db pr) { to[++cnte] = v; nxt[cnte] = head[u]; q[cnte] = pr; head[u] = cnte; return;}void dfs1(int u, int fa) { f[u] = 1 - p[u]; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs1(v, u); f[u] *= (f[v] + (1 - f[v]) * (1 - q[i])); } return;}void dfs2(int u, int fa, int pre) { if (fa) { db h; h = (f[u] + (1 - f[u]) * (1 - q[pre])) &gt; 1e-6 ? g[fa] * f[fa] / (f[u] + (1 - f[u]) * (1 - q[pre])) : 0; g[u] = h + (1 - h) * (1 - q[pre]); } else g[u] = 1; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs2(v, u, i); } return;}int main() { read(n); FOR(i, 1, n - 1) { int u, v, p; read(u), read(v), read(p); add(u, v, p * 0.01), add(v, u, p * 0.01); } FOR(i, 1, n) { int pr; read(pr); p[i] = pr * 0.01; } dfs1(1, 0); dfs2(1, 0, 0); FOR(i, 1, n) ans += 1 - f[i] * g[i]; printf(\"%.6lf\\n\", ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"几种 IO 方式效率的实验","slug":"note-iotest","date":"2021-10-21T09:29:30.000Z","updated":"2022-03-23T04:17:42.180Z","comments":true,"path":"note-iotest/","link":"","permalink":"https://old.blog.imyangty.com/note-iotest/","excerpt":"","text":"前言 CSP 前颓废的成果。本文的目的在于测试出各 IO 方式的效率并进行粗略的比对并选择使用。 控制变量似乎不是很严谨（ 但是能得出大概的结论（ 如果发现有写的不对的地方欢迎直接在评论区 D 我（ 或者加我 QQ 也🉑以。😘 输入效率测试 目前我们考虑读入 10^7 个正整数。 目前大家熟知的读入方式有下面若干种：C 库的 scanf() 函数，std::cin，手写的 getchar() 版本快读以及 fread 版的快读。 一般我们认为，cin 很慢，而 scanf 一般被认为比较快，手写的 fread 版是最快的。但是 cin 有种操作叫做关闭流同步： 123ios::sync_with_stdio(false);cin.tie(NULL); cin 关闭流同步之后的效率如何？getchar() 快读和 scanf() 的效率如何？ 我在本机（Intel Core i5-7200U @2.5Ghz，Windows 10 LTSC，GCC 9.2.0）上进行了如下的测试，得到以下测试结果，其中前十个 testcase 没有启用 -O2，后十个在编译时启用了 -O2 选项，取了平均值后的结果如下（单位为 ms）： case scanf cin cin2 getchar fread avr 9561.3 19845.9 2733.5 3490.7 470.7 avr_O2 9277.3 18647.6 2539.7 3065.2 160.8 可见，在本机的平台下，cin 关闭流同步后竟然有不俗的表现，甚至可以和 getchar 版的快读媲美，但是 fread 吊打一切，在开了 -O2 的情况下更加明显。 随后我在我的另一台电脑（AMD Ryzen 5 2600 @3.40Ghz，Windows 10 LTSC，GCC 4.8.0）上进行了同样的测试，得到下面的结果： case scanf cin cin2 getchar fread avr 5746.9 6426.4 1661.2 1468.7 299 avr_O2 5734.5 6368.8 1639.1 1401.4 98.6 发现在不同的平台上，cin 的效率有所不一，但不关闭流同步时必然慢于 scanf，但关闭流同步后表现十分良好，速度相当快，但是时间仍为 fread 的五倍以上。 接下来在虚拟机内的 NOI Linux 2.0 内进行测试，编译器为 GCC 9.3.0，得到下面的结果（单位 s）： case scanf cin cin2 getchar fread avr 1.5291 2.8893 0.675 0.5305 0.8525 avr_O2 0.9605 2.5989 0.5905 0.2427 0.0863 然后惊奇的发现，fread 居然比 cin 关流同步后还慢（可能是虚拟机的锅）???但是开 -O2 之后仍旧吊打全场。 综上，我们有以下结论： 不同平台/编译器版本下，各种读入方式的效率会有微小的差异。 千万不要用不关流同步的 cin，相当的慢。 IO 量不是特别大的时候可以使用 scanf，当然关流同步的 cin 会有更优的表现。 IO 量十分巨大的时候可以考虑 cin 关流同步或者 fread 版快读。 输出效率测试 考虑输出 10^7 个正整数，我们一般使用 printf，cout，putchar 或者 fwrite 等方式，类似上面的，我们先用本机测试（单位 ms）： case printf cout cout_endl putchar fwrite avr 4101.7 1724.4 35893.1 3432.5 3080.6 avr_O2 3684.5 1463.5 31412.1 3046.3 2644.3 其中 cout_endl 是每输出一个数字用 endl 换行。可以发现几种输出方式的效率差别不是特别大，但是由于 endl 每次会刷新缓冲区，所以会非常的慢，所以需要避免 cout &lt;&lt; n &lt;&lt; endl 这种写法。 同样附上 AMD 的测试结果： case printf cout cout_endl putchar fwrite avr 16860.8 1035.9 40743.6 1709.7 1584.7 avr_O2 16645.8 990 39787.3 1516.3 1359.9 可见不同平台的差异还是存在的。但 cout 的速度依旧可观。 case printf cout cout_endl putchar fwrite avr 814.5 933.6 15801 1007.7 957.5 avr_O2 830.2 945.3 16029.3 476.4 442.6 结论： 部分平台上 printf 的表现并不是很好。 与 cin 相反，**cout 很快。**比想象中的快。 fwrite 并无特别明显的优势，但开了 -O2 之后效率会有所提升。 后记 这个不是很严谨的小实验告诉了我们在 IO 量极其巨大的时候各种 IO 方式的效率差别。但需要注意的是，当数据规模在十万级别及以下时，IO 常数并不是瓶颈，其运行时间都差不多，只需记住不要使用不关闭流同步的 cin 和 endl 即可。 附自己的 IO 模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}template&lt;typename T&gt; il void print(const T &amp;x, const char &amp;c) {print(x), putchar(c);}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T myabs(const T &amp;a) {return a &gt;= 0 ? a : -a;}template&lt;typename T&gt; il void myswap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}int main() { return output(), 0;} 附 1：完整测试结果 本机 i5 Intel Core i5-7200U @2.5Ghz，Windows 10 LTSC。 读入测试： case printf cout cout_endl putchar fwrite 1 3314 1480 36724 3870 3984 2 3547 1688 38312 2971 3240 3 3825 1542 35739 3720 3022 4 5375 1685 35577 3387 2600 5 4626 1857 32677 3168 2497 6 3705 1582 32974 3725 2796 7 4214 2192 36730 4043 2793 8 3777 1615 37561 3217 3505 9 4650 1507 36534 3287 3079 10 3984 2096 36103 2937 3290 11 3773 1444 31294 3062 2546 12 3599 1456 32554 2825 3408 13 3804 1609 33589 3048 2495 14 3598 1434 30778 3090 2499 15 3710 1449 31659 3153 2476 16 3638 1445 30739 3045 2619 17 3816 1475 30838 3063 2509 18 3588 1437 30844 3045 2501 19 3591 1443 30862 3071 2861 20 3728 1443 30964 3061 2529 avr 4101.7 1724.4 35893.1 3432.5 3080.6 avr_O2 3684.5 1463.5 31412.1 3046.3 2644.3 AMD R5 2600 AMD R5 2600 @3.40Ghz，Windows 10 LTSC。 输入测试： case scanf cin cin2 getchar fread 1 5755 6403 1654 1469 298 2 5725 6441 1651 1467 301 3 5740 6452 1661 1472 301 4 5749 6435 1670 1484 298 5 5739 6437 1671 1471 299 6 5761 6428 1661 1474 298 7 5769 6424 1660 1463 297 8 5761 6429 1662 1461 301 9 5735 6395 1668 1464 295 10 5735 6420 1654 1462 302 11 5781 6388 1658 1403 99 12 5725 6379 1641 1397 99 13 5725 6342 1636 1401 98 14 5727 6335 1634 1405 99 15 5778 6354 1630 1400 98 16 5700 6388 1635 1401 98 17 5750 6368 1639 1401 99 18 5731 6372 1638 1404 99 19 5715 6386 1642 1406 99 20 5713 6376 1638 1396 98 avr 5746.9 6426.4 1661.2 1468.7 299 avr_O2 5734.5 6368.8 1639.1 1401.4 98.6 输出测试： case printf cout cout_endl putchar fwrite 1 16545 1004 39836 1693 1594 2 16756 1044 40895 1695 1581 3 16820 1032 40841 1692 1565 4 16655 1014 40853 1737 1593 5 17147 1078 41379 1736 1599 6 16965 1065 41250 1749 1608 7 17099 1048 40937 1712 1586 8 16981 1021 40266 1698 1568 9 16814 1016 40719 1712 1590 10 16826 1037 40460 1673 1563 11 16470 994 39597 1513 1356 12 16584 1009 39748 1511 1365 13 16669 996 40008 1529 1362 14 16725 1002 39792 1515 1352 15 16647 997 39718 1509 1368 16 16654 979 39874 1512 1355 17 16628 1000 39667 1514 1354 18 16660 968 39887 1533 1369 19 16643 987 39732 1514 1362 20 16778 968 39850 1513 1356 avr 16860.8 1035.9 40743.6 1709.7 1584.7 avr_O2 16645.8 990 39787.3 1516.3 1359.9 虚拟机 NOI Linux 2.0 输入测试： case scanf cin cin2 getchar fread 1 1.554 2.897 0.677 0.532 0.856 2 1.523 2.91 0.674 0.531 0.851 3 1.498 2.947 0.675 0.527 0.852 4 1.51 2.839 0.674 0.532 0.854 5 1.526 2.899 0.676 0.532 0.852 6 1.55 2.896 0.675 0.533 0.852 7 1.553 2.86 0.675 0.525 0.853 8 1.496 2.935 0.675 0.529 0.852 9 1.545 2.836 0.673 0.532 0.852 10 1.536 2.874 0.676 0.532 0.851 11 0.957 2.656 0.59 0.242 0.086 12 0.966 2.613 0.588 0.243 0.087 13 0.954 2.547 0.591 0.243 0.086 14 0.948 2.546 0.588 0.242 0.086 15 0.968 2.564 0.588 0.242 0.086 16 0.942 2.549 0.593 0.243 0.086 17 0.993 2.61 0.59 0.243 0.086 18 0.945 2.611 0.591 0.243 0.086 19 0.955 2.621 0.593 0.243 0.087 20 0.977 2.672 0.593 0.243 0.087 avr 1.5291 2.8893 0.675 0.5305 0.8525 avr_O2 0.9605 2.5989 0.5905 0.2427 0.0863 输出测试： case printf cout cout_endl putchar fwrite 1 858 924 15804 988 946 2 811 929 15878 1007 970 3 831 942 15617 1007 977 4 815 927 15745 1016 945 5 741 925 16205 990 948 6 818 931 15274 1040 956 7 790 931 15607 1014 965 8 864 926 15554 1001 957 9 824 950 15842 1007 954 10 793 951 16484 1007 957 11 792 949 16338 483 456 12 854 969 15373 467 445 13 845 992 16049 472 440 14 796 923 15824 478 443 15 878 960 16087 474 437 16 817 936 16525 485 449 17 800 941 15988 474 438 18 845 934 15650 466 435 19 836 901 15754 476 434 20 839 948 16705 489 449 avr 814.5 933.6 15801 1007.7 957.5 avr_O2 830.2 945.3 16029.3 476.4 442.6 附 2：测试代码 输入效率测试 IOtest.cpp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define il inlineconst int maxn = 1e7 + 5, N = 1e7;int a[maxn];void gen() { freopen(\"io.in\", \"w\", stdout); for (int i = 1; i &lt;= N; ++i) printf(\"%d\\n\", i); fclose(stdout);}int read1() { char c = getchar(); int n = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); return n;}clock_t getcharread() { clock_t st = clock(); for (int i = 1; i &lt;= N; i++) a[i] = read1(); clock_t ed = clock(); return ed - st;}clock_t scanfread() { clock_t st = clock(); for (int i = 1; i &lt;= N; i++) scanf(\"%d\", a + i); clock_t ed = clock(); return ed - st;}clock_t cinread() { clock_t st = clock(); for (int i = 1; i &lt;= N; i++) std::cin &gt;&gt; a[i]; clock_t ed = clock(); return ed - st;}clock_t cinread2() { std::ios::sync_with_stdio(false); std::cin.tie(NULL); clock_t st = clock(); for (int i = 1; i &lt;= N; i++) std::cin &gt;&gt; a[i]; clock_t ed = clock(); return ed - st;}namespace fastIO {const int maxc = 1 &lt;&lt; 26;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}}clock_t freadread() { using namespace fastIO; clock_t st = clock(); for (int i = 1; i &lt;= N; i++) read(a[i]); clock_t ed = clock(); return ed - st;}void flush() { fclose(stdin); freopen(\"io.in\", \"r\", stdin); return;}int main() { freopen(\"iotmp.txt\", \"w\", stdout); flush(), printf(\"%ld\\t\", scanfread()); flush(), printf(\"%ld\\t\", cinread()); flush(), printf(\"%ld\\t\", cinread2()); flush(), printf(\"%ld\\t\", getcharread()); flush(), printf(\"%ld\\n\", freadread());} IOtest2.cpp： 1234567891011121314151617#include &lt;bits/stdc++.h&gt;int main() { freopen(\"iotest.csv\", \"w\", stdout); printf(\"case,scanf,cin,cin2,getchar,fread\\n\"); for (int i = 1; i &lt;= 10; ++i) { system(\"IOtest.exe\"); freopen(\"iotmp.txt\", \"r\", stdin); printf(\"%d,\", i); for (int j = 1, tmp; j &lt;= 5; ++j) { scanf(\"%d\", &amp;tmp); printf(\"%d%c\", tmp, j == 5 ? '\\n' : ','); } fclose(stdin); }} 输出效率测试 IOtest.cpp： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;#define il inlineconst int maxn = 1e7 + 5, N = 1e7;int a[maxn];void gen() { freopen(\"io.in\", \"w\", stdout); for (int i = 1; i &lt;= N; ++i) printf(\"%d\\n\", i); fclose(stdout);}clock_t printf() { freopen(\"io.out\", \"w\", stdout); clock_t st = clock(); for (int i = 1; i &lt;= N; ++i) printf(\"%d\\n\", i); clock_t ed = clock(); fclose(stdout); return ed - st;}clock_t cout() { freopen(\"io.out\", \"w\", stdout); clock_t st = clock(); for (int i = 1; i &lt;= N; ++i) std::cout &lt;&lt; i &lt;&lt; '\\n'; clock_t ed = clock(); fclose(stdout); return ed - st;}clock_t cout_endl() { freopen(\"io.out\", \"w\", stdout); clock_t st = clock(); for (int i = 1; i &lt;= N; ++i) std::cout &lt;&lt; i &lt;&lt; std::endl; clock_t ed = clock(); fclose(stdout); return ed - st;}void print(int x) { if (x &gt;= 10) print(x / 10); putchar(x % 10 + '0'); return;}clock_t putchar() { freopen(\"io.out\", \"w\", stdout); clock_t st = clock(); for (int i = 1; i &lt;= N; ++i) print(i), putchar('\\n'); clock_t ed = clock(); fclose(stdout); return ed - st;}namespace fastIO {char obuf[1 &lt;&lt; 26], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}}clock_t fastio() { freopen(\"io.out\", \"w\", stdout); freopen(\"io.out\", \"w\", stdout); using namespace fastIO; clock_t st = clock(); for (int i = 1; i &lt;= N; ++i) print(i), putchar('\\n'); output(); clock_t ed = clock(); fclose(stdout); return ed - st;}int main() { clock_t a[6]; a[1] = printf(); a[2] = cout(); a[3] = cout_endl(); a[4] = putchar(); a[5] = fastio(); freopen(\"iotmp.txt\", \"w\", stdout); for (int i = 1; i &lt;= 5; ++i) printf(\"%d\\n\", a[i]); return 0;} IOtest2.cpp 1234567891011121314151617#include &lt;bits/stdc++.h&gt;int main() { freopen(\"iotest.csv\", \"w\", stdout); printf(\"case,printf,cout,cout_endl,putchar,fwrite\\n\"); for (int i = 1; i &lt;= 10; ++i) { system(\"IOtest.exe\"); freopen(\"iotmp.txt\", \"r\", stdin); printf(\"%d,\", i); for (int j = 1, tmp; j &lt;= 5; ++j) { scanf(\"%d\", &amp;tmp); printf(\"%d%c\", tmp, j == 5 ? '\\n' : ','); } fclose(stdin); }}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"}]},{"title":"P3305 [SDOI2013]费用流","slug":"sol-luogu-p3305","date":"2021-10-10T14:08:21.000Z","updated":"2022-03-23T04:18:30.947Z","comments":true,"path":"sol-luogu-p3305/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3305/","excerpt":"","text":"Description 给定一张网络，Alice 先选择一种最大流方案，Bob 给每条边定单位费用，要求每条边单位费用之和为 P 。 Alice 希望费用最小，Bob 希望费用最大。Bob 在定费用的时候已经知道 Alice 的方案。 如果两人都足够聪明，求网络的最大流和费用。 Solution 我们知道，如果 Bob 已经知道了流的方案，有个很显然的贪心就是他肯定会往流量最大的边分配所有的费用。 证明：设往最大流量 F_1 的边分配 r\\times P 的费用，往次大流量 F_2 的边分配 (1 - r)\\times P 的费用，则总费用为 P(rF_1 + (1 - r)F_2) 显然 r =1 时全式取最大值。 所以要让流量最大的边尽可能最小。这怎么做？二分答案跑最大流。 但是有个问题就是这个流量他不一定是整数，还有可能是实数，所以我们二分的时候要二分出一个实数来，注意一下精度问题。 Implementation 二分上界的地方要加上一个小小的 eps 防止永远搜不出答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)#define il inlinenamespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}}// namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int maxn = 105, maxm = 1005;using ll = long long;using db = double;const ll INF = 1e18;struct edge { int to, nxt; db w;} e[maxm &lt;&lt; 1];int head[maxn], dep[maxn], cur[maxn], cnt = 1;int s, t;il void add(int u, int v, db w) { e[++cnt].to = v; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].w = 0; e[cnt].nxt = head[v]; head[v] = cnt; return;}bool bfs() { static int q[maxn], qhead, qtail; memset(dep, -1, sizeof dep); memcpy(cur, head, sizeof head); q[qhead = qtail = 1] = s; dep[s] = 0; while (qhead &lt;= qtail) { int u = q[qhead++]; GO(u, head) { if (e[i].w &gt; 1e-7 &amp;&amp; dep[v] == -1) { q[++qtail] = v; dep[v] = dep[u] + 1; if (v == t) return true; } } } return false;}db dfs(int u, db in) { if (u == t) return in; db out = 0; GO(u, cur) { cur[u] = i; if (e[i].w &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) { db res = dfs(v, min(in, e[i].w)); e[i].w -= res, e[i ^ 1].w += res; in -= res, out += res; } if (!in) break; } if (!out) dep[u] = -1; return out;}db dinic() { db ret = 0; while (bfs()) ret += dfs(s, INF); return ret;}int n, m, P;struct E { int u, v, w;} e0[maxm];void build(db mid = INF) { cnt = 1, s = 1, t = n; memset(head, 0, sizeof head); FOR(i, 1, m) add(e0[i].u, e0[i].v, min((db)e0[i].w, mid)); return;}template&lt;typename T&gt; il T myabs(const T &amp;a) {return a &gt;= 0 ? a : -a;}int main() { read(n), read(m), read(P); FOR(i, 1, m) read(e0[i].u), read(e0[i].v), read(e0[i].w); build(); int flow = (int)dinic(); printf(\"%d\\n\", flow); db l = 0, r = flow + 1e-5, ans; while (r - l &gt; 1e-7) { db mid = (l + r) / 2; build(mid); if (myabs(dinic() - (db)flow) &lt;= 1e-6) ans = mid, r = mid; else l = mid; } printf(\"%.4lf\\n\", ans * P); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最大流","slug":"maxflow","permalink":"https://old.blog.imyangty.com/tags/maxflow/"}]},{"title":"P6810 「MCOI-02」Convex Hull 凸包","slug":"sol-luogu-p6810","date":"2021-10-10T12:19:36.000Z","updated":"2022-03-23T06:40:10.535Z","comments":true,"path":"sol-luogu-p6810/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p6810/","excerpt":"","text":"Description 给定 1\\le n, m\\le 2\\times 10^6 ， 1\\le p\\le 10^9 ，求 \\sum_{i = 1}^n\\sum_{j = 1}^m\\tau(i)\\tau(j)\\tau(\\gcd(i, j)) 对 p 取模的值。其中 \\tau(i) 代表约数个数。 Solution 可以直接考虑 \\tau(\\gcd(i, j)) 的意义然后暴力做。。 下面假设 n\\ge m 。 \\begin{aligned} &amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\tau(i)\\tau(j)\\tau(\\gcd(i, j))\\\\ =&amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\tau(i)\\tau(j)\\sum_{k\\mid i\\land k\\mid j}1\\\\ =&amp;\\sum_{k = 1}^n\\sum_{k\\mid i\\land i \\le n}\\tau(i)\\sum_{k\\mid j\\land j \\le m}\\tau(j) \\end{aligned} 令 f_n(k) = \\sum_{k\\mid i\\land i\\le n}\\tau(i) 则原式为 \\sum_{k = 1}^n f_n(k)f_m(k) O(n\\log n) 计算所有 \\tau(i) ，然后 O(n\\log n) 计算所有 f_n(k) 和 f_m(k) 足以通过本题。 Implementation 12345678910111213141516171819const int maxn = 2e6 + 5;int n, m, tau[maxn];modint calc(int n, int k) { modint ret = 0; for (int i = k; i &lt;= n; i += k) ret += tau[i]; return ret;}int main() { read(n), read(m), read(mod); if (n &lt; m) {int t = n; n = m; m = t;} FOR(i, 1, n) for (int j = i; j &lt;= n; j += i) ++tau[j]; modint ans = 0; FOR(i, 1, n) ans += calc(n, i) * calc(m, i); print(ans, '\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"莫比乌斯反演","slug":"mobius-inversion","permalink":"https://old.blog.imyangty.com/tags/mobius-inversion/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"}]},{"title":"P5495 Dirichlet 前缀和","slug":"sol-luogu-p5495","date":"2021-10-10T11:38:45.000Z","updated":"2022-03-23T04:18:31.022Z","comments":true,"path":"sol-luogu-p5495/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5495/","excerpt":"","text":"Description 给定 \\{a_n\\} ，求 \\{b_n\\} 满足 b_i = \\sum_{k\\mid i}a_k\\bmod 2^{32} 输出 \\bigoplus_{i = 1}^nb_i 。 Solution 令 i = \\prod p_k^{\\alpha_k} ， j = \\prod_k p_k^{\\beta_k} ，则 a_i 能贡献到 b_j 当且仅当 \\forall k, \\alpha_k \\le \\beta_k 。所以我们其实是在对质因子的指数做一个高维前缀和。类似埃氏筛，复杂度 O(n\\log\\log n) 。 这个东西和 FWT 很像。 Implementation 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using uint = unsigned;uint seed;inline uint getnext() { seed ^= seed &lt;&lt; 13; seed ^= seed &gt;&gt; 17; seed ^= seed &lt;&lt; 5; return seed;}const int maxn = 2e7 + 5;int p[maxn], tot, isp[maxn], n;uint a[maxn];int main() { scanf(\"%d %u\", &amp;n, &amp;seed); FOR(i, 1, n) a[i] = getnext(); FOR(i, 2, n) { if (!isp[i]) p[++tot] = i; for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j) { isp[i * p[j]] = 1; if (i % p[j] == 0) break; } } FOR(j, 1, tot) for (int i = 1; i * p[j] &lt;= n; ++i) a[i * p[j]] += a[i]; uint ans = 0; FOR(i, 1, n) ans ^= a[i]; printf(\"%u\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"高维前缀和","slug":"sosdp","permalink":"https://old.blog.imyangty.com/tags/sosdp/"}]},{"title":"计算几何全家桶","slug":"note-geometry","date":"2021-10-08T13:24:49.000Z","updated":"2022-03-23T04:17:42.173Z","comments":true,"path":"note-geometry/","link":"","permalink":"https://old.blog.imyangty.com/note-geometry/","excerpt":"","text":"前言 最近模拟赛好像比较爱考😢有点虚。毕竟在 NOI 大纲上的等级比较低。 计算几何还是比较烦的一个东西。如果以后打 ICPC 的话还是需要会点的。 先考虑二维计算几何。三维是甚么毒瘤东西 基本定义 一些约定 类型名和宏 12345678#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (b); i &gt;= (a); --i)#define il inlineusing db = double;using ll = long long;using ldb = long double; 浮点误差相关。由于计算几何涉及浮点运算较多，故我们需要减少浮点误差对答案正确性造成的影响。 123const db EPS = 1e-8;int sgn(db x) {return fabs(x) &lt; EPS ? 0 : (x &gt; 0 ? 1 : -1);} 点和向量 我们知道一个有序实数对可以表示点的坐标，同样对于向量也适用。所以我们存储点的方式和向量的方式其实是一样的。 1234567struct Point { db x, y; Point(db _x = 0, db _y = 0) : x(_x), y(_y) {}};using Vector = Point; 向量的加减法，数乘等基本运算先写在这里。 12345Vector operator+(const Vector &amp;a, const Vector &amp;b) {return Vector(a.x + b.x, a.y + b.y);}Vector operator-(const Vector &amp;a, const Vector &amp;b) {return Vector(a.x - b.x, a.y - b.y);}Vector operator*(const Vector &amp;a, const db &amp;lambda) {return Vector(lambda * a.x, lambda * a.y);}Vector operator/(const Vector &amp;a, const db &amp;lambda) {return Vector(lambda / a.x, lambda / a.y);} 其他对象的存储 线段：存储两个端点。 直线：计算甚么的会带来较大的误差，因此保存直线上一点和其方向向量就可以了。 多边形：一般逆时针记录各个顶点。 圆：记录圆心和半径。 特殊曲线：记解析式甚么的。 基本操作 前置公式 正弦定理： \\frac{a}{\\sin A} = \\frac{b}{\\sin B} = \\frac{c}{\\sin C} = 2R 余弦定理： a^2 = b^2 + c^2 - 2bc\\cos A 和角公式/倍角公式以及他们的变形等等： \\sin(\\alpha \\pm \\beta) = \\sin\\alpha\\cos\\beta \\pm \\cos\\alpha\\sin\\beta\\\\ \\cos(\\alpha\\pm\\beta) = \\cos\\alpha\\cos\\beta \\mp \\sin\\alpha\\sin\\beta\\\\ 学好文化课里的这部分还是挺有帮助的。 向量的进阶操作 点积类比做功。 12db operator*(const Vector &amp;a, const Vector &amp;b) {return a.x * b.x + a.y * b.y;} 叉积的一个几何意义是平四有向面积。 12db operator^(const Vector &amp;a, const Vector &amp;b) {return a.x * b.y - a.y * b.x;} 应用： 若两向量的点积为正，则两向量夹角小于 \\dfrac\\pi2 ，若点积为 0 ，则两向量垂直，否则夹角大于 \\dfrac\\pi2 。 \\mathbf a\\times \\mathbf b 的正负性可以判断两个向量的方向位置关系。若其大于 0 ，则 \\mathbf b 在 \\mathbf a 左侧，反之亦然。记忆考虑右手螺旋即可。 向量的旋转。套一个和角公式。 (x, y) 经过旋转 \\theta 之后会得到 (x\\cos\\theta-y\\sin\\theta, x\\sin\\theta + y\\cos\\theta) 。记不住的话大可以现推。 极角 使用 atan2(x, y) 函数来求极角，这样可以在 x=0 时返回正确的结果。 极角排序非常有用。 计算多边形面积 先考虑三角形的情况。我们知道对于一个三角形 OAB ， S_{\\triangle OAB} = \\dfrac12\\overrightarrow{OA}\\times\\overrightarrow{OB} 。这东西可以拿来氵文化课题 所以计算三角形的面积是很简单的。直接坐标相减再叉乘一下就出来了。 整点三角形面积的两倍一定为整数。 咕。 点和线段的位置关系 线段与线段相交 凸包 旋转卡壳 半平面交 Pick 定理 三维计算几何 叉积 现在两个向量叉乘出来还是一个向量 (x_1, y_1, z_1)\\times(x_2,y_2, z_2) = (y_1z_2 - y_2z_1, z_1x_2 - z_2x_1, x_1y_2 - x_2y_1) 实质上为 \\begin{vmatrix} \\vec{i} &amp; \\vec{j} &amp; \\vec{k}\\\\ x_1 &amp; y_1 &amp; z_1\\\\ x_2 &amp; y_2 &amp; z_2 \\end{vmatrix} 把这个行列式打开来就能得到上面的结果。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"计算几何","slug":"computational-geometry","permalink":"https://old.blog.imyangty.com/tags/computational-geometry/"},{"name":"凸包","slug":"convex-hull","permalink":"https://old.blog.imyangty.com/tags/convex-hull/"}]},{"title":"LOJ#2874. 「JOISC 2014 Day1」历史研究","slug":"sol-loj2874","date":"2021-10-06T09:21:31.000Z","updated":"2022-03-23T04:18:30.781Z","comments":true,"path":"sol-loj2874/","link":"","permalink":"https://old.blog.imyangty.com/sol-loj2874/","excerpt":"","text":"Description 定义一段区间的加权众数为一个数字乘上其出现次数的最大值。 10^5 次询问区间加权众数。 Solution 莫队可以做区间众数我们是知道的。 但是这个题的众数带权，莫队的删除操作非常不好实现。这个时候就需要一个叫回滚莫队的科技，使得我们没有删除操作： 将每个询问按以左端点所在块为第一关键字，右端点所在块为第二关键字排序。 按顺序处理询问： 如果左端点的块 B 与上一个询问的左端点的块不同，那么将莫队左端点初始化为 B 的右端点加 1 ，右端点初始化为 B 的右端点。 如果询问的左右端点在同一块内， O(\\sqrt n) 暴力。 如果询问的左右端点所在块不同： 如果询问的右端点大于莫队区间的右端点，扩展莫队的右端点。 扩展莫队的左端点。 回答询问。 撤销左端点的改动，回滚到 B 的右端点加 1 。 分析一下复杂度：设左右端点在一个块内有 C_1 次，不在一个块内有 C_2 次。 不难得到回答第一类询问的复杂度为 O(C_1\\sqrt n) 。 考虑对于左端点在一个块内的一类询问，假设有 x 次： 莫队右端点扩展 O(n) 次。 左端点每次扩展 \\sqrt n 次。 故一类询问的复杂度为 O(n + x\\sqrt n) 。 所以总复杂度为 O(C_1\\sqrt n) + O(n\\sqrt n + C_2\\sqrt n) = O((n+ m)\\sqrt n) 。 这告诉我们，回滚莫队的时间复杂度是对的。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(const T &amp;x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}template&lt;typename T&gt; il void print(const T &amp;x, const char &amp;c) {print(x), putchar(c);}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}using ll = long long;const int maxn = 1e5 + 5;int bel[maxn], n, m, tot, lpos[maxn], rpos[maxn];ll val[maxn], a[maxn], ans[maxn], cnt[maxn], cnt2[maxn];struct node { int l, r, id;} q[maxn];il bool cmp(const node &amp;a, const node &amp;b) { if (bel[a.l] ^ bel[b.l]) return bel[a.l] &lt; bel[b.l]; return a.r &lt; b.r;}void del(int x) {--cnt[a[x]];}void insert(int x, ll &amp;now) {now = max(now, (++cnt[a[x]]) * val[a[x]]);}int main() { read(n), read(m); FOR(i, 1, n) read(val[i]), a[i] = val[i]; std::sort(val + 1, val + n + 1); tot = std::unique(val + 1, val + n + 1) - val - 1; FOR(i, 1, n) a[i] = std::lower_bound(val + 1, val + tot + 1, a[i]) - val; int block = sqrt(n), T = n / block; FOR(i, 1, T) { if (i * block &gt; n) break; lpos[i] = (i - 1) * block + 1; rpos[i] = i * block; } if (rpos[T] &lt; n) ++T, lpos[T] = rpos[T - 1] + 1, rpos[T] = n; FOR(j, 1, T) FOR(i, lpos[j], rpos[j]) bel[i] = j; FOR(i, 1, m) read(q[i].l), read(q[i].r), q[i].id = i; std::sort(q + 1, q + m + 1, cmp); int nowblock = 0, l = 1, r = 0; ll nowans; FOR(i, 1, m) { if (bel[q[i].l] == bel[q[i].r]) { FOR(j, q[i].l, q[i].r) ++cnt2[a[j]]; ll res = 0; FOR(j, q[i].l, q[i].r) res = max(res, cnt2[a[j]] * val[a[j]]); FOR(j, q[i].l, q[i].r) --cnt2[a[j]]; ans[q[i].id] = res; continue; } if (bel[q[i].l] ^ nowblock) { while (r &gt; rpos[bel[q[i].l]]) del(r--); while (l &lt; rpos[bel[q[i].l]] + 1) del(l++); nowans = 0, nowblock = bel[q[i].l]; } while (r &lt; q[i].r) insert(++r, nowans); ll tmp = nowans; int _l = l; while (_l &gt; q[i].l) insert(--_l, tmp); ans[q[i].id] = tmp; while (_l &lt; l) del(_l++); } FOR(i, 1, m) print(ans[i], '\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"分块","slug":"block","permalink":"https://old.blog.imyangty.com/tags/block/"},{"name":"LOJ","slug":"LOJ","permalink":"https://old.blog.imyangty.com/tags/LOJ/"},{"name":"莫队","slug":"mo-algo","permalink":"https://old.blog.imyangty.com/tags/mo-algo/"}]},{"title":"P3175 [HAOI2015]按位或","slug":"sol-luogu-p3175","date":"2021-10-06T02:58:12.000Z","updated":"2022-03-23T04:18:30.930Z","comments":true,"path":"sol-luogu-p3175/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3175/","excerpt":"","text":"Description 一开始有数字 0 ，每秒随机选一个 [0, 2^n - 1] 的数字然后按位或上去，选择 i 的概率为 p_i ，问期望多少秒后变成 2^n - 1 。 Solution 拆开每一位。设 x_k 为第 k 位变为 1 的时间，则我们要求的就是 E(\\max(X)) 。这个东西似乎不太好求，我们考虑 min-max 容斥一下，变为求每个 S\\subseteq X 的 E(\\min(S)) 。 令 p(T) 为选中 T 子集的概率。现在我们要求 E(\\min(S)) ，相当于就是 S 中至少出现一位的期望步数。有 E(\\min(S)) = 1 + \\sum_{T\\cap S = \\varnothing} p(T)E(\\min(S)) 意义就是如果没选到与 S 有交的集合，那么就还需要付出 E(\\min(S)) 的代价。所以 E(\\min(S)) = \\frac{1}{1 - \\sum_{T\\cap S = \\varnothing}p(T)} 现在需要求出所有 T 的 p(T) ，FWT-OR 碾过去做个子集求和即可。 Implementation 意外的好写。 1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)const int maxn = 1 &lt;&lt; 20;using db = double;db p[maxn];int n, cnt[maxn];int main() { scanf(\"%d\", &amp;n); n = (1 &lt;&lt; n); FOR(i, 0, n - 1) scanf(\"%lf\", p + i); for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) p[i + j + k] += p[i + j]; db ans = 0; FOR(i, 1, n - 1) { cnt[i] = cnt[i &gt;&gt; 1] + (i &amp; 1); db tmp = 1 - p[i ^ (n - 1)]; if (tmp &lt; 1e-8) return puts(\"INF\"), 0; ans += ((cnt[i] &amp; 1) ? 1 : -1) * 1.0 / tmp; } printf(\"%lf\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"FWT","slug":"FWT","permalink":"https://old.blog.imyangty.com/tags/FWT/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"min-max容斥","slug":"min-max","permalink":"https://old.blog.imyangty.com/tags/min-max/"}]},{"title":"组合数学复习笔记","slug":"summary-combinatorics","date":"2021-10-03T06:34:00.000Z","updated":"2022-03-23T04:19:24.374Z","comments":true,"path":"summary-combinatorics/","link":"","permalink":"https://old.blog.imyangty.com/summary-combinatorics/","excerpt":"","text":"总结笔记。组合算是一个比较重要的大头。不包看懂，前置知识可能有点多。 如有错漏烦请指正，当感激不尽/kel。 加乘原理 排列组合 定义 n 个有标号元素里面选 m 个排成一排的方案数： \\mathrm A_n^m ，称为排列数，有 \\mathrm A_n^m = \\frac{n!}{(n - m)!} 平凡，不证。 n 个有标号元素里面选 m 个的方案数： \\mathrm C_n^m ，或者记作 \\dbinom n m ，称为组合数，有 \\binom n m = \\frac{\\mathrm A_n^m}{m!} = \\frac{n!}{m!(n - m)!} 相当于去掉 m 的全排列的方案数。 二项式定理 (x + y)^n = \\sum_{k = 0}^n\\binom n kx^ky^{n - k} 组合意义平凡。 x 和 y 取到特殊值时会有奇怪的推广。 \\sum_{k = 0}^n\\binom n k = 2^n \\sum_{k = 0}^n(-1)^k\\binom n k = [n = 0] 组合恒等式 \\binom n k = \\binom{n}{n - k} 组合意义易得。 \\binom n k = \\frac n k \\binom {n - 1}{k - 1} 拆成阶乘形式易得。 \\binom{n}{k} = \\binom{n - 1}{k} + \\binom{n - 1}{k - 1} 考虑钦定一个元素，如果我们现在才选，那么就有 \\dbinom{n - 1}{k - 1} 种方案，如果我们没有选，那么就是 \\dbinom{n -1}{k} 。 \\sum_{k = 0}^kk\\binom n k = n2^{n - 1} 用第二个式子把 k 提掉之后二项式定理可证。 \\binom n r \\binom r k = \\binom n k \\binom{n - k}{r - k} 证明：拆成阶乘的形式易证。组合意义也比较好想。 范德蒙德卷积的推论： \\sum_{k = 0}^r\\binom n k \\binom{m}{r - k} = \\binom{n + m}{r} 证明：考虑组合意义， n + m 中选 r 个可以钦定成在前 n 个里面选 k 个和在后 m 里面选 r - k 个。同时我们也有 (1 + x)^{n + m} = (1 + x)^n(1 + x)^m 。考虑 [x^k](1 + x)^{n + m} 即可。 \\sum_{k = 0}^m\\binom m k \\binom n k = \\sum_{k = 0}^m\\binom{m}{m - k}\\binom n k = \\binom{m + n}{m} 证明：结合 1 式， 5 式和 6 式可证： \\sum_{k = 0}^m\\binom m k\\binom n k = \\sum_{k = 0}^m\\binom{m}{m - k}\\binom{n}{k} = \\sum_{k = 0}^m\\binom{n + m}{m} 上指标求和 \\sum_{k = 0}^n\\binom{k}{m} = \\binom{n + 1}{m + 1} 证明：组合意义：从 \\{0, 1, \\cdots, n\\} 中选出 m + 1 个数，选中的最大数为 k 的方案数为 \\dbinom k m 。 多项式系数 \\binom{n}{n_1, n_2,\\cdots, n_t} 其定义为多项式 (x_1 + x_2 + \\cdots + x_t)^n 中 x_1^{n_1}x_2^{n_2}\\cdots x_t^{n_t} 的系数。 n 个不同的球放进 t 个不同盒子里使得第 i 个盒子有 n_i 个球的方案数。 \\binom{n}{n_1, n_2,\\cdots, n_t} = \\binom{n}{n_1}\\binom{n - n_1}{n_2}\\cdots\\binom{n_t}{n_t} 把组合数拆成阶乘的形式即可得到 \\binom{n}{n_1,\\cdots, n_t} = \\frac{n!}{n_1!n_2!\\cdots n_t!} 递推： \\binom{n}{n_1,\\cdots,n_t} = \\binom{n - 1}{n_1 - 1, n_2,\\cdots, n_t} + \\binom{n - 1}{n_1, n_2 - 1,\\cdots, n_t} + \\binom{n - 1}{n_1, \\cdots,n_t - 1} 和组合数的递推类似。 容斥原理 基本计数应用 经典问题 1：错位排列 例题 1：P5824 十二重计数法（部分）给定 n 个球和 m 个盒子。 I：球之间互不相同，盒子之间互不相同。 II：球之间互不相同，盒子之间互不相同，每个盒子至多装一个球。 III：球之间互不相同，盒子之间互不相同，每个盒子至少装一个球。 VII：球全部相同，盒子之间互不相同。 VIII：球全部相同，盒子之间互不相同，每个盒子至多装一个球。 IX：球全部相同，盒子之间互不相同，每个盒子至少装一个球。 剩余部分留至后文。 I：显然为 m^n 。 II：显然为 m^{\\underline{n}} 。 III：容斥一波，考虑空盒子的个数，得到 \\displaystyle\\sum_{i=0}^m(-1)^i\\binom mi(m-i)^n 。 IX：插板法，我们相当于是将 n 个球划分到 m 个连续段里面去，即相当于是 n - 1 个空里面插 m-1 个板，即 \\displaystyle\\binom {n -1}{m-1} 。 VII：由于一段可以为空，所以不妨强行多塞 m 个元素，再套用 VIII，所以就是 \\displaystyle\\binom{n + m - 1}{m-1} 。 VIII：考虑是哪几个盒子装球，答案显然为 \\displaystyle\\binom mn 。 由问题 IX 和问题 VII，我们可以知道： 对于不定方程 a_1 + \\cdots + a_n = X ，若要求 a_i\\ge 1 ，则方程的解有 \\dbinom{X - 1}{n - 1} 组。 若要求 a_i\\ge 0 ，则方程的解有 \\dbinom{X + n - 1}{n - 1} 组。 这是一类很经典的模型，需要仔细理解。 例题 2：P6475 [NOI Online #2 入门组] 建设城市 问满足以下条件的正整数序列 a_{1,\\cdots, 2n} 的数量，答案对 998244353 取模。 1\\le n,m\\le 10^5 。 \\forall i\\in[1, 2n], a_i\\in[1,m] 。 前 n 个元素不降，后 n 个元素不增。 a_x = a_y 。 本题的关键是考虑长度为 n ，值域 [1, m] 的不降序列的方案数 f(n,m) ，剩余部分是简单的分类讨论。下面用两种方法推导 f(n,m) ： 考虑即为将 n 个小球（高楼）放入 m 个盒子（值域）里，可以有空盒，于是由例题 1，答案显然为 \\dbinom{n + m - 1}{m - 1} 。 考虑长度为 n + m - 1 的操作序列，其中包含给 v 加一和将 v 加到当前序列末尾两个操作。不难发现一个操作序列唯一对应一个不降数列，然后随便想一下发现操作序列的总数为 f(n,m) = \\dbinom{n + m - 1}{n} 。 操作序列的思想很有用。 二项式反演 前言 一种奇形怪状的容斥，常用于转换“恰好”“至少”“至多”等字眼。 形式一 f_n = \\sum_{i = 0}^n\\binom n i g_i \\iff g_n = \\sum_{i = 0}^n(-1)^{n - i}\\binom n i f_i 证明考虑将右式回代入左式： \\begin{aligned} f_n &amp;= \\sum_{i = 0}^n\\binom n i g_i\\\\ &amp;= \\sum_{i = 0}^n\\binom n i\\sum_{j = 0}^i(-1)^{i - j}\\binom i jf_j\\\\ &amp;= \\sum_{i = 0}^n\\sum_{j = 0}^i(-1)^{i - j}\\binom n i \\binom i j f_j\\\\ &amp;= \\sum_{i = 0}^n\\sum_{j = 0}^i(-1)^{i - j}\\binom n j\\binom{n - j}{i - j}f_j\\\\ &amp;= \\sum_{j = 0}^nf_j\\binom n j \\sum_{i = j}^n(-1)^{i - j}\\binom{n - j}{i - j}\\\\ &amp;= \\sum_{j = 0}^nf_j\\binom n j \\sum_{k = 0}^{n - j}(-1)^k\\binom {n - j}{k}\\\\ &amp;= \\sum_{j = 0}^nf_j\\binom n j[n = j]\\\\ &amp;= f_n \\end{aligned} 其中用到了交换求和顺序以及将式子化为卷积形式的 trick。 还有一种使用 EGF 的证明： \\begin{aligned} f_n &amp;= \\sum_{i = 0}^n\\binom n i g_i\\\\ \\frac{f_n}{n!} &amp;= \\sum_{i = 0}^n\\frac{1}{(n - i)!}\\frac{g_i}{i!}\\\\ \\end{aligned} 这是一个卷积的形式，考虑到 \\exp(x) = \\displaystyle\\sum_{i = 0}\\frac{x^i}{i!} ，故有 F(x) = G(x)\\exp(x)\\iff G(x) = F(x)\\exp(-x) \\begin{aligned} \\frac{g_n}{n!} &amp;= \\sum_{i = 0}^n\\frac{f_i}{i!}(-1)^{n - i}(n - i)!\\\\ g_n &amp;= \\sum_{i = 0}^n(-1)^{n - i}\\binom n i f_i \\end{aligned} 根据组合意义可以知道 f_n 表示“至多 n 个”， g_n 表示“恰好 n 个”。 形式二 f_i = \\sum_{j = i}^n\\binom j ig_j\\iff g_i = \\sum_{j = i}^n(-1)^{j - i}\\binom j if_{j} 根据组合意义可以知道 f_n 表示“至少 n 个”， g_n 表示“恰好 n 个”。 应用 可以用于优化容斥，也可以进行奇怪的式子转化。 应用 1 ：错排问题。 设 f_i 为恰好 i 排错个的方案数，则我们知道 n! = \\sum_{i = 0}^n\\binom n i f_i 这明显是二项式反演的形式，反演一下就知道 f_i = \\sum_{i = 0}^n(-1)^{n - i}\\binom n i i! 。 应用 2 ：染色问题。 一列 n 个球， m 种颜色，给每个球染色，要求相邻球颜色不同，且每种颜色至少用 1 次。问方案数。 不考虑至少用 1 次的限制的话就是 m(m - 1)^{n - 1} ，现在我们考虑进去。设 f_k 为至多用 k 种颜色的方案数，即 k(k - 1)^{n - 1} ， g_k 为恰好用 k 种颜色的方案数，则 f_k = \\sum_{i = 0}^k\\binom k ig_i\\iff g_k = \\sum_{i = 0}^k(-1)^{k - i}\\binom k ii(i - 1)^{n - 1} 应用 3 ：斯特林数。 见下文。 例题 1 ：P4859 已经没有什么好害怕的了 给定两个长度为 n 的序列 \\{a\\} 和 \\{b\\} ，将其两两配对，问 a_i &gt; b_i 比 a_i &lt; b_i 的情况恰好多 k 组的方案数。 直接令 k = \\dfrac{n + k}{2} ，即转化为 a_i &gt; b_i 有 k 组。这样会好想一点。 如果不考虑恰好 k 组这个条件而是将其变为至少 k 组，则我们可以考虑一个 dp。首先先分别排好序，然后我们设 dp_{i, j} 表示前 i 个 a 里选了 j 组比 b 大的，则有转移 dp_{i, j} = dp_{i - 1, j} + (l_i - (j - 1))dp_{i - 1, j - 1} l_i 表示比 a_i 小的 b_i 的个数。因为已经选了 j - 1 个所以要扣去 j - 1 。 dp 完了之后还没完，设 f_i 为至少有 i 组的答案，则 f_i = (n - i)!dp_{n, i} ，令 g_i 为恰好为 i 组的答案，然后快乐二项式反演就可以得到 g_k = \\sum_{i = k}^n(-1)^{i - k} \\binom i kf_i O(n^2) 算一下即可。 例题 2 ：P6478 [NOI Online #2 提高组] 游戏 有一棵 n = 2m 个点的有根树，两人初始各有 m 个点。一共 m 轮游戏，每轮游戏两人各选一个点，若两人选的点间构成祖先关系，则这轮会决出胜负。对于 k = 0, 1, 2,\\cdots, m 求出有 k 轮决出胜负的方案数。 n\\le 5000 。 题解见此处。本题就是上题的上树版本。 min-max 容斥 一般形式 假设我们能很容易的求出所有子集的 \\min 但很难求 \\max ，有一种容斥是可以这样做的： \\max(S) = \\sum_{T\\subseteq S} (-1)^{|T| + 1}\\min(T) 证明：不妨给元素从小到大标号为 a_1, a_2,\\cdots,a_n 。 首先， \\max(S) = a_n ，而 \\min(T) = a_n 的情况只有 T = \\{a_n\\} 。贡献为 (-1)^{1 + 1}a_n = a_n 。 而对于剩下的 T ，假设 \\min(T) = a_k ，则 T 一定只能包含 a_k,\\cdots, a_n 等元素，一共有 2^{n - k + 1} 个这样的 T ，而 T 中元素奇偶性又是对半分的，故这些贡献是 0 。 \\blacksquare 同样的还有一种形式： \\min(S) = \\sum_{T\\subseteq S}(-1)^{|T| + 1}\\max(T) 注意 min-max 容斥在期望下也成立，所以经常可以把“最后出现的期望”一类转化为“第一次出现的期望”等问题，见例题 P3175 [HAOI2015]按位或，题解链接。 相关题目： 51nod1355 斐波那契的最小公倍数 P5643 [PKUWC2018]随机游走 当然，min-max 容斥还可以被推广到第 k 大/小，咕。 kth-minmax 容斥 咕咕咕。 群计数相关 紧急营业，模拟赛做到了考到群计数的题。 下面的定理全部没有证明，新学的请移步别处。 群论基础 一个集合 G 和一个运算 \\times ，若满足满足如下四个性质，则称二元组 (G, \\times) 为一个群： 封闭性： \\forall a, b\\in G, a\\times b\\in G 。 结合律： \\forall a, b, c\\in G, (a\\times b)\\times c = a\\times(b\\times c) 。 单位元：TeX parse error: Undefined control sequence \\exist，并且 e 唯一。 逆元： \\forall a\\in G, \\exists a'\\in G, a\\times a' = a'\\times a = e ，并且 a' 唯一。 集合 G 的大小 |G| 称为这个群的阶。 子群： H 为 G 的子集，并且 (H, \\times) 为群，则称 (H,\\times) 为 (G,\\times) 的子群，记为 H\\le G ​。 置换： \\sigma = \\begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ 2 &amp; 5 &amp; 4 &amp; 3 &amp; 1 \\end{pmatrix} 就是把上一行的排列变成下一行。 \\sigma = (a_1, a_2, \\cdots, a_n) 表示一个置换。两个置换可以合成。 \\sigma\\times a = \\sigma(a) = (\\sigma_{a_1}, \\sigma_{a_2},\\cdots,\\sigma_{a_n}) 。 N = \\{1, \\cdots, n\\} ，令 M 为所有排列的集合，令 G = (M, \\times) ，则 G 为一置换群。 封闭性显然，结合律显然，单位元为 (1, 2,\\cdots, n) ，逆元显然。 轮换：将置换用一张有向图表示，由于每个点的入度/出度都为 1 ，所以一定可以形成若干个环，例如置换： \\begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ 2 &amp; 5 &amp; 4 &amp; 3 &amp; 1 \\end{pmatrix} 就可以表示为 (1, 2, 5)(3, 4) 。置换用这些表示一定是一一对应的。 群作用：对于一个集合 M 和群 G ，若给定一二元函数 \\varphi(v, k) ，其中 k\\in M ， v\\in G ，且 \\begin{aligned} \\varphi(e, k) &amp;= k\\\\ \\varphi(g, \\varphi(s, k)) &amp;= \\varphi(g\\times s, k) \\end{aligned} 则称 G 作用于 M 。 Burnside 引理 令 G 为一置换群，作用于 X 。若 x, y\\in X 在 G 作用下可以相等即 \\exists f\\in G,f(x) = y ，则定义 x 和 y 属于一个等价类，不同的等价类数量为 |X / G| = \\frac{1}{|G|}\\sum_{g\\in G}X^g X^g 为 X 在 g 的作用下不动点的数量，即 |\\{x\\in X \\mid g(x) = x\\}| 。 X 在群 G 作用下的等价类总数等于每个 g 作用于 X 的不动点数量的算术平均值。 答案等于每个置换的不动点的平均数。 应用 例题 1：P1446 [HNOI2008]Cards 要给 n 张牌染色， S_r 张红， S_g 张绿， S_b 张蓝。同时给定若干种洗牌法，保证为置换群，问本质不同的染色方案数。 Burnside 引理告诉我们要求出每个置换的不动点个数。我们注意到这里每个置换都可以分解为若干个轮换环，既然是不动点那么每个环内染的颜色必然就相同，我们用一个 f_{r, g,b} 类似背包的 dp 就可以轻松求出不动点个数。 然而一定要考虑单位置换的影响。 例题 2：UVA10601 Cubes 给定 12 根等长，着色的木棒。问能构成的本质不同的正方体数量。颜色最多有 6 种。正方体 A 和 B 本质不同，当 A 不能通过旋转得到 B 。 分析正方体的所有置换并拆成若干个轮换： 恒等变换：即不动。分解为 (1)^{12} 。 以两个相对面中心连线为轴的 90^\\circ 旋转：共有 3\\times 2 = 6 种这样的置换。分解为 (4)^3 。 以两个相对面中心连线为轴的 180^\\circ 旋转：共有 3\\times 1 = 3 种这样的置换。分解为 (2)^6 。 以两个相对棱中心连线为轴的 180^\\circ 旋转：共有 6 种这样的置换。分解为 (1)^2(2)^5 。 以两个相对顶点连线为轴的 120^\\circ 旋转：共有 4\\times 2 = 8 种这样的置换。分解为 (3)^4 。 一共有 24 种这样的置换。 找不动点就是给这些环填上一样颜色的方案数。不难发现就是多重组合数，套公式算就行了。 P4727 [HNOI2009]图的同构计数` 生成函数 特殊数列 卡特兰数 感觉应用也就那几种。 递推公式 1 ： C_n = \\sum_{i = 0}^{n - 1}C_iC_{n - 1 - i} 这个式子是由一个树形 dp 推出来的。 通项公式： C_n = \\frac{\\binom{2n}{n}}{n + 1} = \\binom{2n}{n} - \\binom{2n}{n - 1} 大多数时候通过观察 dp 式子可以直接看出卡特兰，敲一个通项上去就 ok 了。 斯特林数 第二类斯特林数 第二类斯特林数（斯特林子集数）： \\begin{Bmatrix}n\\\\k\\end{Bmatrix} 或 S(n, k) ，表示将两两不同的元素，划分为 k 个互不区分的非空子集的方案数。 \\begin{Bmatrix}n\\\\k\\end{Bmatrix} = \\begin{Bmatrix}n - 1\\\\k - 1\\end{Bmatrix} + k\\begin{Bmatrix}n - 1\\\\k\\end{Bmatrix} 边界为 \\begin{Bmatrix}n\\\\0\\end{Bmatrix} = [n = 0] 。证明考虑组合意义：最后一个数是单独放一个子集还是选一个已经放了的子集放。 我们考虑 m^n = \\sum_{i = 0}^m\\binom m i\\begin{Bmatrix}n\\\\ i\\end{Bmatrix}i! 这个式子的组合意义是：将 n 个元素随意放入 m 个有标号集合的方案数。右边是枚举非空的集合， i! 赋予集合标号。 然后就可以愉快二项式反演： m!\\begin{Bmatrix}n\\\\m\\end{Bmatrix} = \\sum_{i = 0}^m(-1)^{m - i}\\binom m ii^n 化简即可得到卷积形式： \\begin{Bmatrix}n\\\\m\\end{Bmatrix} = \\sum_{i=0}^m\\frac{(-1)^{m - i}}{(m - i)!}\\times \\frac{i^n}{i!} 然后就可以做 P5395 第二类斯特林数·行 了，直接 NTT 碾过去就行了。 例题：P5824 十二重计数法（部分）给定 n 个球和 m 个盒子。 IV：球之间互不相同，盒子全部相同。 V：球之间互不相同，盒子全部相同，每个盒子至多装一个球。 VI：球之间互不相同，盒子全部相同，每个盒子至少装一个球。 VI 显然就为 S(n, m) ，V 则是 [n\\le m] ，而 IV 则考虑枚举放了球的盒子个数，不难发现其为 \\displaystyle\\sum_{i=1}^mS(n, i) 。用 P5395 的代码碾过去就可以了。 第一类斯特林数 上升幂与下降幂 斯特林反演 分拆数 令自然数的分拆为递降正整数的和： n= r_1+r_2+\\cdots+r_k\\quad r_1\\ge r_2\\ge\\cdots\\ge r_k\\ge 1 定义分拆数 p_n 为自然数 n 的分拆方式数。 k 部分拆数 在研究 p_n 之前先考虑研究 k 部分拆数 p(n,k) ，即将 n 拆分为恰好 k 个部分的方案数。 例题 1：P5824 十二重计数法（部分）给定 n 个球和 m 个盒子。 X：球全部相同，盒子全部相同。 XI：球全部相同，盒子全部相同，每个盒子至多装一个球。 XII：球全部相同，盒子全部相同，每个盒子至少装一个球。 先考虑问题 XII，我们可以随便想出一个经典的 dp： p(n,k) = p(n - k, k) + p(n - 1, k - 1) 其组合意义为：考虑最后一个部分放 1 ，或者选择把上一个分拆里面的数字全部加 1 。于是这个东西就可以 O(n^2) dp。 接下来我们考虑一下其生成函数 F_j(x) = p(0, j) + p(1, j)x + p(2, j)x^2 + p(3, j)x^3+\\cdots ，根据上面的递推式我们可以得到 F_j(x) = x^jF_j(x) + xF_{j - 1}(x) 然后化简一下式子： \\displaystyle F_j(x) = \\frac{xF_{j - 1}(x)}{1 - x^j} = x^j\\prod_{k=1}^j\\frac{1}{1 - x^k} 。不妨令 \\displaystyle G_k(x) = \\frac{1}{1 - x^k} ，则 F_j(x) = x^j\\prod_{k = 1}^jG_k(x) = x^jH_j(x) 求 \\prod G_k(x) 貌似是一个经典问题，这里再推导一遍。 \\begin{aligned} H_j(x) &amp;= \\prod_{k=1}^jG_k(x)\\\\ \\ln H_j(x) &amp;= \\sum_{k=1}^j\\ln G_k(x)\\\\ &amp;= -\\sum_{k=1}^j\\ln(1 - x^k)\\\\ &amp;= \\sum_{k=1}^j\\sum_{i=1}^{+\\infty}\\frac{x^{ki}}{i} \\end{aligned} 可以暴力 O(n\\log n) 求出来，然后做 exp 即可。 这里不难发现，问题 XII 的答案为 [x^{n - m}]H_m(x) ，问题 X 的答案为 [x^n]H_m(x) ，问题 XI 的答案为 [n\\le m] 。 事实上，若我们定义的 k 部分拆数中可以有 0 ，则其生成函数就是 H_m(x) 。 五边形数定理 定义五边形数 P_n = \\dfrac{n(3n - 1)}{2} ，将下标扩展后得到广义五边形数 P_n = \\dfrac{n(3n\\pm 1)}{2} 。 定义欧拉函数（区别数论中的欧拉函数) \\phi(x) = \\prod_{i=1}^{+\\infty}(1 - x^i) 则五边形数定理说的就是 \\phi(x) = \\prod_{i=-\\infty}^{+\\infty}(-1)^ix^{\\frac{i(3i-1)}{2}} = 1 + \\prod_{i=0}^{+\\infty}(-1)^ix^{\\frac{i(3i \\pm 1)}{2}} 这部分证明全部咕掉。 求分拆数 注意到，根据上面的 k 部分拆数，我们可以轻松推出分拆数的生成函数为 F(x) = \\prod_{i=1}^{+\\infty}\\frac{1}{1 - x^i} 发现其满足 F(x)\\phi(x) = 1 我们考虑展开 [x^n]F(x)\\phi(x) ，有： p_n - p_{n - 1} - p_{n - 2} + p_{n - 5} + p_{n - 7} - \\cdots = 0 于是我们就得到了分拆数的递推公式（考虑对于 i&lt;0 ， p_i = 0 ）： p_n = p_{n - 1} - p_{n - 2} + p_{n - 5} + p_{n - 7} - \\cdots 由于广义五边形数的增长速度是 O(n^2) 的，所以求分拆数可以在 O(n\\sqrt n) 的时间内进行。 例题 2：P6189 [NOI Online #1 入门组] 跑步 单次询问任意模数拆分数， n = 10^5 。 可以用上面的方法直接做。 123456789101112const int maxn = 1e5 + 5;int mod, n, p[maxn], g[maxn], m;int main() { read(n, mod); p[0] = 1; for (int i = 1; i * (3 * i - 1) / 2 &lt;= n; ++i) g[m++] = i * (3 * i - 1) / 2, g[m++] = i * (3 * i + 1) / 2; FOR(i, 1, n) for (int j = 0; j &lt; m &amp;&amp; g[j] &lt;= i; ++j) p[i] = (p[i] + (((j &gt;&gt; 1) &amp; 1) ? -1ll : 1ll) * p[i - g[j]]) % mod; print((p[n] + mod) % mod); return output(), 0;} 当然也可以根号分治，对于 \\le\\sqrt n 的考虑直接完全背包，然后设 g_{i, j} 为使用 i 个大于等于 \\sqrt n 的数加出 j 的方案数，发现 i\\le \\sqrt n ，最后合并两个 dp 的答案即可。 斐波那契","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"}]},{"title":"置换群计数相关","slug":"note-group","date":"2021-10-02T13:10:07.000Z","updated":"2022-03-23T04:17:42.176Z","comments":true,"path":"note-group/","link":"","permalink":"https://old.blog.imyangty.com/note-group/","excerpt":"","text":"前言 自己的学习笔记，备忘。不包看懂，不包没错。 群计数类问题在实际应用时需要较多前置技能（e.g. 莫比乌斯反演，生成函数，排列组合，etc.）。 群论基础 一个集合 G 和一个运算 \\times ，若满足满足如下四个性质，则称二元组 (G, \\times) 为一个群： 封闭性： \\forall a, b\\in G, a\\times b\\in G 。 结合律： \\forall a, b, c\\in G, (a\\times b)\\times c = a\\times(b\\times c) 。 单位元：TeX parse error: Undefined control sequence \\exist，并且 e 唯一。 逆元： \\forall a\\in G, \\exists a'\\in G, a\\times a' = a'\\times a = e ，并且 a' 唯一。 集合 G 的大小 |G| 称为这个群的阶。 子群： H 为 G 的子集，并且 (H, \\times) 为群，则称 (H,\\times) 为 (G,\\times) 的子群，记为 H\\le G 。 陪集：令 H\\le G ， g\\in G ， gH = \\{g\\times h \\mid h\\in H\\} 为 H 关于 G 内关于 g 的左陪集。右陪集同理，即为 Hg = \\{h\\times g\\mid h\\in H\\} 。 陪集有如下性质： \\forall g\\in G ， |H| = |Hg| 由逆元唯一可得 h\\times g_1\\not= h\\times g_2 。 \\forall g\\in G, g\\in Hg 考虑单位元 e\\in H ， e\\times g = g\\in Hg 。 Hg = H\\iff g\\in H 封闭性。 Ha = Hb\\iff a\\times b^{-1}\\in H Ha = Hb\\implies Ha\\times b^{-1} = H ，由性质 3 ， a\\times b^{-1}\\in H 。 a\\times b^{-1}\\in H\\implies Ha = Hb 显然。 Ha\\cap Hb\\not= \\varnothing\\implies Ha = Hb 这个性质告诉我们：一个子群 H 的陪集要么互不交要么两个相等。 假设： c\\in Ha \\land c\\in Hb ，于是 \\exists h_1, h_2\\in H,h_1\\times a = c, h_2\\times b = c ，故 ab^{-1} = h_2h_1^{-1}\\in H ，由性质 4 有 Ha = Hb 。 H 的全体右陪集的并是 G h 取单位元， g 取遍 G 中所有元素，并起来就一定是 G 。 拉格朗日定理 以下默认 G\\le H ，定义 G/H 为 G 中所有元素的左陪集即 G/H = \\{gH\\mid g\\in G\\} 。定义 [G:H] 表示 G 中 H 不同陪集的数量。 拉格朗日定理： 对于有限群 G 和 H ，若 H\\le G ，有 |H|[G:H] = [G] 所有本质不同陪集互不交，且大小均为 |H| ，并起来就是 G 。所以不同陪集数量 [G:H] 乘上 |H| 即为 |G| 。 置换 \\sigma = \\begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ 2 &amp; 5 &amp; 4 &amp; 3 &amp; 1 \\end{pmatrix} 就是把上一行的排列变成下一行。 \\sigma = (a_1, a_2, \\cdots, a_n) 表示一个置换。两个置换可以合成。 \\sigma\\times a = \\sigma(a) = (\\sigma_{a_1}, \\sigma_{a_2},\\cdots,\\sigma_{a_n}) 。 N = \\{1, \\cdots, n\\} ，令 M 为所有排列的集合，令 G = (M, \\times) ，则 G 为一置换群。 封闭性显然，结合律显然，单位元为 (1, 2,\\cdots, n) ，逆元显然。 轮换：将置换用一张有向图表示，由于每个点的入度/出度都为 1 ，所以一定可以形成若干个环，例如置换： \\begin{pmatrix} 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ 2 &amp; 5 &amp; 4 &amp; 3 &amp; 1 \\end{pmatrix} 就可以表示为 (1, 2, 5)(3, 4) 。置换用这些表示一定是一一对应的。 轨道与稳定子 群作用：对于一个集合 M 和群 G ，若给定一二元函数 \\varphi(v, k) ，其中 k\\in M ， v\\in G ，且 \\begin{aligned} \\varphi(e, k) &amp;= k\\\\ \\varphi(g, \\varphi(s, k)) &amp;= \\varphi(g\\times s, k) \\end{aligned} 则称 G 作用于 M 。 考虑作用于 X 上的 G ， x\\in X 的轨道是 x 通过 G 能转移到的元素的集合，记作 G(x) ，方便起见记 g(x) = \\varphi(g, x) 。 稳定子： G^x = \\{g\\mid g\\in G,g(x) = x\\} 。即为群 G 中满足 g(x) = x 的所有元素 g 的集合。 轨道-稳定子定理： |G^x|\\times |G(x)| = |G| 可以证明 G^x 为 G 的一个子群，然后根据拉格朗日定理， |G^x|\\times[G: G^x] = |G| ，故现在需要证明 [G:G^x] = |G(x)| 。转化为证明存在从 G(x) 到 G^x 所有左陪集的双射。令 \\varphi(g(x)) = gG^x ， f\\in G^x 。 若 f(x) = g(x) ，则 f\\times g^{-1} = x = e(x)\\in G^x ，由于 f\\times G^x = g\\times G^x ，故相同的 f(x) 可以对应相同的陪集。一一对应关系，得证。 Burnside 引理 令 G 为一置换群，作用于 X 。若 x, y\\in X 在 G 作用下可以相等即 \\exists f\\in G,f(x) = y ，则定义 x 和 y 属于一个等价类，不同的等价类数量为 |X / G| = \\frac{1}{|G|}\\sum_{g\\in G}X^g X^g 为 X 在 g 的作用下不动点的数量，即 |\\{x\\in X \\mid g(x) = x\\}| 。 X 在群 G 作用下的等价类总数等于每个 g 作用于 X 的不动点数量的算术平均值。 答案等于每个置换的不动点的平均数 证明： 因为每个元素属于且仅属于一个轨道，故 |X / G| = \\sum_{x \\in X}\\frac{1}{[G:G^x]} 而根据轨道-稳定子定理， [G:G^x] = \\frac{|G|}{|G^x|} 所以 |X / G| = \\sum_{x\\in X}\\frac{|G^x|}{|G|} = \\frac{1}{|G|}\\sum_{x\\in X}|G^x| 而 \\sum|G^x| = \\sum X^g ，得证。 Polya 定理 我们从例题 P4980 【模板】Pólya 定理 出发： 我们不妨将本质不同的 n 元环看作在置换群 G = \\{\\text{rotate 0 time(s)}, \\text{rotate 1 time(s) }, \\cdots, \\text{rotate }n - 1\\text{ times}\\} 的作用下，等价类的数量。 设集合 M 为所有初始的环构成的集合。 由 Burnside 引理得到答案为 \\frac{1}{|G|}\\sum_{g\\in G}M^g 然后依次考虑每个置换对答案的贡献。旋转 0 次的不动点显然为 n^n 个，所有集合都合法。 然后考虑旋转 k 次的不动点数量。不难发现其一定要有长度为 a 的循环节，其中 a\\mid k 。而且我们也知道 a\\mid n ，故循环节的长度为 \\gcd(k, n) 。 答案： \\frac{1}{n}\\sum_{k = 0}^{n - 1}n^{\\gcd(k, n)} 求这个东西就枚举 \\gcd 就行了： \\begin{aligned} &amp;\\frac{1}{n}\\sum_{k = 0}^{n - 1}n^{\\gcd(k, n)}\\\\ =&amp;\\frac{1}{n}\\sum_{d\\mid n}n^d\\sum_{k = 1}^{\\lfloor n / d\\rfloor} [\\gcd(k, \\lfloor n / d\\rfloor) = 1]\\\\ =&amp;\\frac{1}{n}\\sum_{d\\mid n}n^d\\varphi(\\lfloor n / d\\rfloor) \\end{aligned} 做完了。 定义置换 g 的轮换环数为 c(g) ，则 Polya 定理就是 \\frac{1}{|G|}\\sum_{g\\in G}m^{c(g)} m 为可用的颜色数。 例题分析 P1446 [HNOI2008]Cards 题意：要给 n 张牌染色， S_r 张红， S_g 张绿， S_b 张蓝。同时给定若干种洗牌法，保证为置换群，问本质不同的染色方案数。 Burnside 引理告诉我们要求出每个置换的不动点个数。我们注意到这里每个置换都可以分解为若干个轮换环，既然是不动点那么每个环内染的颜色必然就相同，我们用一个 f_{r, g,b} 类似背包的 dp 就可以轻松求出不动点个数。 然而一定要考虑单位置换的影响。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int n, Sr, Sb, Sg, m, tr[65], sz[65], vis[65];modint f[65][65][65];modint calc() { int tot = 0; FOR(i, 0, Sr) FOR(j, 0, Sb) FOR(k, 0, Sg) f[i][j][k] = 0; FOR(i, 1, n) vis[i] = 0; for (int i = 1, p, len; i &lt;= n; ++i) { if (vis[i]) continue; len = 0, p = i; while (!vis[p]) { vis[p] = 1; ++len; p = tr[p]; } sz[++tot] = len; } f[0][0][0] = 1; FOR(i, 1, tot) { DEC(nr, Sr, 0) { DEC(nb, Sb, 0) { DEC(ng, Sg, 0) { if (nr &gt;= sz[i]) f[nr][nb][ng] += f[nr - sz[i]][nb][ng]; if (nb &gt;= sz[i]) f[nr][nb][ng] += f[nr][nb - sz[i]][ng]; if (ng &gt;= sz[i]) f[nr][nb][ng] += f[nr][nb][ng - sz[i]]; } } } } return f[Sr][Sb][Sg];}int main() { read(Sr), read(Sb), read(Sg), read(m), read(mod); modint ans = 0; n = Sr + Sb + Sg; bool flag = 0; FOR(i, 1, m) { bool tmp = 1; FOR(j, 1, n) read(tr[j]), tmp &amp;= (tr[j] == j); ans += calc(), flag |= tmp; } if (!flag) { FOR(j, 1, n) tr[j] = j; ans += calc(); } print(ans * qPow(m + (!flag), mod - 2)); return output(), 0;} UVA10601 Cubes 题意：给定 12 根等长，着色的木棒。问能构成的本质不同的正方体数量。颜色最多有 6 种。正方体 A 和 B 本质不同，当 A 不能通过旋转得到 B 。 分析正方体的所有置换并拆成若干个轮换： 恒等变换：即不动。分解为 (1)^{12} 。 以两个相对面中心连线为轴的 90^\\circ 旋转：共有 3\\times 2 = 6 种这样的置换。分解为 (4)^3 。 以两个相对面中心连线为轴的 180^\\circ 旋转：共有 3\\times 1 = 3 种这样的置换。分解为 (2)^6 。 以两个相对棱中心连线为轴的 180^\\circ 旋转：共有 6 种这样的置换。分解为 (1)^2(2)^5 。 以两个相对顶点连线为轴的 120^\\circ 旋转：共有 4\\times 2 = 8 种这样的置换。分解为 (3)^4 。 一共有 24 种这样的置换。 找不动点就是给这些环填上一样颜色的方案数。不难发现就是多重组合数，套公式算就行了。 123456789101112131415161718192021222324252627282930313233343536373839typedef long long ll;const ll fac[13] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600};int buc[7];ll calc(int x, int sz) { ll res = fac[sz / x]; FOR(i, 1, 6) { if (!(buc[i] % x)) res /= fac[buc[i] / x]; else return 0; } return res;}int main() { int T; read(T); while (T--) { FOR(i, 1, 6) buc[i] = 0; FOR(i, 1, 12) { int tmp; read(tmp); ++buc[tmp]; } ll ans = calc(1, 12) + 6 * calc(4, 12) + 3 * calc(2, 12) + 8 * calc(3, 12); FOR(i, 1, 6) { if (!buc[i]) continue; --buc[i]; FOR(j, 1, 6) { if (!buc[j]) continue; --buc[j]; ans += 6 * calc(2, 10); ++buc[j]; } ++buc[i]; } print(ans / 24, '\\n'); } return output(), 0;} P2561 [AHOI2002]黑白瓷砖 题意：见题面。虽然你在 OEIS 上搜一下样例也是可以做出来的但没必要 所有的置换一共有： 单位置换； 旋转 120^\\circ 和 240^\\circ ； 翻转一次； 旋转 120/240^\\circ 并翻转一次。但是这相当于就是绕不同的对称轴翻转。 共 6 种。 考虑对于一个特定的 n ，寻找每个置换不动点的个数，分类讨论有点心烦。 单位置换： (1)^{n(n + 1) / 2} 。 旋转 120/240^\\circ ：这两个很对称就只考虑一个，不难发现当 n(n + 1) / 2\\equiv 1\\pmod 3 时，有一个中心，否则一定能形成若干个长度为 3 的轮换。而 n(n + 1)/2\\equiv 1\\iff n\\equiv 1\\pmod 3 。 翻转：中轴上有 \\lceil n / 2\\rceil 个不动的，剩余形成若干个长度为 2 的轮换。 然后，令 N = n(n + 1) / 2 ，我们就可以得到答案： \\frac{1}{6}\\left(2^N + 2\\times 2^{\\lceil N / 3\\rceil} + 3\\times 2^{\\frac{N - \\lceil n / 2\\rceil}{2} + \\lceil n / 2 \\rceil}\\right) 要写高精度，比较烦。 1234567891011BigInt pow2[450];int main() { pow2[0] = 1; FOR(i, 1, 420) pow2[i] = pow2[i - 1] * 2; int n; cin &gt;&gt; n; int N = n * (n + 1) / 2; cout &lt;&lt; (pow2[N] + pow2[(N + 2) / 3] * 2 + pow2[(N - (n + 1) / 2) / 2 + (n + 1) / 2] * 3) / 6 &lt;&lt; endl; return 0;} P4727 [HNOI2009]图的同构计数 P4916 [MtOI2018]魔力环","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"群论","slug":"group-theory","permalink":"https://old.blog.imyangty.com/tags/group-theory/"},{"name":"Polya定理","slug":"polya","permalink":"https://old.blog.imyangty.com/tags/polya/"}]},{"title":"NOI Online 题目选做","slug":"sol-noiol","date":"2021-09-30T08:14:50.000Z","updated":"2022-04-05T13:26:15.297Z","comments":true,"path":"sol-noiol/","link":"","permalink":"https://old.blog.imyangty.com/sol-noiol/","excerpt":"","text":"NOI Online #1 入门组 A 文具订购 暴力枚举。 B 跑步 求 n （ n\\le 10^5 ）的拆分数。由于是入门组所以不考虑五边形数定理这些高端做法。 显然，当 n 足够小时，可以考虑完全背包： f_{i, j} 表示前 i 个数加出 j 的方案数。 f_{i, j} = f_{i - 1, j - i} + f_{i, j - i} 然后就有 70 分了。然而 n 很大，故考虑根号分治。令 m = \\sqrt n ，则对于小于 m 的，我们使用完全背包，对于大于等于 m 的，则需要使用另外一种 dp。我们知道，对于大于等于 m 的数，其最多也就只能出现 m 个。所以考虑如下的 dp： g_{i, j} 为使用 i 个大于等于 m 的数，加出 j 的方案数。 则 g_{i, j} = g_{i - 1, j - m} + g_{i, j - i} 这个转移方程的意义为， g_{i - 1, j - m} 表示在拆分序列中加上一个 m ， g_{i, j - i} 表示把拆分序列中每个数加 1 ，这样子操作序列和拆分方案是唯一对应的。 算答案的时候，合并两部分： \\sum_{i = 0}^n\\left(f_{m - 1, i}\\times \\sum_{j = 0}^mg_{j, n - i}\\right) 即可。 C 魔法 挺不错的矩阵快速幂 + Floyd。 NOI Online #2 入门组 A 未了 忘了是啥了，签到题。 B 荆轲刺秦王 忘了怎么做了，是个搜素。 C 建设城市 题意：问满足以下条件的正整数序列 a_{1,\\cdots, 2n} 的数量，答案对 998244353 取模。 1\\le n,m\\le 10^5 。 \\forall i\\in[1, 2n], a_i\\in[1,m] 。 前 n 个元素不降，后 n 个元素不增。 a_x = a_y 。 O(nm) 的 dp 不难设计。 先忽略 a_x = a_y 的限制，考虑构造一个长度为 n ，值域在 [1, m] 内的不降数列（不增的同理）。考虑长度为 n + m - 1 的操作序列，其中包含给 v 加一和将 v 加到当前序列末尾两个操作。不难发现一个操作序列唯一对应一个不降数列，然后随便想一下发现操作序列的总数为 f(n,m) = \\dbinom{n + m - 1}{n} 。 然后将 a_x = a_y 的限制考虑进来之后，不妨枚举 h = a_x 。然后要按 x 和 y 的关系分类讨论： x \\le n&lt;y\\le 2n 。分为四段考虑： 第一段 [1, x - 1] 的为 f(x - 1, h) 。 第二段 [x + 1, n] 的为 f(n - x, m - h + 1) 。 第三段 [n + 1, y - 1] 的为 f(y - 1 - n, m - h + 1) 。 第四段 [y + 1, 2n] 的为 f(2n - y, h) 。 1\\le x&lt;y\\le n 。同样是分为四段考虑，只不过是同时钦定了 a_x 到 a_y 之间的元素。 答案为 f(x - 1, h)\\times f(n - y + 1, m - h + 1)\\times f(n, h) 。 n + 1\\le x&lt;y\\le 2n 。同理，答案为 f(n,h)\\times f(x - n - 1, m - h + 1)\\times f(2n - y, h) 但是对于后两种情况，还有一个思路：不妨直接将 a_x 到 a_y 之间的元素缩在一起。然后你就发现答案为 f(n,m)\\times f(n - (y - x), m) 于是 O(n + m) 解决此题。 NOI Online #2 提高组 C 游戏 有一棵 n = 2m 个点的有根树，两人初始各有 m 个点。一共 m 轮游戏，每轮游戏两人各选一个点，若两人选的点间构成祖先关系，则这轮会决出胜负。对于 k = 0, 1, 2,\\cdots, m 求出恰有 k 轮决出胜负的方案数。 n\\le 5000 。 这个题面长得就很二项式反演。不妨考虑至少有 k 轮决出胜负的方案数。即我们会钦定 k 对祖先关系。找这个东西考虑 dp。令 f_{u, k} 为 u 为根的子树中选了 k 对的方案数。 最后令 g_k 为答案，则有 g_k = \\sum_{i = k}^{n / 2}(-1)^{i - k}\\binom i kf_{1, i}(m - i)! dp 大概是 O(n^2) 的。树形背包式瞎转移转移就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const int maxn = 5005;int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;int size[maxn], cnt1[maxn];char str[maxn];modint f[maxn][maxn], tmp[maxn], fac[maxn], invfac[maxn];modint binom(int n, int m) {return n &lt; m ? 0 : fac[n] * invfac[m] * invfac[n - m];}il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void dfs(int u, int fa) { size[u] = 1, cnt1[u] = str[u] - '0'; f[u][0] = 1; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs(v, u); FOR(j, 0, (size[u] + size[v]) &gt;&gt; 1) tmp[j] = 0; FOR(j, 0, size[u] &gt;&gt; 1) FOR(k, 0, size[v] &gt;&gt; 1) tmp[j + k] += f[u][j] * f[v][k]; FOR(j, 0, (size[u] + size[v]) &gt;&gt; 1) f[u][j] = tmp[j]; size[u] += size[v], cnt1[u] += cnt1[v]; } DEC(i, min(cnt1[u], size[u] - cnt1[u]), 1) { if (str[u] == '1') f[u][i] += f[u][i - 1] * (size[u] - cnt1[u] - (i - 1)); else f[u][i] += f[u][i - 1] * (cnt1[u] - (i - 1)); } return;}int main() { fac[0] = 1; FOR(i, 1, 5000) fac[i] = fac[i - 1] * i; invfac[5000] = qPow(fac[5000], mod - 2); DEC(i, 4999, 0) invfac[i] = (i + 1) * invfac[i + 1]; read(n); read(str + 1); FOR(i, 1, n - 1) { int u, v; read(u), read(v); add(u, v), add(v, u); } dfs(1, 0); FOR(k, 0, n &gt;&gt; 1) { modint res = 0; FOR(i, k, n &gt;&gt; 1) { modint tmp = binom(i, k) * f[1][i] * fac[n / 2 - i]; if ((i - k) &amp; 1) res -= tmp; else res += tmp; } print(res, '\\n'); } return output(), 0;} NOI Online 2022 提高组 A 丹钓战 发现可以离线。 然后二维数点即可。 B 讨论 多测，给定 n 个集合 S_i ，问是否存在 x\\ne y 使得 S_x\\cap S_y \\ne \\varnothing\\land S_x\\not\\subseteq S_y\\land S_y\\not\\subseteq S_x 。 \\sum n\\le 10^6 ， \\sum |S_i|\\le 2\\times 10^6 。 有一个暴力做法： 对于每道题 i ，将会 i 的人拎出来按照 |S| 排序，然后检查相邻的人是否能讨论即可。 正确性证明：假设 |S_x|\\le|S_y|\\le|S_z| ，若 x 和 y 之间， y 和 z 之间都不能相互讨论，则说明 S_x\\subseteq S_y\\subseteq S_z ，那么 x 和 z 也不会相互讨论。 考虑优化。首先将所有人按照 |S| 排序，依次插入。 然后记录会 i 题的上一个人 l_i ，那么每次插入 S_x 的时候考虑 i\\in S_x ， S_{l_i} 和 S_x 是否合法。但是由于每个 S_x 会被多次检查，复杂度还是不对。 而遍历 S_x 的时候，可以顺便求出 S_x 与所有 S_{l_i} 的交集大小，这样就可以直接通过交集大小来判断两个集合是否包含。 所以对于一个测，时间复杂度为 O(n\\log n + \\sum |S_i|) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using fastIO::is;using fastIO::os;const int maxn = 1e6 + 5;int n, k[maxn], a[maxn], vis[maxn], cnt[maxn];vector&lt;int&gt; p[maxn];void solve() { is &gt;&gt; n; FOR(i, 1, n) { is &gt;&gt; k[i]; vis[i] = cnt[i] = 0; vector&lt;int&gt;().swap(p[i]); FOR(j, 1, k[i]) { int x; is &gt;&gt; x; p[i].push_back(x); } a[i] = i; } sort(a + 1, a + n + 1, [](const int &amp;x, const int &amp;y) {return k[x] &lt; k[y];}); FOR(t, 1, n) { int i = a[t]; if (!k[i]) continue; FOR(u, 0, k[i] - 1) ++cnt[vis[p[i][u]]]; FOR(u, 0, k[i] - 1) { int g = vis[p[i][u]]; if (g &amp;&amp; cnt[g] &lt; k[g] &amp;&amp; cnt[g] &lt; k[i]) { os &lt;&lt; \"YES\\n\"; os &lt;&lt; i &lt;&lt; ' ' &lt;&lt; g &lt;&lt; '\\n'; return; } } FOR(u, 0, k[i] - 1) --cnt[vis[p[i][u]]], vis[p[i][u]] = i; } os &lt;&lt; \"NO\\n\"; return;}int main() { int T; is &gt;&gt; T; while (T--) solve(); return 0;} C 如何正确的排序","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"根号分治","slug":"sqrt-division","permalink":"https://old.blog.imyangty.com/tags/sqrt-division/"},{"name":"二项式反演","slug":"binomial-inversion","permalink":"https://old.blog.imyangty.com/tags/binomial-inversion/"}]},{"title":"联合省选 2021 题解","slug":"sol-lhsx2021","date":"2021-09-30T08:14:38.000Z","updated":"2022-03-23T04:18:30.772Z","comments":true,"path":"sol-lhsx2021/","link":"","permalink":"https://old.blog.imyangty.com/sol-lhsx2021/","excerpt":"","text":"B 卷 D1T1 数对 pair 洛谷 P7517 算法：模拟？ Description 给定 n 个正整数 a_i ，请你求出有多少个数对 (i, j) 满足 1 \\le i \\le n ， 1 \\le j\\le n ， i \\ne j 且 a_i 是 a_j 的倍数。 2\\le n\\le2 \\times 10^5 ， 1 \\le a_i \\le 5 \\times {10}^5 。 Solution 前言：答案的上界为 2\\times10^5\\times(2\\times10^5 - 1) 需要开 long long。 注意到我们可以对于每一个单独的数 a_i ，求其对答案产生的贡献，即开桶记录每个数的出现次数，枚举 a_i 的倍数即可，复杂度是很明显的调和 n\\log n ，可以稳过。 考场代码： 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cctype&gt;#define rint register int#define il inline#define FOR(i, a, b) for (rint i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (rint i = a; i &gt;= b; --i)typedef long long ll;const int maxn = 2e5 + 5, maxk = 5e5 + 5;il int mymax(int a, int b) {return a &gt; b ? a : b;}int n, a[maxn], cnt[maxk], maxa;ll ans[maxk];int main(){ freopen(\"pair.in\", \"r\", stdin); freopen(\"pair.out\", \"w\", stdout); n = read(); FOR(i, 1, n) cnt[a[i] = read()]++, maxa = mymax(a[i], maxa); FOR(i, 1, n) { if (ans[a[i]]) continue; for (int k = 1; a[i] &amp;&amp; a[i] * k &lt;= maxa; ++k) ans[a[i]] += cnt[a[i] * k] - (k == 1); } ll Ans = 0; FOR(i, 1, n) Ans += ans[a[i]]; printf(\"%lld\\n\", Ans); return 0;} B 卷 D1T2 / A 卷 D1T1 卡牌游戏 card B 卷 D1T3 | A 卷 D1T3 图函数 graph B 卷 D2T1 取模 mod B 卷 D2T2 | A 卷 D2T1 宝石 gem B 卷 D2T3 | A 卷 D2T2 滚榜 ranklist 就我暴力写挂了成了 25 是吧。 Description 给定 n 支 ACM 队伍在封榜前的过题数 a_i ，比赛结束后主办方以 b_i 不降的顺序公布每支队伍在封榜后的过题数，并且每支队伍在公布后就会成为新的第一名。问最后榜上情况的种数。 \\sum b_i = m\\le 500 ， 0\\le a_i\\le 10^4 ， 1\\le n\\le 13 。 Solution 翻译一下题面，意思就是求出满足下列条件的排列 P 的数量，有 a_{P_i} + b_{P_i} &lt; a_{P_{i + 1}} + b_{P_{i + 1}}\\lor (a_{P_i} + b_{P_i} = a_{P_{i + 1}} + b_{P_i + 1}\\land P_i &lt; P_{i+ 1}) 且 b_{P_i} \\le b_{P_{i + 1}} 。 n 为 13 指引我们考虑状压。设 f_{S, i, j, k} 为当前状态为 S ，上一个为 i ， \\sum b_i 已经用了 j ，上一个 b_i 为 k 的方案数。这样子做的话复杂度为 O(2^nn^2m^2) 。很不幸，这样比 O(n!) 还危。 然而我们只关心排名的情况，不关心每个 b_i 具体的数值。 A 卷 D2T3 支配 dominator","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"}]},{"title":"联合省选 2020 题解","slug":"sol-lhsx2020","date":"2021-09-30T08:14:25.000Z","updated":"2022-03-23T04:18:30.769Z","comments":true,"path":"sol-lhsx2020/","link":"","permalink":"https://old.blog.imyangty.com/sol-lhsx2020/","excerpt":"","text":"B 卷 D1T1 卡牌游戏 洛谷 P6625，LOJ3305 算法：贪心 Description 轩轩某天想到了一个卡牌游戏，游戏规则如下： 初始时轩轩的手中有自左向右排成一排的 n 张卡牌，每张卡牌上有一个整数分值。 接下来，轩轩每次可以选取卡牌序列最左边的连续若干张卡牌（至少 2 张），将它们替换为一张新卡牌。新卡牌将插入到序列的最左端，它的分值为本次操作中被替换掉的卡牌的分值之和。 初始时轩轩总分为 0 ，每执行一次卡牌替换操作，新卡牌的分值将加到总分中。当序列长度为 1 时游戏结束，轩轩也可以在任意时刻结束游戏。 现在给出序列中各个卡牌的分值，请你来帮助轩轩计算他能够获得的最高总分是多少？ Solution 直接贪心即可，可以证明如果当前选的牌分值恰好大于等于 0 ，那么加入总贡献肯定是最优的。 注意数据范围，不开 long long 只有 65pts。 123456789101112131415161718192021typedef long long ll;const int maxn = 1e5 + 5;int n;ll a[maxn];int main(){ n = read(); FOR(i, 1, n) a[i] = read(); ll ans = 0, cur = 0; int chose = 0; FOR(i, 1, n) { cur += a[i], ++chose; if (cur &gt;= 0 &amp;&amp; chose &gt;= 2) ans += cur, chose = 1; } printf(\"%lld\\n\", ans); return 0;} B 卷 D1T2 消息传递 洛谷 P6626，LOJ3306 算法：点分治 Description 给定一个包含 n 个人（从 1 到 n 编号）的树形社交网络。如果一个人在某天收到了一条消息，则下一天他会将消息传递给所有与他有直接社交关系的人。 现在有 m 次询问，每次询问假定第 0 天 x 号人收到了一条消息，请你计算第 k 天时新收到此条消息的人数（即第 k 天前收到过此条消息的人不计入其中）。不同询问间互不影响。 数据范围： 1\\le n,m\\le 10^5 ， 0\\le k\\lt n 。 Solution 发现每次询问的其实就是距离 x 距离为 k 的点有多少。 考虑点分治进行处理：设离 x 的距离为 k 的一个点为 y ，则 x 与 y 之间构成了一条简单路径，这些路径可以使用点分治进行处理。 因为他们无非 经过当前子树的根 u ，直接统计即可 不经过当前子树的根 u ，递归分治即可 具体进行点分治（当前分治根节点为 u ）的时候这样处理： 假设已经处理完了前面的子树并且把距离存进了桶（judge 数组）里面而且把需要处理的点存进了 proc 数组里面 处理当前子树 v ，把距离存进临时桶 judge1 数组里面，把需要处理的点加进 proc 数组 处理当前子树 v 对于前面的子树的贡献，遍历之前的 proc 数组，在 judge1 数组里面统计贡献 处理前面的子树对于当前子树 v 的贡献，遍历新加进去的点，在 judge 数组里面统计贡献 把 judge1 数组中的贡献累加到 judge 中并清空之 当然，最后不要忘记 统计所有子树对于根的贡献 清空 judge 数组 点分治的细节比较烦人，调了很久 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define clr(x) memset(x, 0, sizeof x)int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}inline int max(int a, int b) {return a &gt; b ? a : b;}struct node{ int id, k;};const int maxn = 1e5 + 5;int n, m, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;int qhead[maxn], qk[maxn], qi[maxn], qnxt[maxn], cntq;inline void add(int u, int v){ to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}int size[maxn], maxp[maxn], root, tot, vis[maxn];int ans[maxn];int dis[maxn];void getrt(int u, int fa){ size[u] = 1, maxp[u] = 0; GO(u) { if (vis[v] || v == fa) continue; getrt(v, u); size[u] += size[v]; maxp[u] = max(maxp[u], size[v]); } maxp[u] = max(maxp[u], tot - size[u]); if (maxp[u] &lt; maxp[root]) root = u; return;}int proc[maxn], rem[maxn], judge[maxn], judge1[maxn];void getdis(int u, int fa){ if (qhead[u]) proc[++proc[0]] = u; rem[++rem[0]] = dis[u]; ++judge1[dis[u]]; GO(u) { if (v == fa || vis[v]) continue; dis[v] = dis[u] + 1; getdis(v, u); } return;}int q[maxn];void calc(int u){ proc[0] = 0; int p = 0; GO(u) { if (vis[v]) continue; dis[v] = 1; rem[0] = 0; int proc0 = proc[0]; getdis(v, u); int proc1 = proc[0]; FOR(j, proc0 + 1, proc1) { int cur = proc[j]; for (int ii = qhead[cur]; ii; ii = qnxt[ii]) { int k = qk[ii]; if (k &gt;= dis[cur]) ans[qi[ii]] += judge[k - dis[cur]]; } } FOR(j, 1, proc0) { int cur = proc[j]; for (int ii = qhead[cur]; ii; ii = qnxt[ii]) { int k = qk[ii]; if (k &gt;= dis[cur]) ans[qi[ii]] += judge1[k - dis[cur]]; } } FOR(j, 1, rem[0]) --judge1[rem[j]], ++judge[rem[j]], q[++p] = rem[j]; } for (int i = qhead[u]; i; i = qnxt[i]) ans[qi[i]] += judge[qk[i]]; FOR(i, 1, p) --judge[q[i]]; return;}void divide(int u){ vis[u] = 1; judge[0] = 1; calc(u); GO(u) { if (vis[v]) continue; maxp[0] = n, tot = size[v], root = 0; getrt(v, u); divide(root); } return;}int main(){ int T = read(); while (T--) { n = read(), m = read(); clr(head), clr(vis), clr(qhead); cnte = 0, cntq = 0; FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } FOR(i, 1, m) { int u = read(), k = read(); ans[i] = 0; if (k) { qk[++cntq] = k; qi[cntq] = i; qnxt[cntq] = qhead[u]; qhead[u] = cntq; } else ans[i] = 1; } tot = maxp[root = 0] = n; getrt(1, 0); divide(root); FOR(i, 1, m) printf(\"%d\\n\", ans[i]); } return 0;} B 卷 D1T3 | A 卷 D1T1 冰火战士 洛谷 P6619 Description 一场比赛即将开始。 每位战士有两个属性：温度和能量，有两派战士：冰系战士的技能会对周围造成降温冰冻伤害，因而要求场地温度不低于他的自身温度才能参赛；火系战士的技能会对周围造成升温灼烧伤害，因而要求场地温度不高于他的自身温度才能参赛。 当场地温度确定时，双方能够参赛的战士分别排成一队。冰系战士按自身温度从低到高排序，火系战士按自身温度从高到低排序，温度相同时能量大的战士排在前面。首先，双方的第一位战士之间展开战斗，两位战士消耗相同的能量，能量少的战士将耗尽能量退出比赛，而能量有剩余的战士将继续和对方的下一位战士战斗（能量都耗尽则双方下一位战士之间展开战斗）。如此循环，直至某方战士队列为空，比赛结束。 你需要寻找最佳场地温度：使冰火双方消耗总能量最高的温度的最高值。 现在，比赛还处于报名阶段，目前还没有任何战士报名，接下来你将不断地收到报名信息和撤回信息。其中，报名信息包含报名战士的派系和两个属性，撤回信息包含要撤回的报名信息的序号。每当报名情况发生变化（即收到一条信息）时，你需要立即报出当前局面下的最佳场地温度，以及该场地温度下双方消耗的总能量之和是多少。若当前局面下无论何种温度都无法开展比赛（某一方没有战士能参赛），则只要输出 Peace。 Input 第一行一个数 Q ，表示信息的数量。 接下来 Q 行，每行为 1 t x y （ t \\in \\{0, 1\\} ， x 和 y 都是正整数）或 2 k（ k 是正整数）： 1 t x y 表示一条报名信息， t=0 时报名战士是冰系， t=1 时报名战士是火系， x 表示战士的自身温度， y 表示战士的能量。 2 k 表示一条撤回信息，撤回的是第 k 条信息。被撤回的信息一定是报名信息，已被撤回的信息不会再次被撤回。 Output 共 Q 行，每行有两个用空格隔开的正整数，分别表示当前局面下的最佳温度和该温度下冰火双方消耗的总能量之和。 Data Range 1 \\leq Q \\leq 2 \\times 10^6 ， 1 \\leq x \\leq 2 \\times 10^9 ，所有 y 之和不超过 2 \\times 10^9 ，保证不存在 t, x, y 完全相同的两个战士。 Solution B 卷 D2T1 幸运数字 Description 为庆祝疫情防治取得重大进展，某商场举行酬宾活动，给顾客一些优惠额度，规则如下： 每位顾客可以任意选择一个整数作为自己的幸运数字。 每位顾客的初始优惠额度为 0 元。 商场有 n 个奖励条件，对应不同的奖励额度 w_i 。 每位顾客需要依次比对这 n 个奖励条件，如果该位顾客选择的幸运数字满足第 i 个条件，那么他的优惠额度就会异或上这个条件所对应的奖励额度。 奖励条件共有三种，假设顾客选择的幸运数字为 x ： 区间型条件，其有两个参数 L 与 RR，满足条件为 L \\le x\\le R 。保证 L &lt; R 。 相等型条件，其有一个参数 A ，满足条件为 x = A 。 不等型条件，其有一个参数 B ，满足条件为 x \\neq B 。 小炎同学获知了所有奖励条件的信息，他希望知道一位顾客能够得到的最大优惠额度以及对应的幸运数字是多少，请你帮他计算。 Input 第一行包含一个正整数 n ，代表奖励条件的数量。 接下来 n 行，每行三个或四个整数表示一个奖励条件。每行第一个整数 t_i 代表奖励条件的类型： t_i = 1 则该条件是区间型条件，接下来三个整数，分别代表 L, R, w_i 。 t_i = 2 则该条件是相等型条件，接下来两个整数，分别代表 A, w_i 。 t_i = 3 则该条件是不等型条件，接下来两个整数，分别代表 B, w_i 。 Output 输出一行两个整数，第一个数代表能够得到的最大优惠额度，第二个数代表对应的幸运数字。 如果有多个幸运数字能够得到最大优惠额度，输出绝对值最小的那个。如果还有多个，则输出值最大的。 B 卷 D2T2 | A 卷 D2T1 信号传递 B 卷 D2T3 丁香之路 A 卷 D1T2 组合数问题 A 卷 D1T3 魔法商店 A 卷 D2T2 树 A 卷 D2T3 作业题","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"点分治","slug":"centroid-decomposition","permalink":"https://old.blog.imyangty.com/tags/centroid-decomposition/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"}]},{"title":"P5446 [THUPC2018]绿绿和串串","slug":"sol-luogu-p5446","date":"2021-09-29T11:10:59.000Z","updated":"2022-03-23T04:18:31.017Z","comments":true,"path":"sol-luogu-p5446/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5446/","excerpt":"","text":"Description 定义串 R 的翻转为将 R 的前 |R| - 1 个字符翻转后接到 R 的后面形成的新串。 已知 S 为 R' 的前缀， R' 由 R 经过若干次翻转得到。 问初始的 R 的可能长度。由于任意大于 |S| 的 R 都合法，所以请输出所有小于等于 |S| 的 |R| 。 Solution 首先显然有一种情况是 S 的每个奇数长度的回文后缀，翻转的中心一定就为回文的中心，这是翻转一次的情况。比较棘手的是翻转多次的情况。 我们不妨考虑那些翻转最后一次的情况。 比如 i ，如果 i 的回文左边界为 1 且右边界合法，则 i 肯定也是一个合法的答案。 代码很短，注意本题不需考虑长度为偶数的回文串。 12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)const int maxn = 1e6 + 5;int n, len[maxn], ans[maxn];char s[maxn];template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}int main() { int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%s\", s + 1); n = strlen(s + 1); s[0] = '#', s[n + 1] = '&amp;'; for (int i = 1, r = 0, mid = 0; i &lt;= n; ++i) { len[i] = 0; if (i &lt;= r) len[i] = min(len[(mid &lt;&lt; 1) - i], r - i + 1); while (s[i - len[i]] == s[i + len[i]]) ++len[i]; if (i + len[i] &gt; r) r = i + len[i] - 1, mid = i; ans[i] = 0; } DEC(i, n, 1) { if (i + len[i] - 1 == n) ans[i] = 1; if (ans[i + len[i] - 1] &amp;&amp; i - len[i] + 1 == 1) ans[i] = 1; } FOR(i, 1, n) if (ans[i]) printf(\"%d \", i); puts(\"\"); }}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"Manacher","slug":"Manacher","permalink":"https://old.blog.imyangty.com/tags/Manacher/"}]},{"title":"历年联赛真题选做","slug":"sol-past-noip","date":"2021-09-25T14:31:22.000Z","updated":"2022-03-23T04:18:31.071Z","comments":true,"path":"sol-past-noip/","link":"","permalink":"https://old.blog.imyangty.com/sol-past-noip/","excerpt":"","text":"笑死了还是没补完。 NOIP2011 D1T2 选择客栈 直接维护一个点能匹配到的客栈个数即可。 要开 long long。 D1T3 Mayan 游戏 题面。 首先下落函数可以这样写： 12345678910bool fall() { bool ret = 0; FOR(x, 0, 4) { int top = 0; FOR(y, 0, 6) if (a[x][y]) ret |= (top != y), a[x][top++] = a[x][y]; while (top &lt;= 6) a[x][top++] = 0; } return ret;} 然后是检查的函数 12345678910bool del() { bool ret = 0; bool vis[5][7]; FOR(x, 0, 4) FOR(y, 0, 6) vis[x][y] = 0; FOR(x, 0, 4) FOR(y, 2, 6) if (a[x][y] &amp;&amp; a[x][y - 2] == a[x][y - 1] &amp;&amp; a[x][y - 1] == a[x][y]) vis[x][y - 2] = vis[x][y - 1] = vis[x][y] = ret = 1; FOR(y, 0, 6) FOR(x, 2, 4) if (a[x][y] &amp;&amp; a[x - 2][y] == a[x - 1][y] &amp;&amp; a[x - 1][y] == a[x][y]) vis[x - 2][y] = vis[x - 1][y] = vis[x][y] = ret = 1; FOR(x, 0, 4) FOR(y, 0, 6) if (vis[x][y]) a[x][y] = 0; return ret;} 这里容易写锅。 然后修复的时候一定先掉落后删除。 剪枝：左移的话只有左边没有方块才移动，否则一定有往右边的移动是等价的并且先被遍历到。 然后 dfs 的时候按照他的字典序枚举即可。 D2T1 计算系数 二项式定理裸题。 D2T2 聪明的质监员 傻逼二分答案。 D2T3 观光公交 令 S_i 为在 i 号点出发的最大时间，则不难发现，公交车在 i 号点到达的时间 t(i) = D_{i - 1} + \\max\\{t(i - 1), S_{i - 1}\\} 。 然后 ans = \\sum_i\\{t(B_i) - T_i\\} 。 现在考虑每个氮气加速器的作用。其作用于 D_{i - 1} 后能惠及的乘客需要尽可能多。所以只考虑这个找后面第一个人等车之前的人数即可。 所以考虑维护一个氮气加速器能影响到的右端点 f_i ，有 \\begin{cases} f_n = n\\\\ f_{n - 1} = n\\\\ f_i = \\begin{cases} f_{i + 1} &amp;t(i + 1) &gt; S_{i + 1}\\\\ i + 1 &amp;\\text{otherwise} \\end{cases} \\end{cases} t(i+1) &gt; S_{i + 1} 即为人等车的情况，只有这些情况是能被优化掉的，因为后面的就与他无关了。 每次维护一下 f 和 t ，并找到能影响最多乘客的 i 即可，复杂度 O(nk) 。 123456789101112131415161718192021222324252627282930313233const int maxn = 1e3 + 5, maxm = 1e4 + 5;typedef long long ll;int n, m, k;ll maxt[maxn], D[maxn], T[maxm], A[maxm], B[maxm], t[maxn], arrive[maxn], f[maxn];template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}int main() { read(n), read(m), read(k); FOR(i, 1, n - 1) read(D[i]); FOR(i, 1, m) read(T[i]), read(A[i]), read(B[i]), maxt[A[i]] = max(maxt[A[i]], T[i]), ++arrive[B[i]]; FOR(i, 2, n) t[i] = max(maxt[i - 1], t[i - 1]) + D[i - 1], arrive[i] += arrive[i - 1]; ll ans = 0; FOR(i, 1, m) ans += t[B[i]] - T[i]; while (k--) { f[n - 1] = f[n] = n; DEC(i, n - 2, 1) { if (t[i + 1] &gt; maxt[i + 1]) f[i] = f[i + 1]; else f[i] = i + 1; } ll maxx = 0, pos = 0; FOR(i, 1, n - 1) if (maxx &lt; arrive[f[i]] - arrive[i] &amp;&amp; D[i]) maxx = arrive[f[i]] - arrive[i], pos = i; if (!pos) break; ans -= maxx, --D[pos]; FOR(i, pos, n) t[i] = max(maxt[i - 1], t[i - 1]) + D[i - 1]; } print(ans); return output(), 0;} 加强版咕咕咕。 NOIP2012 D1T1 Vigenère 密码 模拟 + 字符串。 D1T2 国王游戏 没妈高精题。据说是很著名的贪心。 不妨考虑调整法。考虑有两个人 (a_1, b_1) 和 (a_2, b_2) 。令之前的数的乘积为 A ，若第一个人在前面比第二个人在前面优，则 \\begin{aligned} \\max\\left(\\frac{A}{b_1}, \\frac{Aa_1}{b_2}\\right)&amp;&lt; \\max\\left(\\frac{A}{b_2},\\frac{Aa_2}{b_1}\\right)\\\\ (\\text{obviously there is }&amp; \\frac{A}{b_1} &lt; \\frac{Aa_2}{b_1})\\\\ Aa_1b_1 &amp;&lt; Aa_2b_2\\\\ a_1b_1 &amp;&lt; a_2b_2 \\end{aligned} 按照 a_ib_i 排序然后依次算就行了，但是需要高精度。 D1T3 开车旅行 不难发现这个东西满足倍增需要的性质。设 f(i, k, 0/1, 0/1) 为从第 i 个城市 A/B 先开车（取决于第三维），开 2^k 天后 A/B 走的路程（取决于第四维）。 比较烦反正就是。注意一开始需要熟练使用 STL 找最近的和次近的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798using namespace std;typedef pair&lt;int, int&gt; pii;const int maxn = 1e5 + 5;int n;int h[maxn], f[maxn][20][2][2], g[maxn][20][2];set&lt;pii&gt; S;il int myabs(int a) {return a &gt;= 0 ? a : -a;}int la, lb;void calc(int s, int x) { int p = s; la = lb = 0; DEC(j, 19, 0) { if (~g[p][j][0] &amp;&amp; la + lb + f[p][j][0][0] + f[p][j][0][1] &lt;= x) { la += f[p][j][0][0]; lb += f[p][j][0][1]; p = g[p][j][0]; } } return;}int main() { read(n); FOR(i, 1, n) read(h[i]); memset(f, 0x3f, sizeof f); memset(g, -1, sizeof g); S.insert(make_pair(h[n], n)); DEC(i, n - 1, 1) { auto it0 = S.lower_bound(make_pair(h[i], i)), it = it0; if (it != S.begin()) { --it; for (int j = 1; j &lt;= 2; ++j, --it) { if (g[i][0][1] == -1 || myabs(h[i] - it-&gt;first) &lt; myabs(h[i] - h[g[i][0][1]])) g[i][0][0] = g[i][0][1], g[i][0][1] = it-&gt;second; else if (g[i][0][0] == -1 || myabs(h[i] - it-&gt;first) &lt; myabs(h[i] - h[g[i][0][0]])) g[i][0][0] = it-&gt;second; if (it == S.begin()) break; } } it = it0; for (int j = 1; j &lt;= 2 &amp;&amp; it != S.end(); ++j, ++it) { if (g[i][0][1] == -1 || myabs(h[i] - it-&gt;first) &lt; myabs(h[i] - h[g[i][0][1]])) g[i][0][0] = g[i][0][1], g[i][0][1] = it-&gt;second; else if (g[i][0][0] == -1 || myabs(h[i] - it-&gt;first) &lt; myabs(h[i] - h[g[i][0][0]])) g[i][0][0] = it-&gt;second; } S.insert(make_pair(h[i], i)); } FOR(i, 1, n) { FOR(k, 0, 1) { if (~g[i][0][k]) { f[i][0][k][k ^ 1] = 0; f[i][0][k][k] = myabs(h[g[i][0][k]] - h[i]); } } } FOR(j, 1, 19) { FOR(i, 1, n) { FOR(k, 0, 1) { if (j == 1) { if (~g[i][j - 1][k] &amp;&amp; ~g[g[i][j - 1][k]][j - 1][k ^ 1]) { g[i][j][k] = g[g[i][j - 1][k]][j - 1][k ^ 1]; f[i][j][k][0] = f[i][j - 1][k][0] + f[g[i][j - 1][k]][j - 1][k ^ 1][0]; f[i][j][k][1] = f[i][j - 1][k][1] + f[g[i][j - 1][k]][j - 1][k ^ 1][1]; } } else { if (~g[i][j - 1][k] &amp;&amp; ~g[g[i][j - 1][k]][j - 1][k]) { g[i][j][k] = g[g[i][j - 1][k]][j - 1][k]; f[i][j][k][0] = f[i][j - 1][k][0] + f[g[i][j - 1][k]][j - 1][k][0]; f[i][j][k][1] = f[i][j - 1][k][1] + f[g[i][j - 1][k]][j - 1][k][1]; } } } } } int x0; read(x0); int ans = -1; double rate = 1e18; FOR(s, 1, n) { calc(s, x0); double now = (!lb ? 1e9 : (double)la / lb); if (now &lt; rate) rate = now, ans = s; else if (now == rate &amp;&amp; h[s] &gt; h[ans]) rate = now, ans = s; } print(ans), putchar('\\n'); int m; read(m); FOR(i, 1, m) { int s, x; read(s), read(x); calc(s, x); print(la), putchar(' '), print(lb), putchar('\\n'); } return output(), 0;} D2T3 疫情控制 稍加分析问题即可得到我们是需要将所有的军队从原来的位置移到特定的位置上使得根节点到每个叶子的路径都被覆盖到。而最优方案明显是每支军队同时移动，总代价就是花费时间最长的军队花费的时间。 “最大的最小”类型，并且该问题满足单调性，不难想到可以二分答案进行处理，二分的上界显然为树的直径，现在问题的关键是如何判定给定一个时间，能否在给定的时间内完成驻守。 m \\le n\\le 5\\times 10^4 ， m 的范围不是很好 dp，所以就需要想一些神奇的贪心了。 一个军队在的深度越浅，能控制的叶子节点越多，所以首先贪心的在二分的时间允许的范围内把每个军队往上提。这样子答案是不会更劣的。当然肯定有军队能到达根节点，这个时候先把其提到根下面的一级节点。然后再将其贪心地分配到没有被覆盖的根的儿子处。 提根的过程可以用倍增优化，无解的话就是如果军队个数少于根节点的度数就肯定无解。比较难写，代码。 NOIP2013 D1T1 转圈游戏 秒得答案为 (m\\times 10^k + x)\\bmod n 。 D1T2 火柴排队 排序不等式贪心的应用，离散化，新建序列，求逆序对即可。 D2T1 积木大赛 考虑差分数组，每次操作相当于可以给正的差分值减一并对应给负的加一。所以把所有的正差分值加起来即可。 D2T2 花匠 什么毒瘤贪心。。。暴力找拐点。 12345678910111213141516171819const int maxn = 1e5 + 5;int n, a[maxn];int main() { read(n); FOR(i, 1, n) read(a[i]); int b = 1, c = 1; FOR(i, 2, n) { if (b &amp; 1) { if (a[i] &gt; a[i - 1]) ++b; } else if (a[i] &lt; a[i - 1]) ++b; if (c &amp; 1) { if (a[i] &lt; a[i - 1]) ++c; } else if (a[i] &gt; a[i - 1]) ++c; } print(max(b, c), '\\n'); return output(), 0;} D2T3 华容道 NOIP2015 D2T3 运输计划 题意：给定树上若干条链，可以点一条边为 0 ，问最长链长度的最小值。 考虑二分答案。二分一个 mid ，然后只考虑长 &gt; mid 的链，找到一条最长的被这些链覆盖的边，判断最长链减去这条边之后能否满足 mid 。整个过程可以树上差分，十分简单。 NOIP2017 D1T3 逛公园 题意：给定一张有向图，设 1\\to N 的最短路为 d ，求出长度不超过 d + K 的 1\\to N 路径的数量，或报告无解。 N = 10^5 ， M = 2\\times 10^5 ， K\\le 50 ，可能有 0 权边。 注意到 K 很小，尝试创造条件进行 O(NK) 的 dp。首先考虑正反两边最短路跑出 d_1(u) 和 d_N(u) 分别表示 1\\to u 的最短路和 u\\to N 的最短路。然后考虑 dp 状态为 f_{u, j} 表示 1\\to u ，路径长 = d_1(u) + j 的计数。我们可以写出转移： f_{v, j + w(u,v) + d_1(u) - d_1(v)} := f_{v, j + w(u,v) + d_1(u) - d_1(v)} + f_{u, j} 根据三角形不等式： d_1(v)\\le d_1(u) + w(u,v) 可以得到 d_1(u) - d_1(v) + w(u,v)\\ge 0 。所以按照 d_1 排个序然后 dp 就可以解出所有答案有穷的情况。 对于答案无穷的情况，则为可行路径上能出现 0 环。将 0 权边单独拎出来建图然后拓扑排序即得到 0 环，若 0 环上的点 u 满足 d_1(u) + d_N(u)\\le d_1(N) + K 则说明其在可行路上。判断即可。 过不了 UOJ extra test 14。懒得研究正解了。 D2T3 列队 题意： n\\times m 列队，学生依次编号。 q 次操作，每次操作选择 (x, y) 的学生出队，然后向左看齐+向前看齐，学生在 (n,m) 归队。输出每次出队学生的编号。 考虑 n = 1 的情况，可以用一个平衡树维护。 n\\ne 1 的情况，可以用 n 个平衡树维护前 m - 1 列，用一个平衡树单独维护第 m 列。发现我们若是动态开点（一个节点维护一个连续段）的话复杂度可以接受。 难写死了，qnmd。可以考虑直接利用 fhq-treap 的 split 特性，size 维护区间长度。 12345678910111213141516171819void split(int u, ll k) { // 将 u 节点的大小更改为 k if (k &gt;= t[u].r - t[u].l + 1) return; ll want = t[u].l + k - 1; int v = newnode(want + 1, t[u].r); t[u].r = want; rs(u) = merge(v, rs(u)); return pushup(u);}void split(int u, ll sz, int &amp;x, int &amp;y) { if (!u) return x = 0, y = 0, void(); if (t[ls(u)].size &gt;= sz) y = u, split(ls(u), sz, x, ls(u)); else { split(u, sz - t[ls(u)].size); x = u, split(rs(u), sz - t[ls(u)].size - (t[u].r - t[u].l + 1), rs(u), y); } return pushup(u);}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://old.blog.imyangty.com/tags/prefix-sum/"},{"name":"高精度","slug":"bigint","permalink":"https://old.blog.imyangty.com/tags/bigint/"},{"name":"noip","slug":"noip","permalink":"https://old.blog.imyangty.com/tags/noip/"},{"name":"搜索","slug":"searching","permalink":"https://old.blog.imyangty.com/tags/searching/"}]},{"title":"CSP-J 2020 题解","slug":"sol-cspj2020","date":"2021-09-25T05:46:49.000Z","updated":"2022-03-23T04:18:30.745Z","comments":true,"path":"sol-cspj2020/","link":"","permalink":"https://old.blog.imyangty.com/sol-cspj2020/","excerpt":"","text":"前言 临近退役选手来体验一下去年普及组。 T1 优秀的拆分 问能否将一个正整数划分成若干个 2 的正整数次幂之和的形式。 将其化为二进制形式，显然每一位对应一个 2 的次幂。奇数为不可能。 T2 直播获奖 依次给定每个人的分数，分数范围 [0, 600] ，给定获奖率 w\\% ，问每次的获奖分数线。 平衡树查询 kth，普及组，而分数范围很小，开个桶暴力即可。 T3 表达式 给定一个逻辑表达式（只含 \\neg ， \\land 和 \\lor ）的后缀形式，并给出每个元的初始值，每次问取反一个元后表达式的值。表达式长度 1\\le |S|\\le 10^6 ， 1\\le q\\le 10^5 ， 1\\le n\\le 10^5 ，每个询问相互独立。 建出表达式树，然后我们会发现， 0\\land x 和 1\\lor x 中的 x 是不会对答案产生影响的。所以如果在这些子树里面进行操作，答案是不会变的。所以我们对那些可能对答案产生影响的 x 打标记，实现 O(1) 查询，总时间复杂度 O(n + q) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;const int maxn = 1e6 + 5;char str[maxn];int n, a[maxn], mark[maxn];struct node { char ch; int sum, num; node *ls, *rs;};il node* newnode(char c, node *l = NULL, node *r = NULL, int num = -1) { node *cur = new node; cur-&gt;ch = c, cur-&gt;ls = l, cur-&gt;rs = r, cur-&gt;num = num; return cur;}node* stk[maxn];int top;int dfs1(node *u) { if (u-&gt;ch == 0 || u-&gt;ch == 1) return u-&gt;sum = u-&gt;ch; if (u-&gt;ch == '&amp;') return u-&gt;sum = dfs1(u-&gt;ls) &amp; dfs1(u-&gt;rs); else if (u-&gt;ch == '|') return u-&gt;sum = dfs1(u-&gt;ls) | dfs1(u-&gt;rs); else return u-&gt;sum = !dfs1(u-&gt;ls);}void dfs2(node *u) { if (u-&gt;ch == 0 || u-&gt;ch == 1) { mark[u-&gt;num] = 1; return; } int lv = u-&gt;ls-&gt;sum, rv; if (u-&gt;rs != NULL) rv = u-&gt;rs-&gt;sum; if (u-&gt;ch == '&amp;') { if (lv == 1) dfs2(u-&gt;rs); if (rv == 1) dfs2(u-&gt;ls); } else if (u-&gt;ch == '|') { if (lv == 0) dfs2(u-&gt;rs); if (rv == 0) dfs2(u-&gt;ls); } else dfs2(u-&gt;ls);}int main() { fgets(str + 1, 1e6 + 2, stdin); scanf(\"%d\", &amp;n); FOR(i, 1, n) scanf(\"%d\", a + i); for (int i = 1; str[i]; ++i) { if (str[i] != ' ') { if (str[i] == 'x') { int k = 0; ++i; while (isdigit(str[i])) k = 10 * k + (str[i++] - '0'); stk[++top] = newnode(a[k], NULL, NULL, k); } else if (str[i] == '&amp;') { node *x1 = stk[top--], *x2 = stk[top--]; stk[++top] = newnode('&amp;', x1, x2); } else if (str[i] == '|') { node *x1 = stk[top--], *x2 = stk[top--]; stk[++top] = newnode('|', x1, x2); } else if (str[i] == '!') { node *x = stk[top--]; stk[++top] = newnode('!', x); } } } dfs1(stk[top]); dfs2(stk[top]); int q; scanf(\"%d\", &amp;q); while (q--) { int x; scanf(\"%d\", &amp;x); printf(\"%d\\n\", mark[x] ? !stk[top]-&gt;sum : stk[top]-&gt;sum); } return 0;} T4 方格取数 从 (1,1) 出发，走到 (n, m) ，每次只能向右或者向上/下走，问取到的数字之和的最大值。 考虑 dp，令 f(i, j) 为到 (i, j) 的最大值。然后会发现不太可做。 为何？因为走的方向是具有后效性的，遂加一维状态 f(i, j, k) （ k\\in\\{0, 1, 2\\} ，分别表示向右，向上，向下）。于是有转移： \\begin{aligned} f(i, j, 0) &amp;= \\max_{k\\in\\{0, 1, 2\\}}\\{f(i, j - 1, k)\\} + a_{i, j}\\\\ f(i, j, 1) &amp;= \\max_{k\\in\\{0, 1\\}}\\{f(i + 1, j, k)\\} + a_{i, j}\\\\ f(i, j, 2) &amp;= \\max_{k\\in\\{0, 2\\}}\\{f(i - 1, j, k)\\} + a_{i, j} \\end{aligned} 直接转移就行了，答案为 \\max_k\\{f(n, m, k)\\} 。转移的时候先枚举 j 再枚举 i 。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"},{"name":"表达式","slug":"expression","permalink":"https://old.blog.imyangty.com/tags/expression/"}]},{"title":"P3163 [CQOI2014]危桥","slug":"sol-luogu-p3163","date":"2021-09-23T13:40:08.000Z","updated":"2022-03-23T04:18:30.927Z","comments":true,"path":"sol-luogu-p3163/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3163/","excerpt":"","text":"Description n 个岛，有些岛之间有双向桥，有些桥是危桥，只能走两次。 现想在 a_1 和 a_2 间往返 a_n 次，在 b_1 和 b_2 间往返 b_n 次。 问有没有可能。 Solution 显然建超级源和超级汇， (s, a_1, 2a_n) ， (s, b_1, 2a_n) ， (a_2, t, 2b_n) 和 (b_2, t, 2b_n) 。然后危桥容量设为 2 ，剩余桥容量为 +\\inf 。 那么问题来了： 有可能 a_1 出发的流流去了 b_2 ，反之同理。 有可能一个危桥从正向和反向各被经过了两次，共四次。 怎么办呢？我们既然要保证 a_1 的流能流往 a_2 而不是 b_2 ，那不妨交换 b_1 和 b_2 再跑一次最大流，能跑出来 2(a_n + b_n) 就是对的。 证明的话考虑： \\begin{cases} a_1\\to a_2 = a_n - x &amp; a_1\\to b_2 = x\\\\ b_1\\to b_2 = b_n - x &amp; b_1\\to a_2 = x \\end{cases} 交换之后若有 \\begin{cases} a_1\\to a_2 = a_n - y &amp; a_1\\to b_1 = y\\\\ b_2\\to b_1 = b_n - y &amp; b_2\\to a_2 = y \\end{cases} 而流是双向的，所以 a_1\\to b_2\\to a_2 可以有 \\min(x, y) 的流量， b_1\\to a_2\\to b_2 也可以有 \\min(x, y) 的流量，因此如果两次都流满了，说明上面第一种情况不会发生。 第二种情况就是，流都反着流了两遍了，该情况必有一种是不会发生的。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)#define il inlinetemplate&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int maxn = 105, maxm = 20005;const int INF = 1e9;struct edge { int to, nxt, w;} e[maxm &lt;&lt; 1];int head[maxn], dep[maxn], cur[maxn], cnt = 1;int n, m, s, t;il void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].w = 0; e[cnt].nxt = head[v]; head[v] = cnt; return;}bool bfs() { static int q[maxn], qhead, qtail; memset(dep, -1, sizeof dep); memcpy(cur, head, sizeof head); q[qhead = qtail = 1] = s; dep[s] = 0; while (qhead &lt;= qtail) { int u = q[qhead++]; GO(u, head) { if (e[i].w &gt; 0 &amp;&amp; dep[v] == -1) { q[++qtail] = v; dep[v] = dep[u] + 1; if (v == t) return true; } } } return false;}int dfs(int u, int in) { if (u == t) return in; int out = 0; GO(u, cur) { cur[u] = i; if (e[i].w &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) { int res = dfs(v, min(in, e[i].w)); e[i].w -= res, e[i ^ 1].w += res; in -= res, out += res; } if (!in) break; } if (!out) dep[u] = -1; return out;}int dinic() { int ret = 0; while (bfs()) ret += dfs(s, INF); return ret;}char str[55][55];int main() { int n, a1, a2, an, b1, b2, bn; while (~scanf(\"%d %d %d %d %d %d %d\", &amp;n, &amp;a1, &amp;a2, &amp;an, &amp;b1, &amp;b2, &amp;bn)) { ++a1, ++a2, ++b1, ++b2; s = n + 1, t = n + 2; memset(head, 0, sizeof head), cnt = 1; add(s, a1, an &lt;&lt; 1), add(s, b1, bn &lt;&lt; 1); add(a2, t, an &lt;&lt; 1), add(b2, t, bn &lt;&lt; 1); FOR(i, 1, n) scanf(\"%s\", str[i] + 1); FOR(i, 1, n) { FOR(j, 1, n) { if (str[i][j] == 'O') add(i, j, 2); else if (str[i][j] == 'N') add(i, j, INF); } } int flag = 1; flag &amp;= (dinic() == 2 * (an + bn)); memset(head, 0, sizeof head), cnt = 1; add(s, a1, an &lt;&lt; 1), add(s, b2, bn &lt;&lt; 1); add(a2, t, an &lt;&lt; 1), add(b1, t, bn &lt;&lt; 1); FOR(i, 1, n) { FOR(j, 1, n) { if (str[i][j] == 'O') add(i, j, 2); else if (str[i][j] == 'N') add(i, j, INF); } } flag &amp;= (dinic() == 2 * (an + bn)); puts(flag ? \"Yes\" : \"No\"); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"}]},{"title":"P4381 [IOI2008] Island","slug":"sol-luogu-p4381","date":"2021-09-17T15:40:41.000Z","updated":"2022-03-23T04:18:30.989Z","comments":true,"path":"sol-luogu-p4381/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4381/","excerpt":"","text":"Description 给定一片基环森林，求每个基环树连通块的直径和。 以基环内向树的形式给出。 Solution 基环内向树很方便我们直接进行树形 dp 而不用建出真正的森林来。注意到一个环上的点的出边指向的点一定还是环上的点，这很方便我们进行实现。 接下来对于每个联通的基环树考虑。 一个基环树的直径可以有如下两种可能： 经过环的一部分 不经过环，只在子树内 第一步首先拓扑排序找环，然后对环上的每个子树进行树形 dp 找到最长的直径。 然后我们对于环上的每个节点 u ，我们会得到以其为端点在子树内的最大链长 f_u ，记环上两点间最大距离为 d(u, v) ，则我们需要最大化的就是： f_u + f_v + d(u, v) 断环为链，令 p(u) 为环上第 i 个节点的距离，则相当于就是： \\begin{aligned} r_1 &amp;= \\max\\{f_i + f_j + p(j) - p(i)\\}\\\\ r_2 &amp;= \\max\\{f_i + f_j + \\mathrm{len} - p(j) + p(i)\\} \\end{aligned} 的最大值。 然后发现 i 和 j 独立，如果我们令 i&lt;j ， f_1(i) = f_i + p(i) ， f_2(i) = f_i - p(i) ，则 \\begin{aligned} r_1 &amp;= \\max\\{f_2(i) + f_1(j)\\}\\\\ r_2 &amp;= \\max\\{f_1(i) + f_2(j) + \\mathrm{len}\\} \\end{aligned} 扫一遍记录 f_1(i) 和 f_2(i) 的最大值即可，感觉比单调队列方便很多。 答案就是 \\max\\{r_1, r_2, \\mathrm{maxd}\\} 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445using namespace fastIO;typedef long long ll;const int maxn = 1e6 + 5;int n, to[maxn], w[maxn], deg[maxn];int q[maxn], head, tail;ll f[maxn], g[maxn];template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}ll work(int rt) { int u = rt; ll f1 = f[u], f2 = f[u], pre = w[u], r1 = g[u], r2 = -1e18; u = to[u]; while (u != rt) { deg[u] = 0; r1 = max(r1, f[u] + pre + f2); r2 = max(r2, f[u] - pre + f1); r1 = max(r1, g[u]); f1 = max(f1, f[u] + pre); f2 = max(f2, f[u] - pre); pre += w[u]; u = to[u]; } return max(r1, r2 + pre);}int main() { read(n); FOR(i, 1, n) read(to[i]), read(w[i]), ++deg[to[i]]; head = 1, tail = 0; FOR(i, 1, n) if (!deg[i]) q[++tail] = i; while (head &lt;= tail) { int u = q[head++]; g[to[u]] = max(g[to[u]], f[to[u]] + f[u] + w[u]); g[to[u]] = max(g[to[u]], g[u]); f[to[u]] = max(f[to[u]], f[u] + w[u]); if (!--deg[to[u]]) q[++tail] = to[u]; } ll ans = 0; FOR(i, 1, n) if (deg[i]) ans += work(i); print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"树的直径","slug":"diameter-of-tree","permalink":"https://old.blog.imyangty.com/tags/diameter-of-tree/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"基环树","slug":"tree-with-cycle","permalink":"https://old.blog.imyangty.com/tags/tree-with-cycle/"}]},{"title":"P4099 [HEOI2013]SAO","slug":"sol-luogu-p4099","date":"2021-09-17T12:01:05.000Z","updated":"2022-03-23T04:18:30.977Z","comments":true,"path":"sol-luogu-p4099/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4099/","excerpt":"","text":"Description Welcome to SAO ( Strange and Abnormal Online)。这是一个 VR MMORPG， 含有 n 个关卡。但是，挑战不同关卡的顺序是一个很大的问题。 有 n – 1 个对于挑战关卡的限制，诸如第 i 个关卡必须在第 j 个关卡前挑战， 或者完成了第 k 个关卡才能挑战第 l 个关卡。并且，如果不考虑限制的方向性， 那么在这 n – 1 个限制的情况下，任何两个关卡都存在某种程度的关联性。即， 我们不能把所有关卡分成两个非空且不相交的子集，使得这两个子集之间没有任何限制。 求挑战关卡的顺序数量，答案对 10^9 + 7 取模。 n\\le 2000 。 Solution 这是一个树形图，唯一的区别是一个节点可能有不止一个父亲。但是依旧可以考虑树形 dp 的思路，任意定根来进行 dp，但是如果设 f_{i} 为以 i 为根的子树的拓扑序个数貌似不是很好做。 考虑设 f_{i, j} 为 i 在 i 子树中的排名为 j 的方案数。然后就需要考虑如何进行转移了。 考虑 f_{u, k} ， v 为和 u 有边的点，由于其是一个树形图，所以分两种情况讨论： Part. 1 第一种即为 v 连向 u ，注意到在这种情况中 v 必须在 u 的前面。假设现在在合并 f_{u, k_1} 和 f_{v, k_2} ，最后得到 f_{u, k} 。 可以发现， u 之前的元素有 k - 1 个， u 之前在 u 子树内的元素有 k_1 - 1 个， 所以相当于要把 v 子树内的元素合并到这个序列里面。有 \\dbinom{k - 1}{k_1 - 1} 种方案（要保证合并后 u ， v 内元素相对位置不变）；同理， u 后面在 u 子树内的元素有 \\operatorname{size}(u) - k_1 个，合并后 u 后面有 \\operatorname{size}(u) + \\operatorname{size}(v) - k 个位置，所以这部分的方案数是 \\dbinom{\\operatorname{size}(u) + \\operatorname{size}(v) - k}{\\operatorname{size}(u) - k_1} dp 转移方程就是这样子的： f'_{u, k} = \\sum_{k_1 = 1}^{\\operatorname{size}(u)}\\sum_{k_2 = 1}^{\\operatorname{size}(v)}f_{u, k_1}\\times f_{v, k_2} \\times\\binom{k - 1}{k_1 - 1}\\times\\binom{\\operatorname{size}(u) + \\operatorname{size}(v) - k}{\\operatorname{size}(u) - k_1} f' 是为了防止算重，因为前后的意义不一样。 k 的范围是有限制的，是 [k_1 + k_2, \\operatorname{size}(u) + \\operatorname{size}(v)] 。 u 连向 v 的也是一个道理，转移方程是一样的。但是 k 的范围为 [k_1, k_1 + k_2 - 1] 。 k_1 ， k_2 ， k 都需要枚举，按照这个写代码可以获得 40 分的好成绩，时间复杂度 O(n^3) 。 Part. 2 考虑优化，注意到这个 k_2 似乎只出现了一次。可以考虑前缀和优化，首先调换一下枚举的顺序： 对于 v 连向 u 的情况，有 k\\in[k_1 + 1, \\operatorname{size}(u) + \\operatorname{size}(v)] ，然后发现 k_2 的范围即为 [1, k - k_1] 。 对于 u 连向 v 的情况，有 k\\in[k_1, k_1 + \\operatorname{size}(v) - 1] ， k_2 范围即为 [k - k_1 + 1, \\operatorname{size}(v)] 。 然后就可以前缀和优化端掉 k_2 这一维。 时间复杂度直接变成 O(n^2) ，卡卡常可过此题。 需要注意维护一个另外的数组防止贡献被重复计算。 答案为 \\sum_{i}f_{1, i} 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)const int mod = 1e9 + 7;struct modint { typedef int INT; static const INT mod = ::mod; INT val; il void check() { val &gt;= mod ? val %= mod : true; val &lt; 0 ? (val %= mod) += mod : true; return; } modint(INT v = 0) : val(v) {check();} il modint &amp;operator=(INT v) {return val = v, *this;} il modint &amp;operator+=(modint rhs) {return val = val + rhs.val &gt;= mod ? val + rhs.val - mod : val + rhs.val, *this;} il modint &amp;operator-=(modint rhs) {return val = val - rhs.val &lt; 0 ? val - rhs.val + mod : val - rhs.val, *this;} il modint &amp;operator*=(modint rhs) {return val = 1ll * val * rhs.val % mod, *this;} il friend modint operator+(const modint &amp;lhs, const modint &amp;rhs) {return modint(lhs) += rhs;} il friend modint operator-(const modint &amp;lhs, const modint &amp;rhs) {return modint(lhs) -= rhs;} il friend modint operator*(const modint &amp;lhs, const modint &amp;rhs) {return modint(lhs) *= rhs;} il friend bool operator==(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val == rhs.val;} il friend bool operator!=(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val != rhs.val;} il friend bool operator&gt;(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &gt; rhs.val;} il friend bool operator&lt;(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &lt; rhs.val;} il friend bool operator&gt;=(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &gt;= rhs.val;} il friend bool operator&lt;=(const modint &amp;lhs, const modint &amp;rhs) {return lhs.val &lt;= rhs.val;} il modint &amp;operator++() { ++val; if (val == mod) val = 0; return *this; } il modint &amp;operator--() { if (val == 0) val = mod; --val; return *this; } il modint operator++(int) { modint ret = *this; ++*this; return ret; } il modint operator--(int) { modint ret = *this; --*this; return ret; } il modint operator+() const {return *this;} il modint operator-() const {return modint() - *this;} friend modint qPow(modint base, modint exp) { base.check(); modint ret = 1; for (INT p = exp.val; p; p &gt;&gt;= 1, base *= base) if (p &amp; 1) ret *= base; return ret; }};const int maxn = 1005;modint binom[maxn][maxn];int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], w[maxn &lt;&lt; 1], cnte, size[maxn];modint f[maxn][maxn], g[maxn];il void add(int u, int v, int _w) { to[++cnte] = v; nxt[cnte] = head[u]; w[cnte] = _w; head[u] = cnte; return;}void dfs(int u, int fa) { f[u][1] = size[u] = 1; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v == fa) continue; dfs(v, u); memcpy(g, f[u], sizeof g); memset(f[u], 0, sizeof f[u]); if (w[i]) FOR(k1, 1, size[u]) FOR(k, k1, k1 + size[v] - 1) f[u][k] += g[k1] * (f[v][size[v]] - f[v][k - k1]) * binom[k - 1][k1 - 1] * binom[size[u] + size[v] - k][size[u] - k1]; else FOR(k1, 1, size[u]) FOR(k, k1 + 1, size[u] + size[v]) f[u][k] += g[k1] * f[v][k - k1] * binom[k - 1][k1 - 1] * binom[size[u] + size[v] - k][size[u] - k1]; size[u] += size[v]; } FOR(i, 1, size[u]) f[u][i] += f[u][i - 1]; return;}int main() { binom[0][0] = binom[1][0] = binom[1][1] = 1; FOR(i, 2, 1000) { binom[i][0] = binom[i][i] = 1; FOR(j, 1, i - 1) binom[i][j] = binom[i - 1][j] + binom[i - 1][j - 1]; } int T; scanf(\"%d\", &amp;T); while (T--) { memset(head, 0, sizeof head), cnte = 0; scanf(\"%d\", &amp;n); FOR(i, 1, n - 1) { int u, v; char ch; scanf(\"%d %c %d\", &amp;u, &amp;ch, &amp;v); ++u, ++v; add(u, v, ch == '&lt;'); add(v, u, ch == '&gt;'); } dfs(1, 0); printf(\"%d\\n\", f[1][n].val); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://old.blog.imyangty.com/tags/prefix-sum/"}]},{"title":"P2053 [SCOI2007]修车","slug":"sol-luogu-p2053","date":"2021-09-17T09:33:09.000Z","updated":"2022-03-23T04:18:30.875Z","comments":true,"path":"sol-luogu-p2053/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2053/","excerpt":"","text":"Description 同一时刻有 N 位车主带着他们的爱车来到了汽车维修中心。 维修中心共有 M 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。 现在需要安排这 M 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。 说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 2\\le M\\le 9 ， 1\\le N\\le 60 。 Solution 直接考虑似乎不是很好搞，考虑费用的提前计算，一个车在第 j 个技术员倒数第 i 个被修会对总时长产生 i\\times T_{i, j} 的贡献。 所以，相当于就是一张二分图，左部为每辆车，右边为技术员倒数第几个修，连边，流量为 1 ，费用为对应的 i\\times T_{i, j} ，跑最小费用最大流即可。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int INF = 1e9;const int maxn = 10000 + 5, maxm = 2e5 + 5;struct edge { int to, nxt, w, c;} e[maxm &lt;&lt; 1];int head[maxn], cnt = 1, s, t;il void add(int u, int v, int w, int c) { e[++cnt].to = v, e[cnt].w = w, e[cnt].c = c; e[cnt].nxt = head[u], head[u] = cnt; e[++cnt].to = u, e[cnt].w = 0, e[cnt].c = -c; e[cnt].nxt = head[v], head[v] = cnt; return;}namespace MCMF {int dis[maxn], flow[maxn], maxflow, mincost;int pre[maxn], inq[maxn];bool SPFA() { memset(inq, 0, sizeof inq); memset(dis, 0x3f, sizeof dis); std::queue&lt;int&gt; q; q.push(s); inq[s] = 1, dis[s] = 0; flow[s] = INF; while (!q.empty()) { int u = q.front(); q.pop(); inq[u] = 0; GO(u, head) { if (e[i].w &gt; 0 &amp;&amp; dis[u] + e[i].c &lt; dis[v]) { dis[v] = dis[u] + e[i].c; flow[v] = min(flow[u], e[i].w); pre[v] = i; if (!inq[v]) { inq[v] = 1; q.push(v); } } } } return dis[t] &lt; INF;}void update() { int now = t; while (now != s) { int i = pre[now]; e[i].w -= flow[t], e[i ^ 1].w += flow[t]; now = e[i ^ 1].to; } maxflow += flow[t]; mincost += flow[t] * dis[t]; return;}void MCMF() { while (SPFA()) update(); return;}} // namespace MCMFint n, m;int main() { read(m), read(n); s = n + n * m + 1, t = s + 1; FOR(i, 1, n) { add(s, i, 1, 0); FOR(j, 1, m) { int T; read(T); FOR(k, 1, n) add(i, n + (j - 1) * n + k, 1, k * T); add(n + (j - 1) * n + i, t, 1, 0); } } MCMF::MCMF(); printf(\"%.2lf\\n\", (double)MCMF::mincost / (double)n); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"费用流","slug":"mincostflow","permalink":"https://old.blog.imyangty.com/tags/mincostflow/"}]},{"title":"P4313 文理分科","slug":"sol-luogu-p4313","date":"2021-09-16T12:42:53.000Z","updated":"2022-03-23T04:18:30.987Z","comments":true,"path":"sol-luogu-p4313/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4313/","excerpt":"","text":"Description 一个 n\\times m 的矩阵，每个格子要么选 1 要么选 0 ，选 1 会获得 art_{i, j} 的满意度，否则会获得 science_{i,j} 的满意度，若 (i, j) 选了 1 且四联通的格子都选 1 ，则获得 same\\_art_{i, j} 的满意度，若 0 且四联通都 0 ，则获得 same\\_science_{i,j} 的满意度。 Solution 回顾集合划分模型，本题相当于就要把所有点划分到理科和文科两个集合里面去。 从 S 向 (i, j) 连容量为 art_{i, j} 的边，从 (i, j) 向 T 连容量为 science_{i, j} 的边。 然后对于四联通的限制，可以单独开一个点，从 S 向 (i, j)_1 连 same\\_art_{i, j} 的边，从 (i, j)_2 向 T 连 same\\_science_{i, j} 的边。问题就是四联通如何去处理。 回忆：只要不被割断就是选到一个集合里面。 所以从 (i, j)_1 向五个对应的 (i', j') 连 \\inf 边，从五个对应的 (i', j') 向 (i, j)_2 连 \\inf 边。、 用总收益减去最小割即可。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)#define il inlinenamespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int maxn = 50005, maxm = 2e5 + 5;const int INF = 1e9;struct edge { int to, nxt, w;} e[maxm &lt;&lt; 1];int head[maxn], dep[maxn], cur[maxn], cnt = 1;int s, t;il void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].w = 0; e[cnt].nxt = head[v]; head[v] = cnt; return;}bool bfs() { static int q[maxn], qhead, qtail; memset(dep, -1, sizeof dep); memcpy(cur, head, sizeof head); q[qhead = qtail = 1] = s; dep[s] = 0; while (qhead &lt;= qtail) { int u = q[qhead++]; GO(u, head) { if (e[i].w &gt; 0 &amp;&amp; dep[v] == -1) { q[++qtail] = v; dep[v] = dep[u] + 1; if (v == t) return true; } } } return false;}int dfs(int u, int in) { if (u == t) return in; int out = 0; GO(u, cur) { cur[u] = i; if (e[i].w &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) { int res = dfs(v, min(in, e[i].w)); e[i].w -= res, e[i ^ 1].w += res; in -= res, out += res; } if (!in) break; } if (!out) dep[u] = -1; return out;}int dinic() { int ret = 0; while (bfs()) ret += dfs(s, INF); return ret;}int n, m;il int get_id(int x, int y, int k) {return (x - 1) * m + y + k * n * m;}il bool check(int x, int y) {return 1 &lt;= x &amp;&amp; x &lt;= n &amp;&amp; 1 &lt;= y &amp;&amp; y &lt;= m;}const int fx[] = {0, 0, 1, -1};const int fy[] = {1, -1, 0, 0};int main() { read(n), read(m); s = 3 * n * m + 1, t = s + 1; int sum = 0; FOR(i, 1, n) { FOR(j, 1, m) { int art; read(art); sum += art; add(s, get_id(i, j, 0), art); } } FOR(i, 1, n) { FOR(j, 1, m) { int science; read(science); sum += science; add(get_id(i, j, 0), t, science); } } FOR(i, 1, n) { FOR(j, 1, m) { int sameart; read(sameart); sum += sameart; add(s, get_id(i, j, 1), sameart); add(get_id(i, j, 1), get_id(i, j, 0), INF); FOR(k, 0, 3) { int tx = i + fx[k], ty = j + fy[k]; if (!check(tx, ty)) continue; add(get_id(i, j, 1), get_id(tx, ty, 0), INF); } } } FOR(i, 1, n) { FOR(j, 1, m) { int samescience; read(samescience); sum += samescience; add(get_id(i, j, 2), t, samescience); add(get_id(i, j, 0), get_id(i, j, 2), INF); FOR(k, 0, 3) { int tx = i + fx[k], ty = j + fy[k]; if (!check(tx, ty)) continue; add(get_id(tx, ty, 0), get_id(i, j, 2), INF); } } } print(sum - dinic()); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最小割","slug":"mincut","permalink":"https://old.blog.imyangty.com/tags/mincut/"}]},{"title":"P3515 [POI2011]Lightning Conductor","slug":"sol-luogu-p3515","date":"2021-09-14T13:27:55.000Z","updated":"2022-03-23T04:18:30.952Z","comments":true,"path":"sol-luogu-p3515/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3515/","excerpt":"","text":"Description 给定 \\{a_i\\} ，对于每个 i 求出一个最小正整数 p_i 使得 \\forall j 有 a_j\\le a_i + p_i - \\sqrt{|i - j|} 。 Solution 变换一下式子，将要求的放在一边： p_i\\ge a_j - a_i + \\sqrt{|i - j|} 即为 p_i = \\max_j\\{a_j + \\sqrt{|i - j|}\\} - a_i 。把绝对值拆开就是 p_i = \\max\\{\\max_{j = 1}^{i}\\{a_j + \\sqrt{i - j}\\}, \\max_{j = i+ 1}^n\\{a_j + \\sqrt{j - i}\\}\\} - a_i 后面那个东西就是把序列翻转过来再做一次，所以考虑求 f_i = \\max_{j = 1}^{i - 1}\\{a_j + \\sqrt{i - j}\\} 然后再取两遍的最大值。 打表发现决策单调性之后分治或者二分队列即可。 Implementation 预处理 sqrt 函数的 n 个值会快一些。 分治写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;typedef double db;const int maxn = 5e5 + 5;int a[maxn], n;db p[maxn], sq[maxn];template&lt;typename T&gt; il void swap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}void solve(int l, int r, int L, int R) { if (l &gt; r) return; int mid = (l + r) &gt;&gt; 1, k; db mx = 0, tmp; for (int j = L; j &lt;= mid &amp;&amp; j &lt;= R; ++j) if ((tmp = a[j] + sq[mid - j]) &gt; mx) mx = tmp, k = j; p[mid] = max(p[mid], mx); solve(l, mid - 1, L, k); solve(mid + 1, r, k, R); return;}int main() { read(n); FOR(i, 1, n) sq[i] = sqrt(i), read(a[i]); solve(1, n, 1, n); FOR(i, 1, n / 2) swap(a[i], a[n - i + 1]), swap(p[i], p[n - i + 1]); solve(1, n, 1, n); DEC(i, n, 1) print((int)ceil(p[i]) - a[i]), putchar('\\n'); return output(), 0;} 二分写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;typedef double db;const int maxn = 5e5 + 5;int a[maxn], n, q[maxn], head, tail, k[maxn];db f[maxn], sq[maxn];template&lt;typename T&gt; il void swap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}il db calc(int i, int j) {return a[j] + sq[i - j];}int bound(int x, int y) { int l = y, r = k[x] ? k[x] : n, mid, ret = r + 1; while (l &lt;= r) { mid = (l + r) &gt;&gt; 1; if (calc(mid, x) &lt;= calc(mid, y)) ret = mid, r = mid - 1; else l = mid + 1; } return ret;}void solve() { memset(k, 0, sizeof k); head = 1, tail = 0; FOR(i, 1, n) { while (head &lt; tail &amp;&amp; calc(k[tail - 1], q[tail]) &lt; calc(k[tail - 1], i)) --tail; k[tail] = bound(q[tail], i), q[++tail] = i; while (head &lt; tail &amp;&amp; k[head] &lt;= i) ++head; f[i] = max(f[i], calc(i, q[head])); } return;}int main() { read(n); FOR(i, 1, n) sq[i] = sqrt(i), read(a[i]); solve(); FOR(i, 1, n / 2) swap(a[i], a[n - i + 1]), swap(f[i], f[n - i + 1]); solve(); DEC(i, n, 1) print((int)ceil(f[i]) - a[i]), putchar('\\n'); return output(), 0;} Proof 决策单调性的证明： 此处 f_i = \\max\\{a_j+ \\sqrt{i - j}\\} ，令 w(a, b) = \\sqrt{b - a} （ b &gt; a ）。假设 w(a, c) 中 a + 1 &lt; c ，则 \\begin{aligned} w(a, c) &amp;= \\sqrt{c - a}\\\\ w(a + 1, c) &amp;= \\sqrt{c - a - 1}\\\\ w(a, c + 1) &amp;= \\sqrt{c + 1 - a}\\\\ w(a + 1, c + 1) &amp;= \\sqrt{c - a} \\end{aligned} 令 d = c - a ，则 \\begin{aligned} w(a, c) + w(a + 1, c + 1) &amp;= 2\\sqrt d \\\\ w(a, c + 1) + w(a + 1, c) &amp;= \\sqrt{d - 1} + \\sqrt{d + 1} \\end{aligned} 不难发现 2\\sqrt d - \\sqrt{d - 1} -\\sqrt{d + 1} = (\\sqrt{d} - \\sqrt{d - 1}) - (\\sqrt{d + 1} - \\sqrt d) f(x) = \\sqrt x - \\sqrt{x - 1} 为减函数，所以上式大于 0 。 w(a, c) + w(a + 1, c + 1)\\ &gt; w(a, c + 1) + w(a + 1, c) 即交叉大于包含，而我们要求的是最大值，所以四边形不等式成立，该方程具有决策单调性。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"决策单调性优化","slug":"mono-opti-dp","permalink":"https://old.blog.imyangty.com/tags/mono-opti-dp/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"栈","slug":"stack","permalink":"https://old.blog.imyangty.com/tags/stack/"}]},{"title":"CF1237F Balanced Domino Placements","slug":"sol-cf1237f","date":"2021-09-14T09:23:56.000Z","updated":"2022-03-23T04:18:30.676Z","comments":true,"path":"sol-cf1237f/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1237f/","excerpt":"","text":"Description 给定一个 n\\times m 的棋盘，上面已经有 k 个 1\\times 2 骨牌。对于一个骨牌的每个格子，其不能与其他骨牌在一行或一列。问在剩下的格子里放骨牌的方案数，对 998244353 取模。 Solution 本题的一个很重要的思想就是行列独立。即我们可以分开考虑每行和每列。 枚举放了 x 个横向骨牌和 y 个纵向骨牌，则我们知道这 x 个横向骨牌占了 x 行和 x 对相邻的列， y 个纵向骨牌占了 y 列和 y 对相邻的行。我们对这个东西进行 dp。 设 f_{i, j} 为前 i 行选了 j 对相邻的行的方案数， g_{i, j} 为前 i 列选了 j 对相邻的列的方案数。令 n' 和 m' 为摆了 k 个后，初始的可用行和可用列数量，则不难发现答案为 \\sum_{x = 1}^{\\lfloor n'/2\\rfloor}\\sum_{y = 1}^{\\lfloor m'/2\\rfloor}f_{n, x}\\times g_{m, y}\\times\\binom{m' - 2y}{x}\\times\\binom{n' - 2x}{y}\\times x!\\times y! 最后那个 x! 是因为 f_{n, x} 对相邻行和那 x 个列有 x! 种搭配方案， y! 同理。 Implementation 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {}using namespace fastIO;const int maxn = 3600 + 5;int n, m, k;modint fac[maxn], invfac[maxn];int visx[maxn], visy[maxn], nn, mm;modint f[maxn][maxn], g[maxn][maxn];modint binom(int n, int m) { if (n &lt; m || n &lt; 0 || m &lt; 0) return 0; return fac[n] * invfac[n - m] * invfac[m];}int main() { fac[0] = 1; FOR(i, 1, 3600) fac[i] = i * fac[i - 1]; invfac[3600] = qPow(fac[3600], mod - 2); DEC(i, 3600 - 1, 0) invfac[i] = (i + 1) * invfac[i + 1]; read(n), read(m), read(k); FOR(i, 1, k) { int x1, y1, x2, y2; read(x1), read(y1), read(x2), read(y2); visx[x1] = visx[x2] = 1; visy[y1] = visy[y2] = 1; } FOR(i, 1, n) nn += (!visx[i]); FOR(i, 1, m) mm += (!visy[i]); f[0][0] = 1; FOR(i, 1, n) FOR(j, 0, nn / 2) f[i][j] = f[i - 1][j] + ((j &amp;&amp; i &gt; 1 &amp;&amp; !visx[i] &amp;&amp; !visx[i - 1]) ? f[i - 2][j - 1] : 0); g[0][0] = 1; FOR(i, 1, m) FOR(j, 0, mm / 2) g[i][j] = g[i - 1][j] + ((j &amp;&amp; i &gt; 1 &amp;&amp; !visy[i] &amp;&amp; !visy[i - 1]) ? g[i - 2][j - 1] : 0); modint ans = 0; FOR(x, 0, nn / 2) { FOR(y, 0, mm / 2) { ans += f[n][x] * g[m][y] * fac[x] * fac[y] * binom(mm - 2 * y, x) * binom(nn - 2 * x, y); } } print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"CF338D GCD Table","slug":"sol-cf338d","date":"2021-09-12T13:43:51.000Z","updated":"2022-03-23T04:18:30.703Z","comments":true,"path":"sol-cf338d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf338d/","excerpt":"","text":"Description 给定一张 n\\times m 的数表， G(i, j) 是 \\gcd(i, j) 。 给定一个长度为 k 的序列 \\{a_i\\} ，问是否存在 (i, j) （ 1\\le i\\le n ， 1\\le j\\le m - k + 1 ），使得 \\forall 1\\le l\\le k ，都有 G(i, j + l - 1) = a_l 。 1\\le n, m, a_i\\le 10^{12} ， 1\\le k\\le 10000 。 Solution 观察限制： \\gcd(x, y + i - 1) = a_i ，则有 \\begin{aligned} ka_i &amp;= y + i - 1\\\\ y + i - 1 &amp;\\equiv 0\\pmod {a_i}\\\\ y &amp;\\equiv 1 - i\\pmod {a_i} \\end{aligned} 然后一定有 a_i\\mid x ，所以 \\operatorname{lcm}\\{a_i\\}\\mid x 。 所以当 x = k\\operatorname{lcm}\\{a_i\\} 时一定是有解的，exCRT 解出 y 之后检查 x = \\operatorname{lcm}\\{a_i\\} 即可。 Implementation 注意 exCRT 解出来可能有 y = 0 的情况，需要加一句特判。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;typedef long long ll;ll n, m, k, a[10005], mod[10005], r[10005];ll exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if (!b) { x = 1, y = 0; return a; } ll tmp = exgcd(b, a % b, y, x); y -= a / b * x; return tmp;}il ll gcd(ll a, ll b) {return !b ? a : gcd(b, a % b);}typedef long double ldb;il ll mul(ll a, ll b, ll mod) { return (a * b - (ll)((ldb)a / mod * b) * mod + mod) % mod;}ll exCRT(ll *r, ll *m, int n) { for (int i = 2; i &lt;= n; ++i) { ll tmpx, tmpy; ll gcd = exgcd(m[i], m[i - 1], tmpx, tmpy); ll p1 = m[i - 1] / gcd, p2 = m[i] / gcd; exgcd(p1, p2, tmpx, tmpy); m[i] = m[i] / gcd * m[i - 1]; r[i] = (r[i - 1] + mul(m[i - 1], mul((r[i] - r[i - 1]) / gcd, tmpx, m[i]), m[i])) % m[i]; } return (r[n] + m[n] - 1) % m[n] + 1;}int main() { read(n), read(m), read(k); ll x = 1; FOR(i, 1, k) { read(a[i]); x = x / gcd(x, a[i]) * a[i]; if (x &gt; n) return puts(\"NO\"), 0; r[i] = ((a[i] + 1 - i) % a[i] + a[i]) % a[i]; mod[i] = a[i]; } ll y = exCRT(r, mod, k); if (y + k - 1 &gt; m || y &lt; 1) return puts(\"NO\"), 0; FOR(i, 1, k) if (gcd(x, y + i - 1) != a[i]) return puts(\"NO\"), 0; return puts(\"YES\"), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"中国剩余定理","slug":"crt","permalink":"https://old.blog.imyangty.com/tags/crt/"}]},{"title":"P2805 [NOI2009] 植物大战僵尸","slug":"sol-luogu-p2805","date":"2021-09-11T03:52:40.000Z","updated":"2022-03-23T04:18:30.916Z","comments":true,"path":"sol-luogu-p2805/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2805/","excerpt":"","text":"Description 一个 N\\times M 的矩阵，记第 r 行 c 列的植物为 P_{r, c} ，每个植物有如下属性： \\operatorname{Score}(P_{r, c}) ：僵尸击溃 P_{r, c} 能获得的能源。 \\operatorname{Attack}(P_{r, c}) ：该植物能攻击到的位置集合。 一旦某个僵尸进入某植物的攻击位置，僵尸就会立即死亡。僵尸只能从右往左吃植物。 问僵尸们能获得的最大能源收益。 Solution 发现我们有如下关系： 吃掉能攻击到 (r, c) 的植物才能吃掉 P_{r, c} ； 吃掉 P_{r, c + 1} 才能吃掉 P_{r, c} 。 不难发现其是一个形如“做了 A 才能做 B，且每个事件有一定收益”的模型。 就是一个最大权闭合图，建出来然后直接跑最小割即可。 然而会发现连样例都过不去。 原因是：存在着互相依赖的植物，即 A 保护 B，B 也保护 A。这样子用最大权闭合图算出来的是错的答案，因为僵尸不可能吃掉这个环。 所以要先对原图拓扑排序一遍，将环删掉，然后再跑最大权闭合图。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)#define il inlinenamespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int maxn = 1200, maxm = 1e6 + 5;const int INF = 1e9;struct edge { int to, nxt, w;} e[maxm &lt;&lt; 1];int head[maxn], dep[maxn], cur[maxn], cnt = 1;int s, t;il void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].w = 0; e[cnt].nxt = head[v]; head[v] = cnt; return;}bool bfs() { static int q[maxn], qhead, qtail; memset(dep, -1, sizeof dep); memcpy(cur, head, sizeof head); q[qhead = qtail = 1] = s; dep[s] = 0; while (qhead &lt;= qtail) { int u = q[qhead++]; GO(u, head) { if (e[i].w &gt; 0 &amp;&amp; dep[v] == -1) { q[++qtail] = v; dep[v] = dep[u] + 1; if (v == t) return true; } } } return false;}int dfs(int u, int in) { if (u == t) return in; int out = 0; GO(u, cur) { cur[u] = i; if (e[i].w &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) { int res = dfs(v, min(in, e[i].w)); e[i].w -= res, e[i ^ 1].w += res; in -= res, out += res; } if (!in) break; } if (!out) dep[u] = -1; return out;}int dinic() { int ret = 0; while (bfs()) ret += dfs(s, INF); return ret;}int n, m, val[maxn], ind[maxn], vis[maxn];std::vector&lt;int&gt; e0[maxn];il int encode(int x, int y) {return (x - 1) * m + y;}void topo() { static int q[maxn], head, tail; FOR(u, 1, n * m) if (!ind[u]) q[++tail] = u, vis[u] = 1; while (head &lt;= tail) { int u = q[head++]; for (auto v : e0[u]) if (!vis[v] &amp;&amp; !--ind[v]) q[++tail] = v, vis[v] = 1; } return;}int main() { read(n), read(m); s = n * m + 1, t = s + 1; int tot = 0, sum = 0; FOR(i, 1, n) { FOR(j, 1, m) { ++tot; int w; read(val[tot]), read(w); while (w--) { int tr, tc; read(tr), read(tc); e0[tot].push_back(encode(++tr, ++tc)); ++ind[encode(tr, tc)]; } if (j &lt; m) e0[tot + 1].push_back(tot), ++ind[tot]; } } topo(); FOR(u, 1, n * m) { if (!vis[u]) continue; for (auto v : e0[u]) { if (!vis[v]) continue; add(v, u, INF); } if (val[u] &gt;= 0) add(s, u, val[u]), sum += val[u]; else add(u, t, -val[u]); } print(sum - dinic()); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最小割","slug":"mincut","permalink":"https://old.blog.imyangty.com/tags/mincut/"}]},{"title":"P3321 [SDOI2015]序列统计","slug":"sol-luogu-p3321","date":"2021-09-04T15:13:03.000Z","updated":"2022-03-23T04:18:30.950Z","comments":true,"path":"sol-luogu-p3321/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3321/","excerpt":"","text":"Description 给定集合 S ，保证里面元素 x 有 0\\le x &lt; m 。现要生成长度为 n 的数列 A 使得 \\forall i\\in [1, n],A_i\\in S ，且 \\prod A_i\\bmod m = x 。求方案数模 1004535809 Solution 如果是问 \\sum A_i\\bmod m = x 是好做的，多项式快速幂就行了。 但是这个乘积不太好搞啊！ 化乘为加有个特别常用的技巧就是两边同时取对数。我们这样定义对数：随便找一个底数 a ，求出 a^x, x\\in[1, m - 1] ，然后就有 \\log_a(a^x\\bmod m) = x 。既然要 a^x 两两不同，那么这个 a 显然就是 m 的原根。 \\begin{aligned} \\prod_{i = 1}^nA_i \\bmod m &amp;= x\\\\ \\sum_{i = 1}^n\\log_gA_i &amp;=\\log_gx \\end{aligned} 所以我们把 A_i 和 x 取对数，把生成函数表示出来后多项式快速幂就行了（常数项不满足能 \\ln 的要求所以不太能用 O(m\\log m) 的快速幂）。由于 0 不会对答案产生贡献所以可以忽略 0 。注意一下是模 m - 1 的循环卷积。 复杂度 O(m\\log^2m) 。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)#define VEC(i, v) for (int i = 0; i &lt; (int)v.size(); ++i)#define il inline#define clr(f, n) memset(f, 0, (sizeof(int)) * (n))#define cpy(f, g, n) memcpy(f, g, (sizeof(int)) * (n))template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}typedef long long ll;typedef unsigned long long ull;const int mod = 1004535809;const int maxn = 1 &lt;&lt; 17 | 500;ll qPow(ll a, ll b = mod - 2) { ll ret = 1; for (; b; b &gt;&gt;= 1, a = a * a % mod) if (b &amp; 1) ret = a * ret % mod; return ret;}int tr[maxn &lt;&lt; 1], revLim;void getTr(int n) { if (revLim == n) return; revLim = n; FOR(i, 0, n - 1) tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (n &gt;&gt; 1) : 0);}const int G = 3, invG = qPow(G);void DFT(int *g, bool op, int n) { getTr(n); static ull f[maxn &lt;&lt; 1], w[maxn &lt;&lt; 1]; w[0] = 1; FOR(i, 0, n - 1) f[i] = (((ll)mod &lt;&lt; 5ll) + g[tr[i]]) % mod; for (int l = 1; l &lt; n; l &lt;&lt;= 1) { ull tG = qPow(op ? G : invG, (mod - 1) / (l &lt;&lt; 1)); FOR(i, 1, l - 1) w[i] = w[i - 1] * tG % mod; for (int k = 0; k &lt; n; k += (l &lt;&lt; 1)) for (int p = 0; p &lt; l; ++p) { int tt = w[p] * f[k | l | p] % mod; f[k | l | p] = f[k | p] + mod - tt; f[k | p] += tt; } if (l == (1 &lt;&lt; 10)) FOR(i, 0, n - 1) f[i] %= mod; } if (!op) { ull invn = qPow(n); FOR(i, 0, n - 1) g[i] = f[i] % mod * invn % mod; } else FOR(i, 0, n - 1) g[i] = f[i] % mod;}namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;int n, m, x, S;int a[8005], Log[8005];int f[maxn], ans[maxn];bool check(int g, int m) { int vis[8005] = {0}; for (int i = 0, tmp = 1; i &lt; m - 1; ++i, tmp = 1ll * tmp * g % m) { ++vis[tmp]; if (vis[tmp] &gt; 1) return 0; } return 1;}void getG(int m) { int g; FOR(i, 2, m - 1) { if (check(i, m)) { g = i; break; } } for (int i = 0, tmp = 1; i &lt; m - 1; ++i, tmp = 1ll * tmp * g % m) Log[tmp] = i; return;}int lim;int main() { read(n), read(m), read(x), read(S); for (lim = 1; lim &lt; m; lim &lt;&lt;= 1); lim &lt;&lt;= 1; getG(m); FOR(i, 1, S) { int a; read(a), a %= m; if (!a) continue; f[Log[a]] = 1; } ans[0] = 1; for (; n; n &gt;&gt;= 1) { DFT(f, 1, lim); if (n &amp; 1) { DFT(ans, 1, lim); FOR(i, 0, lim - 1) ans[i] = 1ll * ans[i] * f[i] % mod; DFT(ans, 0, lim); DEC(i, lim - 1, m - 1) ans[i - m + 1] = (ans[i] + ans[i - m + 1]) % mod, ans[i] = 0; } FOR(i, 0, lim - 1) f[i] = 1ll * f[i] * f[i] % mod; DFT(f, 0, lim); DEC(i, lim - 1, m - 1) f[i - m + 1] = (f[i] + f[i - m + 1]) % mod, f[i] = 0; } print(ans[Log[x]]); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"原根","slug":"primitive-root","permalink":"https://old.blog.imyangty.com/tags/primitive-root/"}]},{"title":"类欧几里得算法学习笔记","slug":"note-akin-euclidean-algo","date":"2021-09-04T07:38:25.000Z","updated":"2022-03-23T04:17:42.151Z","comments":true,"path":"note-akin-euclidean-algo/","link":"","permalink":"https://old.blog.imyangty.com/note-akin-euclidean-algo/","excerpt":"","text":"前言 洪华敦（SkyDec）于 WC2016 员交提出。 递归过程类似于辗转相除，故称为”类“欧几里得。 一般可以求直线下整点之类的问题。 引入 最常见的形式，即为直线下整点个数： f(a, b, c, n) = \\sum_{i = 0}^n\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor 需要复杂度为 O(\\log n) 的算法。 推导 Part. 1 首先，如果 a\\ge c\\lor b \\ge c ，则可以将 a 和 b 对 c 取模来化简问题： \\begin{aligned} f(a, b, c, n) &amp;= \\sum_{i = 0}^n\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor\\\\ &amp;= \\sum_{i = 0}^n\\left\\lfloor\\frac{(\\left\\lfloor\\frac a c\\right\\rfloor c + a\\bmod c)i + \\left\\lfloor\\frac b c\\right\\rfloor c + b\\bmod c}{c}\\right\\rfloor\\\\ &amp;= \\frac{n(n + 1)}{2}\\left\\lfloor\\frac ac\\right\\rfloor + (n + 1)\\left\\lfloor\\frac bc\\right\\rfloor + f(a\\bmod c, b\\bmod c, c, n) \\end{aligned} 于是问题就转化为了 a, b&lt; c 的形式。 Part. 2 这个和式看上去不是特别好化简的样子。那么就先拆分一下贡献： 首先考虑把那一坨东西拆成如下形式： \\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor = \\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor - 1}1 减一是因为计数变量从 0 开始。 然后 f(a, b, c, n) = \\sum_{i = 0}^n\\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor - 1}1 调换求和顺序，使得 j 不再被 i 限制， f(a, b, c, n) = \\sum_{j = 0}^{\\left\\lfloor\\frac{an + b}{c} \\right\\rfloor}\\sum_{i = 0}^n\\left[j &lt; \\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor\\right] 把不等式进行化简： \\begin{aligned} &amp;j &lt; \\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor\\\\ \\iff &amp; j + 1\\le\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor\\\\ \\iff &amp; j + 1\\le \\frac{ai + b}{c}\\\\ \\iff &amp; j c + c\\le ai + b\\\\ \\iff &amp; jc + c - b\\le ai\\\\ \\iff &amp; jc + c - b - 1 &lt; ai\\\\ \\iff &amp; \\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor &lt; i \\end{aligned} 这一步的关键在于 i 可以被消掉了。因为我们注意到 \\sum_{i = 0}^n\\left[\\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor &lt; i\\right] 的意义为：只有大于等于那一坨式子的 i 能产生贡献，即这一坨的结果实际上就是： n - \\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor 所以，为了方便令 m = \\left\\lfloor\\frac{an + b}{c}\\right\\rfloor 则有 f(a, b, c, n) = \\sum_{j = 0}^{m - 1}\\left(n - \\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor\\right) 拆开来就是 f(a, b, c, n) = nm - \\sum_{j = 0}^{m - 1}\\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor 右边这个形式不就是一个子问题吗，所以 f(a, b, c, n) = nm - f(c, c - b - 1, a, m - 1) 实现 1234567int f(int a, int b, int c, int n) { if (!a) return b / c * (n + 1); if (a &gt;= c || b &gt;= c) return n * (n + 1) / 2 * (a / c) + (n + 1) * (b / c) + f(a % c, b % c, c, n); int m = (a * n + b) / c; return n * m - f(c, c - b - 1, a, m - 1);} 大概是上面的形式，边界是 a = 0 。 g 和 h 函数的求法 \\begin{aligned} g(a, b, c, n) &amp;= \\sum_{i = 0}^ni\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor\\\\ h(a, b, c, n) &amp;= \\sum_{i = 0}^n\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor^2\\\\ \\end{aligned} g 函数 首先， a\\le c\\lor b\\le c 的情况依旧是可以取模化简的： \\begin{aligned} g(a, b, c, n) &amp;= \\sum_{i = 0}^ni\\left\\lfloor\\frac{(\\left\\lfloor\\frac a c\\right\\rfloor c + a\\bmod c)i + \\left\\lfloor\\frac b c\\right\\rfloor c + b\\bmod c}{c}\\right\\rfloor\\\\ &amp;= \\sum_{i = 0}^ni^2\\left\\lfloor\\frac ac\\right\\rfloor + \\sum_{i = 0}^ni\\left\\lfloor\\frac bc\\right\\rfloor + g(a\\bmod c, b\\bmod c, c, n)\\\\ &amp;= \\left\\lfloor\\frac ac\\right\\rfloor\\frac{n(n + 1)(2n + 1)}{6} + \\left\\lfloor\\frac bc\\right\\rfloor\\frac{n(n + 1)}{2} + g(a\\bmod c, b\\bmod c, c, n) \\end{aligned} 取模化简的部分写完之后，来看看 a, b&lt; c 的情况。 m 的意义与上文相同，像上文那样化简。 \\begin{aligned} g(a, b, c, n) &amp;= \\sum_{i = 0}^ni\\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor - 1}1\\\\ &amp;= \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^ni\\left[j &lt; \\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor\\right] \\end{aligned} 令 t = \\displaystyle\\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor ，有 \\begin{aligned} g(a, b, c, n) &amp;= \\sum_{j = 0}^{m - 1}\\sum_{i = 0}^n[i &gt; t]i\\\\ &amp;= \\sum_{j = 0}^{m - 1}\\frac{(t + n + 1)(n - t)}{2}\\\\ &amp;= \\frac 12\\sum_{j = 0}^{m - 1}\\left(-t^2 + (n + 1)n - (n + 1)t + nt\\right)\\\\ &amp;= \\frac 12\\left(mn(n + 1) - h(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1) \\right) \\end{aligned} h 函数 取模化简真心很烦，过程就是憨算，不放了。但建议第一次学的时候自己化一遍。 \\begin{aligned} h(a, b, c, n) &amp;=\\left\\lfloor\\frac ac\\right\\rfloor^2\\frac{n(n + 1)(2n + 1)}{6} + n(n + 1)\\left\\lfloor\\frac ac\\right\\rfloor\\left\\lfloor\\frac bc\\right\\rfloor + (n + 1)\\left\\lfloor\\frac bc\\right\\rfloor^2 + \\\\&amp;+2\\left\\lfloor\\frac ac\\right\\rfloor g(a\\bmod c, b\\bmod c, c, n) + 2\\left\\lfloor\\frac bc\\right\\rfloor f(a\\bmod c, b\\bmod c, c, n) \\\\ &amp;+ h(a\\bmod c, b\\bmod c, c, n) \\end{aligned} 然后是 a, b&lt; c 的情况。但是如果我们直接套上面的形式的话，会发现很难搞，因为会出现 \\sum\\times\\sum 这种不好化简的东西。所以考虑把平方拆开，注意到： n^2 = 2\\frac{n(n + 1)}{2} - n = 2\\sum_{i = 1}^ni - n 依据这个引理进行化简： \\begin{aligned} h(a, b, c, n) &amp;= \\sum_{i = 0}^n\\left(2\\sum_{j = 1}^{\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor}j - \\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor\\right)\\\\ &amp;= 2\\sum_{i = 0}^n\\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor - 1}(j + 1) - f(a, b, c, n) \\end{aligned} 现在考虑 \\sum_{i = 0}^n\\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor - 1}(j + 1) 的计算。 继续调换求和顺序： \\begin{aligned} &amp;\\sum_{i = 0}^n\\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor}(j + 1)\\\\ =&amp;\\sum_{j = 0}^{m - 1}(j + 1)\\sum_{i = 0}^n[i &gt; t]\\\\ =&amp;\\sum_{j = 0}^{m - 1}(j + 1)(n - t)\\\\ =&amp;\\sum_{j = 0}^{m - 1}(jn - t + n -jt)\\\\ =&amp;\\frac{1}{2}nm(m + 1) - \\sum_{j = 0}^{m - 1}(j + 1)t\\\\ =&amp;\\frac12nm(m + 1)-g(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1) \\end{aligned} 因此， \\begin{aligned} h(a, b, c, n) &amp;= nm(m + 1) - 2g(c, c - b - 1, a, m - 1)\\\\ &amp;- 2f(c, c - b - 1, m - 1) - f(a, b, c, n) \\end{aligned} 实现 发现 g 和 h 都要互相使用下一层递归的东西，所以考虑把三个函数绑在一起递归实现。 只能说很难不抄错式子。 洛谷模板代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}}using namespace fastIO;typedef long long ll;const ll mod = 998244353, inv2 = 499122177, inv6 = 166374059;struct query { ll f, g, h;};il ll S1(ll n) {return n * (n + 1) / 2 % mod;}il ll S2(ll n) {return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod;}query calc(ll a, ll b, ll c, ll n) { query ret; ll s1, s2, ac, bc; ll m; ac = a / c, bc = b / c, s1 = S1(n), s2 = S2(n), m = (a * n + b) / c; if (a == 0) { ret.f = bc * (n + 1) % mod; ret.g = bc * s1 % mod; ret.h = bc * bc % mod * (n + 1) % mod; } else if (a &gt;= c || b &gt;= c) { auto pre = calc(a % c, b % c, c, n); ret.f = (s1 * ac % mod + (n + 1) * bc % mod + pre.f) % mod; ret.g = (ac * s2 % mod + bc * s1 % mod + pre.g) % mod; ret.h = (ac * ac % mod * s2 + 2 * s1 * ac % mod * bc % mod + (n + 1) * bc % mod * bc % mod + 2 * ac * pre.g % mod + 2 * bc * pre.f % mod + pre.h) % mod; } else { auto pre = calc(c, c - b - 1, a, m - 1); ret.f = (n * m % mod + mod - pre.f) % mod; ret.g = (m * n % mod * (n + 1) % mod + mod - pre.h + mod - pre.f) % mod * inv2 % mod; ret.h = (n * m % mod * (m + 1) % mod + mod - 2 * pre.g % mod + mod - 2 * pre.f % mod + mod - ret.f) % mod; } return ret;}int main() { int T; read(T); while (T--) { int a, b, c, n; read(n), read(a), read(b), read(c); query ans = calc(a, b, c, n); print(ans.f), putchar(' '), print(ans.h), putchar(' '), print(ans.g), putchar('\\n'); } return output(), 0;} 应用 P5171 Earthquake 题面：求 ax + by\\le c 的非负整数解个数。 1\\le a, b\\le10^9 ， 0\\le c\\le 10^{18} 。 转换一下就是： y\\le \\frac{-ax + c}{b} 即为直线下整点个数。对于一个 x 来说易得答案为 \\left\\lfloor\\frac{-ax + c}{b}\\right\\rfloor + 1 加 1 是因为有 y = 0 。 所以答案为 \\left\\lfloor\\frac ac\\right\\rfloor + 1 + \\sum_{x = 0}^{\\lfloor\\frac ac\\rfloor}\\left\\lfloor\\frac{-ax + c}{b}\\right\\rfloor 但是那个 -a 就很迷惑，假设 b\\ge a （如果 b &lt; a 可以 swap(a, b)），然后给 x 的系数加上 b ，则 \\begin{aligned} \\sum_{x = 0}^{\\lfloor\\frac ca\\rfloor}\\left\\lfloor\\frac{-ax + c}{b}\\right\\rfloor&amp;= \\sum_{x = 0}^{\\lfloor\\frac ca\\rfloor}\\left\\lfloor\\frac{(b - a)x + c}{b} - x\\right\\rfloor\\\\ &amp;= \\sum_{x = 0}^{\\lfloor\\frac ca\\rfloor}\\left\\lfloor\\frac{(b - a)x + c}{b}\\right\\rfloor - \\frac12\\left\\lfloor\\frac ca\\right\\rfloor\\left(\\left\\lfloor\\frac ca\\right\\rfloor + 1\\right) \\end{aligned}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"类欧几里得算法","slug":"akin-euclidean-algo","permalink":"https://old.blog.imyangty.com/tags/akin-euclidean-algo/"}]},{"title":"UVA1322 优化最大值电路 Minimizing Maximizer","slug":"sol-uva1322","date":"2021-09-03T15:11:17.000Z","updated":"2022-03-23T04:18:31.102Z","comments":true,"path":"sol-uva1322/","link":"","permalink":"https://old.blog.imyangty.com/sol-uva1322/","excerpt":"","text":"Description 现要寻找某数组中的最大值。某机器由若干个 Sorter 组成，第 k 个可以把 [l_k, r_k] 中的数字排序。该机器依次运行每个 Sorter，则正常情况下，最后一个数字将成为我们需要的最大值。 求最少保留多少个 Sorter 能使得该机器仍正常工作。注意 Sorter 的顺序不能改变。 2 \\le n \\le 5 \\times 10 ^4 ， 1 \\le m \\le 5 \\times 10 ^ 5 ， 1 \\le i_k \\le j_k \\le n 。 Solution 注意到每一个 Sorter 相当于就是把区间中最大的数移到最右边。 假设当前的最大值在 m 处，那么一个能把他拖到 r_k 的 Sorter 必须满足 l_k\\le m\\le r_k 。所以假设第一个数为最大的，如果这个 Maximizer 能把它拖到最后，那么其必然是合法的。所以问题现在转化成了一个区间覆盖问题。 考虑 dp：设 f_{i, j} 为考虑前 i 个 Sorter，第一个数现在在 j ，选择的最少的 Sorter 数量。 则有转移： f_{k, r_k} = \\min_{l_k\\le j'\\le r_k}\\{f_{k - 1, j'} + 1\\} 朴素的来做是 O(nm) 的，不太行。 但是这个东西每次相当于就是查询一下区间最小值，然后更新一个单点的值。所以可以使用线段树来维护最小值。 Implementation 需要注意 UVa 的最后一行行末不能换行，每组数据之间要空一行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;const int maxn = 5e4 + 5;il int min(int a, int b) {return a &lt; b ? a : b;}int f[maxn &lt;&lt; 2];#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void modify(int i, int j, int k, int x, int v) { if (i == j) { f[k] = min(f[k], v); return; } if (x &lt;= M) modify(i, M, L, x, v); else modify(M + 1, j, R, x, v); f[k] = min(f[L], f[R]); return;}int query(int i, int j, int k, int x, int y) { if (x &lt;= i &amp;&amp; y &gt;= j) return f[k]; int ret = 1e9; if (x &lt;= M) ret = min(ret, query(i, M, L, x, y)); if (y &gt; M) ret = min(ret, query(M + 1, j, R, x, y)); return ret;}int n, m;int main() { int T; read(T); FOR(kase, 1, T) { read(n), read(m); memset(f, 0x7f, sizeof f); modify(1, n, 1, 1, 0); FOR(i, 1, m) { int l, r; read(l), read(r); modify(1, n, 1, r, query(1, n, 1, l, r) + 1); } print(query(1, n, 1, n, n)), putchar('\\n'); if (kase &lt; T) putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"UVA","slug":"UVA","permalink":"https://old.blog.imyangty.com/tags/UVA/"}]},{"title":"CF696D Legen...","slug":"sol-cf696d","date":"2021-09-03T05:14:56.000Z","updated":"2022-03-23T04:18:30.726Z","comments":true,"path":"sol-cf696d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf696d/","excerpt":"","text":"Description 给定若干模板串 S_i ，每个模板串有价值 a_i （不保证 S_i 两两不同）。定义一个字符串 T 的价值为 S_i 出现次数乘上 a_i 的和，问一个长度为 l 的字符串能达到的最大价值。 \\sum|S_i|\\le 200 ， l\\le 10^{14} 。 Solution 显然的 AC 自动机 DP。先合并相同字符串的价值。 不妨令 f_{j, i} 为匹配到 ACAM 上 j 节点，长度为 i 的最大价值。 转移： f_{j, i} = \\max_{(j', j)\\text{ exists}}\\{\\operatorname{val}(j) + f_{j', i - 1}\\} 然后就会发现问题不太对： l 的范围是 10^{14} 级别的，朴素的来做是做不了的。但这个式子和 l 的范围让我们联想到了矩阵快速幂，而 \\sum|S| 的范围为 200 ，于是考虑构造矩阵。首先先写一下一个向量： \\begin{bmatrix} f_{0, i}\\\\ f_{1, i}\\\\ f_{2, i}\\\\ \\vdots\\\\ f_{tot, i} \\end{bmatrix} 看一下施加一下上面的变换，我们的转移矩阵应该是什么样的。令 g_{a, b} = \\begin{cases} \\operatorname{val}(b)&amp;,(b,a)\\text{ exists}\\\\ -\\infty&amp;,\\text{otherwise} \\end{cases} 然后 f_{j, i} = \\max_k\\{g_{j, k} + f_{k, i - 1}\\} 这个明显和 DDP 是一个形式。建立出 g^L 然后乘上初始向量即可。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;cstdio&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define il inlinetypedef long long ll;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}template&lt;int row, int col&gt;struct Matrix { ll ele[row][col]; Matrix() {memset(ele, 0xcf, sizeof ele);} il ll* operator[](int a) {return ele[a];}};template&lt;int m, int n, int p&gt; Matrix&lt;m, p&gt; operator*(Matrix&lt;m, n&gt; a, Matrix&lt;n, p&gt; b) { Matrix&lt;m, p&gt; ret; FOR(k, 0, n - 1) { FOR(i, 0, m - 1) { FOR(j, 0, p - 1) { ret[i][j] = max(ret[i][j], a[i][k] + b[k][j]); } } } return ret;}template&lt;int n&gt; Matrix&lt;n, n&gt; qPow(Matrix&lt;n, n&gt; mat, ll exp) { Matrix&lt;n, n&gt; ret; FOR(i, 0, n - 1) ret.ele[i][i] = 0; for (; exp; exp &gt;&gt;= 1, mat = mat * mat) if (exp &amp; 1) ret = ret * mat; return ret;}struct node { int ch[26], fail; ll val;} t[205];int tot;void insert(char *s, ll val) { int u = 0, len = strlen(s + 1); FOR(i, 1, len) { int c = s[i] - 'a'; if (!t[u].ch[c]) t[u].ch[c] = ++tot; u = t[u].ch[c]; } t[u].val += val; return;}void build() { static int q[205], qhead = 1, qtail = 0; FOR(c, 0, 25) if (t[0].ch[c]) q[++qtail] = t[0].ch[c]; while (qhead &lt;= qtail) { int u = q[qhead++]; t[u].val += t[t[u].fail].val; FOR(c, 0, 25) if (t[u].ch[c]) t[t[u].ch[c]].fail = t[t[u].fail].ch[c], q[++qtail] = t[u].ch[c]; else t[u].ch[c] = t[t[u].fail].ch[c]; } return;}int n;char str[205];ll l, v0[205];int main() { scanf(\"%d %lld\", &amp;n, &amp;l); FOR(i, 1, n) scanf(\"%lld\", v0 + i); FOR(i, 1, n) { scanf(\"%s\", str + 1); insert(str, v0[i]); } build(); Matrix&lt;205, 205&gt; trans; Matrix&lt;205, 1&gt; v; v[0][0] = 0; FOR(u, 0, tot) FOR(c, 0, 25) trans[t[u].ch[c]][u] = max(trans[t[u].ch[c]][u], t[t[u].ch[c]].val); v = qPow(trans, l) * v; ll ans = 0; FOR(i, 0, tot) ans = max(ans, v[i][0]); printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"AC自动机","slug":"acam","permalink":"https://old.blog.imyangty.com/tags/acam/"}]},{"title":"SP839 OPTM - Optimal Marks","slug":"sol-sp839","date":"2021-09-02T13:54:58.000Z","updated":"2022-03-23T04:18:31.095Z","comments":true,"path":"sol-sp839/","link":"","permalink":"https://old.blog.imyangty.com/sol-sp839/","excerpt":"","text":"Description 给定一张无向图 G(V, E) ，每个顶点有一个 int 范围内的点权。对于边 (u, v) ，其边权为 a_u\\operatorname{xor} a_v 。现已知部分点的点权，要求确定其他点的点权使得边权总和最小。 要求输出点权方案，若有多解，要求输出 \\sum a_i 最小的方案。 Solution 异或很难搞，拆成 \\log 个图，按位考虑。 然后现在的问题就变为了将这些点划分进 \\{0, 1\\} 里面。然后注意到对于边 (u, v) ，若 a_u\\not=a_v ，则会产生代价。 这不就是最小割的集合划分模型吗。 首先题目里面的点都连双向边，容量为 1 。 然后对于 k 个已知点 u ，如果该位为 1 则连 (S, u) ，否则连 (u, T) ，边权为 +\\infty 表示不会被割开。 考虑意义： S 可达的点选 1 ，可达 T 的点选 0 。残量网络中 S 能到达的点就是选了 1 的。依据此构造方案。既然要让 1 尽量小，那么就让最靠近 S 的最小割参与贡献就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)#define il inlinenamespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int maxn = 505, maxm = 50005;const int INF = 1e9;struct edge { int to, nxt, w;} e[maxm &lt;&lt; 1];int head[maxn], dep[maxn], cur[maxn], cnt = 1;int s, t;il void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].w = 0; e[cnt].nxt = head[v]; head[v] = cnt; return;}bool bfs() { static int q[maxn], qhead, qtail; memset(dep, -1, sizeof dep); memcpy(cur, head, sizeof head); q[qhead = qtail = 1] = s; dep[s] = 0; while (qhead &lt;= qtail) { int u = q[qhead++]; GO(u, head) { if (e[i].w &gt; 0 &amp;&amp; dep[v] == -1) { q[++qtail] = v; dep[v] = dep[u] + 1; if (v == t) return true; } } } return false;}int dfs(int u, int in) { if (u == t) return in; int out = 0; GO(u, cur) { cur[u] = i; if (e[i].w &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) { int res = dfs(v, min(in, e[i].w)); e[i].w -= res, e[i ^ 1].w += res; in -= res, out += res; } if (!in) break; } if (!out) dep[u] = -1; return out;}int dinic() { int ret = 0; while (bfs()) ret += dfs(s, INF); return ret;}int n, m, k, U[3005], V[3005], val[505], fixed[505], vis[505];void calc(int k) { memset(head, 0, sizeof head), cnt = 1; memset(vis, 0, sizeof vis); FOR(i, 1, n) if (fixed[i]) ((1 &lt;&lt; k) &amp; val[i]) ? add(s, i, INF) : add(i, t, INF); FOR(i, 1, m) add(U[i], V[i], 1), add(V[i], U[i], 1); dinic(); FOR(i, 1, n) if (dep[i] &gt;= 0) val[i] |= (1 &lt;&lt; k); return;}int main() { int T; read(T); while (T--) { memset(fixed, 0, sizeof fixed); memset(val, 0, sizeof val); read(n), read(m), s = n + 1, t = s + 1; FOR(i, 1, m) read(U[i]), read(V[i]); read(k); FOR(i, 1, k) { int tmp; read(tmp); read(val[tmp]), fixed[tmp] = 1; } FOR(k, 0, 30) calc(k); FOR(i, 1, n) print(val[i]), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最小割","slug":"mincut","permalink":"https://old.blog.imyangty.com/tags/mincut/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://old.blog.imyangty.com/tags/SPOJ/"}]},{"title":"图的连通性相关","slug":"note-connectivity","date":"2021-09-01T15:32:13.000Z","updated":"2022-03-23T04:17:42.166Z","comments":true,"path":"note-connectivity/","link":"","permalink":"https://old.blog.imyangty.com/note-connectivity/","excerpt":"","text":"前言 一直对这方面不是很理解，开个坑记录一下。 基本概念 对于有向图： 强连通：对于一张有向图，若每个点互相可达，则称为强连通。 强连通分量：极大的强连通子图。 对于无向图： 点割集：若删掉该集合的点后图不连通，则称为点割集。大小为 1 的点割集就是割点。 点联通度：若 k + 1\\le |V| 且不存在大小为 k - 1 的点割集，则称该图 k- 点联通。最大的 k ，即最小点割集合的大小。 边割集/边联通度：类似。 点双连通：没有割点的连通图是点双连通的。 边双连通：没有桥的连通图是边双连通的。 点双连通分量：极大的点双连通子图（简称点双）。 边双连通分量：极大的边双连通子图（简称边双）。 强连通分量（SCC） 使用 tarjan 算法做到 O(n + m) 。 dfs 生成树 tarjan 算法是基于 dfs 的。考虑在原图上生成一棵 dfs 生成树。 那么原图的边可以分为如下几类： 树边：就是在 dfs 生成树的边，当一个点搜素找到一个没有访问的点时生成。 返祖边：指向祖先节点的边。 横叉边：搜索时遇到的访问过的但是不是自己祖先的点。 前向边：搜索时遇到子树节点时的边。 有如下引理：假设 u 是某个 SCC 在 dfs 生成树中第一个遇到的点，则 SCC 剩余的点肯定在子树内， u 称为 SCC 的根。证明可用反证法，不再展开。 Tarjan 算法 构造 dfs 生成树的同时维护一个栈，表示访问过的还未加入 SCC 的点。 对于每个节点维护 \\operatorname{dfn}(u) 和 \\operatorname{low}(u) 。含义分别是： \\operatorname{dfn}(u) 时间戳。 \\operatorname{low}(u) ： u 或其子树内节点能回溯到的最早的还在栈中的节点的 \\operatorname{dfn} 。 根据以下定义，有 123456low[u] = min { dfn[u], low[v], (u, v) 为树边，v 为 u 儿子 dfn[v], (u, v) 为指向栈中节点的非横叉边} 发现一个 SCC 中只存在一个 u 使得 \\operatorname{dfn}(u) = \\operatorname{low}(u) ，回溯的过程中判定，栈中 u 往后的节点构成 SCC。 实现 12345678910111213141516171819202122232425int dfn[maxn], low[maxn], ins[maxn], stk[maxn], top;int dfnClock, scc[maxn], sccCnt;void tarjan(int u) { dfn[u] = low[u] = ++dfnClock; stk[++top] = u, ins[u] = 1; GO(u, head) { if (!e[i].w) continue; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (ins[v]) low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { ++sccCnt; while (true) { int now = stk[top--]; ins[now] = 0; scc[now] = sccCnt; if (now == u) break; } } return;} 应用 可以将一些互相可达的点缩在一起，一张图缩完后会变成一张 DAG，方便进行 dp。 双连通分量（BCC） 对于无向图而言的。 点双连通不具有传递性，即 A 与 B 点双连通、 B 与 C 点双连通并不能推出 A 与 C 点双连通（考虑 B 为割点的情况） 相反地，边双连通具有传递性。 边双连通分量（e-BCC） \\operatorname{dfn} 和 \\operatorname{low} 的定义与上面的类似。 则对于 dfs 树上的一条边 (u, v) ，其会是割边当且仅当 \\operatorname{dfn}(u) &lt; \\operatorname{low}(v) 意义为，从子树 v 出发， 在不经过 (u, v) 的前提下无法走到比 x 更早访问的节点。这条边 (u, v) 显然就应该是桥。 缩点也不说了，好缩的。割边会缩成若干个 e-BCC，最后的结果是一棵树/森林（因为不能有环），一个点仅会属于一个 e-BCC，桥不属于任何 e-BCC。 12345678910111213141516void tarjan(int u, int last) {//last 为上一条边的编号，判父亲用 dfn[u] = low[u] = ++dfnClock; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (!dfn[v]) { tarjan(v, i); if (low[v] &gt; dfn[u]) bridge[i] = bridge[i ^ 1] = 1;//这里是标记桥 low[u] = min(low[u], low[v]); } else if (i != (last ^ 1))//注意判一下是不是 dfs 树上的父亲 low[u] = min(low[u], dfn[v]); } return;} 经典题：问最多添加多少条边可以使得图边双连通。答案为缩完点之后的叶子个数除以二向上取整。构造的话考虑每次连两个叶子起来就可以形成一个环，环上的都会被消掉。 点双连通分量（v-BCC） 定义依旧类似。判断一个点 u 是否为割点的方法： 若 u 为 dfs 树的根节点，则其只要有多于一个子树，其就是割点。（考虑去掉根之后两个子树不连通） 否则，考虑 v 为 u 的子节点，则 u 为割点当且仅当 \\operatorname{dfn}(u)\\le \\operatorname{low}(v) 。即， v 子树内的点只能最多回到 u ，不能再往上。 求割点的代码： 123456789101112131415161718void tarjan(int u) { dfn[u] = low[u] = ++cnt; for (auto v : G[u]) { if (!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); if (low[v] &gt;= dfn[u] &amp;&amp; u != root) { ans += (!cut[u]); cut[u] = 1; } child += (u == root); } low[u] = min(low[u], dfn[v]); } if (u == root &amp;&amp; child &gt; 1) ans++, cut[u] = 1;} 缩点甚么的直接去看后面圆方树吧。 2-SAT 咕。 圆方树 毒瘤数据结构。 引入 直接讲广义圆方树吧。 定义：任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。什么意思？就是一条边只能出现在至多一个环里面。这样的图长得就很像仙人掌，所以就叫做仙人掌。 最初的狭义圆方树一般拿来处理仙人掌上的问题，但是广义圆方树还可以处理无向图上的问题。其可以将一些一般无向图上不好做的事情转化到树上，然后就可以使用树剖/LCT/点分之类的方法去维护。 我们定义不存在割点的图为点双连通图。在圆方树上，每个点双连通分量（以后简称点双）对应一个方点，原来的每个点对应圆方树上一个圆点。就像这样（图源 WC 课件）： 下面是圆方树的一些性质： 设点双有 c 个，则圆方树有 n + c 个点。所以要开二倍空间。 一个条边连接了一个方点和一个圆点。 若原图不连通，则会形成若干圆方森林。 原图中不是割点的点都是叶子，一个割点会连接若干个方点。 构建 这里的构建用的 tarjan 算法和一般的求 v-BCC 的不太一样。 \\operatorname{dfn}(u) ： u 的 dfs 序，和普通 tarjan 相同。 \\operatorname{low}(u) ： u 的子树中的某个节点通过至多一次返祖边或向父亲的树边能访问到的点的最小 dfs 序。 像下面这张图（图源小粉兔的博客）： 注意 9 的 \\mathrm{low} 是 7 ，因为规定了向父亲的树边也可以。 对于 (u, v) ，发现如果 \\operatorname{low}(v) = \\operatorname{dfn}(u) ，则说明 v 子树内的点构成一个点双，将栈内除了 u 的点退栈，顺便与新建的方点连边。当然 u 也要与方点连边，但是不退栈。 下面放一个构建圆方树的代码。 12345678910111213141516171819202122void tarjan(int u) { dfn[u] = low[u] = ++dfnClock; stk[++top] = u; for (int i = head0[u]; i; i = e0[i].nxt) { int &amp;v = e0[i].to; if (!dfn[v]) {= tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] == dfn[u]) { ++fang; while (true) { int x = stk[top--]; add(fang, x), add(x, fang); if (x == v) break; } add(fang, u), add(u, fang); } } else low[u] = min(low[u], dfn[v]); } return;} 应用 P5236 【模板】静态仙人掌 传送门。大意：给定一棵仙人掌，多次询问两点间最短路。 多次询问最短路不是很好搞，但是仙人掌一条边最多在一个环上的性质启迪我们可以把环缩起来处理。这样子我们就可以求树上最短路了。 如何建立？我们考虑建出圆方树，然后给每条边定权值，这样子就可以在树上求最短路了，求 LCA 即可，可是，怎么给圆方树的边定权？ 我们令一个环上 dfn 最小的点为这个环的根，则这个环的方点到这些环上的圆点的边权即为该点到根的最短路。对于只有两个节点的情况，类似。但是我们需要求出环长，由于仙人掌的特性，一个点双只有一条返祖边，所以我们把栈顶的点找到就可以算了。 然后算最短路的时候，如果两点的 LCA 是圆点，就直接无脑算就行了，但是如果是方点则需要特判一下， 看这两个点在环上的最短路是多少。 具体细节看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107const int maxn = 2e4 + 5, maxm = 4e4 + 5;struct edge { int to, nxt, w;} e0[maxm], e[maxn &lt;&lt; 1];int head0[maxn], head[maxn], cnte0, cnte;int n, m, fang, q;void add0(int u, int v, int w) { e0[++cnte0].to = v; e0[cnte0].w = w; e0[cnte0].nxt = head0[u]; head0[u] = cnte0; return;}void add(int u, int v, int w) { e[++cnte].to = v; e[cnte].w = w; e[cnte].nxt = head[u]; head[u] = cnte; return;}int dfn[maxn], low[maxn], dfnClock, stk[maxn], top;int dis0[maxn], val[maxn], r[maxn];void tarjan(int u, int fa) { dfn[u] = low[u] = ++dfnClock; stk[++top] = u; for (int i = head0[u]; i; i = e0[i].nxt) { int &amp;v = e0[i].to; if (!dfn[v]) { val[v] = e0[i].w; dis0[v] = dis0[u] + e0[i].w; tarjan(v, u); low[u] = min(low[u], low[v]); if (low[v] == dfn[u]) { ++fang; r[fang] = val[stk[top]] + dis0[stk[top]] - dis0[u]; while (true) { int x = stk[top--], tmp = dis0[x] - dis0[u]; tmp = min(tmp, r[fang] - tmp); add(fang, x, tmp), add(x, fang, tmp); if (x == v) break; } add(fang, u, 0), add(u, fang, 0); } } else { low[u] = min(low[u], dfn[v]); if (v != fa &amp;&amp; dfn[v] &lt; dfn[u]) val[u] = e0[i].w; } } return;}int dis[maxn], fa[maxn][20], dep[maxn];void dfs(int u, int pre) { fa[u][0] = pre; for (int i = 1; fa[fa[u][i - 1]][i - 1]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1]; for (int i = head[u]; i; i = e[i].nxt) { int &amp;v = e[i].to; if (v == pre) continue; dis[v] = dis[u] + e[i].w; dep[v] = dep[u] + 1; dfs(v, u); } return;}using pii = std::pair&lt;int, int&gt;;pii LCA(int u, int v) { if (dep[u] &lt; dep[v]) std::swap(u, v); for (int delta = dep[u] - dep[v], i = 0; delta; delta &gt;&gt;= 1, ++i) if (delta &amp; 1) u = fa[u][i]; if (u == v) return pii(u, -1); DEC(i, 15, 0) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i]; if (fa[u][0] &lt;= n) return pii(fa[u][0], -1); else return pii(u, v);}int main() { read(n), read(m), read(q); FOR(i, 1, m) { int u, v, w; read(u), read(v), read(w); add0(u, v, w), add0(v, u, w); } fang = n, tarjan(1, 0); dfs(1, 0); while (q--) { int u, v; read(u), read(v); auto p = LCA(u, v); if (~p.second) { int tmp = myabs(dis0[p.first] - dis0[p.second]); tmp = min(tmp, r[fa[p.first][0]] - tmp); print(dis[u] + dis[v] - dis[p.first] - dis[p.second] + tmp, '\\n'); } else print(dis[u] + dis[v] - 2 * dis[p.first], '\\n'); } return output(), 0;} P5058 [ZJOI2004]嗅探器 传送门。建出圆方树，找两个点中间的圆点即可，其一定是割点。 P4320 道路相遇 传送门。这个相当于就是求圆方树两点间圆点的个数，树剖维护一下就可以了。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"缩点","slug":"shrink","permalink":"https://old.blog.imyangty.com/tags/shrink/"}]},{"title":"P2423 [HEOI2012]朋友圈","slug":"sol-luogu-p2423","date":"2021-09-01T12:28:48.000Z","updated":"2022-03-23T04:18:30.910Z","comments":true,"path":"sol-luogu-p2423/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2423/","excerpt":"","text":"Description 一张无向图有 A 和 B 两个点集，每个点均有点权。 若 x, y\\in A\\land a_x\\operatorname{xor}a_y\\equiv 1\\pmod 2 ，则 (x, y) 有边。 若 x, y\\in B\\land (b_x\\operatorname{xor}b_y\\equiv 0\\pmod 2\\lor \\operatorname{popcount}(b_x\\operatorname{or} b_y)\\equiv 1\\pmod 2) ，则 (x, y) 有边。 另有 m 条边 (x, y) ，满足 x\\in A\\land y\\in B 。 求这张图的最大团。 Solution A 中奇偶性不同的点有边， B 中奇偶性相同的点有边，不同的有一部分有边。 最大团是 NPC 的，考虑这张图的补图。 \\overline{A} 中奇数点和偶数点分别为完全图， \\overline{B} 中奇偶性不同的点构成二分图。而求无向图的最大团等价于求补图的最大独立集。所以 \\overline{A} 中最多取两个点 x 和 y 满足 x 和 y 不连边，然后把 \\overline{B} 中与这两个点相连的点删掉之后跑最大匹配即可。 枚举 \\overline{A} 中的点即可。 Implementation 注意剪枝，实现上有很多需要注意的细节，也有很多妙不可言的写法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define GO(u, x) for (int i = x[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)#define il inline#define popcount(x) __builtin_popcount(x)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}const int maxn = 3005, maxm = 9e6 + 5;const int INF = 1e9;struct edge { int to, nxt, w;} e[maxm &lt;&lt; 1];int head[maxn], dep[maxn], cur[maxn], cnt = 1;int s, t;il void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].w = w; e[cnt].nxt = head[u]; head[u] = cnt; e[++cnt].to = u; e[cnt].w = 0; e[cnt].nxt = head[v]; head[v] = cnt; return;}bool bfs() { static int q[maxn], qhead, qtail; memset(dep, -1, sizeof dep); memcpy(cur, head, sizeof head); q[qhead = qtail = 1] = s; dep[s] = 0; while (qhead &lt;= qtail) { int u = q[qhead++]; GO(u, head) { if (e[i].w &gt; 0 &amp;&amp; dep[v] == -1) { q[++qtail] = v; dep[v] = dep[u] + 1; if (v == t) return true; } } } return false;}int dfs(int u, int in) { if (u == t) return in; int out = 0; GO(u, cur) { cur[u] = i; if (e[i].w &gt; 0 &amp;&amp; dep[v] == dep[u] + 1) { int res = dfs(v, min(in, e[i].w)); e[i].w -= res, e[i ^ 1].w += res; in -= res, out += res; } if (!in) break; } if (!out) dep[u] = -1; return out;}int ans;void dinic(int val) { int ret = val; while (bfs()) { ret -= dfs(s, INF); if (ret &lt;= ans) return; } ans = ret; return;}int A, B, m;int a[205], b[3005], st[2][3005], top[2], tot, U[maxm], V[maxm], vis[3005];std::vector&lt;int&gt; G[205];void connect() { memset(head, 0, sizeof head), cnt = 1; FOR(i, 1, tot) if (vis[U[i]] &amp;&amp; vis[V[i]]) add(U[i], V[i], 1); FOR(i, 1, top[0]) if (vis[st[0][i]]) add(s, st[0][i], 1); FOR(i, 1, top[1]) if (vis[st[1][i]]) add(st[1][i], t, 1); return;}int main() { int T; read(T); while (T--) { read(A), read(B), read(m); FOR(i, 1, A) read(a[i]); FOR(i, 1, B) read(b[i]), st[b[i] &amp; 1][++top[b[i] &amp; 1]] = i; s = B + 1, t = B + 2, ans = 0; FOR(i, 1, top[0]) { FOR(j, 1, top[1]) { if (!(popcount(st[0][i] | st[1][j]) &amp; 1)) { U[++tot] = st[0][i]; V[tot] = st[1][j]; } } } memset(head, 0, sizeof head), cnt = 1; FOR(i, 1, tot) add(U[i], V[i], 1); FOR(i, 1, top[0]) add(s, st[0][i], 1); FOR(i, 1, top[1]) add(st[1][i], t, 1); dinic(B); FOR(i, 1, m) { int x, y; read(x), read(y); G[x].push_back(y); } FOR(x, 1, A) { memset(vis, 0, sizeof vis); for (auto v : G[x]) ++vis[v]; int P = 1; FOR(i, 1, B) P += vis[i]; if (P &lt;= ans) continue; connect(), dinic(P); } FOR(x, 1, A) { FOR(y, 1, A) { memset(vis, 0, sizeof vis); if (!((a[x] ^ a[y]) &amp; 1)) continue; for (auto v : G[x]) ++vis[v]; for (auto v : G[y]) ++vis[v]; int P = 2; FOR(i, 1, B) { vis[i] = (vis[i] &lt; 2) ? 0 : 1; P += vis[i]; } if (P &lt;= ans) continue; connect(), dinic(P); } } print(ans), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"二分图","slug":"bi-graph","permalink":"https://old.blog.imyangty.com/tags/bi-graph/"}]},{"title":"CF449D Jzzhu and Numbers","slug":"sol-cf449d","date":"2021-08-28T14:31:19.000Z","updated":"2022-03-23T04:18:30.714Z","comments":true,"path":"sol-cf449d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf449d/","excerpt":"","text":"Description 给定多重集 S ，问从 S 中选子集使得按位与结果为 0 的方案数对 10^9 + 7 取模的结果。 Solution 考虑生成函数。 令 F_i(x) = x^{U} + x^{a_i} ， * 为按位与卷积， U 为 2^k - 1 （全集），则 F(x) = F_1(x)*F_2(x)*\\cdots*F_n(x) 中 [x^0]F(x) 就是答案。 然而这样做的复杂度是 n\\max\\{a\\}\\log\\max\\{a\\} 的。显然不行。 但是， F_i(x) 只有两项不为 0 ！ 所以 \\operatorname{FWT}(F(x))_i = c(i, U) + c(i, a_i) ，故其只能为 1 或 2 。 现在需要求的就是对于每个 k\\in[0, U] ，求 \\displaystyle\\prod_{i = 0}^{n}(1 + c(k, a_i)) 。所以只要有 a_i 贡献的到的超集 k ，其产生的贡献就是 2 ，知道了有多少个 a_i 能贡献到这个 k 之后一个快速幂就可以了。这个东西其实就是子集求和，可以使用 AND-FWT。具体地，设出一个序列 C ， C_i 表示有多少个 a_k = i ，然后对 C 做 AND-FWT 的结果为 C' ， C'_k 就是能贡献到 k 的 a_i 的数量，再 C'_k = 2^{C'_k} ，求出 \\operatorname{IFWT}(C') 取出 \\operatorname{IFWT}(C')_0 就是答案。 注意一下全 0 的情况，若把 lim 设为 1 则会多算一个空集，要特判。 Implementation 12345678910111213141516171819202122232425262728const int maxn = 2e6 + 5;modint f[maxn], pow[maxn];int n;void AND(modint *f, int lim, modint x = 1) { for (int o = 2, k = 1; o &lt;= lim; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; lim; i += o) for (int j = 0; j &lt; k; ++j) f[i + j] += f[i + j + k] * x; return;}int main() { read(n); FOR(i, 1, n) { int tmp; read(tmp); ++f[tmp]; } pow[0] = 1; FOR(i, 1, n) pow[i] = 2 * pow[i - 1]; int lim = 1 &lt;&lt; 20; AND(f, lim, 1); FOR(i, 0, lim - 1) f[i] = pow[f[i].val]; AND(f, lim, mod - 1); print(f[0]); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"FWT","slug":"FWT","permalink":"https://old.blog.imyangty.com/tags/FWT/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"位运算卷积学习笔记","slug":"note-fwt","date":"2021-08-28T12:09:11.000Z","updated":"2022-03-23T06:38:15.220Z","comments":true,"path":"note-fwt/","link":"","permalink":"https://old.blog.imyangty.com/note-fwt/","excerpt":"","text":"快速沃尔什变换/FWT 参考：位运算卷积(FWT) &amp; 集合幂级数 by cmdblock 前言 我们考虑一般的加法卷积： c_k = \\sum_{i + j = k} a_ib_j 类似地，我们可以定义位运算卷积： c_k = \\sum_{i\\oplus j = k}a_ib_j 其中 \\oplus 是某种按位运算。 已知的是，FFT 是通过将系数表示乘上一个范德蒙矩阵变成点值表示然后直接对应相乘，考虑构造一个类似的过程，将两序列转成新序列再对应相乘。 构造 设 \\operatorname{FWT}(A) 为幂级数 A 变换之后得到的幂级数。令 C = A * B 为 A 与 B 位运算卷积后的结果。则需要满足： A*B = C\\iff \\operatorname{FWT}(A)\\cdot\\operatorname{FWT}(B) = \\operatorname{FWT}(C) FFT 是一个线性变换，相当于乘上一个范德蒙矩阵。考虑对 FWT 构造一个类似的转移矩阵。 设 c(i, j) 为变换系数，即 A_j 对 \\operatorname{FWT}(A)_i 产生的贡献，则 \\operatorname{FWT}(A)_i = \\sum_{j = 0}^{n - 1}c(i, j)A_j 根据 \\operatorname{FWT}(A)_i\\cdot\\operatorname{FWT}(B)_i=\\operatorname{FWT}(C)_i ，发现 \\begin{aligned} \\left(\\sum_{j = 0}^{n - 1}c(i, j)A_j\\right)\\left(\\sum_{j = 0}^{n - 1}c(i, j)B_j\\right) &amp;= \\sum_{j = 0}^{n - 1}c(i, j)C_j\\\\ \\sum_{j = 0}^{n - 1}\\sum_{k = 0}^{n - 1}c(i,j)c(i, k)A_jB_k &amp;= \\sum_{j = 0}^{n -1}c(i, j)C_j \\end{aligned} 而 A*B = C ， \\begin{aligned} \\sum_{j = 0}^{n - 1}c(i, j)C_j &amp;= \\sum_{j = 0}^{n - 1}c(i,j)\\sum_{t_1\\oplus t_2 = j}A_{t_1}B_{t_2}\\\\ \\sum_{j = 0}^{n - 1}\\sum_{k = 0}^{n - 1}c(i,j)c(i, k)A_jB_k &amp;= \\sum_{j = 0}^{n - 1}c(i,j)\\sum_{t_1\\oplus t_2 = j}A_{t_1}B_{t_2}\\\\ &amp;= \\sum_{j = 0}^{n - 1}\\sum_{t_1\\oplus t_2 = j}A_{t_1}B_{t_2}c(i, j)\\\\ &amp;= \\sum_{t_1 = 0}^{n - 1}\\sum_{t_2 = 0}^{n - 1}A_{t_1}B_{t_2}c(i, t_1\\oplus t_2) \\end{aligned} 对比以下左右两边，发现 c(i, j)c(i, k) = c(i, j\\oplus k) 同时，位运算是具有按位独立性的，所以知道了所有的 c(x, y) （ x, y\\in \\{0, 1\\} ）之后就可以求出所有的 c(i, j) ，具体地，把 i 和 j 的第 k 位称为 i_k 和 j_k ，则 c(i, j) = \\prod c(i_k, j_k) ，证明显然。 现在考虑 \\operatorname{FWT}(A)_i 的计算。前面说过，其等于 \\sum_{j = 0}^{n - 1}c(i, j)A_j 然后计算就是 O(n^2) 的，貌似没什么卵用。 接下来假定 n = 2^m ，然后按位折半： \\begin{aligned} \\operatorname{FWT}(A)_i &amp;= \\sum_{j = 0}^{n - 1}c(i, j)A_j\\\\ &amp;= \\sum_{j = 0}^{n / 2 - 1}c(i, j)A_j + \\sum_{j = n/2}^{n - 1}c(i, j)A_j\\\\ &amp;= c(i_0, 0)\\sum_{j = 0}^{n / 2 - 1}c(i', j')A_j + c(i_0, 1)\\sum_{j = n / 2}^{n - 1}c(i', j')A_j\\\\ \\end{aligned} 然后就会惊奇的发现：问题的规模得到了减半。设 A 的前一半为 A_0 ，后一半为 A_1 ，则 \\begin{aligned} \\operatorname{FWT}(A)_i &amp;=c(0, 0)\\operatorname{FWT}(A_0)_i + c(0, 1)\\operatorname{FWT}(A_1)_i&amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{FWT}(A)_{i + n/2}&amp;= c(1, 0)\\operatorname{FWT}(A_0)_i + c(1, 1)\\operatorname{FWT}(A_1)_i&amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} 分析一下时间复杂度： T(n) = T(n / 2) + O(n) = O(n\\log n) 。逆变换也就是 c 矩阵的逆，具体下文。 具体的位运算卷积 对于不同的位运算 \\oplus ，构造相应的 c 矩阵。将 \\begin{bmatrix} c(0, 0)&amp;c(0, 1)\\\\ c(1, 0)&amp;c(1, 1) \\end{bmatrix} 称为位矩阵。 OR 卷积 c(i, j)c(i, k) = c(i, j\\lor k) 。 c(i, j)c(i, j) = c(i, j) ，故 c(i, j)\\in\\{0, 1\\} 。 \\begin{cases} c(1, 0)c(1, 1) = c(1, 1)\\\\ c(0, 1)c(0, 0) = c(0, 1) \\end{cases} 合法的矩阵有 \\begin{bmatrix}1 &amp; 1 \\\\ 1 &amp; 0\\end{bmatrix} 和 \\begin{bmatrix}1 &amp; 0\\\\1 &amp; 1\\end{bmatrix} 。 第二个的意义为 c(i, j) = [i\\land j = j] ， \\operatorname{FWT}(A)_i = \\displaystyle\\sum_{j = 0}^{n - 1}c(i, j) A_j = \\sum_{j\\in i}A_j 。相当于就是子集求和，并且其逆阵的形式很对称，所以使用第二个矩阵。 \\begin{aligned} \\operatorname{FWT}(A)_i &amp;=\\operatorname{FWT}(A_0)_i &amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{FWT}(A)_{i + n/2}&amp;= \\operatorname{FWT}(A_0)_i + \\operatorname{FWT}(A_1)_i&amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} 12345678void OR(modint *f) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) f[i + j + k] += f[i + j]; return;} \\begin{bmatrix} 1 &amp; 0\\\\ 1 &amp; 1 \\end{bmatrix}^{-1} = \\begin{bmatrix} 1 &amp; 0\\\\ -1 &amp; 1 \\end{bmatrix} \\begin{aligned} \\operatorname{IFWT}(A)_i &amp;=\\operatorname{IFWT}(A_0)_i &amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{IFWT}(A)_{i + n/2}&amp;= \\operatorname{IFWT}(A_0)_i - \\operatorname{IFWT}(A_1)_i&amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} 所以就可以写出如下的代码： 12345678void OR(modint *f, modint x = 1) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) f[i + j + k] += f[i + j] * x; return;} AND 卷积 c(i, j)c(j, k) = c(i,j\\land k) ，类似地， c(i,j)\\in\\{0,1\\} 。 \\begin{cases} c(0, 0)c(0, 1) = c(0, 0)\\\\ c(1, 0)c(1, 1) = c(1, 0)\\\\ \\end{cases} 合法的矩阵有 \\begin{bmatrix}1 &amp; 1\\\\ 0 &amp; 1\\end{bmatrix} 和 \\begin{bmatrix}0 &amp; 1\\\\1 &amp; 1\\end{bmatrix} 。第一种的意义为 c(i, j) = [i\\land j = i] ， \\operatorname{FWT}(A)_i = \\displaystyle\\sum_{j=0}^{n - 1}c(i,j)A_j = \\sum_{i\\in j}A_j ，相当于超集求和，且求逆完的形式比较对偶，所以使用第一种： \\begin{aligned} \\operatorname{FWT}(A)_i &amp;=\\operatorname{FWT}(A_0)_i + \\operatorname{FWT}(A_1)_i &amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{FWT}(A)_{i + n/2}&amp;=\\operatorname{FWT}(A_1)_i &amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} \\begin{bmatrix} 1 &amp; 1\\\\0 &amp; 1 \\end{bmatrix}^{-1} = \\begin{bmatrix} 1 &amp; -1\\\\ 0 &amp; 1 \\end{bmatrix} \\begin{aligned} \\operatorname{IFWT}(A)_i &amp;=\\operatorname{IFWT}(A_0)_i - \\operatorname{IFWT}(A_1)_i &amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{IFWT}(A)_{i + n/2}&amp;=\\operatorname{IFWT}(A_1)_i &amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} 12345678void AND(modint *f, modint x = 1) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) f[i + j] += f[i + j + k] * x; return;} XOR 卷积 c(i, j)c(i, k) = c(i, j\\operatorname{xor} k) 。 合法的有 \\begin{bmatrix}1 &amp; 1\\\\ 1 &amp; -1\\end{bmatrix} 和 \\begin{bmatrix}1 &amp; 1 \\\\ -1 &amp; 1\\end{bmatrix} 。第二种求完逆形式不太好，选用第一种。 \\begin{aligned} \\operatorname{FWT}(A)_i &amp;=\\operatorname{FWT}(A_0)_i + \\operatorname{FWT}(A_1)_i&amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{FWT}(A)_{i + n/2}&amp;= \\operatorname{FWT}(A_0)_i -\\operatorname{FWT}(A_1)_i&amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; -1 \\end{bmatrix}^{-1} = \\begin{bmatrix} 1/ 2 &amp; 1/ 2\\\\ 1/2 &amp; -1/2 \\end{bmatrix} \\begin{aligned} \\operatorname{IFWT}(A)_i &amp;=\\frac 1 2\\operatorname{IFWT}(A_0)_i + \\frac 1 2\\operatorname{IFWT}(A_1)_i&amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{IFWT}(A)_{i + n/2}&amp;= \\frac 1 2\\operatorname{IFWT}(A_0)_i -\\frac 1 2\\operatorname{IFWT}(A_1)_i&amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} 1234567891011void XOR(modint *f, modint x = 1) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) { f[i + j] += f[i + j + k]; f[i + j + k] = f[i + j] - f[i + j + k] - f[i + j + k]; f[i + j] *= x, f[i + j + k] *= x; } return;} 板子 P4717 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455const int maxn = 1 &lt;&lt; 19;int n;modint A[maxn], B[maxn], a[maxn], b[maxn];void OR(modint *f, modint x = 1) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) f[i + j + k] += f[i + j] * x; return;}void AND(modint *f, modint x = 1) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) f[i + j] += f[i + j + k] * x; return;}void XOR(modint *f, modint x = 1) { for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1) for (int i = 0; i &lt; n; i += o) for (int j = 0; j &lt; k; ++j) { f[i + j] += f[i + j + k]; f[i + j + k] = f[i + j] - f[i + j + k] - f[i + j + k]; f[i + j] *= x, f[i + j + k] *= x; } return;}void mul(modint *f, modint *g) { FOR(i, 0, n) f[i] *= g[i]; return;}int main() { read(n); n = 1 &lt;&lt; n; FOR(i, 0, n - 1) read(A[i]); FOR(i, 0, n - 1) read(B[i]); cpy(A, a), cpy(B, b), OR(a, 1), OR(b, 1), mul(a, b), OR(a, MOD - 1); FOR(i, 0, n - 1) print(a[i]), putchar(' '); putchar('\\n'); cpy(A, a), cpy(B, b), AND(a, 1), AND(b, 1), mul(a, b), AND(a, MOD - 1); FOR(i, 0, n - 1) print(a[i]), putchar(' '); putchar('\\n'); cpy(A, a), cpy(B, b), XOR(a, 1), XOR(b, 1), mul(a, b), XOR(a, (MOD + 1) / 2); FOR(i, 0, n - 1) print(a[i]), putchar(' '); putchar('\\n'); return output(), 0;} 总结 整体的思路： 回顾 FFT，现在要求构造一种线性变换满足 \\operatorname{FWT}(A)\\cdot\\operatorname{FWT}(B) = \\operatorname{FWT}(C)\\iff A*B = C 。 考虑构造系数矩阵 c(i, j) 满足 \\operatorname{FWT}(A)_i = \\sum c(i, j)A_j 。 发现 c(i, j)c(i, k) = c(i, j\\oplus k) 。 发现所有的 c(i, j) 可以由 c(x, y)(x,y\\in\\{0, 1\\}) 得到。 将 \\operatorname{FWT}(A)_i 的式子折半拆开，发现变为两个子问题。 \\begin{aligned} \\operatorname{FWT}(A)_i &amp;=c(0, 0)\\operatorname{FWT}(A_0)_i + c(0, 1)\\operatorname{FWT}(A_1)_i&amp;i_0 = 0, i\\in[0, n / 2)\\\\ \\operatorname{FWT}(A)_{i + n/2}&amp;= c(1, 0)\\operatorname{FWT}(A_0)_i + c(1, 1)\\operatorname{FWT}(A_1)_i&amp;i_0 = 1, i\\in[0, n / 2) \\end{aligned} 对于具体的位运算，构造出 \\begin{bmatrix}c(0, 0)&amp; c(0, 1)\\\\ c(1, 0) &amp; c(1, 1) \\end{bmatrix} 及其逆阵，尽量使得两种形式统一。 敲出迭代版代码。 同时注意一下： AND 卷积是超集求和； OR 卷积是子集求和。 应用 主要运用到 FWT 的线性性。即 \\operatorname{FWT}(A) + \\operatorname{FWT}(B) = \\operatorname{FWT}(A + B)\\\\ \\operatorname{FWT}(cA) = c\\operatorname{FWT}(A) 然后就可以用其优化一些生成函数的运算。 同时，FWT 求子集/超级和的应用也是很广泛的。 注意当 A 中只有若干项为 1 时是可以大力分类讨论的。 ABC212H - Nim Counting sol 利用了 FWT 的线性性，所以 FWT 完之后直接等比数列求和再 IFWT 回去就是对的。 CF449D Jzzhu and Numbers sol 涉及到了子集求和和 FWT 的线性性。分析只有两项不为 0 的序列做 FWT 之后的性质。","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"FWT","slug":"FWT","permalink":"https://old.blog.imyangty.com/tags/FWT/"}]},{"title":"P7848 「dWoi R2」FFT / 狒狒贴","slug":"sol-luogu-p7848","date":"2021-08-27T02:46:23.000Z","updated":"2022-03-23T04:18:31.055Z","comments":true,"path":"sol-luogu-p7848/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p7848/","excerpt":"","text":"Description 给定 \\{a_i\\} ， n\\le 2^{17} ， k\\le 10^{18} ，求 a NTT k 次后的结果。 Solution 做一次 DFT 相当就是给 A 向量左乘一个范德蒙矩阵，考虑范德蒙矩阵平方之后是什么样： V^2_{i,j} = \\sum_{k = 0}^{n - 1} \\omega^{ik+kj}=\\omega^{i +j}\\sum_{k = 0}^{n - 1}\\omega^k 注意一下，只有 i + j = 0 或 i + j = n 的时候 V_{i, j} = n ，否则一定有 V_{i, j} = 0 。 然后分析这个 V^2 左乘一个向量会带来什么：很明显是所有元素乘以 n 然后把后 n - 1 个元素反转。那么把 V^4 乘给一个向量就是所有元素乘 n^2 。 所以，把所有元素乘上 (n^2)^{\\lfloor k / 4\\rfloor} ，然后再做 k\\bmod 4 次 NTT 就可以得到答案。 Implementation 12345678910111213int f[maxn];int main() { ll n, k; read(n), read(k); n = 1ll &lt;&lt; n; FOR(i, 0, n - 1) read(f[i]); ll tmp = qPow(n * n, k / 4); FOR(i, 0, n - 1) f[i] = 1ll * f[i] * tmp % mod; FOR(i, 1, k % 4) DFT(f, 1, n); FOR(i, 0, n - 1) print(f[i]), putchar(' '); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"FFT","slug":"FFT","permalink":"https://old.blog.imyangty.com/tags/FFT/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P5641 【CSGRound2】开拓者的卓识","slug":"sol-luogu-p5641","date":"2021-08-15T08:06:25.000Z","updated":"2022-03-23T04:18:31.027Z","comments":true,"path":"sol-luogu-p5641/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5641/","excerpt":"","text":"Description 给定序列 \\{a_i\\} ，定义 sum_{k,l, r} = \\begin{cases} \\displaystyle\\sum_{i = l}^ra_i&amp;k = 1\\\\ \\displaystyle\\sum_{i = l}^r\\sum_{j = i}^rsum_{k - 1, i, j}&amp;k&gt;1 \\end{cases} 对于给定的 k 和 n ，求出每个 sum_{k, 1, i} （ 1\\le i\\le n ）。答案对 998244353 取模。 1\\le n\\le 10^5 。 Solution 答案显然为 sum_{k, 1, r} = \\sum_{i = 1}^r cnt_i\\times a_i 考虑如何计算 cnt_i 。 思考 cnt_i 的组合意义，发现其就是选取 k - 1 个区间 [l_j, r_j] 使得 i 被这些区间覆盖且 [l_j, r_j]\\subseteq[l_{j + 1}, r_{j + 1}] 的方案数。至于为什么是 k - 1 个是因为有一个 [1, r] 是已经确定了的。 我们于是有 1\\le l_1\\le l_2\\le l_{k - 1}\\le i ，令 d_{k} = i - l_{k - 1} ， d_{k - 1} = l_{k - 1} - l_{k - 2} ， d_2 = l_2 - l_1 ， d_1 = l_1 - 1 ，然后就有 d_1 + d_2 + \\cdots + d_k = i - 1 ， 这个东西插板法一下就是 \\dbinom{i + k - 2}{k - 1} ，而对于 r 的情况是一个道理，插完板就是 \\dbinom{r - i + k - 1}{k - 1} 。 所以就有 sum_{k, 1, r} = \\sum_{i = 1}^r\\binom{i + k - 2}{k - 1}\\binom{r - i + k - 1}{k - 1}a_i 这个东西是一个卷积的形式（ i + r - i = r ），设 F_i = a_i\\dbinom{i + k - 2}{k - 1} ， G_i = \\dbinom{i + k + 1}{k - 1} ，则 sum_{k, 1, r} = \\displaystyle\\sum_{i = 1}^rF_iG_{r - i} 所以可以大力 NTT。现在最关键的是如何求出 \\dbinom{i + k - 2}{k - 1} 和 \\dbinom{i + k - 1}{k - 1} 。 可以线性递推！把 G_i 处理出来之后直接 F_i = a_iG_{i - 1} 。 \\begin{aligned} G_i &amp;= \\binom{i + k - 1}{k - 1} = \\frac{(i + k - 2)!(i + k - 1)}{i(i - 1)!(k - 1)!}\\\\ G_{i - 1} &amp;= \\binom{i + k - 2}{k - 1} = \\frac{(i + k - 2)!}{(i - 1)!(k - 1)!} \\end{aligned} 所以有如下结论 G_i = \\frac{i + k - 1}{i}G_{i - 1} 注意一下边界，边界是 G_0 = 1 。 Implementation 于是一不小心成了洛谷最优解。 123456789101112131415Poly f, g;int n, k, a[maxn];int main() { read(n), read(k); FOR(i, 1, n) read(a[i]); g.resize(n + 1), f.resize(n + 1), lim = n + 1, initInv(); g[0] = 1; FOR(i, 1, n) g[i] = 1ll * g[i - 1] * inv[i] % mod * (i + k - 1) % mod; FOR(i, 1, n) f[i] = 1ll * g[i - 1] * a[i] % mod; f = f * g; FOR(i, 1, n) print(f[i]), putchar(' '); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4451 [国家集训队]整数的lqp拆分","slug":"sol-luogu-p4451","date":"2021-08-15T06:54:01.000Z","updated":"2022-03-23T04:18:30.992Z","comments":true,"path":"sol-luogu-p4451/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4451/","excerpt":"","text":"Description 设斐波那契数列为 \\{F_n\\} ，求 g(n) = \\sum_{m&gt;0,a_i &gt; 0,\\sum a_i = n}\\prod_{i = 1}^mF_{a_i} 对 10^9 + 7 取模的结果。 Solution 很容易发现： g(0) = 1\\\\ g(n) = \\sum_{i \\ge 1} g(n - i)F_i 设 g 的 OGF 为 G(x) ，斐波那契熟列的 OGF 为 F(x) ，则有 G(x) = G(x)F(x) + 1 代入 F(x) = \\dfrac{x}{1 - x - x^2} ，得到 \\begin{aligned} G(x) &amp;= \\frac{1}{1 - F(x)}\\\\ G(x) &amp;= \\frac{1}{1 - \\frac{x}{1 - x - x^2}}\\\\ G(x) &amp;= \\frac{1 - x - x^2}{1 - 2x - x^2}\\\\ G(x) &amp;= 1 + \\frac{x}{1 - 2x - x^2}\\\\ \\end{aligned} 现在的目标就是展开 \\dfrac{x}{1 - 2x - x^2} 。 发现我们会做的是类似于 \\dfrac{1}{1 - cx} 的形式，类似斐波那契那样，因式分解一下下。 x^2 + 2x - 1 = 0 的两解分别为 -1\\pm\\sqrt2 ，代入一下发现 \\begin{aligned} \\frac{x}{1 - 2x - x^2} &amp;= \\frac{x}{(x_1 - x)(x_2 - x)}\\\\ &amp;= \\frac{x}{x_2 - x_1}\\left(\\frac{1}{x_1 - x} - \\frac{1}{x_2 - x}\\right)\\\\ &amp;= \\frac{x}{x_2 - x_1}\\left(\\frac{1}{x_1}\\frac{1}{1 - \\frac{1}{x_1}x} - \\frac{1}{x_2}\\frac{1}{1 - \\frac{1}{x_2}x}\\right)\\\\ &amp;= \\frac{x}{x_2 - x_1}\\left(\\frac{1}{x_1}\\sum_{i\\ge 0}\\frac{x^{i}}{x_1^i} - \\frac{1}{x_2}\\sum_{i \\ge 0}\\frac{x^i}{x_2^i}\\right)\\\\ &amp;= \\frac{1}{x_2 - x_1}\\left(\\sum_{i\\ge 0}\\frac{x^{i + 1}}{x_1^{i + 1}} - \\sum_{i\\ge 0}\\frac{x^{i + 1}}{x_2^{i + 1}}\\right)\\\\ \\end{aligned} 于是就有了 g(n) = \\frac{1}{x_2 - x_1}\\left(\\frac{1}{x_1^n} - \\frac{1}{x_2^n} \\right) 将 x_1 和 x_2 代入便有 g(n) = \\frac{\\sqrt2}{4}\\left[(1 + \\sqrt2)^n - (1 - \\sqrt2)^n\\right] 取 2 模 10^9 + 7 意义下的二次剩余 59713600 直接计算即可。由于 n 很大，根据欧拉定理对 10^9 + 6 取模即可。 Implementation 代码很短很好写。 12345678910111213141516171819202122#include &lt;cstdio&gt;const int mod = 1e9 + 7, sqrt2 = 59713600;int qPow(int a, int b = mod - 2, int p = mod) { int ret = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if (b &amp; 1) ret = 1ll * ret * a % p; return ret;}char str[10005];int main() { scanf(\"%s\", str + 1); int n = 0; for (int i = 1; str[i]; ++i) n = (10ll * n + str[i] - '0') % (mod - 1); printf(\"%d\\n\", 1ll * sqrt2 * qPow(4) % mod * (qPow(1 + sqrt2, n) - qPow(1 - sqrt2 + mod, n) + mod) % mod); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF438E The Child and Binary Tree","slug":"sol-cf438e","date":"2021-08-14T14:04:40.000Z","updated":"2022-03-23T04:18:30.711Z","comments":true,"path":"sol-cf438e/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf438e/","excerpt":"","text":"Description 现有一长度为 n 的互异正整数序列 \\{c_1, c_2, \\cdots, c_n\\} 。令二叉树的权值都从该序列中产生。对任意 1\\le s\\le m ，求出权值和恰好为 s 的不同二叉树的个数，答案对 998244353 取模。 Solution 考虑一个朴素的 DP。令 f_i 为权值和为 i 的二叉树的个数。则有如下转移： \\begin{cases} f_0 = 1\\\\ f_n = \\sum_{i = 1}^n[i\\in C]\\sum_{j = 0}^{n - i}f_jf_{n - i - j}&amp; n &gt; 0 \\end{cases} 然后设生成函数 \\displaystyle G(x) = \\sum_{i \\ge 0}[i\\in C]x^i ， F(x) = \\displaystyle\\sum_{i\\ge0} f_ix^i 。然后我们对于 n&gt;0 有下面这个式子： f_n = \\sum_{i = 1}^n g_i\\sum_{j = 0}^{n - i}f_jf_{n - i - j} 然后 i + j + (n - i - j) = n ，所以这其实就是三个多项式卷到一起，即 F(x) = 1 + G(x)F^2(x) 这个多出来的 1 是指 f_0 = 1 。 用初中知识算一下发现 F(x) = \\frac{1\\pm\\sqrt{1 - 4G(x)}}{2G(x)} 那么问题来了， + 和 - 应该取哪个呢？考虑取 + 的情况，下面运用一个叫分母无理化的小技巧。 \\begin{aligned} F(x) &amp;= \\frac{1 + \\sqrt{1 - 4G(x)}}{2G(x)}\\\\ &amp;= \\frac{4G(x)}{2G(x)(1 - \\sqrt{1 - 4G(x)})}\\\\ &amp;= \\frac{2}{1 - \\sqrt{1 - 4G(x)}} \\end{aligned} 然后会惊奇的发现当 x = 0 时整坨式子将不收敛（分母为 0 ）。 取 - 呢？ \\begin{aligned} F(x) &amp;= \\frac{1 - \\sqrt{1 - 4G(x)}}{2G(x)}\\\\ &amp;= \\frac{2}{1 + \\sqrt{1 - 4G(x)}} \\end{aligned} 开根，求逆，做完了。其思想就是将卷积形式的 dp 套上生成函数然后进行推导。 Implementation 犯困，犯了些憨憨错误。。。 123456789101112131415int n, m;Poly g, one(1, 1);int main() { read(n), read(m); g.resize(lim = m + 1); FOR(i, 1, n) { int c; read(c); if (c &lt;= m) g[c] = 1; } g = 2 * polyInv(one + polySqrt(one - 4 * g)); FOR(i, 1, m) print(g[i]), putchar('\\n'); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"数论复习笔记","slug":"summary-number-theory","date":"2021-08-12T06:49:34.000Z","updated":"2022-04-12T08:48:44.391Z","comments":true,"path":"summary-number-theory/","link":"","permalink":"https://old.blog.imyangty.com/summary-number-theory/","excerpt":"","text":"自己的总结，既适合新手入门也适合省选复习。文章可能很长，善用 TOC 进行跳转。 主要分为若干个板块，可能中间会有难度较高的内容，可以跳读。 前置常用技巧 较难归类的但是非常实用的小技巧。 常见符号 下文使用时将不加说明。 求和/求积符号： \\sum_{i = 1}^n f(i) = f(1) + f(2) + \\cdots f(n)\\\\ \\prod_{i =1}^nf(i) = f(1)\\times f(2)\\times \\cdots\\times f(n)\\\\ \\sum_{p(x)\\text{ is true}}f(x) = f(x_1) + f(x_2) + \\cdots\\text{for all }x_i\\text{ that meet the proposition} 艾弗森括号： [P] = \\begin{cases} 1,&amp;\\text{if the proposition } P \\text{ is true}\\\\ 0,&amp;\\text{if the proposition } P \\text{ is false} \\end{cases} 集合的表示： S = \\{x:P\\} 表示满足条件 P 的 x 构成的集合。 龟速乘/快速乘 有些毒瘤题会存在形如 ll * ll % ll 的操作，直接乘是会溢出出去的，在开不了 __int128 的时候只能考虑这两种方法。 龟速乘是指像做快速幂一样，只不过是乘法换加法，思想是一样的： 1234567891011ll mul(ll a, ll b, ll mod) { ll ans = 0, x = a; b = (b + mod) % mod, a = (a + mod) % mod; for (; b; b &gt;&gt;= 1ll) { if (b &amp; 1ll) ans = (ans + x) % mod; x = (x &lt;&lt; 1) % mod; } return ans;} 而快速乘则是利用了 long double 的神奇性质，一行就可以搞定： 1234567typedef long long ll;typedef long double ldb;il ll mul(ll a, ll b, ll mod) { return (a * b - (ll)((ldb)a / mod * b) * mod + mod) % mod;} 还未经过实测，但是模数很大时建议不使用，容易掉精度。 其原理即为 a\\times b\\equiv a\\times b - \\left\\lfloor\\frac{a\\times b}{p}\\right\\rfloor p\\pmod p upd：解禁了 __int128 之后这个东西应该是没必要了。。 光速幂 由于快速幂怎么样都会带一个 \\log ，在部分时限卡得很紧的题目中仍会 TLE，故引入该 trick。 其适用于模数固定，底数固定的情况。例： a^b\\bmod p ，其中 a 和 p 不变。 原理为分段打表。首先 p 如果为质数的话就欧拉定理降个幂，然后设指数上界为 m ，考虑 \\sqrt m 为阈值，处理出 a^0, a^1, \\cdots, a^{\\sqrt m} ，然后再处理出 a^0, a^{\\sqrt m}, a^{2\\sqrt m}, \\cdots, a^{\\sqrt m \\times \\sqrt m} 。 这样就可以 O(1) 回答询问。代码很好写，不放了。 底函数/顶函数 记 \\lfloor x\\rfloor 表示 x 向下取整， \\lceil x\\rceil 表示 x 向上取整。 那么有常见放缩： \\lfloor x\\rfloor \\le x\\le \\lceil x\\rceil 。 关键性质 1 ：若 f(x) 是单增函数，且 f(x)\\in\\mathbb Z\\implies x\\in\\mathbb Z ，则 \\lfloor f(\\lfloor x\\rfloor )\\rfloor = \\lfloor f(x)\\rfloor\\land \\lceil f(\\lceil x\\rceil )\\rceil = \\lceil f(x)\\rceil 具体证明可以画出函数图像来脑补一下。 这于是告诉了我们，对于正整数 n ，有 \\lfloor\\lfloor x / m\\rfloor/n\\rfloor = \\lfloor x / mn\\rfloor ，这个结论在后文推导莫比乌斯反演题目的时候很有用。 另外，对于底函数，有 关键性质 2 ：对于正整数 n 和 x ，若令 y = \\displaystyle\\left\\lfloor\\frac{n}{\\lfloor\\frac nx\\rfloor}\\right\\rfloor ，则 \\forall i\\in[x, y] 有 \\lfloor n / i\\rfloor = \\lfloor n / x\\rfloor 。（整除分块） 具体证明见下文。 数学基础 对数函数：若 a^x = b ，其中 a&gt;0\\land a\\ne1,b&gt;0 ，则 \\log_ab = x 。一般地记 \\ln x = \\log_{\\mathrm e}x ， \\lg x = \\log_{10}x 。 对数函数的运算性质： \\begin{aligned} \\log_ab &amp;= \\frac{\\log_cb}{\\log_ca}&amp;\\text{换底公式}\\\\ \\log_ab\\log_bc &amp;= \\log_ac\\\\ \\log_a{xy} &amp;= \\log_a x + \\log_ay&amp;\\text{化乘为加}\\\\ \\end{aligned} 换 底 公 式 化 乘 为 加 复杂度分析时一般忽略底数（因为也就是常数级别的差距）。 另外给出几个常见和式的估算： A(n) =\\displaystyle 1 + \\frac{1}{\\sqrt 2} + \\frac{1}{\\sqrt 3} + \\cdots + \\frac{1}{\\sqrt n} ，放缩或者积分逼近有 A(n) = \\Theta(\\sqrt n) 。 B(n) = 1 + \\sqrt 2+ \\sqrt 3+\\cdots + \\sqrt n ，积分逼近有 B(n) = \\Theta(n\\sqrt n) 。 调和级数求和 H(n) = \\displaystyle 1 + \\frac12 + \\frac 13 + \\cdots \\frac 1n ，积分逼近或放缩有 H(n) = \\Theta(\\ln n) 。 还有一些很重要的公式： 等差数列前缀和： S(n) = \\dfrac{(a_1 + a_n)n}{2} 。 等比数列前缀和： S(n) = \\dfrac{a_1(1 - q^n)}{1 - q} 。 一些常见的前缀和： 1+2+\\cdots+n = \\dfrac{n(n+1)}{2} 。 1^2+2^2+\\cdots+n^2 = \\dfrac{n(n+1)(2n+1)}{6} 。 1^3 + 2^3 + \\cdots + n^3 = \\left(\\dfrac{n(n+1)}{2}\\right)^2 。 数论基础 一些很基础的内容，大体了解之后再开始下面的深入学习。 整除 设 a,b\\in Z ，其中 a\\ne 0 。若 \\exists q\\in Z 使得 b = aq ，则说 b 可以被 a 整除，记作 a\\mid b 。 a 为 b 的约数， b 为 a 的倍数。 具有如下性质： 传递性： a\\mid b\\land b\\mid c\\implies a\\mid c a\\mid b\\land a\\mid c\\iff \\forall x,y\\in Z, a\\mid xb + yc 带余除法 一般来说，令 a,b\\in Z ，其中 a\\ne 0 ，则一定存在唯一确定的一组整数 q 和 r 满足 b = qa + r,0\\le r &lt; |a| 称为带余除法， q 为商， r 为余数。 注意， r 只能取 \\{0, 1, \\cdots, a - 1\\} 中的数字。在 C++ 中，使用 a % b 语句得到 a 除以 b 的余数。 LCM 与 GCD LCM，GCD 的详细定义见下文。 互素： 若 \\gcd(a_1, a_2) = 1 ，则称 a_1 与 a_2 互素（既约/互质），记作 a_1\\perp a_2 。 若 \\gcd(a_1,\\cdots, a_n) = 1 ，则称 a_1,\\cdots, a_n 互素。 多个整数互素并不代表他们一定两两互素。 质数 质数：令 a\\neq 0,\\pm 1 ，若 a 除了 \\pm 1 和 \\pm a 外无其他约数，则称 a 为质数。 合数：令 a\\neq 0,\\pm 1 ，若 a 不是质数，则为合数。 以下的质数一般指正质数。 大于 1 的整数 a 为合数等价于 a = d\\times e ，其中 1&lt; d,e &lt;a 。 偶质数只有 2 。 质数有无限个，证明考虑反证法。 对于合数 a ，一定存在质数 p \\le \\sqrt a 使得 p\\mid a 。 算术基本定理（唯一分解定理） 正整数 a 必能表示成如下形式： a = p_1^{\\alpha_1}p_2^{\\alpha_2}\\cdots p_k^{\\alpha_k} 其中 p_i 为质数，上式为 a 的标准质因子分解式。 同余 设整数 m\\neq 0 ， m\\mid a - b ，则称在模 m 意义下， a 与 b 同余，记作 a\\equiv b\\pmod m 一般来说模数都是正整数。 性质： 自反性： a\\equiv a\\pmod m 。 对称性： a\\equiv b\\pmod m\\iff b\\equiv a\\pmod m 。 传递性： a\\equiv b\\pmod m\\land b\\equiv c\\pmod m\\implies a\\equiv c\\pmod m 。 线性运算：若 a\\equiv b\\pmod m ， c\\equiv d\\pmod m ，则 a\\pm c\\equiv b\\pm d\\pmod m 。（加减上） ac\\equiv bd\\pmod m 。乘法可以但是除法不行。 若 a\\equiv b\\pmod m ，则 ak\\equiv bk\\pmod {mk} ，其中 k\\neq 0 。 除法的情况： k\\mid a\\land k\\mid b\\land k\\mid m ：若 a\\equiv b\\pmod m ，则 \\dfrac ak\\equiv \\dfrac bk\\pmod{\\dfrac mk} 。 乘法逆元见下。 一般在写程序时应用： 123(a + b) % p = (a % p + b % p) % p(a * b) % p = (a % p) * (b % p) % p 这就是为什么很多题目要求我们对很大的答案可以取模输出。 数论函数 定义域为 \\mathbf N^* ，值域为 \\mathbf C 的函数（可看作数列）。 积性函数：若 f(1) = 1 ，且 \\forall x\\perp y 都有 f(xy) = f(x)f(y) ，则称 f(n) 为积性函数。 完全积性：若 f(1) = 1 ，且 \\forall x,y 都有 f(xy) = f(x)f(y) ，则称 f(n) 为完全积性函数。 若 f(x) 和 g(x) 为积性函数，则下列函数也是积性（易证）： \\begin{aligned} h(x) &amp;= f(x^p)\\\\ h(x) &amp;= f^p(x)\\\\ h(x) &amp;= f(x)g(x)\\\\ h(x) &amp;= f(x)*g(x) = \\sum_{d\\mid x}f(d)g(\\frac xd) \\end{aligned} 积性函数一般可以指导我们干这样的事情，令 x = \\prod p_i^{\\alpha_i} （标准分解式） F(x) = \\prod F(p_i^{\\alpha_i}) 这个性质很关键，可以解决很多问题。 常见的函数： 单位函数： \\epsilon(n) = [n = 1] ，完全积性。 幂函数： \\operatorname{id}_k(n) = n^k ， \\operatorname{id}_1 一般记作 \\operatorname{id} ，完全积性。 常数函数： 1(n) = 1 ，完全积性。 除数函数： \\sigma_k(n) = \\sum_{d\\mid n}d^k ， \\sigma_0(n) 一般记作 d(n) 或 \\tau(n) ，表示约数个数。 \\sigma_1(n) 一般记作 \\sigma(n) ，表示约数之和，积性。 欧拉函数： [1, n] 内与 n 互质的数的个数： \\varphi(n) = \\sum_{i = 1}^{n - 1}[i\\perp n] ，积性。 莫比乌斯函数： \\mu(n) = \\begin{cases}1&amp;n = 1\\\\0&amp;\\exists d &gt; 1\\land d^2\\mid n\\\\(-1)^{\\omega(n)}&amp;\\text{otherwise}\\end{cases} ，其中 \\omega(n) 表示 n 的本质不同质因子个数。 欧拉函数的性质下文会提到，莫比乌斯函数会在莫反一节进一步展开。 几乎所有的积性函数都可以使用 O(n) 线性筛，详见下文线性筛部分。 最大公约数相关 基础性质 \\gcd(a, b) 表示 a 和 b 的最大公约数，其相当于在每个质因子的幂次上面取 \\min 。 \\operatorname{lcm}(a, b) 表示 a 和 b 的最小公倍数，相当于取 \\max 。 即： \\begin{aligned} a &amp;= \\prod p_i^{x_i}\\\\ b &amp;= \\prod p_i^{y_i}\\\\ \\gcd(a, b) &amp;= \\prod p_i^{\\min(x_i, y_i)}\\\\ \\operatorname{lcm}(a, b) &amp;= \\prod p_i^{\\max(x_1, y_i)} \\end{aligned} 于是我们可以得到下面的一个关键性质（常用于 \\gcd 和 \\operatorname{lcm} 的互化）： \\gcd(a,b) \\times \\operatorname{lcm}(a,b) = a\\times b 对于多个数，相当于就是 \\gcd(a,\\gcd(b, c)) ，道理是一样的。 欧几里得算法（辗转相除法） 考虑求 \\gcd(a,b) 。结论： \\gcd(a,b) = \\gcd(b, a\\bmod b) 考虑进行证明： 若 a &lt; b ，则 \\gcd(b, a\\bmod b) = \\gcd(b, a) ，显然得证。 否则，设 a = qb + r ，其中 0\\le r &lt; b ，显然 r = a\\bmod b ， \\forall d\\mid a, d\\mid b ，都有 d\\mid (a - qb) ，即 d\\mid r ，相当于 a,b 和 r, b 的公因数集合是一样的。其 gcd 自然相等，得证。 递归写法，因为 \\gcd(a, 0) = a ，所以递归终止条件是 b = 0 。 12int gcd(int a, int b) {return !b ? a : gcd(b, a % b);} 时间复杂度：由于若 a \\ge b ，则 a\\bmod b 一次至少可以让 a 折半， a&lt;b 的下一步必然是 a\\ge b ，故时间复杂度为 O(\\log n) 。上界很松，但 \\gcd(Fib_i, Fib_{i + 1}) 可以将其卡满。 Stein 算法（更相减损术） 算法流程： \\forall a,b\\in \\mathbf N, a \\ge b\\implies \\gcd(a, b) = \\gcd(a, a - b) = \\gcd(b, a - b) 并且 \\gcd(2a, 2b) = 2\\gcd(a, b) 证明略过，该算法主要在除法/取模操作很慢时有相当好的优化效果（如计算高精度 gcd 时）。 例题：P2152 [SDOI2009]SuperGCD：高精度求 gcd。 拓展欧几里得 求解过程 考虑解决一类问题：求不定方程 ax + by = c 的整数解，其中 a,b,c\\in\\mathbf Z 。 由下文裴蜀定理可知， \\gcd(a,b)\\mid c 时方程才有解。现在不妨先解决方程 ax + by = \\gcd(a, b) ，解出答案后扩大相应倍数即可。 设 \\begin{aligned} ax_1 + by_1 &amp;= \\gcd(a, b)\\\\ bx_2 + (a\\bmod b)y_2 &amp;= \\gcd(b, a\\bmod b) \\end{aligned} 由于 (a, b) = (b, a\\bmod b) ，故 \\begin{aligned} ax_1 + by_1 &amp;= bx_2 + (a\\bmod b)y_2\\\\ ax_1 + by_1 &amp;= bx_2 + (a - b\\lfloor\\frac ab\\rfloor)y_2\\\\ ax_1 + by_1 &amp;= bx_2 + ay_2 - b(\\lfloor\\frac ab\\rfloor y_2)\\\\ ax_1 + by_1 &amp;= ay_2 + b(x_2 - \\lfloor\\frac ab\\rfloor y_2) \\end{aligned} 所以 x_1 = y_2 ， y_1 = x_2 - \\lfloor\\frac ab\\rfloor y_2 。写成代码就是： 12345678910int exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { x = 1, y = 0; return a; } int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;} 边界条件显然有 a\\times 1 + 0\\times b = a 。 这样子解出来的一组解是 ax + by = \\gcd(a, b) 的一组特解 (x_0, y_0) 。回代一下原方程： \\begin{aligned} ax_0 + by_0 &amp;= \\gcd(a, b)\\\\ a\\cdot\\frac{cx_0}{\\gcd(a, b)} + b\\cdot\\frac{cy_0}{\\gcd(a, b)} &amp;= c \\end{aligned} 所以原方程的特解 x^* 和 y^* 为 x^* =\\frac{cx_0}{\\gcd(a, b)}, y^* =\\frac{cy_0}{\\gcd(a, b)} 构造通解 设任意 d\\in\\mathbf Q ，则 a(x^* + db) + b(y^* - da) = c 必然是成立的。通解需要保证 x^* + db 与 y^* - da 都为整数，所以通解的形式为： x = x^* + s\\cdot\\frac{b}{\\gcd(a, b)}\\\\ y = y^* - s\\cdot\\frac{a}{\\gcd(a, b)} 其中 s\\in \\mathbf Z 。 我们是不是就可以知道， x 和 y 是负相关的。其实我们将其表示的直线画在坐标系里面就会发现这是显然的。 判断解的个数/最小正整数解之类的把不等式列出来，算清楚就可以解决了。 值域分析 咕了。 裴蜀定理 对于两个数的情况： \\forall a, b\\in \\mathbf Z ，令 \\gcd(a, b) = d ，则 \\forall x,y\\in\\mathbf Z ，都有 d\\mid ax + by 特别的， \\exists x, y\\in\\mathbf Z 使得 ax + by = d 证明：考虑若 ax + by = d 成立，则 ax + by = sd （其中 s\\in \\mathbf Z ）也是成立的。所以先证明 ax + by = d 成立。 然后，假设其成立，则我们可以两边同时除以 d ，得到 a'x + b'y = 1 ，故我们证明其成立即可。 我们构造一个解：回顾辗转相除法，设每次模出来的余数为 r_i ，则我们有： (a_1, b_1) = (b_1, r_1) = (r_1, r_2) = \\cdots (r_{n - 1}, r_n) = 1 展开辗转相除过程中的运算： \\begin{aligned} a_1 &amp;= q_1b_1 + r_1\\\\ b_1 &amp;= q_2r_1 + r_2\\\\ r_1 &amp;= q_3r_2 + r_3\\\\ &amp;\\cdots\\\\ r_{n - 3} &amp;= q_{n - 1}r_{n - 2} + r_{n - 1}\\\\ r_{n - 2} &amp;= q_{n}r_{n - 1} + r_n\\\\ r_{n - 1} &amp;= q_{n + 1}r_n \\end{aligned} 辗转相除到最后， r_n = 1 ，将所有的 q 换成 x 的形式： r_{n - 2} = x_nr_{n - 1} + 1 r_{n - 2} - r_{n - 1}x_n = 1 然后将倒数第三个式子 r_{n - 1} = r_{n - 3} - x_{n - 1}r_{n - 2} 代入，则 r_{n - 3}x_1 - x_{n - 1}x_nr_{n - 2} = r_{n - 2} - 1 整理得 (1 + x_{n -1}x_n)r_{n - 2} - x_nr_{n - 3} = 1 一步步回代，就可以得到 ax+ by = 1 的形式。 拓展到 n 个整数上，令 a_1,\\cdots,a_n\\in\\mathbf Z ，令 \\gcd\\{a_1,\\cdots, a_n\\} = d ，则 \\forall x_i\\in \\mathbf Z ，都有 d\\mid \\sum_{i = 1}^na_ix_i 例题：P4549 【模板】裴蜀定理：最小的情况明显是 \\gcd 。 基于值域预处理的快速 GCD 这是一个当询问 gcd 的次数巨大多而值域 N 有限（ 10^6 级别左右）时，可以 O(N) 预处理， O(1) 回答单次询问的神奇方法。有些时候可以拯救你的常数。 定义一个数集 \\{a_1, \\cdots, a_k\\} 为 n 的分解当 \\prod_{i =1}^ka_i = n 。 引理：可以将值域内的每个数 n 分解为 \\{a, b, c\\} ，且 a,b,c\\le \\sqrt n 或为质数。下面默认 a\\le b\\le c 。 证明：不妨设 c 不为质数且 c&gt; \\sqrt n 。那么 c 显然可以分解为 \\{d, e\\} 且 d\\le e\\land d\\le \\sqrt n 。而 a\\times b= \\dfrac nc&lt; \\sqrt n ， 所以有 n 的分解 \\{d, ab, e\\} ，于是乎可以这样一直分解下去到合法为止。 然后对于询问 \\gcd(x, y) ，我们就分解 x = abc ，分开考虑其贡献。 a 对答案的贡献为 \\gcd(a, y) = \\gcd(a, y\\bmod a) ，然后将 y 除掉 \\gcd(a, y) 防止重复统计贡献，然后对 b 和 c 做同样的事情就可以了。 现在的问题是如何在 O(N) 的时间内计算出每个数的分解。 方法：对于 x = 1 ，显然为 \\{1, 1, 1\\} ；对于 x\\ge 2 ，找到 x 的最小质因子 p 以及 \\dfrac xp 的合法分解 \\{a_0, b_0, c_0\\} ，则 x 的一种合法分解为 \\{a_0p, b_0, c_0\\} 的升序排序。 证明： x 为质数时显然成立，为 \\{1, 1, x\\} 。 p\\le\\sqrt[4]x 时，由于 a_0\\le\\sqrt[3]{\\dfrac{x}{p}} ，故 a_op\\le \\sqrt x 。 p &gt; \\sqrt[4]x 时： a_0 = 1 时，有 a_0p = p\\le \\sqrt x 。 a_0\\ne 1 时，由于 x 不为素数，所以 \\dfrac xp 的最小质因子 q 即为 x 的第二小质因子，一定 \\ge p 。我们又可以知道 p \\le q\\le a_0\\le b_0\\le c_0 ，所以 pa_0b_0c_0 &gt; (\\sqrt[4]x)^4 = x 与 pa_0b_0c_0 = x 矛盾，故该情况不存在。 那么线性筛的时候顺带用最小质因子更新，预处理 \\sqrt N 范围的 \\gcd 数组即可。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738const int N = 1e6, T = 1e3, maxn = 5005;int isp[N + 5], p[N + 5], cnt;int fac[N + 5][3], _gcd[T + 5][T + 5];void sieve() { fac[1][0] = fac[1][1] = fac[1][2] = 1; FOR(i, 2, N) { if (!isp[i]) p[++cnt] = i, fac[i][0] = fac[i][1] = 1, fac[i][2] = i; for (int j = 1; i * p[j] &lt;= N &amp;&amp; j &lt;= cnt; ++j) { int tmp = i * p[j]; isp[tmp] = 1; fac[tmp][0] = fac[i][0] * p[j]; fac[tmp][1] = fac[i][1], fac[tmp][2] = fac[i][2]; if (fac[tmp][0] &gt; fac[tmp][1]) myswap(fac[tmp][0], fac[tmp][1]); if (fac[tmp][1] &gt; fac[tmp][2]) myswap(fac[tmp][1], fac[tmp][2]); if (i % p[j] == 0) break; } } FOR(i, 0, T) _gcd[i][0] = _gcd[0][i] = i; FOR(i, 1, T) FOR(j, 1, i) _gcd[i][j] = _gcd[j][i] = _gcd[j][i % j]; return;}int gcd(int x, int y) { int ans = 1; FOR(i, 0, 2) { int d; if (fac[x][i] &lt;= T) d = _gcd[fac[x][i]][y % fac[x][i]]; else if (y % fac[x][i] == 0) d = fac[x][i]; else d = 1; y /= d; ans *= d; } return ans;} 类欧几里得算法 是一个比较阴间的东西。详细全文见类欧学习笔记。该算法由洪华敦（SkyDec）于 WC2016 员交提出。递归过程类似于辗转相除，故称为”类“欧几里得。一般可以求直线下整点之类的问题。 基本形式 若令 f(a, b, c, n) = \\sum_{i = 0}^n\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor 则若我们令 m = \\displaystyle\\left\\lfloor\\frac{an + b}{c}\\right\\rfloor ，有 f(a, b, c, n) = \\begin{cases} \\displaystyle \\frac{n(n + 1)}{2}\\left\\lfloor\\frac ac\\right\\rfloor + (n + 1)\\left\\lfloor\\frac bc\\right\\rfloor + f(a\\bmod c, b\\bmod c, c, n) &amp; a\\ge c\\lor b\\ge c\\\\ \\displaystyle nm - f(c, c - b - 1, a, m - 1)&amp;\\text{otherwise} \\end{cases} 而 f(a, b, c, n) 的意义即为直线 y = \\dfrac{ai + b}{c} 下方整点的个数。 简要推导 该问题较为复杂，不妨一步步考虑起。假设 a\\ge c\\lor b\\ge c ，则我们可以先将 a 和 b 对 c 取模，即 \\begin{aligned} f(a, b, c, n) &amp;= \\sum_{i = 0}^n\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor\\\\ &amp;= \\sum_{i = 0}^n\\left\\lfloor\\frac{(\\left\\lfloor\\frac a c\\right\\rfloor c + a\\bmod c)i + \\left\\lfloor\\frac b c\\right\\rfloor c + b\\bmod c}{c}\\right\\rfloor\\\\ &amp;= \\frac{n(n + 1)}{2}\\left\\lfloor\\frac ac\\right\\rfloor + (n + 1)\\left\\lfloor\\frac bc\\right\\rfloor + f(a\\bmod c, b\\bmod c, c, n) \\end{aligned} 然后问题就变成了 a,b&lt; c 的形式。 先考虑拆分贡献，将 \\displaystyle\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor 拆成 \\displaystyle\\sum_{j = 0}^{\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor - 1}1 的形式，随后调换求和顺序，使得 j 不受 i 限制， \\displaystyle\\sum_{j = 0}^{\\left\\lfloor\\frac{an + b}{c} \\right\\rfloor}\\sum_{i = 0}^n\\left[j &lt; \\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor\\right] ，之后就是化简这个不等式，不等式的化简过程如下： \\begin{aligned} &amp;j &lt; \\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor\\\\ \\iff &amp; j + 1\\le\\left\\lfloor\\frac{ai + b}{c} \\right\\rfloor\\\\ \\iff &amp; j + 1\\le \\frac{ai + b}{c}\\\\ \\iff &amp; j c + c\\le ai + b\\\\ \\iff &amp; jc + c - b\\le ai\\\\ \\iff &amp; jc + c - b - 1 &lt; ai\\\\ \\iff &amp; \\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor &lt; i \\end{aligned} 中间用到了几步比较巧妙的放缩。然后 i 就没了，令 \\displaystyle m = \\left\\lfloor\\frac{an + b}{c}\\right\\rfloor ，则 \\displaystyle f(a, b, c, n) = \\sum_{j = 0}^{m - 1}\\left(n - \\left\\lfloor\\frac{jc + c - b - 1}{a}\\right\\rfloor\\right) ，拆开来发现其实其就是一个子问题。所以得到答案 \\displaystyle f(a, b, c, n) = nm - f(c, c - b - 1, a, m - 1) 。 写成代码就是下面这样，边界是 a = 0 ： 1234567int f(int a, int b, int c, int n) { if (!a) return b / c * (n + 1); if (a &gt;= c || b &gt;= c) return n * (n + 1) / 2 * (a / c) + (n + 1) * (b / c) + f(a % c, b % c, c, n); int m = (a * n + b) / c; return n * m - f(c, c - b - 1, a, m - 1);} 扩展形式 \\begin{aligned} g(a, b, c, n) &amp;= \\sum_{i = 0}^ni\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor\\\\ h(a, b, c, n) &amp;= \\sum_{i = 0}^n\\left\\lfloor\\frac{ai + b}{c}\\right\\rfloor^2\\\\ \\end{aligned} 这两个函数的计算大同小异。都是分别考虑 a\\ge c\\lor b\\ge c 并取模化简，然后一步步化简式子化成子问题。 直接放结论： g(a,b,c,n) = \\begin{cases} \\displaystyle\\left\\lfloor\\frac ac\\right\\rfloor\\frac{n(n + 1)(2n + 1)}{6} + \\left\\lfloor\\frac bc\\right\\rfloor\\frac{n(n + 1)}{2} + g(a\\bmod c, b\\bmod c, c, n) &amp; a\\ge c\\lor b\\ge c\\\\ \\displaystyle\\frac 12\\left(mn(n + 1) - h(c, c - b - 1, a, m - 1) - f(c, c - b - 1, a, m - 1) \\right)&amp;\\text{otherwise} \\end{cases} 很阴间。 h(a, b, c, n) = \\begin{cases} \\begin{aligned} &amp;\\left\\lfloor\\frac ac\\right\\rfloor^2\\frac{n(n + 1)(2n + 1)}{6} + n(n + 1)\\left\\lfloor\\frac ac\\right\\rfloor\\left\\lfloor\\frac bc\\right\\rfloor + (n + 1)\\left\\lfloor\\frac bc\\right\\rfloor^2 + \\\\&amp;+2\\left\\lfloor\\frac ac\\right\\rfloor g(a\\bmod c, b\\bmod c, c, n) + 2\\left\\lfloor\\frac bc\\right\\rfloor f(a\\bmod c, b\\bmod c, c, n) \\\\ &amp;+ h(a\\bmod c, b\\bmod c, c, n) \\end{aligned}&amp;a\\ge c\\lor b\\ge c\\\\\\\\\\\\ nm(m + 1) - 2g(c, c - b - 1, a, m - 1)\\\\ - 2f(c, c - b - 1, m - 1) - f(a, b, c, n)&amp;\\text{otherwise} \\end{cases} 万能欧几里得 素数 简介 定义见上文。 关于素数密度，有如下重要结论：设小于等于 x 的素数有 \\pi(x) 个，则 \\pi(x)\\sim\\frac{n}{\\ln n} 估计素数个数上很有用。 筛法 想要找出 [1, n] 内所有的数字，一般有如下两种方法： Eratosthenes 筛法 一般称为埃筛。思想：合数的倍数一定是合数，而质数的 \\ge 2 倍数一定是合数。 所以算法流程就是，当碰到一个质数时，标记其全部倍数。当碰到合数时直接跳过不管。 时间复杂度为 O(n\\log\\log n) ，暂时不要求掌握其证明。 埃筛的应用其实有限，但是在 Dirichlet 前缀和还是运用到了其思想的。 欧拉线性筛 上面的埃筛虽然实际跑的不慢，但当 n 达到 10^7 以至 10^8 级别时仍然会显得很吃力。 我们考虑，如果每个合数只被其最小的质因子筛去，是不是时间复杂度就是 O(n) 了。 算法流程： 遇到一个没被筛过的数时，其肯定为质数，标记一下。 然后枚举已经有过的素数 p_j ，标记 i\\times p_j 为合数，当 p_j\\mid i 时结束循环。 即 12345678FOR(i, 2, n) { if (!isp[i]) pri[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; ++j) { isp[i * pri[j]] = 1; if (!(i % pri[j])) break; }} 解释一下这样做的原理：我们注意到 p_j\\mid i 时， p_j 一定是 i\\times p_j 的最小质因子，因为如果存在更小的，一定会被先枚举到。由于一个合数需要被其最小质因子筛去，所以此时需要结束循环。 本方法不仅可以筛质数，还可以求很多积性函数的值。每个合数都被其最小质因子筛去这一关键性质决定了其极强的扩展性，详见下文筛法部分。 素性测试 暴力判断 我们可以 O(\\sqrt n) 来判断单个数是不是质数。 涉及到多个数的判断的话可以使用线性筛。 但是如果数很大（ 10^{18} 级别）的话我们还是需要使用概率性素性测试通过牺牲一部分正确率来换取更高的效率。 Fermat 素性测试 根据下文提到的费马小定理，对于质数 p 和正整数 a &lt; p 一定有 a^{p - 1}\\equiv 1\\pmod p ，所以为了判断 n 的素性，可以不断选取 [2, n - 1] 中的基 a 然后判断是否有 a^{n - 1}\\equiv 1 。 但是由于费马小定理的逆定理不存在，所以上述方法可能会错误判断。例如若 a^{n - 1}\\equiv 1\\pmod n 但 n 不是素数，则称 n 为以 a 为底的伪素数。同时还存在一类合数满足 \\forall a\\perp n 都有 a^{n -1}\\equiv 1 成立，这样的数被称为卡迈克尔数。 Miller-Rabin 素性测试 实战中可以使用的一种高效素数判断方法，对 n 进行 k 轮测试的复杂度为 O(k\\log^3n) ，且基本不会出错。 二次探测定理：若 p 为奇素数，则 x^2\\equiv 1\\pmod p 的解为 x\\equiv \\pm1\\pmod p 。证明考虑移项出 (x + 1)(x - 1) \\equiv 0 即可。 那么我们就将 Fermat 素性测试和二次探测定理联合起来使用，考虑将 n - 1 分解成 u\\times 2^t ，然后先求出 a^u\\pmod n ，之后对他进行 t 次平方操作，若中途发现非平凡平方根则其不是素数，否则通过本轮测试。 取 A = \\{2,3,5,7,11,13,17,19,23\\} 便可通过绝大部分数据。给我背板子！ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using ll = long long;const ll a[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23};ll qPow(ll base, ll exp, ll mod) { ll ret = 1; for (; exp; exp &gt;&gt;= 1, base = __int128(base) * base % mod) if (exp &amp; 1) ret = __int128(ret) * base % mod; return ret;}bool isPrime(ll n) { FOR(i, 0, 8) if (n == a[i]) return true; if (n &lt; 2 || !(n &amp; 1)) return false; ll t = 0, u = n - 1, j; while (!(u &amp; 1)) u &gt;&gt;= 1, ++t; FOR(i, 0, 8) { ll v = qPow(a[i], u, n); if (v == 1) continue; for (j = 1; j &lt;= t; ++j) { if (v == n - 1) break; v = __int128(v) * v % n; } if (j &gt; t) return false; } return true;}int main() { ll x; while (cin &gt;&gt; x) puts(isPrime(x) ? \"Y\" : \"N\"); return 0;} 质因数分解 Pollard-Rho 会在 NOI 前重构。 朴素分解 最最最朴素的枚举因子然后 O(\\sqrt n) 的分解方法略。 需注意：若提前打好了质数表，复杂度降为 \\displaystyle O\\left(\\sqrt{\\frac{n}{\\ln n}}\\right) 。 当 n 为 10^{18} 级别时其显得无能为力。故我们还是考虑牺牲正确性来换取性能，考虑如何求出一个数的非平凡因子。 有一个最朴素的随机算法： 123456789101112131415template&lt;typename T&gt; T rnd(T l, T r = 0) { static mt19937 eng(20041031); if (l &gt; r) swpa(l, r); uniform_int_distribution&lt;T&gt; dis(l, r); return dis(eng);}ll findFact(ll n) { if (isPrime(n)) return n; ll x; do x = rnd(2, n - 1); while (n % x); return x;} 这个想法确实非常的蠢（类比猴子排序），但这确实是 Pollard-Rho 算法的基础。 生日悖论 一个房间里有 23 个人，则他们中有两人生日相同的概率超过一半，这应该是个很经典的 fun fact。 这启示我们，对于一个 [1, n] 的随机整数生成器，生成序列中第一个重复数字前期望有 \\sqrt{\\dfrac{\\pi n}{2}} 个数，这里是证明。 这告诉我们，采用“组合随机采样”的方法，满足答案的组合比单体个数要多，所以可以提高正确率。回到原来的问题，发现一个很关键的性质： \\forall k\\in\\mathbb N, \\gcd(k,n)\\mid n 。所以只要选到恰当的 k 使得 \\gcd(k, n) &gt; 1 即可求得一个非平凡因子。关键是，这样的 k 的个数还不少。 不妨选一组数 x_1,\\cdots, x_m ，若 \\gcd(|x_i - x_j|, n)&gt; 1 ，则我们可以直接返回 \\gcd(|x_i - x_j|, n) ，而如何选数显得尤为必要。 伪随机函数 Pollard-Rho 算法使用了些技巧，通过 f(x) = (x^2 + c)\\bmod n 来生成一个随机数序列 \\{x_i\\} ，其中 c 为随机出来的常数。 随机一个 x_1 ，然后对于 i\\ge 2 ， x_i = f(x_{i - 1}) ，可以近似认为他随机。但是会发现其会进入一个环（所以叫做 \\rho 算法）。例如取 c = 2, x_1 = 1 的情况： 1,3,11,23,31, 11,23,31,\\cdots Floyd 判环 “龟兔赛跑”。用两个数 t 和 r ，初始时 t = r = 1 ，然后每次兔子跳两格，乌龟走一步： x_t = x_i ， x_{r} = x_{2i} 。注意到他们迟早是会相遇的。 所以可以写出如下代码： 1234567891011ll findFact(ll n) { ll c = rnd(1, n - 1); ll t = f(0, c, n), r = f(f(0, c, n), c, n); while (t != r) { ll d = gcd(myabs(t - r), n); if (d &gt; 1) return 1; t = f(t, c, n), r = f(f(r, c, n), c, n); } return n;} 优化 求 \\gcd 的个数太多了，求一次就是 O(\\log n) ，需要优化。 考虑若 \\gcd(x, n)&gt;1 则 \\gcd(xy, n) &gt; 1 ，更进一步的有 \\gcd(xy\\bmod n, n) &gt; 1 。所以可以将所有的 |t - r| 在模意义下相乘，再做 \\gcd 。 考虑倍增以避免 \\gcd 过多或者在环上停留过久。 1234567891011121314151617181920ll findFact(ll n) { ll c = rnd(1, n - 1); ll s = 0, t = 0; int step = 0, goal = 1; ll val = 1; for (goal = 1; ; goal &lt;&lt;= 1, s = t, val = 1) { for (step = 1; step &lt;= goal; ++step) { t = f(t, c, n); val = __int128(val) * myabs(t - s) % n; if (step % 127 == 0) { ll d = gcd(val, n); if (d &gt; 1) return d; } } ll d = gcd(val, n); if (d &gt; 1) return d; } return n;} 下面是 Library Checker 质因数分解的模板实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using ll = long long;const ll a[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23};vector&lt;ll&gt; ans;ll qPow(ll base, ll exp, ll mod) { ll ret = 1; for (; exp; exp &gt;&gt;= 1, base = __int128(base) * base % mod) if (exp &amp; 1) ret = __int128(ret) * base % mod; return ret;}bool isPrime(ll n) { FOR(i, 0, 8) if (a[i] == n) return true; if (n &lt; 2 || !(n &amp; 1)) return false; ll t = 0, u = n - 1; while (!(u &amp; 1)) u &gt;&gt;= 1, ++t; FOR(i, 0, 8) { ll v = qPow(a[i], u, n), j; if (v == 1) continue; for (j = 1; j &lt;= t; ++j) { if (v == n - 1) break; v = __int128(v) * v % n; } if (j &gt; t) return false; } return true;}ll f(ll x, ll c, ll mod) {return (__int128(x) * x % mod + c) % mod;}ll rnd(ll l, ll r = 0) { static mt19937_64 eng(20041031); if (l &gt; r) swap(l, r); uniform_int_distribution&lt;ll&gt; dis(l, r); return dis(eng);}ll pollardRho(ll n) { ll c = rnd(1, n - 1); ll s = 0, t = 0, val = 1; int step = 0, goal = 1; for (goal = 1; ; goal &lt;&lt;= 1, s = t, val = 1) { for (step = 1; step &lt;= goal; ++step) { t = f(t, c, n); val = __int128(val) * __builtin_llabs(s - t) % n; if (step % 127 == 0) { ll d = __gcd(val, n); if (d &gt; 1) return d; } } ll d = __gcd(val, n); if (d &gt; 1) return d; }}vector&lt;ll&gt; work(ll n) { if (n &lt; 2) return {}; if (isPrime(n)) return {n}; ll p = n; while (p &gt;= n) p = pollardRho(n); vector&lt;ll&gt; tmp = work(p), ret; while (n % p == 0) { for (auto &amp;x : tmp) ret.emplace_back(x); n /= p; } tmp = work(n); for (auto &amp;x : tmp) ret.emplace_back(x); return ret;}int main() { int T; cin &gt;&gt; T; while (T--) { ll n; cin &gt;&gt; n; auto ans = work(n); sort(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; ' '; for (auto &amp;x : ans) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; endl; } return 0;} 反素数 基础整除理论 同余类与剩余系 同余类（也称剩余类），指全体整数按照对一个正整数的同余关系而分成的类。具体地，设 m 为给定正整数， C_r(r = 0,1,\\cdots, m -1) 表示形如 qm + r 的整数构成的集合，其中 q\\in\\mathbb Z ，则 C_0,\\cdots, C_{m - 1} 称为模 m 的同余类。 相当于，每个整数被包含在一个类中，且同一个类内的元素彼此模 m 同余。 设 a_0,\\cdots, a_{m - 1} 为 m 个整数，当他们两两之间都不在同一个同余类中，我们就称其为模 m 的一个完全剩余系。 若剩余系内的每个元素均与 m 互质，则称其为简化剩余系/缩系/既约剩余系。 乘法逆元 定义 又叫做数论倒数。若 ax\\equiv1\\pmod p ，且 a\\perp p ，则称 x 为 a 关于模 p 的乘法逆元，记作 x = a^{-1} 。 从群论的角度考虑的话： 1 为群 (\\mathbb Z_p, \\times) 的单位元， ax\\equiv1 即意味着 x 为 a 的逆元。 一般来说，我们如果要计算 \\dfrac ab\\pmod p ， 那么我们可以考虑计算 a\\times b^{-1}\\pmod p ，这即为有理数取模的意义。 求单个逆元 求逆元是一个很重要的话题，是做大多数组合题/数论题的基础。 第一种方法是当 p 为质数时，用下面提到的费马小定理可以得到 a^{-1} \\equiv a^{p - 2}\\pmod p 于是我们在模意义下求一个快速幂即可。 第二种方法较为通用，我们列出方程 ax\\equiv 1\\pmod p ，然后转化为不定方程 ax + py = 1 ，使用 exgcd 来求解 x 的值。同时我们可以注意到，这个方程有解等价于 a\\perp p 。故当 a\\perp p 时其关于模 p 的逆元才存在。 线性求逆元 有一个很重要的技巧：线性求 [1, n] 的逆元。我们如果每个单独的求的话，复杂度为 n\\log n ，在 n 为 10^7 时显然是不够用的。 令 p=ki+r ，其中 k=\\lfloor \\frac p i\\rfloor ， r=p\\bmod i ，且 1&lt;r&lt;i&lt;p 。则在模 p 意义下有 ki+r\\equiv 0\\pmod p 两边同时乘以 r^{-1}i^{-1} ，则 kr^{-1}+i^{-1}\\equiv0\\pmod p 移项， i^{-1}\\equiv-kr^{-1}\\pmod p 代入 k=\\lfloor \\frac p i\\rfloor ， r=p\\bmod i ，有 i^{-1}\\equiv -\\lfloor \\frac p i\\rfloor(p\\bmod i)^{-1}\\pmod p 由于要保证 i^{-1}&gt;0 ，在最终式子的右边加上 p （ p\\equiv 0\\pmod p ），最终的式子就是： i^{-1}\\equiv p-\\lfloor \\frac p i\\rfloor(p\\bmod i)^{-1}\\pmod p 令 inv[i] 表示 i^{-1} 则递推式如下： 123for (int i = 2; i &lt;= n; i++) inv[i] = (p - p / i) * inv[p % i] % p; 事实上，这个东西没有必要记忆，在下文学习阶乘逆元后可以用更自然的方法求出来。本法的扩展性不如下面的方法强。 阶乘逆元 求组合数的时候经常用得到。 首先可以把模意义下的阶乘全部求出来，然后快速幂求一下 n! 的逆元。 然后有 (i!)^{-1} = (i + 1)\\times((i + 1)!)^{-1} 显然，不证。推就推完了。我们还可以得到 i^{-1} = (i - 1)!\\times (i!)^{-1} 。 这种方法非常好理解并且有较好的扩展性，一定要牢记。 小小扩展一下： P5431 【模板】乘法逆元 2。 实际上就是类似于阶乘逆元的方法。我们考虑求一个前缀积，然后给最后一个 s_n 求一个逆元，之后就可以一步步倒推回去求出 a_i^{-1} 。 欧拉函数 定义 Euler's totient function， \\varphi(n) ，表示 [1, n] 中和 n 互质的数的个数。即 \\varphi(n) = \\sum_{i = 1}^n[i\\perp p] 性质 欧拉函数是积性函数。 n = \\sum_{d\\mid n}\\varphi(d) 。 该点可以在下文中的莫比乌斯反演处进行进一步学习。 \\forall n \\gt 1 ， [1,n] 中与 n 互质的数之和为 n\\varphi(n)/2 。简证：与 n 不互质的数 x,n-x 成对出现，所以平均值为 n/2 。 若 n = p^k （下文中若 p 不加说明则默认为质数），则 \\varphi(n) = p^k - p^{k - 1} 。 证明考虑定义即可。 [1, p^k] 中除了 p^{k} / p = p^{k - 1} 个 p 的倍数外都与 p^k 互质。 单个欧拉函数的计算：令 n = \\prod p_i^{c_i} ，则 \\varphi(n) = n\\prod(1 - \\frac{1}{p_i}) 证明：由欧拉函数的积性，我们可以得到 \\begin{aligned} \\varphi(n) &amp;= \\prod\\varphi(p_i^{k_i})\\\\ &amp;= \\prod p_i^{k_i - 1}(p_i - 1)\\\\ &amp;= \\prod p_i^{k_i}(1 - \\frac{1}{p_i})\\\\ &amp;= n\\prod(1 - \\frac 1{p_i}) \\end{aligned} 所以我们在求单个欧拉函数值时，可以用下面的代码： 1234567891011int phi(int n) { int ans = n; for (int i = 2; i * i &lt;= n; ++i) if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } if (n &gt; 1) ans = ans / n * (n - 1); return ans;} 欧拉函数的线性筛法： \\varphi(1) = 1 。 质数： \\varphi(p) = p - 1 。 合数：我们知道每个合数 n 都是被其最小质因子 p 筛掉的，设 n = n'p 。 当 p\\perp n' 时，由欧拉函数的积性显然有 \\varphi(n) = \\varphi(n')(p - 1) 。 当 p\\not\\perp n' 时，则 p 也是 n' 的最小质因子，而且 n' 包含了 n 所有的质因子。 \\begin{aligned} \\varphi(n) &amp;= n\\prod\\frac{p_i - 1}{p_i}\\\\ &amp;= pn'\\prod\\frac{p_i - 1}{p_i}\\\\ &amp;= p\\varphi(n') \\end{aligned} 所以就可以按照如下的代码线性求出 [1, n] 的欧拉函数值。 12345678910111213141516171819void init() { phi[1] = 1; for (int i = 2; i &lt;= maxn; ++i) { if (!vis[i]) { phi[i] = i - 1; p[++tot] = i; } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= maxn; ++j) { vis[i * p[j]] = 1; if (i % p[j] == 0) { phi[i * p[j]] = p[j] * phi[i]; break; } phi[i * p[j]] = (p[j] - 1) * phi[i]; } } return;} 欧拉函数的衰减速度是 O(\\log) 级别的。 应用 （扩展）欧拉定理中有应用。 在莫比乌斯反演中扮演重要角色。 抓住欧拉函数与互质的关系。 欧拉定理 费马小定理 若 p 为素数，且 a\\perp p ，则 a^{p - 1}\\equiv 1\\pmod p 。 另一个形式： a^p\\equiv p\\pmod p 。 证明见下面的欧拉定理。这个东西最重要的用途就是求逆元，见上文。 欧拉定理 若 a,n\\in\\mathbb{N}^+,a\\perp n ，则 a^{\\varphi(n)}\\equiv 1\\pmod n 证明： 设 n 的简化剩余系为 \\lbrace\\overline{a_1},\\overline{a_2},\\cdots,\\overline{a_{\\varphi(n)}} \\rbrace 。对 \\forall a_i, a_j ，若 aa_i\\equiv aa_j\\pmod n ，则 a(a_i-a_j)\\equiv 0\\pmod n 。因为 a\\perp n ，所以 a_i\\equiv a_j 。故当 a_i\\not=a_j 时， aa_i,aa_j 也代表不同同余类。 而简化剩余系关于模 n 乘法运算封闭 ，所以简化剩余系 \\lbrace\\overline{a_1},\\overline{a_2},\\cdots,\\overline{a_{\\varphi(n)}} \\rbrace 与 \\lbrace\\overline{aa_1},\\overline{aa_2},\\cdots,\\overline{aa_{\\varphi(n)}} \\rbrace 是等价的。综上： a^{\\varphi(n)}a_1a_2\\cdots a_{\\varphi(n)}\\equiv (aa_1)(aa_2)\\cdots(aa_{\\varphi(n)})\\equiv a_1a_2\\cdots a_{\\varphi(n)}\\equiv 1\\pmod n 欧拉定理得证。 当 p 为质数时， \\varphi(p) = p - 1 ，且只有 p 的倍数与 p 不互质。显然当 a\\perp p 时 a^{p - 1} \\equiv 1\\pmod n ，两边同乘 a 得到费马小定理。而当 a\\not\\perp p 时费马小定理显然成立。 扩展欧拉定理 a^b\\equiv \\begin{cases} a^{b\\bmod \\phi(m)}&amp;,a\\perp m\\\\ a^b&amp;,a\\not\\perp m\\land b&lt;\\phi(m)\\\\ a^{b \\bmod \\phi(m) + \\phi(m)}&amp;,a\\not\\perp m\\land b \\ge \\phi(m) \\end{cases} \\pmod m 常用于降幂，当指数特别大的时候可以降低指数。此处与欧拉定理不一样的是 a 与 m 无需互质。 证明： 设 m = p^r\\times s （ \\gcd(p,s) = 1 ）。 由欧拉定理得 p^{\\phi(s)}\\equiv 1\\pmod s ，由欧拉函数积性得 \\phi(m) = \\phi(s)\\phi(p^r) 。所以 p^{\\phi(m)}\\equiv 1\\pmod s 。设 p^{\\phi(m)}=ks + 1 ，则 p^{\\phi(m) + r} = km + p^r ，所以 p^{\\phi(m) + r}\\equiv p^r\\pmod m 。 当 b\\ge r 时， p^b\\equiv p^{b - r}\\times p^r\\equiv p^{b - r}\\times p^{\\phi(m) + b}\\pmod m 。 因为 r\\le \\phi(p^r)\\le \\phi(m) ，所以当 b\\ge 2\\phi(m) 时 b - \\phi(m)\\ge r ，所以 p^b\\equiv p^{b - \\phi(m)}\\pmod m ，即 p^b\\equiv p^{b\\bmod \\phi(m) + \\phi(m)}\\equiv m 。 将 a 质因数分解之后乘起来，就可以得到 a^b\\equiv a^{b\\bmod \\phi(m) + \\phi(m)}\\pmod m 。 但是需要注意当 b&lt;\\phi(m) 的时候上述结论不一定正确。 应用（降幂塔） 例题：P4139 上帝与集合的正确用法 T\\le 10^3 次询问，求 2^{\\infty}\\bmod p 的值， p\\le 10^7 。 考虑使用扩展欧拉定理： 2^\\infty\\equiv 2^{2^\\infty \\bmod \\phi(p) + \\phi(p)}\\pmod{\\phi(p)} 现在我们发现需要求的变成了 2^\\infty\\bmod \\phi(p) ，这样子问题的规模就被缩小了，先线性筛出欧拉函数然后递归处理每组数据即可。返回的条件是 p = 1 时返回 0 。时间复杂度 123456int calc(int p){ if (p == 1) return 0; return qpow(2, calc(phi[p]) + phi[p], p);} CF906D Power Tower。本题也是扩展欧拉定理的应用，乍一看直接 dfs 处理的复杂度跑不过去，但考虑到 \\phi(n) 是 \\log 级别衰减的，所以不用担心跑不过去。 P3934 [Ynoi2016] 炸脖龙 I 区间加，查询 a_l^{a_{l + 1}^{a_{l + 2}^{\\cdots^{a_r}}}} 。同样只需要考虑 a_l 后面的一小段， \\phi 值就会降到 1 。 P3747 [六省联考 2017] 相逢是问候 每次操作将 a_i 替换成 c^{a_i} ，区间求和。 线性同余方程 一般线性同余方程 一般的线性同余方程是形如 ax\\equiv b\\pmod m 求解可以考虑使用 exgcd，将方程转化为 ax + my = b ，便可以求出 x 的一个解。 P1082 [NOIP2012 提高组] 同余方程。对于这种 ax\\equiv 1\\pmod m 的，根据逆元的定义可以直接求逆，这里不展开。 中国剩余定理 简介 又称孙子定理。用于求解线性同余方程组。 \\begin{cases} x\\equiv &amp;a_1\\pmod{m_1} \\\\ x\\equiv&amp; a_2\\pmod{m_2} \\\\ &amp;\\vdots \\\\ x\\equiv &amp;a_n\\pmod{m_n} \\end{cases} 要求 \\forall i\\ne j ，有 m_i\\perp m_j 。即，模数要两两互质。 结论 构造解： 计算 M = \\displaystyle\\prod_{i = 1}^n m_i ， M_i = \\dfrac M {m_i} 。 对于每个 M_i 计算其在模 m_i 意义下的逆元 t_i = M_i^{-1} 。 方程组的一个特解为 x_0 = \\displaystyle\\sum_{i = 1}^na_iM_it_i 。 最小正整数解即为 x_0\\bmod M ，方程组的解集为 \\left\\lbrace x|x=\\displaystyle\\sum_{i=1}^na_iM_it_i+kM,k\\in\\mathbb{Z}\\right\\rbrace 证明 首先，我们易知 \\forall j\\in[1,n] ，当 i\\neq j 时有 a_jM_jt_j\\equiv 0\\pmod{m_i} 当 i=j 时有 a_iM_it_i\\equiv a_iM_iM_i^{-1}\\equiv a_i\\pmod{m_i} 所以对于我们得到的解 x=\\displaystyle\\sum_{i=1}^na_iM_it_i ，对于任意的 m_i 都有 x\\equiv a_i\\pmod{m_i} ，定理得证。 类比拉格朗日插值。 应用 模板题 https://www.luogu.com.cn/problem/P1495。 代码实现如下： 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;typedef long long ll;ll n, a[15], m[15], Mul, M[16], inv[16], x, y;void exgcd(ll a, ll b, ll&amp; x, ll&amp; y) { if (b == 0) { x = 1; y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x;}int main() { Mul = 1; scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; i++) { scanf(\"%lld %lld\", m + i, a + i); Mul *= m[i]; } ll ans = 0; for (int i = 1; i &lt;= n; i++) { M[i] = Mul / m[i]; x = 0, y = 0; exgcd(M[i], m[i], x, y); inv[i] = x &lt; 0 ? x + m[i] : x; ans += a[i] * M[i] * inv[i]; } printf(\"%lld\\n\", ans % Mul); return 0;} 一般来说可以在其他算法里面被使用，裸题很少。 P3868 [TJOI2009] 猜数字 线性同余方程的合并（exCRT） 当 \\begin{cases} x\\equiv r_1\\pmod{m_1}\\\\ x\\equiv r_2\\pmod{m_2}\\\\ \\cdots\\\\ x\\equiv r_n\\pmod{m_n} \\end{cases} 中的模数不两两互质时，CRT 需要的 M_i 模 m_i 的逆元就不一定存在。所以我们的方法是：两两合并这些方程，最后用 exgcd 求解。 先考虑两个未知数的情况： \\begin{cases} x\\equiv r_1\\pmod{m_1} \\\\ x\\equiv r_2\\pmod{m_2} \\\\ \\end{cases} 这个方程可以改写为： x=k_1m_1+r_1=k_2m_2+r_2 其中 k_1,k_2 为未知量，然后方程可以进一步改写为关于 k_1,k_2 的形式： k_1m_1 - k_2m_2=r_2-r_1 由裴蜀定理得这个方程有解的条件是 \\gcd(m_1,m_2)\\mid r_2-r_1 ，若有解， 则令 \\displaystyle d = \\gcd(m_1,m_2),p_1 = \\frac{m_1}{d},p_2=\\frac{m_2}{d} ，方程化为 k_1p_1-k_2p_2 = \\frac{r_2-r_1}{d} 使用 exgcd 求出方程 p_1\\lambda_1 + p_2\\lambda_2 = 1 的解 \\lambda_1,\\lambda_2 ，则 \\begin{cases} k_1=\\lambda_1\\cdot\\dfrac{r_2-r_1}{d} \\\\ k_2=\\lambda_2\\cdot\\dfrac{r_2-r_1}{d} \\end{cases} 把 k_1 还原回去，得到满足原方程的一个特解 x^* = m_1\\lambda_1\\cdot\\dfrac{r_2-r_1}{d} + r_1 则这个方程所有的通解为 x = x^* + k\\cdot\\operatorname{lcm}(m_1,m_2),k\\in\\mathbb{Z} 。 所以两个方程就合并为一个： x\\equiv x^*\\pmod{\\operatorname{lcm}(m_1,m_2)} 这样子两两合并下去就可以将所有的方程合为一个，得解。 应用较为广泛，可以在 exLucas 中发挥其作用。 P4777 【模板】扩展中国剩余定理（EXCRT） P4774 [NOI2018] 屠龙勇士 组合数取模 Lucas 定理 原来主要是为了解决组合数取模的问题，在 p 进制上的表示可以进行数位 dp。 常见应用： 直接求 \\dbinom n m \\bmod p ，其中 p 为较小质数：这可以直接使用 Lucas 定理。 使用 \\displaystyle \\binom n m \\equiv \\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor}\\cdot \\binom{n\\bmod p}{m\\bmod p}\\pmod p 化简式子，见超能粒子炮。 利用其在 p 进制表示下的性质进行数位 dp，见清华集训组合数问题。 定理内容 \\binom n m \\equiv \\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor}\\cdot \\binom{n\\bmod p}{m\\bmod p}\\pmod p 其中 p 为质数。一般拿来求 \\binom nm ，当 p 范围较小时。 123456int lucas(int n, int m){ if (!m) return 1; return 1ll * lucas(n / p, m / p) * C(n % p, m % p) % p;} \\dbinom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor} 是可以递归算的，而 \\dbinom{n\\bmod p}{m\\bmod p} 可以直接算。 另一种形式：对于整数 a ， b 和素数 p ，若 \\begin{aligned} a &amp;= \\sum_{i = 0}^k a_ip^i\\\\ b &amp;= \\sum_{i = 0}^k b_ip^i \\end{aligned} （相当于把 a 和 b 在 p 进制下表示）则 \\binom ab\\equiv\\prod_{i = 0}^k\\binom{a_i}{b_i}\\pmod p 反复套用第一个形式会发现两个是等价的。 证明 需要一定的组合数学基础。 引理 首先考虑 \\binom p n \\bmod p 的取值，注意到展开组合数之后其为如下形式： \\frac{p!}{n!(p-n)!}\\bmod p 而显然，由于分子中 p! 是一定有质因子 p 的，所以只有当 n = 0\\lor n = p 的时候（即 p! 能被消干净）整体的结果为 1 ，否则为 0 。即 \\binom p n\\bmod p = [n = 0\\lor n = p] 进而我们可以得到 \\begin{aligned} (a + b)^p&amp;=\\sum_{n = 0}^p\\binom p na^nb^{p - n}\\\\ &amp;\\equiv \\sum_{n= 0}^p[n = 0\\lor n = p]a^nb^{p - n}\\\\ &amp;\\equiv a^p + b^p\\pmod p \\end{aligned} 然后将其推广到二项式的情况， \\begin{aligned} (ax^n + bx^m)^p&amp;\\equiv a^px^{np} + b^px^{mp}\\\\ &amp;\\equiv ax^{np} + bx^{mp} \\end{aligned} 即我们可以直接把指数 p 给提进来。 证明 考虑二项式 (1+x)^n 在 x^m 处的系数模 p 的结果，不难发现其即为 \\displaystyle\\binom n m\\bmod p 。利用上述引理，我们可以做出如下推导： \\begin{aligned} (1+x)^n&amp;\\equiv(1+x)^{p\\lfloor n/p\\rfloor}(1+x)^{n\\bmod p}\\\\ &amp;\\equiv(1+x^p)^{\\lfloor n/p\\rfloor}(1+x)^{n\\bmod p} \\end{aligned} 我们将其看作两个多项式 (1+x^p)^{\\lfloor n/p\\rfloor} 与 (1+x)^{n\\bmod p} 的卷积，考虑这两个式子对 (1 + x)^n 产生的贡献： (1+x^p)^{\\lfloor n/p\\rfloor} 展开后得到的项的次数均为 p 的倍数。 (1+x)^{n\\bmod p} 展开后得到的项的次数最多为 p - 1 。 所以对 x^m 的系数仅有一种产生贡献的方案，考虑一下这个贡献怎么来的：就是 (1+x^p)^{\\lfloor n/p\\rfloor} 中取 p 的倍数次项，这部分的系数即 \\displaystyle\\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor} ，然后在 (1+x)^{n\\bmod p} 中取剩余的部分，这部分的系数即 \\displaystyle\\binom{n\\bmod p}{m\\bmod p} 。 所以我们得出结论 \\binom n m \\equiv \\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor}\\cdot \\binom{n\\bmod p}{m\\bmod p}\\pmod p 应用 一般拿来做组合数取模，是很基础的内容，可以辅助推式子。 在 p 进制下的展开形式可以做数位 dp。 P3807 【模板】卢卡斯定理/Lucas 定理 P2480 [SDOI2010]古代猪文 P4345 [SHOI2015]超能粒子炮·改 51nod1778 小Q的集合 Kummer 定理 是一个小番外。 质数在阶乘中的幂次 勒让德在 1808 年提出 n! 中含有的质数 p 的幂次为 \\sum_{i\\ge 1}\\lfloor n / p^i\\rfloor 。 证明： n! = 1\\times 2\\times\\cdots \\times p\\times \\cdots\\times 2p\\times \\cdots\\times \\lfloor n / p\\rfloor p\\times \\cdots\\times n ，将 p 的倍数提出来，为 p^{\\lfloor n / p\\rfloor}\\lfloor n / p\\rfloor! ，这里面显然有 \\lfloor n/p\\rfloor 个 p 。然后递归寻找 \\lfloor n /p\\rfloor! 即可。 下面我们记 \\nu(n!) = \\sum_{i \\ge 1}\\lfloor n /p^i\\rfloor 。 当然还有一种公式是 v_p(n!) = \\dfrac{n - S_p(n)}{1 - p} ，其中 S_p(n) 表示 p 进制下 n 的各位数字和。证明在这里先不写了。 质数在组合数中的幂次 我们可以发现： \\nu\\left(\\binom{n+m}m\\right) = \\sum_{i = 1}(\\lfloor(n + m)/ p^i\\rfloor - \\lfloor n / p^i\\rfloor- \\lfloor m / p^i\\rfloor) 我们可以注意到，对于某个 p^i ， \\lfloor n / p^i\\rfloor 相当于在 p 进制下去掉后面的 i 位， m + n 在第 i + 1 位产生进位的条件显然就为 \\lfloor(n + m)/ p^i\\rfloor - \\lfloor n / p^i\\rfloor- \\lfloor m / p^i\\rfloor ，这就是 Kummer 定理。 \\dbinom{n + m}{m} 中质因子 p 的个数为 n,m 在 p 进制下做加法的进位次数。 CF582D Number of Binominal Coefficients：利用上面的定理进行数位 dp。 扩展卢卡斯 求 \\binom nm\\bmod M 的值。其中 M 不一定为质数。和卢卡斯定理关系不大。 考虑使用唯一分解定理分解模数 M 得到 M = \\prod p_i^{k_i} 的形式，然后对于每个 p_i^{k_i} 单独求解，最后用 CRT 合并。拆开组合数的式子，我们发现： \\binom n m \\equiv \\frac{n!}{m!(n - m)!}\\pmod{p^k} 然而下面那个东西不一定能算模 p^k 意义下的乘法逆元，那么我们就把所有的 p 提出来，设 f(n) = \\frac{n!}{p^{\\nu(n!)}} ， \\nu(n) 上面已经说明。提出来之后就可以得到 f(n)\\not\\equiv 0\\pmod{p^k} ，可以求逆。现在就需要计算 \\frac{f(n)}{f(m)f(n - m)}p^{\\nu(n!) - \\nu(m!) - \\nu((n - m)!)} 上文说过了 \\nu(n!) = \\sum_{i\\ge 1}\\lfloor n /p^i\\rfloor ，下面考虑如何求 f(n) 。 p^{\\nu(n!)} 是可以求逆的，这里就不再赘述。主要来看 n! 怎么求。我们把 n! 的式子展开来，提出 p 的倍数： n! = 1\\times2\\times\\cdots\\times(p-1)\\times p\\times [(p+1)\\times\\cdots\\times(2p - 1)]\\times 2p\\times\\cdots 中间是存在循环节的： \\displaystyle\\prod_{i,i\\perp q}^{q^k}i\\equiv\\prod_{i,i\\perp q}^{q^k}(i + tq^k)\\pmod{q^k} ，这个循环节循环了 \\displaystyle\\left\\lfloor\\frac{n}{p^k}\\right\\rfloor 次，所以考虑暴力把 \\displaystyle\\prod_{i,i\\perp p}^{p^k}i 求出来然后快速幂求一波 \\displaystyle\\left\\lfloor\\frac{n}{p^k}\\right\\rfloor 次幂。当然最后是需要乘上余项 \\displaystyle\\prod_{i,i\\perp p}^{n\\bmod p^k}i ，暴力就可以了。剩下的项是 \\displaystyle p^{\\lfloor n/p\\rfloor}\\cdot\\left(\\left\\lfloor\\frac n p\\right\\rfloor\\right)! 。前者可以快速幂，后面的可以递归求，即为 f(\\lfloor\\frac np\\rfloor) 。 于是我们就做完了。来看下代码：洛谷 P4720 【模板】扩展卢卡斯，细节巨大多。下面的写法，一次询问的复杂度为 O(M\\log M) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using ll = long long;ll n, m, mod;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y) { if (!b) return x = 1, y = 0, void(); exgcd(b, a % b, y, x), y -= a / b * x; return;}il ll inv(ll n, ll mod) { ll x, y; exgcd(n, mod, x, y); return (x + mod) % mod;}ll qPow(ll base, ll exp, ll mod) { ll ret = 1; for (; exp; exp &gt;&gt;= 1, base = base * base % mod) if (exp &amp; 1) ret = ret * base % mod; return ret;}ll CRT(int n, ll *a, ll *m) { ll M = 1, ret = 0; FOR(i, 1, n) M *= m[i]; FOR(i, 1, n) { ll w = M / m[i]; ret = (ret + a[i] * w % mod * inv(w, m[i]) % mod) % mod; } return (ret + mod) % mod;}ll f(ll n, ll p, ll pk) { if (!n) return 1; ll ret = 1; FOR(i, 1, pk) if (i % p) ret = ret * i % pk; ret = qPow(ret, n / pk, pk); for (ll i = n / pk * pk + 1; i &lt;= n; ++i) if (i % p) ret = ret * (i % pk) % pk; return ret * f(n / p, p, pk) % pk;}ll multiLucas(ll n, ll m, ll p, ll pk) { int cnt = 0; for (ll i = n; i; i /= p) cnt += i / p; for (ll i = m; i; i /= p) cnt -= i / p; for (ll i = n - m; i; i /= p) cnt -= i / p; return qPow(p, cnt, pk) * f(n, p, pk) % pk * inv(f(m, p, pk), pk) % pk * inv(f(n - m, p, pk), pk) % pk;}ll exLucas(ll n, ll m, ll p) { int cnt = 0; ll pk[20], a[20]; for (ll i = 2; i * i &lt;= p; ++i) { if (p % i == 0) { pk[++cnt] = 1; while (p % i == 0) pk[cnt] *= i, p /= i; a[cnt] = multiLucas(n, m, i, pk[cnt]); } } if (p &gt; 1) pk[++cnt] = p, a[cnt] = multiLucas(n, m, p, p); return CRT(cnt, a, pk);}int main() { read(n, m, mod); print(exLucas(n, m, mod)); return output(), 0;} 当然，上面这种做法不是最快的。按理来说，如果模数 M 固定，可以预处理 + 光速幂，可以做到更更优，但是由于没有什么用所以不写了。 阶与原根/二次剩余/离散对数 阶/指数 定义 对于 a\\in \\mathbb Z ， m\\in\\mathbb N^* ，且 a\\perp m ，最小的满足 a^x\\equiv 1\\pmod m 的正整数 x 被称为 a 模 m 的阶（或者指数），记作 \\delta_m(a) 。 抽代中这里的阶就是模 m 缩系关于乘法形成的群中，元素 a 的阶。而 \\delta 表示阶也仅限这个特殊群。 性质 性质 1 ： a^0,a^1, \\cdots, a^{\\delta_m(a) - 1} 构成一个模 m 的剩余系（即两两不同余），并且剩余系内所有元与 m 互质。 证明：考虑反证法，设存在 0\\le i&lt;j&lt; \\delta_m(a) 且 a^i\\equiv a^j\\pmod m ，那么一定有 a^{|i - j|}\\equiv 1\\pmod m ，与阶的最小性矛盾，证毕。 性质 2 ：若 a^n\\equiv 1\\pmod m ，则 \\delta_m(a)\\mid n 。 证明：做带余除法，设 n = q\\delta_m(a) + r ，若 r &gt; 0 则有 a^r\\equiv a^r(a^{\\delta_m(a)})^q\\equiv a^n\\equiv 1\\pmod m 和阶的最小性矛盾，故 r = 0 。 可以推导出几个推论： a^p\\equiv a^q\\pmod m\\iff p\\equiv q\\pmod{\\delta_a(m)} 。 \\delta_a(m)\\mid \\varphi(m) （考虑欧拉定理）。 设 k\\in \\mathbb N ： \\delta_m(a^k) = \\frac{\\delta_m(a)}{\\gcd(\\delta_m(a), k)} 证明： \\begin{aligned} a^{k\\delta_m(a^k)}=(a^k)^{\\delta_m(a^k)}&amp;\\equiv 1\\pmod m\\\\ \\delta_m(a)&amp;\\mid k\\delta_m(a^k)\\\\ \\frac{\\delta_m(a)}{\\gcd(\\delta_m(a), k)}&amp;\\mid \\delta_m(a^k) \\end{aligned} 而且 a^{\\delta_m(a)}\\equiv 1\\pmod m ： (a^k)^{\\frac{\\delta_m(a)}{\\gcd(\\delta_m(a), k)}} = (a^{\\delta_m(a)})^{\\frac{k}{\\gcd(\\delta_m(a), k)}}\\equiv 1\\pmod m 所以 \\delta_m(a^k)\\mid \\frac{\\delta_m(a)}{\\gcd(\\delta_m(a), k)} 综合一下，证毕。 （虽然看不出 \\gcd 那个有什么卵用） 性质 3 ：设 m\\in\\mathbb N^* ， a,b\\in \\mathbb Z 且 a\\perp m, b\\perp m ，则 \\delta_m(ab) = \\delta_m(a)\\delta_m(b)\\iff \\delta_m(a)\\perp \\delta_m(b) 可以理解为 \\delta_m(x) 有“积性”。 证明先略去，赶时间。 求法 枚举 \\varphi(m) 的因子。 好像没有什么卵用，略过。 原根 定义 继承上文阶的定义，若 \\delta_m(a) = \\varphi(m) ，则称 a 为模 m 的原根。 抽代中，“原根”是循环群的生成元。并非每个模 m 缩系关于乘法的群都是循环群，不是的话说明其不存在原根。 性质 证明暂时不写了（笑） 原根判定定理：设 m\\ge 3 ， a\\perp m ，则 a 为模 m 的原根的充要条件是，对于 \\varphi(m) 的每个质因数 p ，都有 a^{\\frac{\\varphi(m)}{p}}\\not\\equiv 1\\pmod m 。 。 原根存在定理： m 存在原根当且仅当 m = 2,4,p^{\\alpha}, 2p^{\\alpha} ，其中 p 为奇素数。 不写证明。 原根个数：若 m 的原根存在，则个数为 \\varphi(\\varphi(m)) 。 不写证明。 最小原根的数量级： O(m^{0.25 + \\varepsilon}) 。 这个告诉我们，暴力求原根是对的。 求法 求单个原根就直接暴力从 1 开始枚举并依次判定即可，利用原根判定定理。 应用 NTT。 例题：ABC212G - Power Pair 给定质数 p ，问数对 (x, y) 的个数模 998244353 ： 0\\le x, y\\le p - 1 \\exists n, x^n\\equiv y\\pmod p 2\\le p\\le 10^{12} 。 r 为模 p 的原根当且仅当最小的使得 r^e\\equiv 1\\pmod p 的正整数为 e = p - 1 。本题需要用到的性质： r^i\\bmod p, i\\in[0, p - 1] 的值两两不同，且对于一个质数，一定有原根存在。 设 x\\equiv r^a\\pmod p ， y\\equiv r^b\\pmod p ，不难发现 (x, y) 总能有一个 (a, b) 与之对应。于是就有 an\\equiv b\\pmod{p - 1} 。现在就是需要找满足上式的 (a, b) 的数量。 枚举 a ，则上式有解的条件是 \\gcd(a, p - 1)\\mid b （裴蜀定理）。那对于所有的 a 就可以写成： \\sum_{a = 1}^{p - 1}\\frac{p - 1}{\\gcd(a, p - 1)} 然后 O(p) 是过不去的，要考虑优化。优化它的方法明显是寻找 \\gcd(a, p - 1) 相同的 a 的个数。根据 p - 1 的因数个数 为 O(\\sqrt p) 的，故这些 \\gcd 也只有 O(\\sqrt p) 个。我们枚举 \\gcd(a, p - 1) = g ，有 \\sum_{g\\mid p - 1}\\frac{p - 1}{g}\\times\\phi\\left(\\frac{p - 1}{g}\\right) \\phi(n) 可以暴力计算。 O(\\sqrt p\\log p) ，因为 \\log 的上界很松，轻松通过。 离散对数 求最小的正整数 x 满足 a^x\\equiv b\\pmod m ，记作 x = \\operatorname{lnd}_a b 。 BSGS Baby-Step-Giant-Step（大步小步算法，BSGS）可以用来求解 a\\perp m 的离散对数。 首先由费马小定理可以知道答案一定在 [1, m - 1] 之间。 然后设 x = i\\sqrt m - j ，则 a^{i\\sqrt m -j}\\equiv b\\pmod m ，即 a^{i\\sqrt m} \\equiv ba^j\\pmod m ，而 i 和 j 都是 \\sqrt m 级别的，所以考虑在哈希表中预处理每个 ba^j ，然后枚举 i 判断 a^{i\\sqrt m} 是否在哈希表内出现过即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;unordered_map&gt;#define R register#define FOR(i, a, b) for(R int i = a; i &lt;= b; ++i)#define int long longstd::unordered_map&lt;int, int&gt; hash;int ksm(int base, int p, int mod) { int ans = 1; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ans = ans * base % mod; base = base * base % mod; } return ans;}int BSGS(int a, int b, int p) { hash.clear(); if (a % p == 0) return -1; int t = ceil(sqrt(p)), val, tmp; hash[val = b] = 0; FOR(j, 1, t) hash[val = val * a % p] = j; a = ksm(a, t, p), val = 1; FOR(i, 1, t) { val = val * a % p; if (tmp = hash[val]) return val = i * t - tmp, (val % p + p) % p; } return -1;}signed main() { int p, a, b; scanf(\"%lld %lld %lld\", &amp;p, &amp;a, &amp;b); int ans = BSGS(a, b, p); if (ans &gt;= 0) return printf(\"%lld\\n\", ans), 0; else return printf(\"no solution\\n\"), 0;} exBSGS 当 a 和 m 不互质的时候，在模 m 意义下 a 的逆元不一定存在。所以考虑强行让他互质。 设 d_1 = \\gcd(a, p) ，若 d_1\\not\\mid b ，则无解。否则将方程同时除以 d_1 ： \\frac{a}{d_1}\\cdot a^{x-1}\\equiv \\frac{b}{d_1}\\pmod {\\frac{p}{d_1}} 若 a 和 \\dfrac{p}{d_1} 仍然不互质就接着上面的流程。直到 a\\perp \\dfrac{p}{\\prod d_i} 。 记所有的 \\displaystyle\\frac{b}{\\prod d} = B, \\frac{p}{\\prod d} = P,\\prod\\frac a d = A ，则方程最后变为 Aa^{x - k}\\equiv B\\pmod P 此时 A\\perp P ，所以我们就可以愉快地求出 A^{-1}\\pmod P 然后把他乘到右边来，方程就化为 a^{x - k}\\equiv A^{-1}B\\pmod P 用 BSGS 求出该方程的解即可，然后记得加回 k 。 细节：如果 TeX parse error: Undefined control sequence \\or，最小自然数解必然为 0 ，然后如果在递归的过程中发现 A=B ，则说明 x = k ，可直接返回答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;unordered_map&gt;#define R register#define FOR(i, a, b) for(R int i = a; i &lt;= b; ++i)#define int long longstd::unordered_map&lt;int, int&gt; hash;int ksm(int base, int p, int mod) { int ans = 1; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ans = ans * base % mod; base = base * base % mod; } return ans;}int exgcd(int a, int b, int&amp; x, int&amp; y) { if (!b) return x = 1, y = 0, a; int tmp = exgcd(b, a % b, y, x); return y -= a / b * x, tmp;}int inv(int a, int mod) { int x, y; exgcd(a, mod, x, y); return (x % mod + mod) % mod;}int BSGS(int a, int b, int p) { hash.clear(); if (a % p == 0) return -1; int t = ceil(sqrt(p)), val, tmp; hash[val = b] = 0; FOR(j, 1, t) hash[val = val * a % p] = j; a = ksm(a, t, p), val = 1; FOR(i, 1, t) { val = val * a % p; if (tmp = hash[val]) return val = i * t - tmp, (val % p + p) % p; } return -1;}int exBSGS(int a, int b, int p) { if (a == 1 || p == 1) return 0; int x, y, k = 0, na = 1, g = exgcd(a, p, x, y); while (g &gt; 1) { if (b % g) return -1;//判无解 ++k, b /= g, p /= g, na = (na * (a / g)) % p;//递归 if (na == b)//特判可以直接返回答案的情况 return k; g = exgcd(a, p, x, y); } int ans = BSGS(a, b * inv(na, p) % p, p); return ans == -1 ? -1 : ans + k;}signed main() { int a, p, b; for (scanf(\"%lld %lld %lld\", &amp;a, &amp;p, &amp;b); a || b || p; scanf(\"%lld %lld %lld\", &amp;a, &amp;p, &amp;b)) { int ans = exBSGS(a % p, b % p, p); if (ans &gt; 0) printf(\"%lld\\n\", ans); else printf(\"No Solution\\n\"); } return 0;} 二次剩余 求解 x^2\\equiv a\\pmod m ，其中 m 为奇素数。若 x 存在则称 x 为模 m 的二次剩余。 解的数量 x^2\\equiv m 的解？我们肯定知道 x_0^2\\equiv x_1^2 。移项，平方差，有 (x_0 - x_1) (x_0 + x_1) \\equiv 0 。因为 x_0 - x_1\\not\\equiv0 ，所以 x_0 和 x_1 互为相反数。 p 为奇素数时模意义下的相反数就肯定不会相等，而且奇偶性不同。 任意一对相反数都会对应一个二次剩余，故模 m 意义下的二次剩余一共有 \\dfrac{m - 1}{2} 个，其余的非零数都是非二次剩余。 欧拉准则 Euler 判别准则： a 为模 m 的二次剩余等价于 a^{\\frac{m - 1}{2}}\\equiv 1\\pmod m ，否则 a^{\\frac{m - 1}{2}}\\equiv -1\\pmod m 。 考虑费马小定理： a^{m - 1}\\equiv 1\\pmod m ，由于 m 为奇素数，故 a^{2\\times\\frac{m - 1}{2}}\\equiv 1\\pmod m ，相当于 a^{\\frac{m - 1}{2}} 是 1 “开根”后的结果，根据二次探测定理（上文 Miller-Rabin 处）其只可能为 \\pm 1 。 考虑证明充分性：若 a 是二次剩余，则 a^{\\frac{m - 1}{2}}\\equiv (x^2)^{\\frac{m-1}{2}}\\equiv x^{m - 1}\\equiv 1\\pmod m ，证毕。 考虑证明必要性：若 a^{\\frac{m-1}{2}}\\equiv 1\\pmod m ，则将 a 表示为 g^k ，其中 g 为模 m 的原根，那么有 g^{k\\frac{m-1}{2}}\\equiv 1 ，由于 g 是原根，所以 m - 1=\\varphi(m) 为其阶，故一定有 m - 1\\mid k\\dfrac{m-1}{2} ，故 k 为偶数。这就是说 (g^{k/2})^2\\equiv a ，所以 a 为二次剩余。 Cipolla 算法 由于模 m 意义下的二次剩余有 \\dfrac{m - 1}{2} 个，所以期望两次就能找到一个 b 满足 b^2 - a 为非二次剩余。 然后便是 Cipolla 的核心思想：扩域，人为定义 i^2 = b^2 - a ，所以所有的数都可以被表达为 A + Bi 的形式，则 a \\equiv (b + i)^{m + 1}\\pmod m ，所以 x \\equiv (a + i)^{\\frac{m - 1}{2}} 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int t, n, p, w;struct cmplx { int x, y;};il cmplx mul(cmplx a, cmplx b, int p) { cmplx ans = {0, 0}; ans.x = ((1ll * a.x * b.x % p + 1ll * a.y * b.y % p * w % p) + p) % p; ans.y = ((1ll * a.x * b.y % p + 1ll * a.y * b.x % p) + p) % p; return ans;}int qPow(int a, int b, int p) { int ret = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if (b &amp; 1) ret = 1ll * ret * a % p; return ret;}int qPow(cmplx a, int b, int p) { cmplx ans = {1, 0}; for (; b; b &gt;&gt;= 1, a = mul(a, a, p)) if (b &amp; 1) ans = mul(ans, a, p); return ans.x % p;}int cipolla(int n, int p) { n %= p; if (p == 2) return n; if (qPow(n, (p - 1) / 2, p) == p - 1) return -1; int a; while (1) { a = rand() % p; w = ((1ll * a * a % p - n) % p + p) % p; if (qPow(w, (p - 1) / 2, p) == p - 1) break; } cmplx x = {a, 1}; return qPow(x, (p + 1) / 2, p);}int main() { srand(time(0)); read(t); while (t--) { read(n), read(p); if (!n) { putchar('0'), putchar('\\n'); continue; } int ans1 = cipolla(n, p), ans2 = p - ans1; if (ans1 == -1) { puts(\"Hola!\"); continue; } else print(min(ans1, ans2)), putchar(' '), print(max(ans1, ans2)); putchar('\\n'); } return output(), 0;} 莫比乌斯反演相关 警告：本节对推式子能力要求较高。 这一部分内容在 OI 中的考察以式子的化简求值为主。 整除分块 是学习莫比乌斯反演前的很重要的前置知识。 是基于 \\lfloor n / i\\rfloor 最多只有 \\sqrt n 种取值的。可以加快运算。将相同的 \\lfloor n / i\\rfloor 合在一起，体现了分块思想。 不加证明地，结论就是每一段 i\\in[x,\\lfloor\\frac{n}{\\lfloor n/i\\rfloor}\\rfloor] 中 \\lfloor \\frac n i\\rfloor 的值都等于 \\frac n x 。 复杂度证明如下。求证：对于 n \\in\\mathbb{N^*} ， \\left\\lfloor \\dfrac n i \\right\\rfloor,i\\in[1,n] 的数量级是 O(\\sqrt n) 级别的。 证明：对于 i\\le \\sqrt n ， \\lfloor\\frac n i\\rfloor 至多有 \\sqrt n 个取值，然后对于 i\\gt \\sqrt n ， \\lfloor \\frac n i\\rfloor\\lt \\sqrt n ，所以 \\lfloor \\frac n i\\rfloor 也至多有 \\sqrt n 种取值。所以 \\lfloor\\frac n i\\rfloor 至多有 2\\sqrt n 种取值。 上面的算法中，由于每种取值只计算了一遍，所以复杂度 O(\\sqrt n) 。 以下关于分块右端点的证明参考了李煜东《算法竞赛进阶指南》的证明。 设 g(i) = \\displaystyle\\lfloor\\frac{n}{\\lfloor\\frac n i\\rfloor}\\rfloor 。显然 f(i) = \\displaystyle\\frac n i 单调减，而 \\displaystyle g(i)\\ge \\left\\lfloor\\frac{n}{\\frac n i}\\right\\rfloor = x ，所以 \\displaystyle \\frac{n}{g(i)}\\le \\lfloor\\frac n i\\rfloor 。另外， \\displaystyle \\left\\lfloor \\frac{n}{g(i)}\\right\\rfloor\\ge \\left\\lfloor\\frac{n}{\\frac{n}{\\lfloor\\frac n i\\rfloor}}\\right\\rfloor = \\lfloor\\frac n i\\rfloor ，所以 \\displaystyle\\left\\lfloor \\frac{n}{g(i)}\\right\\rfloor = \\lfloor\\frac n i\\rfloor 。进一步可得， \\forall x\\in[i,g(i)] ， \\displaystyle\\left\\lfloor\\frac n i\\right\\rfloor 的值都相等。 所以第一次确定下 l =1 ，然后求出 r = g(l) ，统计这个块内的答案，再 l = r + 1 ，继续处理，得到最终答案。 12345for (int l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); // do something} UVA11526 H(n) P3935 Calculating P2260 [清华集训2012]模积和 P2261 [CQOI2007]余数求和 狄利克雷卷积 定义两个数论函数 f(n),g(n) 的狄利克雷卷积 (f*g)(n) 为 (f*g)(n) = \\sum_{d\\mid n}f(d)g\\left(\\frac nd\\right) 类比一下一般的加法卷积 c_k = \\sum_{i}a_ib_{k - i} ，我们可以发现狄利克雷卷积为关于乘法的卷积。 其具有如下常见性质： 交换律： f*g = g*f ，乘法满足交换律，得证。 结合律： (f*g)*h=f*(g*h) ： \\sum_{(ij)k = n}(f(i)g(j))h(k)=\\sum_{i(jk) = n}f(i)(g(j)h(k)) 对加法的分配律： (f+g)*h = f*h + g*h ： \\begin{aligned} &amp;(f(n) + g(n)) * h(n)\\\\ =&amp;\\sum_{d\\mid n}(f(d) + d(d))h\\left(\\frac nd\\right)\\\\ =&amp;\\sum_{d\\mid n}f(d)h\\left(\\frac nd\\right) + \\sum_{d\\in n}g(d)h\\left(\\frac nd\\right)\\\\ =&amp;f(n)*h(n) + g(n)*h(n) \\end{aligned} 与数乘的结合律： (cf)*g = c(f*g) 。 单位元： \\epsilon * f = f ， \\epsilon(n) = [n = 1] 。即这个单位元函数当 n = 1 时返回 1 ，当 n\\not=1 时返回 0 。 \\begin{aligned} f * \\epsilon &amp;= \\sum_{d\\mid n} f(d)\\epsilon\\left(\\frac nd\\right) \\end{aligned} 不难验证其正确性：只有当 d = n 时 \\epsilon(n/d) 才等于 1 ，只保留了 f(n) 这一项。 狄利克雷逆元： f^{-1}*f=\\epsilon 。考虑如何求这个逆元： \\begin{aligned} \\epsilon &amp;= f^{-1}*f\\\\ \\epsilon &amp;= \\sum_{d\\mid n}f^{-1}(d)f\\left(\\frac nd\\right)\\\\ \\epsilon(n) &amp;= f^{-1}(n)f(1) + \\sum_{d\\mid n\\land d &lt; n} f^{-1}(d)f\\left(\\frac nd\\right)\\\\ f^{-1}(n) &amp;=\\frac1{f(1)}\\left(\\epsilon(n) - \\sum_{d\\mid n\\land d &lt; n} f^{-1}(d)f\\left(\\frac nd\\right)\\right) \\end{aligned} 于是这个逆元就被求出来了。不难发现只要 f 满足 f(1)\\not=0 ，其就会具有逆元。 莫比乌斯函数 在这之前可能需要回顾一下之前讲过的几个数论函数，下面将不会重复提及。 上面的 \\mu(n) 就是莫比乌斯函数。写得更清楚的定义为： \\mu(n) = \\begin{cases} 1&amp;n = 1\\\\ 0&amp;n\\text{ 含有平方因子}\\\\ (-1)^{\\omega(n)}&amp;\\omega(n)\\text{ 为 }n\\text{ 的本质不同质因子个数} \\end{cases} 含 有 平 方 因 子 为 的 本 质 不 同 质 因 子 个 数 同时其有一个等价的定义： \\mu(n) = 1^{-1}(n) 即， \\mu(n) 为常函数 1(n) 的狄利克雷逆元。这就意味着 \\mu*1 = \\epsilon ，所以 \\sum_{d\\mid n}\\mu(d) = \\epsilon(n) = [n = 1] 有一个常见的反演结论是： [i\\perp j] = [\\gcd(i,j) = 1] = \\sum_{d\\mid\\gcd(i,j)}\\mu(d) 这个意义应该是很好理解的，不赘述了。 下面还有一个常见反演结论（欧拉反演）： \\varphi * 1= \\operatorname{id} 证明：由于 \\varphi 为积性函数，所以我们只需证明 n = p^c 时其成立即可。 \\begin{aligned} \\varphi * 1 &amp;= \\sum_{d\\mid n}\\varphi(d)\\\\ &amp;= \\sum_{i = 0}^c\\varphi(p^i)\\\\ &amp;= 1 + p^0(p - 1) + p^1(p -1) + \\cdots + p^{c - 1}(p - 1)\\\\ &amp;= p^c\\\\ &amp;= \\operatorname{id} \\end{aligned} 另外，两边同时卷 \\mu 可以得到 \\varphi = \\operatorname{id}*\\mu = \\sum_{d\\mid n}d\\mu\\left(\\frac nd\\right) \\mu 的求法见下文线性筛部分。 莫比乌斯反演公式 基本形式 内容是，已知两数论函数 f(n) ， g(n) ： f(n) = \\sum_{d\\mid n}g(d)\\iff g(n) = \\sum_{d\\mid n}\\mu\\left(\\frac nd\\right)f(d) 这个公式被称为莫比乌斯反演公式（Möbius inversion formula），用狄利克雷卷积表示就是 f = g * 1\\iff g = f * \\mu 写成狄利克雷卷积的形式就好证明了，直接左边卷上 \\mu 就能得到右边。 扩展形式 乘积形式的： f(n) = \\prod_{d\\mid n}g(d) \\iff g(n) = \\prod f(d)^{\\mu(\\frac nd)},\\forall n &gt; 1 证明：两边同时取对数： \\begin{aligned} \\ln f(n) &amp;= \\sum_{d\\mid n}\\ln g(d)\\\\ \\ln g(n) &amp;= \\sum_{d\\mid n}\\ln f(d)\\mu\\left(\\frac nd\\right)\\\\ g(n) &amp;= \\prod_{d\\mid n}f(d)^{\\mu(\\frac nd)} \\end{aligned} 倍数形式的： f(n) = \\sum_{n\\mid d}g(d)\\iff g(n) = \\sum_{n\\mid d}\\mu\\left(\\frac dn\\right)f(d) 证明： \\begin{aligned} &amp;\\sum_{n\\mid d}\\mu\\left(\\frac dn\\right)f(d)\\\\ =&amp;\\sum_{k= 1}^\\infty\\mu(k)f(kn) = \\sum_{k = 1}^\\infty\\mu(k)\\sum_{kn\\mid d}g(d)\\\\ =&amp;\\sum_{n\\mid d}g(d)\\sum_{k\\mid \\frac{d}{n}}\\mu(k)= \\sum_{n\\mid d}g(d)\\epsilon\\left(\\frac dn\\right)\\\\ =&amp;g(n) \\end{aligned} 将 d 表示成 kn 的形式，然后将左边的式子代入。之后交换枚举顺序变为枚举 n 的倍数然后反求 k ，最后发现就是 \\epsilon 。 莫比乌斯反演与容斥的关系 参考了论文哥的博客。 首先根据算术基本定理，将一个 n 分解为 p_i^{k_i} 的结构，然后对于一个数论函数 f ，定义其 zeta 变换 f\\zeta ： f\\zeta(n) = \\sum_{d\\mid n}f(d) 其实质是枚举了 k_i 表示中的每一维都不大于自己的数，相当于一个高维前缀和。（其实这个就是狄利克雷前缀和，P5495 Dirichlet 前缀和）求这个东西的时候可以像 FMT 一样，类似埃筛的 O(n\\log\\log n) 。 然后如何从高维前缀和还原成单点的值呢？考虑使用容斥原理，回顾一下高维前缀和的式子。需要枚举每一维相同或者小 1 的数，以此决定容斥系数。定义 \\mu(n) = \\prod_{i = 1}^\\infty (-1)^{[e_i = 1]}0^{[e_k &gt; 1]} 即：某一维为 0 时，对函数值没有影响，某一维为 1 时，函数值乘上 -1 ，某一维大于 1 时，函数值为 0 。否则若 n 为 c 个质数的积，则 \\mu(n) = (-1)^c 。 我们枚举 d\\mid n ，用 \\dfrac nd 找到每一维的差，再用 \\mu 找到对应的容斥系数，即： f(n) = \\sum_{d\\mid n}\\mu\\left(\\frac nd\\right)f\\zeta(d) 把这个变换称为莫比乌斯变换，即 f\\mu(n) = \\sum_{d\\mid n}\\mu\\left(\\frac nd\\right)f(d) 而 f\\zeta\\mu = f 。 所以本质上，莫比乌斯反演是一个容斥的过程。 \\mu 充当着容斥系数这一角色。 应用 下面放几个莫比乌斯反演的经典应用。假定 n\\ge m 。 典例 0 \\sum_{i =1 }^n\\gcd(i,n) = \\sum_{d\\mid n}d\\varphi(n/d) 对应例题P2303 [SDOI2012] Longge 的问题。 这里是一个比较常用的技巧：有很多的 \\gcd(i,n) 都是一样的，我们枚举 \\gcd ： \\displaystyle\\sum_{d\\mid n}d\\sum_{i= 1}^n[\\gcd(i, n)= d] ，然后化为 \\gcd(i,j) = 1 的形式： \\displaystyle\\sum_{d\\mid n}d\\sum_{i=1}^{n/d}[\\gcd(i,n/d)=1] ，注意到右边那个东西实际上就是 \\varphi(n/d) ，所以就化简完了。 典例 1 \\sum_{i = 1}^n\\sum_{j = 1}^m[\\gcd(i,j) = k] = \\sum_{d=1}^{\\lfloor \\frac nk\\rfloor}\\mu(d)\\left\\lfloor\\frac{n}{kd}\\right\\rfloor\\left\\lfloor\\frac{m}{kd}\\right\\rfloor 对应例题P3455 [POI2007]ZAP-Queries。 简要推导：首先将其化为 \\gcd(i, j) = 1 的形式，得到 \\displaystyle\\sum_{i = 1}^{n'}\\sum_{j = 1}^{m'}\\sum_{d\\mid\\gcd(i,j)}\\mu(d) ，然后写成枚举 d 的形式： \\displaystyle\\sum_{i = 1}^{n'}\\sum_{j = 1}^{m'}\\sum_{d = 1}[d\\mid\\gcd(i,j)]\\mu(d) ，再调换一下求和顺序： \\displaystyle\\sum_{d=1}^{\\min(n',m')}\\mu(d)\\sum_{i = 1}^{n'}\\sum_{j = 1}^{m'}[d\\mid\\gcd(i,j)] 。最后的式子即要求 i,j 同为 d 的倍数，所以最终得到答案。 典例 2 \\sum_{i = 1}^n\\sum_{j = 1}^m[\\gcd(i,j) \\in P] = \\sum_{T = 1}^n\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\sum_{k\\mid T\\land k\\in P}\\mu\\left(\\frac Tk\\right) 其中 P 为质数集。对应例题P2257 YY的GCD。 简要推导：首先枚举这个质数 k ，然后像上一题一样化简可以得到 \\displaystyle\\sum_{k\\in P}\\sum_{d=1}^{\\lfloor \\frac nk\\rfloor}\\mu(d)\\left\\lfloor\\frac{n}{kd}\\right\\rfloor\\left\\lfloor\\frac{m}{kd}\\right\\rfloor 。现在仍然不够快，接下来巧妙换元令 T = kd ，然后调换枚举顺序改为枚举 T ： \\displaystyle\\sum_{T= 1}^n\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\sum_{k\\mid T,k\\in P}\\mu\\left(\\frac Tk\\right) 。后者可以预处理，然后套整除分块即可。 典例 3 \\sum_{i = 1}^n\\sum_{j = 1}^m\\operatorname{lcm}(i, j) = \\sum_{d = 1}^nd\\sum_{k = 1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)k^2\\sum_{i = 1}^{\\lfloor\\frac{n}{kd}\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac{m}{kd}\\rfloor}ij 对应例题P1829 [国家集训队]Crash的数字表格 / JZPTAB。 简要推导： \\displaystyle\\sum_{i = 1}^n\\sum_{j = 1}^m\\frac{ij}{\\gcd(i, j)} ，然后枚举 gcd，变成 \\displaystyle\\sum_{d = 1}^n\\sum_{i = 1}^n\\sum_{j = 1}^m\\frac{ij}{d}[\\gcd(i,j) = d] ，然后是经典反演，变成 \\displaystyle\\sum_{d = 1}^nd\\sum_{i = 1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac md\\rfloor}ij\\sum_{k\\mid \\gcd(i,j)}\\mu(k) ，再然后调换顺序枚举 k ， \\displaystyle\\sum_{d = 1}^nd\\sum_{k = 1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)\\sum_{i = 1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac md\\rfloor}ij[k\\mid i][k\\mid j] ，最后得到 \\displaystyle\\sum_{d = 1}^nd\\sum_{k = 1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)k^2\\sum_{i = 1}^{\\lfloor\\frac{n}{kd}\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac{m}{kd}\\rfloor}ij 。这个东西的后半坨可以 O(1) ，然后就是套两层整除分块的事情了。 典例 4 \\sum_{i=1}^n\\sum_{j=1}^m\\sigma_0(ij) = \\sum_{d=1}^n\\mu(d)F(\\lfloor n / d\\rfloor)F(\\lfloor m /d \\rfloor) 其中， F(n) = \\displaystyle\\sum_{i=1}^n\\left\\lfloor\\frac ni\\right\\rfloor = \\sum_{i=1}^n\\sigma_0(i) 。推导：首先是一个经典结论，证明见下文： \\sigma_0(xy) = \\sum_{i\\mid x}\\sum_{j\\mid y}[i\\perp j] 然后就可以开始反演了： \\displaystyle\\sum_{i=1}^n\\sum_{j=1}^m\\sigma_0(i,j) = \\sum_{i=1}^n\\sum_{j=1}^m\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x,y) = 1] ，然后调换一下内外层求和顺序有 \\displaystyle\\sum_{i=1}^n\\sum_{j=1}^m[\\gcd(i,j) = 1]\\left\\lfloor\\frac ni\\right\\rfloor\\left\\lfloor \\frac mj\\right\\rfloor 。将 [\\gcd(i,j) = 1] 用 \\mu 来化开之后变为 \\displaystyle\\sum_{i=1}^n\\sum_{j=1}^m\\left\\lfloor\\frac ni\\right\\rfloor\\left\\lfloor \\frac mj\\right\\rfloor\\sum_{d\\mid i,d\\mid j}\\mu(d) ，再将 d 提到最外面就有 \\displaystyle\\sum_{d=1}^n\\mu(d)\\left(\\sum_{d\\mid i, i\\le n}\\sum_{d\\mid j,j\\le m}\\left\\lfloor\\frac ni\\right\\rfloor\\left\\lfloor \\frac mj\\right\\rfloor\\right) ，里面直接再除以个 d 就有上面那个式子了。 至于为什么 \\displaystyle\\sum_{i=1}^n\\left\\lfloor\\frac ni\\right\\rfloor = \\sum_{i=1}^n\\sigma_0(i) ，分析一下 \\sigma_0 是如何被贡献出来的即可。 其余例题 例题 1：P1447 [NOI2010] 能量采集：求 \\sum_{i=1}^n\\sum_{j=1}^m(2\\gcd(i,j) - 1) 显然将式子化简就变成 2\\displaystyle\\sum_{i=1}^n\\sum_{j=1}^m\\gcd(i,j)-nm 。现在考虑 \\sum_i\\sum_j\\gcd(i,j) 怎么求。考虑枚举之： \\sum_{d}d\\sum_i\\sum_j[\\gcd(i,j)=d] ，发现后面就是上面的典例 1 ，可以 O(n\\sqrt n) 干掉。但是其可以进一步优化。考虑答案式 \\displaystyle\\sum_{d=1}^nd\\sum_{k=1}^{\\lfloor n /d\\rfloor}\\mu(k)\\lfloor n/kd\\rfloor\\lfloor m/kd\\rfloor 。用典例 2 的换元，换得 \\displaystyle\\sum_{T=1}^{n}\\sum_{d\\mid T}d\\mu(T/d)\\lfloor n / T\\rfloor\\lfloor m / T\\rfloor ，注意到前面的经典结论： \\phi = \\mu*\\mathrm{id} ，所以可以写成 \\displaystyle\\sum_{T=1}^n\\lfloor n / T\\rfloor\\lfloor m / T\\rfloor\\phi(T) 。这样就变成 O(n) - O(\\sqrt n) 的了。 例题 2 ：「贵州省选模拟 2022」线段树 I by Asd_Okuu n\\le 20 次询问，每次询问给定 1\\le x,y,z\\le 5\\times 10^{17} ，保证 y - z\\ge 1 ，求 \\sum_{i=0}^z\\gcd(x + i, y - i) 如果一上来就枚举 \\gcd 的话本题将变得较为困难，不妨先考虑辗转相减法的一个变形： \\gcd(i,j) = \\gcd(i + j, j) ，所以将上面的式子化成 \\sum_{i=0}^z\\gcd(x + i, x + y) 然后问题就变得很简单了，不妨考虑用前缀和变成求 f(n,m) = \\displaystyle\\sum_{i=1}^n\\gcd(n, m) ，然后直接按上面的方法枚举 \\gcd ，换元，求解。最后化出来的式子长这样： \\sum_{T\\mid m}\\left\\lfloor\\frac nT \\right\\rfloor\\varphi(T) 对于 m\\le 10^7 的情况可以线性筛出 \\varphi ，复杂度为 O(m + n\\sqrt m) 。 对于 m\\le 10^9 的情况可以枚举因数然后暴力求 \\varphi ，复杂度未知但表现很不错，如果你会证明复杂度请私信我。 对于 m\\le 10^{18} 的情况，首先 Pollard-rho 分解出质因数，然后利用唯一分解式枚举 T ，与此同时顺便算出 \\varphi(T) ，时间复杂度为 O(n(m^{0.25} + \\sigma_0(m))) 。 例题 3 ：洛谷 P3312 [SDOI2014]数表 Q\\le 2\\times 10^4 次询问，给定 n,m\\le 10^5,a ，求 \\sum_{i = 1}^n\\sum_{j = 1}^m\\sigma(\\gcd(i,j))\\times[\\sigma(\\gcd(i,j)) \\le a]\\bmod 2^{31} 不妨先忽略 \\sigma(\\gcd(i,j)) \\le a 的限制来化简式子： \\begin{aligned} &amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\sigma(\\gcd(i,j))\\\\ =&amp;\\sum_{d = 1}^n\\sigma(d)\\sum_{i = 1}^{\\lfloor n/d\\rfloor}\\sum_{j = 1}^{\\lfloor m / d\\rfloor}\\sum_{x\\mid i\\land x \\mid j}\\mu(x)\\\\ =&amp;\\sum_{d = 1}^n\\sigma(d)\\sum_{x = 1}^{\\lfloor n / d\\rfloor}\\lfloor n / dx\\rfloor\\lfloor m/ dx\\rfloor\\mu(x)\\\\ =&amp;\\sum_{T = 1}^n\\lfloor n / T\\rfloor\\lfloor m / T\\rfloor\\sum_{d\\mid T}\\sigma(d)\\mu(T/d) \\end{aligned} 最后一步换了个元令 T = dx 。若再考虑让 f(T) = \\displaystyle\\sum_{d\\mid T}\\sigma(d)\\mu(T/d) ，则要求的东西就被转化为了 \\sum_{T = 1}^n\\lfloor n / T\\rfloor\\lfloor m / T\\rfloor f(T) 然后注意到， \\sigma(d) 能对 f(T) 产生贡献当且仅当 \\sigma(d)\\le a ，那么不妨离线所有询问然后将询问按 a 排序，再将预处理好的 \\sigma(d) 从小到大排序，用树状数组维护 f ，每次加 \\sigma(d)\\mu(T / d) 都会使得 d 的倍数对应的 f(T) 增加。对于每个询问直接整除分块。时间复杂度 O(q\\sqrt n\\log n + n \\log^2 n) 。 例题 4 ：CF1139D Steps to One 给定正整数 m\\le 10^5 ，初始空数列，每次随机一个 1\\sim m 的整数加在数列末尾，数列的 \\gcd = 1 时停止。问期望长度，对 10^9 + 7 取模。 不妨设 f_i 为当前数列 \\gcd 为 i 时，期望的剩余步数。则我们有朴素转移： f_i = \\frac 1m\\sum_{j=1}^mf_{\\gcd(j, i)} + 1 边界条件为 f_1 = 0 ，答案即为 \\dfrac 1m\\sum f_i 。需要注意特判 \\gcd(i,j) = i 的情况，解个方程后发现就是 f_i = \\frac{1 + \\frac1m\\sum_{j=1,i\\not\\mid j}^m f_{\\gcd(i,j)}}{1 - \\lfloor\\frac{m}{i}\\rfloor} O(m^2\\log m) 显然有点寄，套路地枚举 g = \\gcd(i,j) ，令 c(i,g) 表示 \\sum_{x=1}^m[\\gcd(x, i) = g] ，则 f_i = \\frac{1 + \\frac1m \\sum_{g\\mid i,g\\ne i}f_gc(i,g)}{1 - \\lfloor\\frac mi\\rfloor} 现在推导 c ： \\begin{aligned} c(i,g) &amp;= \\sum_{x=1}^m[\\gcd(x,i) = g]\\\\ &amp;=\\sum_{x' =1}^{\\lfloor \\frac mg\\rfloor}[\\gcd(x', i/g) = 1]\\\\ &amp;=\\sum_{x'=1}^{\\lfloor\\frac mg\\rfloor}\\sum_{d\\mid \\gcd(x', i / g)}\\mu(d)\\\\ &amp;=\\sum_{d\\mid \\frac ig}\\mu(d)\\left\\lfloor\\frac{m}{gd} \\right\\rfloor \\end{aligned} 于是求 c(i,g) 的时间复杂度为 O(\\sqrt{\\frac ig}) 。设总时间复杂度为 T(m) ，则 T(m) = \\sum_{i=2}^m\\sum_{g\\mid i}O\\left(\\sqrt{\\frac ig}\\right) = \\sum_{i=2}^m\\sum_{j\\mid i}O(\\sqrt j) \\sim m\\int_1^mj^{-0.5}\\mathrm{d}j = O(m\\sqrt m) 但是这题还有另一种做法，即直接从期望开推： \\begin{aligned} E(n) &amp;= \\sum_{i\\ge 1}P(i = n)\\times i\\\\ &amp;= \\sum_{i\\ge 1}P(i = n)\\sum_{j=1}^i 1\\\\ &amp;=\\sum_{j\\ge 1}\\sum_{i\\ge j}P(n = i)\\\\ &amp;=\\sum_{i\\ge 1}P(n\\ge i)\\\\ &amp;= 1 + \\sum_{i\\ge1}P(n&gt;i) \\end{aligned} 求 P(n &gt; i) 的时候考虑 \\gcd_{j=1}^{n}\\{a_j\\} = 1 的时候就会结束，简单容斥一下再反演： \\begin{aligned} P(n&gt;i) &amp;= P\\left(\\gcd_{j=1}^i\\{a_i\\} &gt;1\\right)\\\\ &amp;= 1 - P\\left(\\gcd_{j=1}^i\\{a_i\\} =1\\right)\\\\ &amp;= 1 - \\frac{\\sum_{d=1}^m\\mu(d)\\lfloor\\frac md\\rfloor^i}{m^i}\\\\ &amp;= -\\frac{\\sum_{d=2}^m\\mu(d)\\lfloor\\frac md\\rfloor^i}{m^i} \\end{aligned} 回代上面的式子，有 \\begin{aligned} E(n) &amp;= 1 + \\sum_{i\\ge 1} P(n &gt; i)\\\\ &amp;= 1 - \\sum_{i\\ge 1}\\frac{\\sum_{d=2}^m\\mu(d)\\lfloor\\frac md\\rfloor^i}{m^i}\\\\ &amp;= 1 - \\sum_{i\\ge 1}\\frac{1}{m^i}\\sum_{d=2}^m\\mu(d)\\left\\lfloor\\frac md\\right\\rfloor^i\\\\ &amp;= 1 - \\sum_{d=2}^m\\mu(d)\\sum_{i\\ge 1}\\left(\\frac{\\lfloor\\frac md\\rfloor}{m}\\right)^i&amp;\\text{recall the formula }x + x^2+\\cdots=\\frac{x}{1-x}\\\\ &amp;= 1 - \\sum_{d=2}^m\\mu(d)\\frac{\\lfloor\\frac md\\rfloor}{m - \\lfloor\\frac md\\rfloor} \\end{aligned} 可以 O(m) ，但也可以上杜教做到 O(m^{2/3}) 但没必要。 例题 5 ：CF1559E Mocha and Stars 求满足如下条件的序列 (a_1, a_2, \\cdots , a_n) 的数量： \\forall i\\in[1, n], a_i\\in[l_i, r_i] ； \\sum a_i\\le m ； \\gcd(a_1, a_2, \\cdots, a_n) = 1 2\\le n\\le 50 ， 1\\le m\\le 10^5 ，答案对 998244353 取模。 不考虑 \\gcd 的限制，发现其为一个背包。令 f_{i, j} 为前 i 个物品，背包容量为 j 的方案数，则有转移方程： f_{i, j} = \\sum_{k = l_i}^{r_i}f_{i - 1, j - k} 这样直接去做是 O(nm^2) 的，发现转移可以使用前缀和优化，具体设 s_{i, j} 表示 s_{i, j} = \\sum_{k = 0}^jf_{i, k} 然后就有了转移方程 f_{i, j} = s_{i - 1, j - l_i} - s_{i - 1, j - r_i - 1} 背包部分的复杂度为 O(nm) 。接下来考虑 \\gcd 的限制，对于这种多个的情况一样可以考虑反演： \\begin{aligned} &amp;\\sum_{a_1=l_1}^{r_1}\\sum_{a_2=l_2}^{r_2}\\cdots\\sum_{a_n=l_n}^{r_n}[\\gcd(a_1,\\cdots,a_n)=1]\\left[\\sum_{i = 1}^na_i\\le m\\right]\\\\ =&amp;\\sum_{a_1=l_1}^{r_1}\\sum_{a_2=l_2}^{r_2}\\cdots\\sum_{a_n=l_n}^{r_n}\\left[\\sum_{i = 1}^na_i\\le m\\right]\\sum_{d \\mid \\gcd(a_1,\\cdots,a_n)}\\mu(d)\\\\ =&amp;\\sum_{a_1=l_1}^{r_1}\\sum_{a_2=l_2}^{r_2}\\cdots\\sum_{a_n=l_n}^{r_n}\\left[\\sum_{i = 1}^na_i\\le m\\right]\\sum_{d\\mid a_1,\\cdots,d \\mid a_n}\\mu(d)\\\\ =&amp;\\sum_{d=1}^m\\mu(d)\\sum_{a_1=\\lceil\\frac{l_1}{d}\\rceil}^{\\lfloor\\frac{r_1}{d}\\rfloor}\\sum_{a_2=\\lceil\\frac{l_2}{d}\\rceil}^{\\lfloor\\frac{r_2}{d}\\rfloor}\\cdots\\sum_{a_n=\\lceil\\frac{l_n}{d}\\rceil}^{\\lfloor\\frac{r_n}{d}\\rfloor}\\left[\\sum_{i = 1}^na_i\\le \\left\\lfloor\\frac m d\\right\\rfloor\\right] \\end{aligned} 然后枚举 d\\in[1, m] ，发现其就是个子问题， O(nm\\log m) 解决。对于 \\mu(d) = 0 的情况跳过还可以加速。 例题 6 ：P6271 [湖北省队互测2014]一个人的数论 定义 f_m(n) 为所有小于 n 且与 n 互素的正整数的 m 次方之和。给定 m 的值和 n 的质因数分解式，求 f_m(n)\\bmod 10^9 + 7 的值。 若 n = \\prod_{i = 1}^{w}p_i^{\\alpha_i} 有 1\\le w \\le 1000 ， 2\\le p_i\\le 10^9 ， 1\\le \\alpha_i\\le 10^9 ， 0\\le m \\le 100 。 一道非常牛逼的题。首先明确要求的内容为 \\sum_{i=1}^{n-1}i^m[\\gcd(i, n) = 1] 然后直接开始反演： \\begin{aligned} \\sum_{i=1}^{n-1}i^m[\\gcd(i, n) = 1] &amp;= \\sum_{i=1}^{n}i^m[\\gcd(i, n) = 1]\\\\ &amp;=\\sum_{i=1}^ni^m\\sum_{d\\mid \\gcd(i,n)}\\mu(d)\\\\ &amp;=\\sum_{d\\mid n}\\mu(d)\\sum_{i=1}^{\\frac nd}(id)^m\\\\ &amp;=\\sum_{d\\mid n}\\mu(d)d^m\\sum_{i=1}^{\\frac nd} i^m \\end{aligned} 然后似乎就化不动了。。但是注意到式子里有形如 f(n) = \\displaystyle\\sum_{i=1}^n i^m ，即自然数幂之和，其必然为关于 n 的 m + 1 次多项式，因为 m 很小所以可以暴力将 f(x) = \\displaystyle\\sum_{i=0}^{m+1}f_ix^i 的系数消元出来。然后回代一下式子： \\begin{aligned} &amp;\\sum_{d\\mid n}\\mu(d)d^m\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor} i^m\\\\ =&amp;\\sum_{d\\mid n}\\mu(d)d^m\\sum_{i=1}^{m+1}f_i\\left(\\frac nd\\right)^{i}\\\\ =&amp;\\sum_{i=1}^{m+1}f_i\\sum_{d\\mid n}\\mu(d)d^m\\left(\\frac nd\\right)^{i} \\end{aligned} 发现后面那坨是积性函数的卷积，所以可以对于所有的 p_i^{\\alpha_i} 求一遍然后乘起来，现在考虑怎么快速求之。 注意到有个东西叫 \\mu ，所以会产生贡献的只有 d = 1 和 d = p_i 的情况，所以要算的实际就是 p_i^{\\alpha_ii} - p_i^{m + \\alpha_ii - i} 。问题解决了，时间复杂度 O(m^3 + m(m + w)) 。 常见结论/方法 写代码的时候注意 long long 和取模的问题，很容易出岔子。 化简式子的时候可以将无关变量提前： \\sum_{i = 1}^nf(n)\\sum_{j = 1}^mk\\times g(n) = \\sum_{i = 1}^nf(n)k\\sum_{j = 1}^mg(n) 交换枚举顺序： \\sum_{i = 1}^nf(n)\\sum_{d\\mid i}g(d) = \\sum_{d = 1}^ng(d)\\sum_{i = 1}^{\\lfloor\\frac nd\\rfloor}f(id) 尝试构造 \\epsilon = [n = 1] ： \\begin{aligned} &amp;\\sum_{i = 1}^n\\sum_{j = 1}^mf(\\gcd(i, j))\\\\ =&amp;\\sum_{d = 1}^n\\sum_{i = 1}^n\\sum_{j = 1}^mf(d)[\\gcd(i,j) = d]\\\\ =&amp;\\sum_{d = 1}^nf(d)\\sum_{i = 1}^n\\sum_{j = 1}^m[\\gcd(i,j) = d] \\end{aligned} 之后就懒得写了。 \\operatorname{lcm}(i,j) = \\dfrac{ij}{\\gcd(i,j)} 过于平凡，不写。 巧妙换元减少枚举数量： \\sum_{P(k)}\\sum_{d = 1}^{\\lfloor \\frac nk\\rfloor}\\mu(d)\\left\\lfloor\\frac{n}{kd}\\right\\rfloor\\left\\lfloor\\frac{m}{kd}\\right\\rfloor = \\sum_{T = 1}^n\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\sum_{k\\mid T, P(k)}\\mu\\left(\\frac Tk\\right) 除数函数的重要性质: d(xy) = \\sum_{i\\mid x}\\sum_{j\\mid y}[\\gcd(i,j) = 1] 证明：考虑一一映射每个因子。 设 k\\mid xy ， k 中有因子 p^c ，我们强行规定先取 i 中的 p ，除非不够，再去取 j 中的 p 。这样子，如若我们要求 i\\perp j ，则每个因子 k 都唯一对应一个 (i, j) 。命题得证。 对于一般的除数函数 \\sigma_k ，上述性质仍然可以扩展： \\sigma_k(xy) = \\sum_{i\\mid x}\\sum_{j\\mid y}\\left(\\frac{x}{i}\\right)^kj^k[\\gcd(i,j) = 1] 证明依旧考虑上面的思路。可能写成这样会更好理解： \\sigma_k(xy) = \\sum_{i\\mid x}\\sum_{j\\mid y}i^kj^k[\\gcd(x / i, j) =1] 然后换一下 i 和 x / i 就可以了。 筛法 埃筛 通过“ x 是合数，则 x 的倍数也是合数”来减少标记次数，即只标记所有素数的倍数。 12345678910111213void Eratosthenes() { isp[0] = isp[1] = 1; for (int i = 2; i &lt;= N; ++i) { if (!isp[i]) { prime[++totp] = i; if (1ll * i * i &lt;= N) for (int j = i * i; j &lt;= N; j += i) isp[j] = 1; } } return;} 时间复杂度 O(n\\log\\log n) ，没有什么弔用，复杂度分析略（因为不会），唯一用处是可以拿来分析 Dirichlet 前缀和的复杂度。 线性筛 又名欧拉筛，可以以线性的时间复杂度筛出给定值域内的素数。上文已经提到了如何用欧拉筛筛素数，但是欧拉筛的强大之处在于，其利用的每个合数被最小质因子筛去性质使得它可以同时求出积性函数的值。 欧拉函数/莫比乌斯函数 首先再次强调：每个合数 n 会被其最小质因子 p 筛去，下面令 n' = n / p 。 对于 p\\not\\mid n' 的情况， n' 和 p 必然互质，此时有 \\varphi(n) = \\varphi(n')\\times \\varphi(p) = (p - 1)\\varphi(n') 。 否则对于 p\\mid n' 的情况， n' 必然包含 n 的所有质因子，拆开 \\varphi(n) 的表达式有 \\begin{aligned} \\varphi(n) &amp;= n\\times \\prod \\frac{p_i - 1}{p_i}\\\\ &amp;= p\\times n'\\times \\prod\\frac{p_i - 1}{p_i}\\\\ &amp;= p\\times \\varphi(n') \\end{aligned} 那么事情就变得明朗了，对于质数， \\varphi(n) = n - 1 ，对于合数，在筛的过程中按照上面的公式求就可以了。注意边界 \\varphi(1) = 1 。 12345678910111213141516171819void sieve() { phi[1] = 1; for (int i = 2; i &lt;= maxn; ++i) { if (!vis[i]) { phi[i] = i - 1; p[++tot] = i; } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= maxn; ++j) { vis[i * p[j]] = 1; if (i % p[j] == 0) { phi[i * p[j]] = p[j] * phi[i]; break; } phi[i * p[j]] = (p[j] - 1) * phi[i]; } } return;} 而于莫比乌斯函数，则相对更好考虑。还是令 n' = n / p ， p 为 n 的最小质因子。 对于质数， \\mu(n) = -1 ，对于合数，按照上面的方式分类讨论： p\\not\\mid n' ，则 n' 与 p 一定互质， \\mu(n) = -\\mu(n') 。 否则 p\\mid n' ，这说明 n 里面至少有一个平方因子（ p^2 ），所以 \\mu(n) = 0 。 还是注意边界， \\mu(1) = 1 ，记不住的话考虑积性函数的性质。 12345678910111213141516void sieve() { mu[1] = 1; for (int i = 2; i &lt;= N; ++i) { if (!vis[i]) { mu[i] = -1; prime[++tot] = i; } for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= N; ++j) { vis[i * prime[j]] = 1; if (i % prime[j]) mu[i * prime[j]] = -mu[i]; else break; } } return;} 当然一般是最后要做前缀和的，这个另说吧。 除数函数 首先，若将 n 唯一分解： \\displaystyle n = \\prod_{i=1}^sp_i^{\\alpha_i} ，则有 d(n) = \\displaystyle\\prod_{i=1}^s(1 + \\alpha_i) 。其组合意义为：每个质因子选不大于 \\alpha_i 个出来，其一定为 n 的因数。 由于 n 会被最小质因子 p 筛去，所以还需要对每个数额外维护其最小质因子的幂次 f 。 对于质数， d(n) = 2 ， f(n) = 1 。 当 p\\not\\mid n' ，根据 d 的积性，有 d(n) = 2d(n') ， f(n) = 1 。 否则，根据上面的公式有 \\displaystyle d(n) = \\frac{d(n')}{1 + f(n')} \\times(2 + f(n’)) ， f(n) = f(n') + 1 。 对于 \\sigma ，有如下公式： \\sigma(n) = \\displaystyle\\prod_{i=1}^s\\sum_{j=0}^{\\alpha_i}p_i^j 。组合意义为：考虑每个质因子里面选不同的次数出来组合成这 d(n) 个因数。 类似的，需要维护最小质因子的各次幂之和 g ： 对于质数， \\sigma(n) = g(n) = 1 + n 。 当 p\\not\\mid n' ，根据 \\sigma 的积性有 \\sigma(n) = (p + 1)\\sigma(n') ， g(n) = 1 + p 。 否则，根据上面的公式有 g(n) = pg(n') + 1 ， \\displaystyle \\sigma(n) = \\frac{\\sigma(n')}{g(n')}\\times g(n) 。 代码就不放了，感受了上面的过程之后遇到题目可以自己推导。 而对于一般的 \\sigma_k ，一样有公式 \\sigma_k(n) = \\displaystyle\\prod_{i=1}^s\\sum_{j=0}^{\\alpha_i} p_i^{jk} 。同样维护一下 g 即可。 幂函数 当然，直接 O(n\\log n) 求幂函数也是可以的，但是某些时候时限可能会卡的很紧。 根据 \\mathrm{id}_k 的完全积性，对于质数处的点值快速幂一下，其他情况直接乘起来就没问题了。 杜教筛 杜教筛可以在低于线性的时间复杂度内求出一类积性函数的前缀和。 前置知识：上文莫比乌斯反演部分，积性函数部分。 算法流程 是一种类似硬构造的感觉。令我们要求的积性函数为 f(n) ，其前缀和为 S(n) 。 现在想办法构造一个 S(n) 关于 S\\left(\\left\\lfloor\\dfrac ni\\right\\rfloor\\right) 的递推式，不妨让 f 卷上另一个积性函数 g 然后考虑其前缀和： \\begin{aligned} &amp;\\sum_{i=1}^n (f*g)(i)\\\\ =&amp;\\sum_{i=1}^n\\sum_{d\\mid i}g(d)f\\left(\\frac id\\right)\\\\ =&amp;\\sum_{d=1}^ng(d)\\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}f(i)\\\\ =&amp;\\sum_{d=1}^ng(d)S\\left(\\left\\lfloor\\dfrac nd\\right\\rfloor\\right) \\end{aligned} 第三行是交换枚举顺序然后提出了 g(d) 。 然后将 g(1)S(n) 移项一下就得到了杜教筛的核心式子： g(1)S(n) = \\sum_{i=1}^n(f*g)(i) - \\sum_{d=2}^ng(d)S\\left(\\left\\lfloor\\dfrac nd\\right\\rfloor\\right) 如果能快速算出 (f*g)(n) 和 g(n) 的前缀和的话，就意味着上面的式子可以快速递归计算。见下面伪代码： 12345678910ll getSum(int n) { if (hash[n]) return hash[n]; // 记忆化 ll ret = f_g_sum(n); // 求 (f*g)(i) 的前缀和 for (ll l = 2, r; l &lt;= n; l = r + 1) { // 整除分块 r = min(n, n / (n / l)); ret -= (g_sum(r) - g_sum(l - 1)) * getSum(n / l); } return ret;} 由于网上关于杜教筛复杂度的证明有各种说法，所以此处先咕着。总之一般而言，杜教筛时间复杂度为 O(n^{0.75}) ，若用线性筛提前处理好前 n^{2/3} 项的话复杂度则降低为 O(n^{2/3}) 。 常见模型 模型 1 ：筛 \\varphi 。 发现 \\varphi * \\boldsymbol 1 = \\mathrm{id} ，所以取 f = \\varphi ， g = 1 ，然后就可以很容易杜教筛辣： S(n) = \\frac{n(n+1)}{2} - \\sum_{d=2}^n S\\left(\\left\\lfloor\\dfrac nd\\right\\rfloor\\right) 模型 2 ：筛 \\mu 。 会发现 \\mu * \\boldsymbol 1 = \\varepsilon ，所以取 f = \\mu ， g = \\boldsymbol 1 ，然后： S(n) = 1 - \\sum_{d=2}^nS\\left(\\left\\lfloor\\dfrac nd\\right\\rfloor\\right) 模型 3 ：筛 \\sigma_k ，即除数函数，定义见上文。 由于 \\sigma_k = \\boldsymbol 1 * \\mathrm{id}_k ，所以 \\sigma_k * \\mu = \\mathrm{id}_k ，然后： S(n) = \\sum_{i=1}^n\\mathrm{id}_k(i) - \\sum_{d=2}^n\\mu(d)S\\left(\\left\\lfloor\\dfrac nd\\right\\rfloor\\right) 顺便需要筛出 \\mu 。 模型 4 ： \\mu\\cdot \\mathrm{id}_k 和 \\varphi\\cdot \\mathrm{id}_k 。点乘型。 构造 g 的时候让 g 来一个 \\mathrm{id}_k 卷掉即可。具体地： \\begin{aligned} (\\mu\\cdot \\mathrm{id}_k)* \\mathrm{id}_k &amp;= \\sum_{d\\mid n}\\mu(d)d^k\\left(\\frac nd\\right)^k\\\\ &amp;= n^k\\sum_{d\\mid n}\\mu(d)\\\\ &amp;= \\varepsilon \\end{aligned} 至于欧拉，则有 \\begin{aligned} (\\varphi \\cdot \\mathrm{id}_k) * \\mathrm{id}_k &amp;= \\sum_{d\\mid n}\\varphi(d)d^k\\left(\\frac nd\\right)^k\\\\ &amp;= n^k\\sum_{d\\mid n}\\varphi(d)\\\\ &amp;= \\mathrm{id}^{k + 1} \\end{aligned} 然后杜教筛的过程略。 note：常见的 \\mathrm{id}_k 前缀和： \\displaystyle\\sum_{i=1}^n\\mathrm{id}(i) = \\frac{n(n+1)}{2} ，这个应该是较常规的等差数列求和。 \\displaystyle\\sum_{i=1}^n\\mathrm{id}_2(i) = \\frac{n(n+1)(2n+1)}{6} ，证明可以考虑数归。 \\displaystyle\\sum_{i=1}^n\\mathrm{id}_3(i) = \\left[\\frac{n(n+1)}{2}\\right]^2 ，证明同样考虑数归。 此外，由于 (\\sum \\mathrm{id}_k)(n) 是关于 n 的 k+ 1 次多项式（经典结论），故当 k 不大时可以考虑将系数插出来然后 O(k) 单次求值。 上面的几个式子建议牢记，可以省去自己推的麻烦。 模型 5 ：筛 \\mu^2 。 应该是比较神仙的构造 g 函数了。 此处取 g(n) = [n = k^2, k\\in \\mathbb{N}_+] 。虽然 g 的前缀和看似不好求，但是我们对于这种真值表达式的函数，可以改变枚举的策略使得其恒成立，变为常数函数。 (f*g)(n) = \\displaystyle\\sum_{d\\mid n}g(d)f(n / d) ，观察发现 g(d)f(n / d) 仅在 d 取到 n 的最大平方因子时为 1 ，否则为 0 。因为若 d 不为最大平方因子，则 n / d 肯定含平方因子， \\mu^2(n / d) = 0 。否则 n / d 一定不含平方因子， f(n / d) = g(d) = 1 。所以 f*g = \\boldsymbol 1 。 套回杜教筛的式子： \\begin{aligned} S(n) &amp;= \\sum_{i=1}^n (f*g)(i) - \\sum_{d=2}^ng(d)S\\left(\\left\\lfloor\\frac nd\\right\\rfloor \\right)\\\\ &amp;= n - \\sum_{d=2}^{\\lfloor \\sqrt n\\rfloor} S\\left(\\left\\lfloor\\frac{n}{d^2}\\right\\rfloor \\right) \\end{aligned} 没法整除分块，所以可能复杂度危。 但其实还有另一种方法：我们考虑容斥。 S(n) 可以看作 总数 - 一个平方数的倍数 + 两个平方数的倍数 - .....，发现容斥系数就是 \\mu ，所以 S(n) = \\displaystyle\\sum_{i=1}^{\\lfloor \\sqrt n\\rfloor}\\mu(i)\\lfloor n / i^2\\rfloor 。 另有小结论 \\mu^2(n) = \\displaystyle\\sum_{d^2\\mid n}\\mu(d) 。 应用 例题 1 ：P4213 【模板】杜教筛（Sum） T\\le 10 组询问，一次询问查询 \\varphi 和 \\mu 的前缀和， n&lt; 2^{31} 。 主要看下代码怎么写的。 12345678910111213141516171819202122232425262728293031323334using ll = unsigned long long;const int maxn = 1e7 + 15;std::unordered_map&lt;ll, ll&gt; Mu, Phi;ll mu[maxn], phi[maxn];int vis[maxn], p[maxn], tot;void init() {// 线性筛 mu 和 phi 在 1e7 处前缀和的过程省略}ll getSumPhi(ll n) { if (n &lt;= maxn) return phi[n]; if (Phi[n]) return Phi[n]; ll ans = (ll)(n + 1ll) * (ll)n / 2ll; // id 的前缀和 for (ll l = 2, r; l &lt;= n; l = r + 1) { r = n / (n / l); ans -= (r - l + 1LL) * getSumPhi(n / l); } return Phi[n] = ans; // 记忆化}ll getSumMu(ll n) { if (n &lt;= maxn) return mu[n]; if (Mu[n]) return Mu[n]; ll ans = 1; // epsilon 的前缀和就是 1 for (ll l = 2, r; l &lt;= n; l = r + 1) { r = n / (n / l); ans -= (r - l + 1LL) * getSumMu(n / l); } return Mu[n] = ans; // 记忆化} 例题 2 ：LOJ#6491. 「XXOI 2018」简单的最大公约数 ABC162E - Sum of gcd of Tuples (Hard) 的加强：给定 1\\le N, K\\le 10^{11} ，求 \\sum_{a_1 = 1}^K\\sum_{a_2 = 1}^K\\cdots\\sum_{a_N = 1}^K\\gcd_{i = 1}^N\\{a_i\\}\\bmod {10^9 + 7} 答案对 2^{64} 取模。 先考虑反演： \\begin{aligned} &amp;\\sum_{a_1 = 1}^K\\sum_{a_2 = 1}^K\\cdots\\sum_{a_N = 1}^K\\gcd_{i = 1}^N\\{a_i\\}\\\\ =&amp;\\sum_{a_1 = 1}^K\\cdots\\sum_{a_N = 1}^K\\sum_{d\\mid a_1,\\cdots d\\mid a_N}\\varphi(d)\\\\ =&amp;\\sum_{d = 1}^K\\varphi(d)\\sum_{a_1 = 1}^K\\cdots\\sum_{a_N = 1}^K[d\\mid \\gcd\\{a_i\\}]\\\\ =&amp;\\sum_{d = 1}^K\\varphi(d)\\left\\lfloor\\frac Kd\\right\\rfloor^N \\end{aligned} 然后就可以整除分块 + 杜教筛了，时间复杂度为 O(n^{2/3}) 。 例题 3 ：P3768 简单的数学题 给定 n\\le 10^{10} 和 5\\times 10^8\\le p\\le 1.1\\times 10^9 ，保证 p 为质数，求 \\left(\\sum_{i=1}^n\\sum_{j=1}^nij\\gcd(i,j) \\right)\\bmod p 首先显然先欧拉反演： \\begin{aligned} \\sum_{i=1}^n\\sum_{j=1}^nij\\gcd(i,j) &amp;= \\sum_{i=1}^n\\sum_{j=1}^nij\\sum_{d\\mid \\gcd(i,j)}\\varphi(d)\\\\ &amp;= \\sum_{d=1}^n\\varphi(d)\\sum_{i=1}^n[d\\mid i]i\\sum_{j=1}^n[d\\mid j]j\\\\ &amp;= \\sum_{d=1}^n\\varphi(d)d^2 \\left( \\frac{(1 + \\lfloor n / d\\rfloor)\\lfloor n / d\\rfloor}{2}\\right)^2 \\end{aligned} 发现后面那坨式子可以整除分块，而 \\varphi(d)d^2 就是上面讲的 \\varphi \\cdot \\mathrm{id}_k 类型，直接做即可。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"}]},{"title":"P5488 差分与前缀和","slug":"sol-luogu-p5488","date":"2021-08-11T13:40:51.000Z","updated":"2022-03-23T04:18:31.019Z","comments":true,"path":"sol-luogu-p5488/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5488/","excerpt":"","text":"Description 给定一个长度为 n 的序列，求出其 k 阶差分或前缀和。 系数对 1004535809 取模， 1\\le n\\le 10^5 ， 1\\le k\\le 10^{2333} 。 Solution Part. 1 考虑做一阶前缀和的时候我们干了些什么，发现每个项都被其前面的每个项都贡献了一次。将序列的生成函数建出来，不难发现答案的生成函数即为 f(x)\\times\\sum_{i = 0}^{+\\infty}x^i = \\frac{f(x)}{1 - x} 做 k 次就是乘上 \\dfrac{1}{1 - x} 的 k 次方。 而差分呢？类比上面的思路，求 k 阶差分即为乘上 1 - x 的 k 次方。 这个东西明显可以用多项式快速幂来做，只不过常数会升天。洛谷上开 O2 可过。 12345678910111213141516171819int n, k, t;char s[3000];Poly f, g;int main() { scanf(\"%d %s %d\", &amp;n, s + 1, &amp;t); for (int i = 1; s[i]; ++i) k = (10ll * k + s[i] - '0') % mod; lim = n, initInv(); f.resize(n), g.resize(n); FOR(i, 0, n - 1) scanf(\"%d\", &amp;f[i]); g[0] = 1, g[1] = mod - 1; g = polyExp(k * polyLn(g)); if (!t) g = polyInv(g); f = f * g; print(f); return output(), 0;} Part. 2 考虑不那么暴力去做，而是去思考那两个形式幂级数有什么性质。 考虑差分： (1 - x)^k ，上二项式定理： (1 - x)^k = \\sum_{i = 0}^{+\\infty}(-1)^i\\binom k ix^i 然后 k 这么大，搞什么屁。 然而这题的组合数是可以递推的： \\binom k i = \\binom{k}{i - 1}\\times\\frac{k - i + 1}{i} k 就可以直接对模数取模了。 然后不太好想的是前缀和： \\dfrac{1}{(1 - x)^k} 。我们把它看成 (1 - x)^{-k} 然后上广义二项式定理： \\begin{aligned} (1 - x)^{-k} &amp;= \\sum_{i = 0}^{\\infty}(-1)^i\\binom{-k}i x^i\\\\ &amp;= \\sum_{i = 0}^\\infty(-1)^i\\frac{(-k)^{\\underline{i}}}{i!}x^i\\\\ &amp;= \\sum_{i = 0}^\\infty\\frac{(k + i - 1)^{\\underline{i}}}{i!}x^i\\\\ &amp;= \\sum_{i = 0}^\\infty\\binom{k + i - 1}i x^i \\end{aligned} 然后我们稍微推一下就发现这个组合数也可以递推： \\binom{k + i - 1}{i} = \\binom{k + i - 2}{i - 1}\\times\\frac{k + i - 1}{i} 于是我们就可以更加优秀地通过此题。 12345678910111213141516171819202122int n, k, t;char s[3000];Poly f, g;int main() { scanf(\"%d %s %d\", &amp;n, s + 1, &amp;t); for (int i = 1; s[i]; ++i) k = (10ll * k + s[i] - '0') % mod; lim = n, initInv(); f.resize(n), g.resize(n); FOR(i, 0, n - 1) scanf(\"%d\", &amp;f[i]); if (!t) { g[0] = 1; FOR(i, 1, n - 1) g[i] = 1ll * g[i - 1] * (k + i - 1) % mod * inv[i] % mod; } else { g[0] = 1; FOR(i, 1, n - 1) g[i] = 1ll * (mod - 1) * (k - i + 1) % mod * inv[i] % mod * g[i - 1] % mod; } print(f * g); return output(), 0;} Implementation 附上前面的板子吟唱： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)#define VEC(i, v) for (int i = 0; i &lt; (int)v.size(); ++i)#define il inline#define ll long long#define ull unsigned long long#define clr(f, n) memset(f, 0, (sizeof(int)) * (n))#define cpy(f, g, n) memcpy(f, g, (sizeof(int)) * (n))#define MOD 1004535809template&lt;typename T&gt; il T min(const T &amp;a, const T &amp;b) {return a &lt; b ? a : b;}template&lt;typename T&gt; il T max(const T &amp;a, const T &amp;b) {return a &gt; b ? a : b;}namespace poly {#define int int const int G = 3, mod = MOD, maxn = 1 &lt;&lt; 17 | 500; typedef std::vector&lt;int&gt; Poly; ll qPow(ll a, ll b = mod - 2) { ll ret = 1; for (; b; b &gt;&gt;= 1, a = a * a % mod) if (b &amp; 1) ret = a * ret % mod; return ret; } const int invG = qPow(G); int tr[maxn &lt;&lt; 1], revLim, lim; void getTr(int n) { if (revLim == n) return; revLim = n; FOR(i, 0, n - 1) tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (n &gt;&gt; 1) : 0); } void NTT(int *g, bool op, int n) { getTr(n); static ull f[maxn &lt;&lt; 1], w[maxn &lt;&lt; 1]; w[0] = 1; FOR(i, 0, n - 1) f[i] = (((ll)mod &lt;&lt; 5ll) + g[tr[i]]) % mod; for (int l = 1; l &lt; n; l &lt;&lt;= 1) { ull tG = qPow(op ? G : invG, (mod - 1) / (l &lt;&lt; 1)); FOR(i, 1, l - 1) w[i] = w[i - 1] * tG % mod; for (int k = 0; k &lt; n; k += (l &lt;&lt; 1)) for (int p = 0; p &lt; l; ++p) { int tt = w[p] * f[k | l | p] % mod; f[k | l | p] = f[k | p] + mod - tt; f[k | p] += tt; } if (l == (1 &lt;&lt; 10)) FOR(i, 0, n - 1) f[i] %= mod; } if (!op) { ull invn = qPow(n); FOR(i, 0, n - 1) g[i] = f[i] % mod * invn % mod; } else FOR(i, 0, n - 1) g[i] = f[i] % mod; } void mul(int *f, int *g, int n) { FOR(i, 0, n - 1) f[i] = 1ll * f[i] * g[i] % mod; return; } Poly operator+(const Poly &amp;A, const Poly &amp;B) { Poly C = A; C.resize(max(A.size(), B.size())); VEC(i, B) C[i] = (C[i] + B[i]) % mod; return C; } Poly operator-(const Poly &amp;A, const Poly &amp;B) { Poly C = A; C.resize(max(A.size(), B.size())); VEC(i, B) C[i] = (C[i] + mod - B[i]) % mod; return C; } Poly operator*(const int c, const Poly &amp;A) { Poly C = A; VEC(i, A) C[i] = 1ll * c * C[i] % mod; return C; } Poly operator-(const Poly &amp;A) { Poly ret; ret.resize(A.size()); VEC(i, A) ret[i] = mod - A[i]; return ret; } Poly operator*(const Poly &amp;A, const Poly &amp;B) { static int a[maxn &lt;&lt; 1], b[maxn &lt;&lt; 1]; cpy(a, &amp;A[0], A.size()); cpy(b, &amp;B[0], B.size()); Poly C; C.resize(min(lim, (int)(A.size() + B.size() - 1))); int n = 1; for (n = 1; n &lt; (int)(A.size() + B.size() - 1); n &lt;&lt;= 1); NTT(a, 1, n), NTT(b, 1, n); mul(a, b, n), NTT(a, 0, n); cpy(&amp;C[0], a, C.size()); clr(a, n), clr(b, n); return C; } void polyInv(const Poly &amp;A, Poly &amp;B, int n) { if (!n) return; if (n == 1) B.push_back(qPow(A[0])); else if (n &amp; 1) { polyInv(A, B, --n); int sav = 0; FOR(i, 0, n - 1) sav = (sav + 1ll * B[i] * A[n - i]) % mod; B.push_back(1ll * sav * qPow(mod - A[0]) % mod); } else { polyInv(A, B, n &gt;&gt; 1); Poly sA; sA.resize(n); cpy(&amp;sA[0], &amp;A[0], n); B = 2 * B - B * B * sA; B.resize(n); } return; } Poly polyInv(const Poly &amp;A) { Poly C; polyInv(A, C, A.size()); return C; } int inv[maxn]; void initInv() { inv[1] = 1; FOR(i, 2, lim) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; return; } Poly deri(const Poly &amp;A) { Poly C = A; for (int i = 1; i &lt; (int)C.size(); ++i) C[i - 1] = 1ll * C[i] * i % mod; if (!C.empty()) C.pop_back(); return C; } Poly ints(const Poly &amp;A) { Poly C = A; for (int i = (int)C.size() - 1; i &gt; 0; --i) C[i] = 1ll * C[i - 1] * inv[i] % mod; if (!C.empty()) C[0] = 0; return C; } Poly polyLn(const Poly &amp;A) { return ints(deri(A) * polyInv(A)); } void polyExp(const Poly &amp;A, Poly &amp;B, int n) { if (!n) return; if (n == 1) B.push_back(1); else if (n &amp; 1) { polyExp(A, B, n - 1); n -= 2; int sav = 0; FOR(i, 0, n) sav = (sav + 1ll * (i + 1) * A[i + 1] % mod * B[n - i]) % mod; B.push_back(1ll * sav * inv[n + 1] % mod); } else { polyExp(A, B, n / 2); Poly lnB = B; lnB.resize(n); lnB = polyLn(lnB); VEC(i, lnB) lnB[i] = (mod + A[i] - lnB[i]) % mod; ++lnB[0]; B = B * lnB; B.resize(n); } return; } Poly polyExp(const Poly &amp;f) { Poly ret; polyExp(f, ret, f.size()); return ret; }#undef int} using namespace poly;namespace fastIO { const int maxc = 1 &lt;&lt; 23; char obuf[maxc], *__pO = obuf; il void putchar(char c) {*__pO++ = c;} template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return; } void print(Poly A) { VEC(i, A) print(A[i]), putchar(' '); putchar('\\n'); return; } void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} using namespace fastIO;","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"51nod1778 小Q的集合","slug":"sol-51nod1778","date":"2021-08-05T12:09:12.000Z","updated":"2022-03-23T04:18:30.647Z","comments":true,"path":"sol-51nod1778/","link":"","permalink":"https://old.blog.imyangty.com/sol-51nod1778/","excerpt":"","text":"Description 定义一个集合 S ， |S| = n 。对于任意一个 S 的子集 T ，定义 f(T) = |T|^k ，定义 T 关于 S 的补集为 S - T 。问若等概率选取一个子集 T ，那么 f(T) - f(S - T) 的方差是多少。 输出 (v\\times2^n)\\bmod m 。 1\\le k\\le 10^6 ， k\\le n\\le 10^{10^6} ， 2\\le m\\le 10^6 且 m 为质数。 Solution 首先要知道方差的定义：设 x 为随机变量，则 x 的方差 D(x) 定义为 D(x) = E(x^2) - E^2(x) 也即，平方的期望减去期望的平方。 然后我们肯定知道， f(T) - f(S - T) 的期望肯定为 0 ，所以只需计算平方的期望。 \\begin{aligned} 2^nE((f(T) -f(S - T))^2) &amp;\\equiv 2^n\\frac{\\sum_{i = 0}^n\\binom n i(i^k - (n - i)^k)^2}{2^n}\\\\ &amp;\\equiv \\sum_{i = 0}^n\\binom{\\left\\lfloor\\frac np\\right\\rfloor}{\\left\\lfloor\\frac ip\\right\\rfloor}\\binom{n\\bmod p}{i\\bmod p}(i^k - (n - i)^k)^2\\\\ &amp;\\equiv\\sum_{i = 0}^{\\left\\lfloor\\frac np\\right\\rfloor}\\binom{\\left\\lfloor\\frac np\\right\\rfloor}{i}\\sum_{j = 0}^{n\\bmod p}\\binom{n\\bmod p}{j}((ip + j)^k - (n - ip - j)^k)^2\\\\ &amp;\\equiv\\sum_{i = 0}^{\\left\\lfloor\\frac np\\right\\rfloor}\\binom{\\left\\lfloor\\frac np\\right\\rfloor}{i}\\sum_{j = 0}^{n\\bmod p}\\binom{n\\bmod p}{j}(j^k - (n - j)^k)^2\\\\ &amp;\\equiv2^{\\lfloor\\frac np\\rfloor}\\sum_{j = 0}^{n\\bmod p}\\binom{n\\bmod p}{j}(j^k - (n - j)^k)^2\\pmod p\\\\ \\end{aligned} 第二行是使用 Lucas 定理展开，第三行是类似整除分块的思想，第四行是通过二项式定理展开把 ip 那项扬了，第五行是二项式定理把 \\displaystyle\\sum_{i = 0}^{\\left\\lfloor\\frac np\\right\\rfloor}\\binom{\\left\\lfloor\\frac np\\right\\rfloor}{i} 化开。 然后右边的 \\displaystyle\\sum_{j = 0}^{n\\bmod p}\\binom{n\\bmod p}{j}(j^k - (n - j)^k)^2\\pmod p 是可以直接求的。考虑到 2^{p - 1}\\equiv 1\\pmod p ，前面那个东西就可以处理成 \\displaystyle 2^{\\lfloor\\frac np\\rfloor\\bmod (p - 1)} 。 Implementation i^k 和组合数可以直接处理，然后随便做做就有了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 1e6 + 5;typedef long long ll;char s[maxn];ll k, m, ik[maxn], c[maxn], fac[maxn], invfac[maxn];ll qPow(ll a, ll b, ll p = m) { ll ret = 1; for (; b; b &gt;&gt;= 1, a = a * a % p) if (b &amp; 1) ret = 1ll * ret * a % p; return ret;}int main() { scanf(\"%s\", s + 1); scanf(\"%lld %lld\", &amp;k, &amp;m); k %= (m - 1); int len = strlen(s + 1); ll n = 0, res = 0, sum = 0; FOR(i, 1, len) { n = (n * 10 + s[i] - '0') % m; res = res * 10 + s[i] - '0'; sum = (sum * 10 + res / m) % (m - 1); res %= m; } ll ans = 0; fac[0] = 1; FOR(i, 1, n) fac[i] = fac[i - 1] * i % m; invfac[n] = qPow(fac[n], m - 2); DEC(i, n - 1, 0) invfac[i] = invfac[i + 1] * (i + 1) % m; FOR(i, 0, n) { ik[i] = qPow(i, k); c[i] = fac[n] * invfac[n - i] % m * invfac[i] % m; } FOR(i, 0, n) ans = (ans + (ik[i] - ik[n - i]) * (ik[i] - ik[n - i]) % m * c[i] % m) % m; printf(\"%lld\\n\", qPow(2, sum) * ans % m); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"51nod","slug":"51nod","permalink":"https://old.blog.imyangty.com/tags/51nod/"},{"name":"Lucas定理","slug":"lucas","permalink":"https://old.blog.imyangty.com/tags/lucas/"},{"name":"方差","slug":"variance","permalink":"https://old.blog.imyangty.com/tags/variance/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"}]},{"title":"P2839 [国家集训队]middle","slug":"sol-luogu-p2839","date":"2021-08-03T15:45:03.000Z","updated":"2022-03-23T04:18:30.922Z","comments":true,"path":"sol-luogu-p2839/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2839/","excerpt":"","text":"Description 一个长度为 n 的序列，定义中位数为排完序后的第 \\lfloor n/ 2\\rfloor 项。每次给定 a &lt; b &lt; c &lt; d ，问对于所有满足 l\\in [a,b] ， r\\in[c,d] 的子区间 [l, r] 的中位数的最大值。 强制在线。 n,q 为 20000 级别。 Solution 首先离散化。 对于中位数问题，有一种套路做法。二分答案 x ，令区间内所有小于 x 的数d为 -1 ，所有大于等于 x 的数为 1 ，求个区间和，则中位数大于等于 x 当且仅当区间权值和大于 0 。 然后在这个问题里面，我们也可以二分答案 x 。设区间权值和的前缀和为 p_i ，则我们明显需要 i\\in[a, b] 中的最小的 p_{i - 1} 和 i\\in[c, d] 中的最大的 p_{i} 。这个东西显然可以使用线段树维护。 但是 x 有很多个？怎么办？注意到 x 从小到大改变的时候一定是将一些 -1 改为 +1 ，相当于我们就只是修改了一些后缀，可以直接区间加来做。然后这个东西就可以用可持久化来节省空间了。 Implementation 区间加的主席树空间复杂度是 O(n\\log^2n) 的，实测开 300 倍空间可过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO { const int maxc = 1 &lt;&lt; 21; char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf; il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;} template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n; } char obuf[maxc], *__pO = obuf; il void putchar(char c) {*__pO++ = c;} template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return; } void output() {fwrite(obuf, __pO - obuf, 1, stdout);}}using namespace fastIO;const int maxn = 20005;int n, a[maxn], aa[maxn], tota;std::vector&lt;int&gt; pos[maxn];//每个数出现的位置集合struct node { int maxv, minv, tag, ls, rs; node() { maxv = -1e9, minv = 1e9; tag = ls = rs = 0; }} t[maxn * 300];int root[maxn], cnt;int clone(int k) { t[++cnt] = t[k]; return cnt;}#define ls(k) t[k].ls#define rs(k) t[k].rs#define M ((i + j) &gt;&gt; 1)il int max(int a, int b) {return a &gt; b ? a : b;}il int min(int a, int b) {return a &lt; b ? a : b;}void pushup(int k) { t[k].minv = min(t[ls(k)].minv, t[rs(k)].minv); t[k].maxv = max(t[ls(k)].maxv, t[rs(k)].maxv); return;}void build(int i, int j, int &amp;k) { if (!k) k = ++cnt; if (j &lt;= i) { t[k].maxv = t[k].minv = i; return; } build(i, M, ls(k)); build(M + 1, j, rs(k)); pushup(k); return;}il void add(int k, int val) { t[k].tag += val; t[k].maxv += val; t[k].minv += val; return;}il void pushdown(int k) { if (t[k].tag) { if (ls(k)) ls(k) = clone(ls(k)), add(ls(k), t[k].tag); if (rs(k)) rs(k) = clone(rs(k)), add(rs(k), t[k].tag); t[k].tag = 0; } return;}int modify(int k, int i, int j, int x, int y, int val) { k = clone(k); if (x &lt;= i &amp;&amp; y &gt;= j) { add(k, val); return k; } pushdown(k); if (x &lt;= M) ls(k) = modify(ls(k), i, M, x, y, val); if (y &gt; M) rs(k) = modify(rs(k), M + 1, j, x, y, val); pushup(k); return k;}int query(int i, int j, int k, int x, int y, int op) { if (x &gt; y) return op ? -1e9 : 1e9; if (x &lt;= i &amp;&amp; y &gt;= j) return op ? t[k].maxv : t[k].minv; pushdown(k); int ret = op ? -1e9 : 1e9; if (x &lt;= M) ret = op ? max(ret, query(i, M, ls(k), x, y, op)) : min(ret, query(i, M, ls(k), x, y, op)); if (y &gt; M) ret = op ? max(ret, query(M + 1, j, rs(k), x, y, op)) : min(ret, query(M + 1, j, rs(k), x, y, op)); return ret;}int main() { read(n); FOR(i, 1, n) read(a[i]), aa[i] = a[i]; std::sort(aa + 1, aa + n + 1); tota = n; FOR(i, 1, n) a[i] = std::lower_bound(aa + 1, aa + tota + 1, a[i]) - aa, pos[a[i]].push_back(i); build(1, n, root[1]); FOR(val, 2, tota) { root[val] = clone(root[val - 1]); for (auto p : pos[val - 1]) { root[val] = modify(root[val], 1, n, p, n, -2); } } int q; read(q); int last = 0; while (q--) { int p[4]; read(p[0]), read(p[1]), read(p[2]), read(p[3]); FOR(i, 0, 3) p[i] = (p[i] + last) % n + 1; std::sort(p, p + 4); int ans = 1, l = 1, r = tota; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; int tmp1, tmp2; int tmp = (tmp1 = query(1, n, root[mid], p[2], p[3], 1)) - (tmp2 = min(query(1, n, root[mid], max(p[0] - 1, 1), max(p[1] - 1, 1), 0), p[0] - 1 == 0 ? 0 : 1e9)); if (tmp &gt;= 0) ans = mid, l = mid + 1; else r = mid - 1; } print(last = aa[ans]), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"主席树","slug":"persistent-segtree","permalink":"https://old.blog.imyangty.com/tags/persistent-segtree/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P3302 [SDOI2013]森林","slug":"sol-luogu-p3302","date":"2021-08-03T12:52:07.000Z","updated":"2022-03-23T04:18:30.944Z","comments":true,"path":"sol-luogu-p3302/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3302/","excerpt":"","text":"Description 维护一片森林，支持下面操作，强制在线： 问 u 到 v 上的第 k 小点权。 将 u 和 v 联通 保证操作合法。 n\\le 8\\times 10^4 。 Solution 看到连边操作想到 LCT，但是 LCT 似乎不是很好处理 k 小点权。 静态 k 小点权考虑主席树，建议先看 P2633 Count on a tree。 然后学会了那个题的做法（ u 点上维护从根到 u 的链的信息主席树，树上差分）之后就可以来考虑下这题。 不妨直接使用最暴力的做法，连接两棵树的时候将小树接到大树上面然后暴力重构小树中维护的主席树。可以发现这样子做的时空复杂度均为 O(n\\log^2n) 。 Implement 主席树数组一定要开够，否则 RE。 LCA 的求法最好使用倍增，比较方便（树的形态改变了），但是倍增里面最好不要涉及到点的深度，因为深度随着连边是会改变的。 1234567891011int getLCA(int u, int v) { if (u == v) return u; if (dep[u] &gt; dep[v]) std::swap(u, v); DEC(k, 17, 0) if (dep[fa[v][k]] &gt;= dep[u]) v = fa[v][k]; if (u == v) return u; DEC(k, 17, 0) if (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k]; return fa[u][0];} 这样写是没问题的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])namespace fastIO {}using namespace fastIO;const int maxn = 8e4 + 5;int n, m, q, tota;int a[maxn], aa[maxn];int bel[maxn], size[maxn], fa[maxn][18], dep[maxn];int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;void addEdge(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}il int find(int u) {return u == bel[u] ? u : bel[u] = find(bel[u]);}struct node { int sum, ls, rs; node() {sum = ls = rs = 0;}} t[maxn * 500];int root[maxn], cnt;#define ls(k) t[k].ls#define rs(k) t[k].rs#define M ((i + j) &gt;&gt; 1)int clone(int k) { t[++cnt] = t[k]; return cnt;}int insert(int k, int i, int j, int x) { k = clone(k); ++t[k].sum; //printf(\"k %d [%d, %d] = %d\\n\", k, i, j, t[k].sum); if (i == j) return k; if (x &lt;= M) ls(k) = insert(ls(k), i, M, x); else rs(k) = insert(rs(k), M + 1, j, x); return k;}void dfs(int u, int f, int rt) { bel[u] = rt; fa[u][0] = f; ++size[rt], dep[u] = dep[f] + 1; FOR(j, 1, 17) fa[u][j] = fa[fa[u][j - 1]][j - 1]; //printf(\"rt %d, now %d\\n\", rt, u); root[u] = insert(root[f], 1, tota, a[u]); GO(u) { if (v == f) continue; dfs(v, u, rt); } return;}int getLCA(int u, int v) { if (u == v) return u; if (dep[u] &gt; dep[v]) std::swap(u, v); DEC(k, 17, 0) if (dep[fa[v][k]] &gt;= dep[u]) v = fa[v][k]; if (u == v) return u; DEC(k, 17, 0) if (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k]; return fa[u][0];}int query(int k, int u1, int u2, int k1, int k2, int i, int j) { if (i == j) return aa[i]; int sum = t[ls(u1)].sum + t[ls(u2)].sum - t[ls(k1)].sum - t[ls(k2)].sum; if (sum &lt; k) return query(k - sum, rs(u1), rs(u2), rs(k1), rs(k2), M + 1, j); else return query(k, ls(u1), ls(u2), ls(k1), ls(k2), i, M);}int main() { read(n); read(n), read(m), read(q); FOR(i, 1, n) read(a[i]), aa[i] = a[i]; std::sort(aa + 1, aa + n + 1); tota = std::unique(aa + 1, aa + n + 1) - aa - 1; FOR(i, 1, n) a[i] = std::lower_bound(aa + 1, aa + n + 1, a[i]) - aa; FOR(i, 1, m) { int u, v; read(u), read(v); addEdge(u, v), addEdge(v, u); } FOR(i, 1, n) if (!bel[i]) dfs(i, 0, i); int last = 0; while (q--) { char c; readC(c); int u, v; read(u), read(v), u ^= last, v ^= last; if (c == 'Q') { int k; read(k), k ^= last; int lca = getLCA(u, v); print(last = query(k, root[u], root[v], root[lca], root[fa[lca][0]], 1, tota)), putchar('\\n'); } else { addEdge(u, v), addEdge(v, u); int ru = find(u), rv = find(v); if (size[ru] &lt; size[rv]) std::swap(ru, rv), std::swap(u, v); dfs(v, u, ru); } } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"主席树","slug":"persistent-segtree","permalink":"https://old.blog.imyangty.com/tags/persistent-segtree/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P7429 [THUPC2017] 气氛","slug":"sol-luogu-p7429","date":"2021-08-02T12:25:56.000Z","updated":"2022-03-23T04:18:31.050Z","comments":true,"path":"sol-luogu-p7429/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p7429/","excerpt":"","text":"Description t 组数据（ 1\\le t\\le 100 ），问 n - 1 维空间中的 n + 1 个点构成的凸包的广义体积。点的坐标一定是 0 或 1 。 Solution 首先，这 n + 1 个点肯定是参与构成了整个凸包的，因为点的坐标一定为 0 或 1 。 而我们想想 n -1 维空间中 n 个点构成的凸包的体积，无非就是用这 n 个点张成 n - 1 个向量，然后求出行列式的值除以 n 的阶乘取绝对值，证明可以随便搜一下或者直接当结论记住。也可以手推一下 2 维和 3 维空间的情况发现其是对的。 可是我们这题的点有 n + 1 个，没办法直接用行列式做，怎么办呢？ 不妨从二维的情况考虑起。 考虑求四边形 ABCD 的体积，不难发现我们可以依次求 \\triangle ABC ， \\triangle BCD ， \\triangle ABD 和 \\triangle ACD 的面积，在图上已经显示出来。然后会发现这样刚好将每个区域覆盖了两次。 考虑三维的情况。 然后考虑 \\binom 5 4 = 5 个四面体，发现他们的体积加起来也就是整个凸包的体积的两倍。 所以我们可以大胆猜想， n - 1 维空间中 n + 1 个点构成的凸包的体积等于所有选 n 个点构成的凸包体积之和的一半。 事实上这也是正确的，我太屑了不会证明。 于是这道题就做完了。具体地，每次选择一个不出现的点，然后随便取一个点为起点算出 n - 1 个向量，然后高斯消元计算出这 n - 1 个向量组成的 n - 1 维行列式（消成对角阵之后直接将对角线元素相乘），把这些行列式的值加起来。得到的结果除以二输出即可。 Implement 实现的时候需要注意： 题目要求我们乘上 (n - 1)! 后输出，所以我们不用除以 (n - 1)! 了。 由于我们需要行列式的值的绝对值，所以不能进行模意义下的高斯消元，需要使用 double 进行高斯消元。 消元完后得到的行列式的值需要四舍五入成 long long（可能爆 int）然后计入答案。 最后乘上 2 的逆元 5\\times10^8 + 4 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {}using namespace fastIO;const int maxn = 40, mod = 1e9 + 7, inv2 = 5e8 + 4;struct Point {//存储点/向量 int dim; int x[maxn];} p[maxn];Point operator-(const Point &amp;a, const Point &amp;b) { Point ret; ret.dim = a.dim; FOR(i, 1, ret.dim) ret.x[i] = a.x[i] - b.x[i]; return ret;}typedef double db;db mat[maxn][maxn];int n;double det(int n, db a[40][40]) {//Gauss-Jornan 消元计算行列式 FOR(i, 1, n) { int r = i; FOR(j, i + 1, n) if (fabs(a[j][i]) &gt; fabs(a[r][i])) r = j; std::swap(a[r], a[i]); FOR(k, 1, n) { if (k == i) continue; db div = a[k][i] / a[i][i]; FOR(j, i + 1, n) a[k][j] -= div * a[i][j]; } } db ret = 1; FOR(i, 1, n) ret *= a[i][i]; return ret;}int main() { int t; read(t); while (t--) { read(n); FOR(i, 1, n + 1) { p[i].dim = n - 1; FOR(j, 1, n - 1) read(p[i].x[j]); } int ans = 0; FOR(ban, 1, n + 1) { int st = (ban == 1) ? 2 : 1; for (int j = 1, col = 1; j &lt;= n + 1 &amp;&amp; col &lt;= n - 1; ++j, ++col) { while (j == st || j == ban) ++j; Point tmp = p[j] - p[st]; FOR(r, 1, n - 1) mat[r][col] = tmp.x[r]; } ans = (ans + (long long)fabs(round(det(n - 1, mat)))) % mod; } print(1ll * ans * inv2 % mod), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"计算几何","slug":"computational-geometry","permalink":"https://old.blog.imyangty.com/tags/computational-geometry/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"行列式","slug":"det","permalink":"https://old.blog.imyangty.com/tags/det/"}]},{"title":"P3301 [SDOI2013]方程","slug":"sol-luogu-p3301","date":"2021-08-01T16:00:57.000Z","updated":"2022-03-23T04:18:30.942Z","comments":true,"path":"sol-luogu-p3301/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3301/","excerpt":"","text":"Description 给定不定方程 x_1 + x_2 + \\cdots + x_n = m 对于 i\\in[1, n_1] ，有如下限制： x_i\\le A_i 对于 i\\in (n_1,n_2] ，有如下限制： x_i\\ge A_i 求该方程正整数解的组数。答案对 p 取模， p\\in\\{10007,262203414,437367875\\} 。 Solution 首先考虑不定方程 \\sum_{i =1}^nx_i = m 的正整数解个数，显然其为插板法： \\binom{m - 1}{n - 1} 然后我们考虑 x_i\\ge A_i 的限制，显然，我们把 m 减去 \\sum_{i = n_1 + 1}^{n_2}(A_i - 1) ，然后就把问题转化为了直接插板。 然后考虑到 x_i\\le A_i 的限制不好处理，既然限制数最大为 8 ，不如考虑容斥，将其转化为 x_i\\ge A_i + 1 的形式来处理。 这样子每次计算的答案为 \\binom{m' - 1}{n - 1}\\bmod p 然后这一坨式子是可以使用扩展 Lucas 来算的（因为 p 不为质数）。 Implementation 分解一下三个模数： 262203414 = 2\\times 3\\times 11\\times397\\times10007 437367875 = 5^3\\times7^3\\times101^2 10007 是质数 这样子可以省去扩展卢卡斯分析 q^k 的过程，大大减少常数。 同时优化一下扩展卢卡斯处理阶乘的过程，提前计算好，这样也可以大力卡常。不然根本卡不过去。 一定要注意传进去计算 \\dbinom n m 的时候 n &lt; m 的情况是存在的，一定要特判掉。 细节较多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cassert&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {}using namespace fastIO;int T, p;int n, n1, n2, m;int a[17];int qPow(int a, int b, int p) { int ret = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if (b &amp; 1) ret = 1ll * ret * a % p; return ret;}namespace p10007 { using namespace std; const int mod = 10007; int fac[10050], invfac[10050]; void init() { fac[0] = 1; FOR(i, 1, mod - 1) fac[i] = 1ll * fac[i - 1] * i % mod; invfac[mod - 1] = qPow(fac[mod - 1], mod - 2, mod); DEC(i, mod - 2, 0) invfac[i] = 1ll * invfac[i + 1] * (i + 1) % mod; return; } il int C(int n, int m, int p) { if (n &lt; m) return 0; if (!m) return 1; return 1ll * fac[n] * invfac[m] % mod * invfac[n - m] % mod; } int lucas(int n, int m, int p) { if (!m) return 1; return 1ll * lucas(n / p, m / p, p) * C(n % p, m % p, p) % p; }}void exgcd(int a, int b, int &amp;x, int &amp;y) { if (!b) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; return;}il int inv(int n, int p) { int x, y; exgcd(n, p, x, y); return (x + p) % p;}int q1[] = {0, 2, 3, 11, 397, 10007}, q2[] = {0, 5, 7, 101}, q[10];int qk1[] = {0, 2, 3, 11, 397, 10007}, qk2[] = {0, 125, 343, 10201}, qk[10], d;int retfac[10];int calc(int n, int i) { if (!n) return 1; int ret = retfac[i]; ret = qPow(ret, n / qk[i], qk[i]); FOR(j, n / qk[i] * qk[i] + 1, n) if (j % q[i]) ret = 1ll * ret * (j % qk[i]) % qk[i]; return 1ll * ret * calc(n / q[i], i) % qk[i];}int multiLucas(int n, int m, int i) { if (n &lt; m) return 0; int cnt = 0; for (int j = n; j; j /= q[i]) cnt += j / q[i]; for (int j = m; j; j /= q[i]) cnt -= j / q[i]; for (int j = n - m; j; j /= q[i]) cnt -= j / q[i]; return 1ll * qPow(q[i], cnt, qk[i]) * calc(n, i) % qk[i] * inv(calc(m, i), qk[i]) % qk[i] * inv(calc(n - m, i), qk[i]) % qk[i];}int CRT(int n, int *a, int *m, int mod) { int M = 1, ret = 0; FOR(i, 1, n) M *= m[i]; FOR(i, 1, n) { int w = M / m[i]; ret = (ret + 1ll * a[i] * w % mod * inv(w, m[i]) % mod) % mod; } return (ret + mod) % mod;}int exLucas(int n, int m, int p) { if (n &lt; m) return 0; if (p == 10007) return p10007::lucas(n, m, p); int a[10]; FOR(i, 1, d) a[i] = multiLucas(n, m, i); return CRT(d, a, qk, p);}void init() { if (p == 262203414) { d = 5; FOR(i, 1, d) qk[i] = qk1[i], q[i] = q1[i]; } else { d = 3; FOR(i, 1, d) qk[i] = qk2[i], q[i] = q2[i]; } FOR(i, 1, d) { retfac[i] = 1; FOR(j, 1, qk[i]) if (j % q[i]) retfac[i] = 1ll * retfac[i] * j % qk[i]; } return;}int main() { read(T), read(p); p10007::init(); init(); while (T--) { read(n), read(n1), read(n2), read(m); FOR(i, 1, n1 + n2) read(a[i]); FOR(i, n1 + 1, n1 + n2) m -= a[i] - 1; int ans = 0; FOR(S, 0, (1 &lt;&lt; n1) - 1) { int popcnt = 0, nowm = m; FOR(i, 1, n1) if ((1 &lt;&lt; (i - 1)) &amp; S) nowm -= a[i], ++popcnt; int tmp = exLucas(nowm - 1, n - 1, p); ans = (ans + ((popcnt &amp; 1) ? (p - tmp + p) % p : tmp)) % p; } print(ans), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Lucas定理","slug":"lucas","permalink":"https://old.blog.imyangty.com/tags/lucas/"},{"name":"容斥原理","slug":"inclusion-exclusion-principle","permalink":"https://old.blog.imyangty.com/tags/inclusion-exclusion-principle/"},{"name":"中国剩余定理","slug":"crt","permalink":"https://old.blog.imyangty.com/tags/crt/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P3232 [HNOI2013]游走","slug":"sol-luogu-p3232","date":"2021-07-31T11:12:38.000Z","updated":"2022-03-23T04:18:30.936Z","comments":true,"path":"sol-luogu-p3232/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3232/","excerpt":"","text":"Description 无向连通图， n 点 m 边， 2\\le n\\le 500 ， 1\\le m\\le 125000 。 从 1 号点开始随机游走，每一步等概率选一条出边，代价为边的编号。游走到 n 时结束。求最小期望代价。 Solution 首先，明显是求出每条边的期望经过次数然后贪心排序计算贡献。但是每条边的期望经过次数貌似不是很好弄，所以考虑求出每个点的期望经过次数。设为 f_i ，则有： f_u = \\begin{cases} 1 + \\displaystyle\\sum_{(u,v)\\in E\\land v\\not=n}\\frac{f_v}{\\mathrm{deg}_v}&amp;u = 1\\\\ \\displaystyle\\sum_{(u,v)\\in E\\land v\\not=n}\\frac{f_v}{\\mathrm{deg}_v}&amp;\\mathrm{else} \\end{cases} 这个东西可以使用高斯消元列出方程式来求解。 解出来了之后考虑一条边 e_i = (u, v) 的期望次数。不难发现其即为 g_i = \\frac{f_u}{\\mathrm{deg}_u} + \\frac{f_v}{\\mathrm{deg}_v} 所以求出来之后排序，贪心计算答案即可。 Implementation 注意我们需要解的是 f_1,\\cdots,f_{n - 1} ，所以列的方程组只有 n - 1 个元。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO { const int maxc = 1 &lt;&lt; 21; char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf; il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;} template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n; }}using namespace fastIO;typedef double db;const int maxn = 505, maxm = 125005;db a[maxn][maxn], f[maxn];int n, m, deg[maxn];struct edge { int u, v; double g; il bool operator&lt;(const edge &amp;b) const {return g &gt; b.g;}} e[maxm];std::vector&lt;int&gt; G[maxn];il void addEdge(int u, int v) { G[u].push_back(v); G[v].push_back(u); return;}void gauss() { FOR(i, 1, n - 1) { int r = i; FOR(j, i + 1, n - 1) if (fabs(a[j][i]) &gt; fabs(a[r][i])) r = j; std::swap(a[i], a[r]); FOR(k, 1, n - 1) { if (k == i) continue; db div = a[k][i] / a[i][i]; FOR(j, i + 1, n) a[k][j] -= div * a[i][j]; } } FOR(i, 1, n - 1) f[i] = a[i][n] / a[i][i]; return;}int main() { read(n), read(m); FOR(i, 1, m) read(e[i].u), read(e[i].v), ++deg[e[i].u], ++deg[e[i].v], addEdge(e[i].u, e[i].v); FOR(u, 1, n - 1) { a[u][u] = -1; if (u == 1) a[u][n] = -1; for (auto v : G[u]) if (v != n) a[u][v] = 1.00 / deg[v]; } gauss(); FOR(i, 1, m) e[i].g = f[e[i].u] / deg[e[i].u] + f[e[i].v] / deg[e[i].v]; std::sort(e + 1, e + m + 1); db ans = 0; FOR(i, 1, m) ans += i * e[i].g; printf(\"%.3lf\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"高斯消元","slug":"gauss-elimination","permalink":"https://old.blog.imyangty.com/tags/gauss-elimination/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P6076 [JSOI2015]染色问题","slug":"sol-luogu-p6076","date":"2021-07-31T07:47:12.000Z","updated":"2022-03-23T04:18:31.038Z","comments":true,"path":"sol-luogu-p6076/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p6076/","excerpt":"","text":"Description 萌萌家有一个棋盘，这个棋盘是一个 n \\times m 的矩形，分成 n 行 m 列共 n \\times m 个小方格。 现在萌萌和南南有 C 种不同颜色的颜料，他们希望把棋盘用这些颜料染色，并满足以下规定： 棋盘的每一个小方格既可以染色（染成 C 种颜色中的一种），也可以不染色。 棋盘的每一行至少有一个小方格被染色。 棋盘的每一列至少有一个小方格被染色。 每种颜色都在棋盘上出现至少一次。 求染色方案总数模 10^9 + 7 的值 Solution 考虑容斥：枚举 i 行 j 列没有染色，有 k 种颜色没有染。那么答案就是 (C + 1)^{nm} - \\sum_{i = 1}^n\\sum_{j = 1}^m\\sum_{k = 1}^C (C - k + 1)^{(n - i)(m - j)}\\binom n i\\binom m j\\binom c k(-1)^{i + j + k} 直接算这个答案就可以了。复杂度 O(nmc) 。 Implementation 快速幂太慢了，考虑先枚举 k ，然后预处理出所有的 (c - k + 1) 的幂。 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)typedef long long ll;const ll mod = 1e9 + 7;const int maxn = 405;ll n, m, c, binom[maxn][maxn], pow[maxn * maxn];int main() { scanf(\"%lld %lld %lld\", &amp;n, &amp;m, &amp;c); binom[1][0] = binom[1][1] = 1; FOR(i, 1, 400) { binom[i][0] = 1, binom[i][i] = 1; FOR(j, 1, i - 1) binom[i][j] = (binom[i - 1][j - 1] + binom[i - 1][j]) % mod; } ll ans = 0; FOR(k, 0, c) { pow[0] = 1; FOR(i, 1, n * m) pow[i] = pow[i - 1] * (c - k + 1) % mod; FOR(i, 0, n) FOR(j, 0, m) ans = (ans + (((i + j + k) &amp; 1) ? mod - 1 : 1) * binom[n][i] % mod * binom[m][j] % mod * binom[c][k] % mod * pow[(n - i) * (m - j)]) % mod; } printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"容斥原理","slug":"inclusion-exclusion-principle","permalink":"https://old.blog.imyangty.com/tags/inclusion-exclusion-principle/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"BZOJ 3601. 一个人的数论","slug":"sol-bzoj3601","date":"2021-07-30T10:23:21.000Z","updated":"2022-03-23T04:18:30.655Z","comments":true,"path":"sol-bzoj3601/","link":"","permalink":"https://old.blog.imyangty.com/sol-bzoj3601/","excerpt":"","text":"Description 定义 f_m(n) 为所有小于 n 且与 n 互素的正整数的 m 次方之和。给定 m 的值和 n 的质因数分解式，求 f_m(n)\\bmod 10^9 + 7 的值。 若 n = \\prod_{i = 1}^{w}p_i^{\\alpha_i} 有 1\\le w \\le 1000 ， 2\\le p_i\\le 10^9 ， 1\\le \\alpha_i\\le 10^9 ， 0\\le m \\le 100 。 Solution Part. 1 首先明确一下求的东西是什么： \\sum_{i = 1}^{n - 1}i^m[\\gcd(i, n) = 1] 然后发现貌似把上界改成 n 也不会有事，反正 n &gt; 1 。 然后就可以从 [\\gcd(i, n) = 1] 入手开始化简式子了。 \\begin{aligned} &amp;\\sum_{i = 1}^ni^m\\sum_{d\\mid i, n}\\mu(d)\\\\ =&amp;\\sum_{d \\mid n}\\mu(d)\\sum_{i = 1}^{\\frac nd}(id)^m\\\\ =&amp;\\sum_{d \\mid n}\\mu(d)d^m\\sum_{i = 1}^{\\frac nd}i^m\\\\ \\end{aligned} 第一行是反演变换将 [(i, n) = 1] 换掉。 第二行是更换枚举顺序，令 i = i'd ，则我们枚举 i' 即可。 第三行就是把能提出来的给提出来。 Part. 2 观察到式子里面有一项形如 f(n) = \\sum_{i = 1}^ni^m 的东西，根据经验可得 f(n) 为关于 n 的 m + 1 次多项式。令这个多项式为 \\sum_{i = 0}^{m + 1}f_in^i 。这些系数是可以直接暴力高斯消元求出来的，再回过头看看我们的式子： \\begin{aligned} &amp;\\sum_{d \\mid n}\\mu(d)d^m\\sum_{i = 1}^{\\frac nd}i^m\\\\ =&amp;\\sum_{d \\mid n}\\mu(d)d^m\\sum_{i = 0}^{m + 1}f_i\\left(\\frac nd\\right)^i\\\\ =&amp;\\sum_{i = 0}^{m + 1}f_i\\sum_{d \\mid n}\\mu(d)d^m\\left(\\frac nd\\right)^i \\end{aligned} 后面的那个东西是积性函数的卷积，所以他们本身也满足积性，可以把所有的 p_i^{\\alpha_i} 的函数值算出来之后乘在一起得到结果。问题就是怎么快速求这个长得怪怪的东西。 Part. 3 注意到我们要求的是形如 p_i^{\\alpha_i} 这样的东西的函数值。那么当 \\alpha_i\\ge 2 的时候是肯定会出现平方因子的，这部分 d 是不用计算的因为 \\mu(d) = 0 。所以实际上要算的就只有 d = 1 和 d = p_i 的情况。即我们需要算 p_i^{\\alpha_ii} - p_i^mp_i^{\\alpha_ii-i} 。 算法就是枚举 i ，然后对每个质因子算一遍那个积性函数的值然后乘起来，再乘上 f_i 累加进答案中。 所以，总的时间复杂度就是 O(m^3 + m(m + w)) 。 Implementation 首先是初始化矩阵的时候，千万注意是否有非法访问，否则 WA 70。 其次是注意该开 long long 的地方一定不能漏掉，否则 WA 50。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO { const int maxc = 1 &lt;&lt; 21; char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf; il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;} template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n; }}using namespace fastIO;typedef long long ll;const int mod = 1e9 + 7;ll qPow(ll a, ll b, ll p = mod) { if (b &lt; 0) b += mod - 1; ll ret = 1; for (; b; b &gt;&gt;= 1, a = 1ll * a * a % p) if (b &amp; 1) ret = 1ll * ret * a % mod; return ret;}il int inv(int a, int m = mod) {return qPow(a, m - 2, m);}const int maxw = 1005;int m, w;ll p[maxw], a[maxw];ll mat[105][105], f[105], sum[105];void initMat() { FOR(i, 1, m + 2) { sum[i] = (qPow(i, m) + sum[i - 1]) % mod; mat[i - 1][0] = 1, mat[i - 1][m + 2] = sum[i]; FOR(j, 1, m + 1) mat[i - 1][j] = mat[i - 1][j - 1] * i % mod; } return;}//行：[0, m + 1]，列：[0, m + 2]void gauss() { FOR(i, 0, m + 1) { int r = i; FOR(j, i + 1, m + 1) if (mat[j][i] &gt; mat[r][i]) r = j; std::swap(mat[r], mat[i]); ll div = inv(mat[i][i]); FOR(j, i, m + 2) mat[i][j] = mat[i][j] * div % mod; FOR(j, i + 1, m + 1) { div = mat[j][i]; FOR(k, i, m + 2) mat[j][k] = ((mat[j][k] - mat[i][k] * div % mod) % mod + mod) % mod; } } f[m + 1] = mat[m + 1][m + 2]; DEC(i, m, 0) { f[i] = mat[i][m + 2]; FOR(j, i + 1, m + 1) f[i] = ((f[i] - mat[i][j] * f[j] % mod) % mod + mod) % mod; } return;}int main() { read(m), read(w); FOR(i, 1, w) read(p[i]), read(a[i]); initMat(); gauss(); ll ans = 0; FOR(i, 0, m + 1) { ll tmp = 1; FOR(j, 1, w) tmp = qPow(p[j], a[j] * i % (mod - 1)) * (1ll - qPow(p[j], m - i) + mod) % mod * tmp % mod; ans = (ans + tmp * f[i] % mod) % mod; } printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://old.blog.imyangty.com/tags/BZOJ/"},{"name":"莫比乌斯反演","slug":"mobius-inversion","permalink":"https://old.blog.imyangty.com/tags/mobius-inversion/"},{"name":"高斯消元","slug":"gauss-elimination","permalink":"https://old.blog.imyangty.com/tags/gauss-elimination/"}]},{"title":"HDU4944 FSF’s game","slug":"sol-hdu4944","date":"2021-07-30T08:01:42.000Z","updated":"2022-03-23T04:18:30.764Z","comments":true,"path":"sol-hdu4944/","link":"","permalink":"https://old.blog.imyangty.com/sol-hdu4944/","excerpt":"","text":"Description T 组（ T \\le 5\\times 10^5 ）询问，每次给定 n\\le 5\\times 10^5 ，求： \\sum_{i = 1}^n\\sum_{j = i}^n\\sum_{d\\mid i, j}\\frac{ij}{\\gcd(\\frac id, \\frac jd)}\\bmod 2^{32} Solution Part. 1 直接大力推式子： \\begin{aligned} \\sum_{i = 1}^n\\sum_{j = i}^n\\sum_{d\\mid i, j}\\frac{ij}{\\gcd(\\frac id, \\frac jd)} &amp;= \\sum_{i = 1}^n\\sum_{j = i}^n\\sum_{d\\mid \\gcd(i, j)}\\frac{ij}{\\gcd(\\frac id, \\frac jd)}\\\\ &amp;= \\sum_{i = 1}^n\\sum_{j = i}^n\\sum_{d\\mid \\gcd(i, j)}\\frac{ijd}{\\gcd(i, j)}\\\\ &amp;= \\sum_{i = 1}^n\\sum_{j = i}^n\\sum_{d\\mid \\gcd(i, j)}d\\operatorname{lcm}(i, j)\\\\ &amp;= \\sum_{d = 1}^n\\sum_{i = 1}^{\\left\\lfloor\\frac nd\\right\\rfloor}\\sum_{j = i}^{\\left\\lfloor\\frac nd\\right\\rfloor}d\\operatorname{lcm}(id, jd)\\\\ &amp;= \\sum_{d = 1}^nd^2\\sum_{i = 1}^{\\left\\lfloor\\frac nd\\right\\rfloor}\\sum_{j = i}^{\\left\\lfloor\\frac nd\\right\\rfloor}\\operatorname{lcm}(i, j)\\\\ \\end{aligned} 令 f(n) = \\sum_{i = 1}^n\\sum_{j = i}^n\\operatorname{lcm}(i, j) 则我们要求的东西就变为了 \\sum_{d = 1}^nd^2f\\left(\\left\\lfloor\\frac nd\\right\\rfloor\\right) Part. 2 现在考虑如何求 f(n) 。 首先，求 \\sum_{i =1}^n\\operatorname{lcm}(i, n) 是可以解决的，见 SPOJ5971 LCMSUM - LCM Sum。然后对其做前缀和，可以得到 \\sum_{i = 1}^n\\sum_{j = 1}^i\\operatorname{lcm}(i, j) ，这个东西和 f(n) 是相等的。至于为什么：这个东西是对于 \\forall i\\in [1, n] ， j\\le i 的 (i, j) 计入贡献，而 f(n) 是对于 \\forall i \\in[1, n] ， j\\ge i 的 (i, j) 计入贡献，两者是对称的。 所以 f(n) 就可以在 O(n) 的时间内预处理出来了。 Part. 3 如果直接使用整除分块，那么复杂度将为 O(n\\log n + T\\sqrt n) ，在 10^5 的数据范围下是过不去的。 那么我们只能考虑枚举 d ，设 \\left\\lfloor\\frac nd\\right\\rfloor = i 那么当前这个 d 产生贡献的区间为 [id, (i + 1)d - 1] ，贡献为 d^2f(i) 。所以考虑对于每个合法的 i 都给对应的 n 的区间打上标记然后使用前缀和优化。这样的复杂度就为 O(n\\log n + T) 了。 Implementation 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define int unsigned#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO { const int maxc = 1 &lt;&lt; 21; char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf; il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;} template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n; }}using namespace fastIO;typedef long long ll;const int maxn = 5e5 + 5;int flg[maxn], p[maxn], cntp;ll f[maxn], ans[maxn];void init() { f[1] = 1; FOR(i, 2, maxn - 3) { if (!flg[i]) p[++cntp] = i, f[i] = 1ll * (i - 1) * i + 1; for (int j = 1; j &lt;= cntp &amp;&amp; i * p[j] &lt;= maxn - 3; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { f[i * p[j]] = f[i] + (f[i] - f[i / p[j]]) * p[j] * p[j]; break; } f[i * p[j]] = f[i] * f[p[j]]; } } FOR(i, 1, maxn - 3) f[i] = ((f[i] + 1) * i) / 2, f[i] += f[i - 1]; for (ll d = 1; d &lt;= maxn - 3; ++d) for (ll i = 1; i * d &lt;= maxn - 3; ++i) { ans[d * i] += d * d * f[i]; if (d * (i + 1) &lt;= maxn - 3) ans[d * (i + 1)] -= d * d * f[i]; } FOR(i, 1, maxn - 3) ans[i] += ans[i - 1]; return;}signed main() { int T; read(T); init(); FOR(kase, 1, T) { int n; read(n); printf(\"Case #%u: %u\\n\", kase, (unsigned)ans[n]); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"莫比乌斯反演","slug":"mobius-inversion","permalink":"https://old.blog.imyangty.com/tags/mobius-inversion/"},{"name":"HDU","slug":"HDU","permalink":"https://old.blog.imyangty.com/tags/HDU/"}]},{"title":"CF1238E Keyboard Purchase","slug":"sol-cf1238e","date":"2021-07-28T11:08:02.000Z","updated":"2022-03-23T04:18:30.679Z","comments":true,"path":"sol-cf1238e/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1238e/","excerpt":"","text":"题意 给定一个长度为 n 的小写字符串 S ，其只包含前 m 个字母。键盘是这 m 个字母的一种排列。 只用一只手指输入 S ，所以在键盘上会花代价将手指从一个字母移到另一个字母。代价定义为键盘上其的距离。 最小化代价和。 1\\le n\\le 10^5 ， 1\\le m\\le 20 。 思路 观察到 m 很小，可以对其进行状压。但是如果不提前将字母的贡献拆开，将会很难设计无后效性的状态。假设我们已经解决了这个问题，那么就可以很轻松的设 f_S 为选了 S 这些字母，强制 可以提前预处理出 a(x, y) 表示有多少次从 x 到 y ，可以 O(n) 。 然后考虑一对字母 (x, y) 产生的贡献：无非就算 a(x, y)\\times|p_x - p_y| ，其中 p_x 和 p_y 为 x 和 y 在键盘上的位置。现在的问题就算，我们不好去处理这个 p_x 和 p_y 。那么干脆就拆开式子：如果 x 在键盘上的位置更靠前，则 x 的贡献为 -a(x, y)\\times p_x ， y 的贡献为 a(x, y)\\times p_y ；反之亦然。 所以，一个字母 x 会产生的贡献就是 \\sum_{p_y &lt; p_x}a(y, x)\\times p_x -\\sum_{p_y &gt; p_x}a(x, y)\\times p_x 既然现在已经拆开了所有字母产生的贡献，那么不妨就直接做 O(m^2\\times2^m) 的 dp，其中状态 O(2^m) ，转移 O(m) ，计算贡献 O(m) 。转移时枚举下一个加什么字母就可以了。 总复杂度 O(n + 2^mm^2) 。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef long long ll;const int maxn = 1e5 + 5, maxm = 23;int n, m;ll a[maxm][maxm], f[1 &lt;&lt; maxm];char s[maxn];template&lt;typename T&gt; il void to_min(T &amp;a, T b) { b &lt; a ? a = b : 0; return;}int main() { scanf(\"%d %d\", &amp;n, &amp;m); scanf(\"%s\", s + 1); FOR(i, 1, n - 1) ++a[s[i] - 'a'][s[i + 1] - 'a'], ++a[s[i + 1] - 'a'][s[i] - 'a']; memset(f, 0x3f, sizeof f); f[0] = 0; FOR(S, 0, (1 &lt;&lt; m) - 1) { ll cnt = 0; FOR(j, 0, m - 1) cnt += (S &gt;&gt; j) &amp; 1; FOR(i, 0, m - 1) { if ((1 &lt;&lt; i) &amp; S) continue; ll sum = 0; FOR(j, 0, m - 1) { if (j == i) continue; if ((1 &lt;&lt; j) &amp; S) sum += cnt * a[j][i]; else sum -= cnt * a[i][j]; } to_min(f[S | (1 &lt;&lt; i)], f[S] + sum); } } printf(\"%lld\\n\", f[(1 &lt;&lt; m) - 1]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"决策单调性优化动态规划","slug":"note-mono-opti-dp","date":"2021-07-26T09:06:49.000Z","updated":"2022-03-23T04:17:42.193Z","comments":true,"path":"note-mono-opti-dp/","link":"","permalink":"https://old.blog.imyangty.com/note-mono-opti-dp/","excerpt":"","text":"[TOC] 决策单调性的定义 对于任意四个转移点 a &lt; b &lt; c &lt; d 。若以下条件满足： f_c 从 b 转移比从 a 转移优可以推出 f_d 从 b 转移比从 a 转移优，则说明满足决策单调性。 即：dp 的转移点是单调的。 四边形不等式在 2D/1D 动态规划中的应用 前言 在区间 dp 中，经常会遇到以下形式的状态转移方程： f(l, r) = \\min_{l\\le k &lt; r}\\left\\{f(l, k) + f(k + 1, r)\\right\\} + w(l, r) 直接暴力的做，复杂度为 O(n^3) ，但如果 w(l, r) 满足一些特殊性质时，可以考虑四边形不等式优化成 O(n^2) 。 基本概念 首先，令 w(l, r) 为定义在 \\mathbb Z 上的二元函数。 区间包含的单调性：若 \\forall a \\le b &lt; c \\le d ，有 w(b, c) \\le w(a, d) ，则 w 具有区间包含的单调性。（即里面不超过外面） 四边形不等式：若 \\forall a \\le b &lt; c\\le d ，有 w(a, c) + w(b, d)\\le w(b, c) + w(a, d) ，则 w 满足四边形不等式。（记忆方法：交叉小于包含） 四边形不等式定理 四边形不等式定理：若 w(i, j) 满足四边形不等式和单调性，则 dp 计算 f(i, j) 的复杂度是 O(n^2) 的。 为了证明这两个定理，有以下两个 Lemma： Lemma 1：若 w(i, j) 满足四边形不等式和单调性，则 f(i, j) 满足四边形不等式。 Lemma 2：记 s(i, j) 为 dp 的最优转移点，即 s(i, j) = \\arg\\min_{l\\le k &lt; r}\\{f(l, k) + f(k + 1, r)\\} 。则 s(i, j - 1) \\le s(i, j) \\le s(i + 1, j) 。 Lemma 2 直接用于 dp 优化。 定理证明 懒得证了，不会也不想看。 但是需要注意一下，如果题目中说的是 \\max ，则四边形不等式将变为反四边形不等式， 即 w(a,c) + w(b, d) \\ge w(b, c) + w(a, d) 而区间包含的单调也变为 w(b, c) \\ge w(a, d) 。 应用——石子合并 此时的 w(i, j) 即为 [i, j] 的石子数量。区间包含的单调性是显然的，而四边形不等式是刚好取到等号，所以最小化的一问可以使用四边形不等式进行优化。而最大化则不可以，但是稍加分析可得最大化的转移方程如下： f_2(i, j) = \\max(f_2(i + 1, j), f_2(i, j - 1)) + w(i, j) 。 代码如下： 1234567891011FOR(len, 2, n) { for (int i = 1, j = i + len - 1; j &lt;= n &lt;&lt; 1; ++i, ++j) { f2[i][j] = max(f2[i + 1][j], f2[i][j - 1]) + a[j] - a[i - 1]; f1[i][j] = 1 &lt;&lt; 30; FOR(k, s[i][j - 1], s[i + 1][j]) { if (f1[i][j] &gt; f1[i][k] + f1[k + 1][j] + a[j] - a[i - 1]) f1[i][j] = f1[i][k] + f1[k + 1][j] + a[j] - a[i - 1], s[i][j] = k; } }} 这样下来均摊的复杂度就是 O(n^2) 。 应用2——UVA10304 题意：给定 n 个节点，安排其成为一个二叉树使得 \\sum d_ia_i 最大。 直接设 f_{i, j} 为将 [i, j] 变为一棵二叉树的最小代价，则枚举根节点 k ，有很明显的区间 dp： f_{i, j} = \\min_{i\\le k\\le j} \\{f_{i, k - 1} + f_{k + 1, j} - e_k\\} + w(i, j) 其中 w(i, j) = \\sum_{k = i}^je_k 。 然后，区间和这个东西满足四边形不等式，所以可以记录最优转移点来优化转移。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 255;int n, f[maxn][maxn], a[maxn], sum[maxn], s[maxn][maxn];il int cost(int i, int j, int k) {return sum[j] - sum[i - 1] - a[k];}il bool to_min(int &amp;a, int b) {return b &lt; a ? (a = b, 1) : 0;}int main() { while (~scanf(\"%d\", &amp;n)) { FOR(i, 1, n) scanf(\"%d\", a + i), sum[i] = sum[i - 1] + a[i], s[i][i] = i; memset(f, 0x3f, sizeof f); FOR(i, 1, n) f[i + 1][i] = f[i][i - 1] = 0, f[i][i] = 0; FOR(len, 2, n) for (int i = 1, j = i + len - 1; j &lt;= n; ++i, ++j) for (int k = s[i][j - 1]; k &lt;= s[i + 1][j]; ++k) if (to_min(f[i][j], f[i][k - 1] + f[k + 1][j] + cost(i, j, k))) s[i][j] = k; printf(\"%d\\n\", f[1][n]); } return 0;} 四边形不等式在 1D/1D 动态规划中的应用 前言 考虑一类动态规划： f_i = \\min\\{f_j + w(i, j)\\} 朴素的做法是 O(n^2) 的，如果 w(i, j) 具有一些神奇的性质则可以优化为 O(n\\log n) 。 定理 若 w(i, j) 满足四边形不等式，则 f_i 的最优转移点 k 是单调的。 当然实际操作中一般使用打表暴力观察最优决策点找单调性。 证明 反证法：设 f_i 的最优转移点为 p_i ，假设有 y &lt; x 且 p_y &gt; p_x 。 根据最优决策： f_{p_x} + w(p_x, x) \\le f_{p_y} + w(p_y,x)\\\\ 我们知道的是： p_x &lt; p_y &lt; y &lt; x ，代一下四边形不等式： w(p_x, y) + w(p_y, x) \\le w(p_x, x) + w(p_y, y) 两式相加： f_{p_x} + w(p_x, y)\\le f_{p_y} + w(p_y, y) 说明 p_x 转移到 y 比从 p_y 到 y 更优，与假设矛盾，得证。 法1——二分队列/栈 P1912 [NOI2009] 诗人小G。 容易列出转移方程 f_i = \\min_{j &lt; i}\\{f_j + |s_i - s_j -1 - L|^p\\} 打表发现对于 x\\le y ，一定有 p_x\\le p_y ，即决策点单调，决策点是一段一段的形如下面这样： 121112222444446666666 而我们一开始如果只考虑 1 为决策点的话，是这样的： 121111111111111111111 加入 2 之后，是这样的： 121112222222222222222 加入 4 之后，是这样的： 121112222444444444444 所以考虑二分来维护一个决策点可以管理的区间。用单调队列来实现这个过程。 加入一个决策点的时候有三种情况： 旧决策完全不如新决策，即旧决策管的左端点从新决策转移来一定更优，此时弹队列右端； 旧决策吊打新决策，即旧决策管理的左端点比从新决策转移来优，此时不弹队列； 旧决策中等不如新决策，即旧决策管的左端点从旧决策转移更优，右端点则从新决策转移来更优，此时将旧决策进行拆分，然后插入新决策。 转移的时候考虑队头可不可以转移，如果可以转移则直接从队头转移，否则弹队头。 所以我们的 dp 过程应该是这样的：其中 k 表示该决策点能管到的区间右端点。 12345678FOR(i, 1, n) { while (head &lt; tail &amp;&amp; k[head] &lt;= i) ++head; f[i] = calc(q[head], i), pre[i] = q[head]; while (head &lt; tail &amp;&amp; k[tail - 1] &gt;= bound(q[tail], i)) --tail; k[tail] = bound(q[tail], i); q[++tail] = i;} bound(x, y) 函数负责决定 x 决策点和 y 相比，两者的临界点，代码如下 1234567891011int bound(int x, int y) { int l = x, r = n + 1, mid; while (l &lt; r) { mid = (l + r) &gt;&gt; 1; if (calc(x, mid) &gt;= calc(y, mid))//x比y在mid处更l r = mid; else l = mid + 1; } return l;} 法2——分治 假设已知 f_l, f_{l+ 1},\\cdots, f_r 的最优决策点在 [L, R] 上，令 m = (l + r) / 2 ，设其最优决策点为 p_m ，则由决策单调性可以知道 f_l,\\cdots, f_m 的最优决策点在 [L, p] 上， f_{m + 1},\\cdots, f_r 的最优决策点在 [p, R] 上。 这样子问题的归模就得到了减半，每次找 m 的决策点的时候暴力扫 [L, R] 即可。但是这样做的前提是 w(i, j) 能 O(1) 计算，否则复杂度会萎掉，而二分队列就不存在这个问题。 但是分治的代码明显很好写啊！ 这是 P3515 [POI2011]Lightning Conductor 分治部分的代码。题解链接。 123456789101112void solve(int l, int r, int L, int R) { if (l &gt; r) return; int mid = (l + r) &gt;&gt; 1, k; db mx = 0, tmp; for (int j = L; j &lt;= mid &amp;&amp; j &lt;= R; ++j) if ((tmp = a[j] + sq[mid - j]) &gt; mx) mx = tmp, k = j; p[mid] = max(p[mid], mx); solve(l, mid - 1, L, k); solve(mid + 1, r, k, R); return;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"决策单调性优化","slug":"mono-opti-dp","permalink":"https://old.blog.imyangty.com/tags/mono-opti-dp/"},{"name":"四边形不等式","slug":"quadrangle-inequality","permalink":"https://old.blog.imyangty.com/tags/quadrangle-inequality/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"}]},{"title":"HDU6756 Finding a MEX","slug":"sol-hdu6756","date":"2021-07-19T13:40:50.000Z","updated":"2022-03-23T04:18:30.767Z","comments":true,"path":"sol-hdu6756/","link":"","permalink":"https://old.blog.imyangty.com/sol-hdu6756/","excerpt":"","text":"题意 给定一张无向图 G = (V, E) ，节点编号从 1 到 n ，每个节点有权值 A_u 。定义 S_u = \\{A_v:(u,v)\\in E\\} ， F_u = \\operatorname{mex} S_u 。 \\operatorname{mex} 的含义是一个集合中最小的没有出现过的非负整数。 两种操作 1 u x 将 A_u 修改为 x 2 u 查询 F_u 多组数据， 1 \\le T\\le 10 ， |V|,|E|, q \\le 10^5 ， 0\\le A_u\\le 10^9 。 思路 考虑（不完全是）根号分治。 首先明确一点，设 d_u 为点 u 的度，则答案区间肯定为 [0, d_u] 。那么我们将度数大的点归为大点，度数小的点归为小点。查询小点的时候直接暴力，查询大点的时候使用数据结构。 如果设阈值为 \\sqrt n ，则大点的个数不会超过 \\sqrt n 个，可以使用分块或树状数组维护 mex 值，复杂度分别为 O(T(n\\sqrt n)) 和 O(T(n\\sqrt n\\log n)) 。 具体的做法都是用数组维护出现过的数字的个数（开桶），然后树状数组相当于就是 vis 数组做个前缀和，如果 S(n) \\not= n 说明肯定有数字没有出现，分块同理。 注意到一次修改操作最多影响 \\sqrt n 个点，而查询操作是只有 O(q) 次的，所以分块效率会优于树状数组二分，因为其可以 O(1) 修改 O(\\sqrt n) 查询，用查询换修改，不亏。 另一种偷懒写法 使用 std::set 来维护 mex。。。里面装没有出现过的数字，然后第一个元素就是答案。 当然这个时候就需要玄学调参了，否则就是 TLE。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;set&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define lowbit(x) (x &amp; -x)namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;const int maxn = 1e5 + 5, block = 1000;int n, m;int a[maxn], deg[maxn], id[maxn], cnt, tmp[1005], vis[105][maxn];std::vector&lt;int&gt; g[maxn];std::set&lt;int&gt; s[105];void init() { n = read(), m = read(); FOR(i, 1, n) a[i] = read(), g[i].clear(), deg[i] = 0, id[i] = 0; cnt = 0; FOR(i, 1, m) { int u = read(), v = read(); g[u].push_back(v), g[v].push_back(u); ++deg[u], ++deg[v]; } FOR(u, 1, n) { if (deg[u] &gt;= block) { ++cnt; id[u] = cnt, s[cnt].clear(); FOR(i, 0, deg[u]) s[cnt].insert(i), vis[cnt][i] = 0; for (auto v : g[u]) { if (a[v] &lt;= deg[u]) { ++vis[cnt][a[v]]; s[cnt].erase(a[v]); } } } } return;}void solve() { int q = read(); while (q--) { int op = read(); if (op == 1) { int u = read(), x = read(); for (auto v : g[u]) { if (!id[v]) continue; if (x &lt;= deg[v]) { ++vis[id[v]][x]; s[id[v]].erase(x); } if (a[u] &lt;= deg[v]) if (!--vis[id[v]][a[u]]) s[id[v]].insert(a[u]); } a[u] = x; } else { int u = read(); if (id[u]) printf(\"%d\\n\", *s[id[u]].begin()); else { for (auto v : g[u]) if (a[v] &lt;= deg[u]) tmp[a[v]] = 1; int ans = 0; FOR(i, 0, deg[u]) { if (!tmp[i]) { ans = i; break; } } for (auto v : g[u]) if (a[v] &lt;= deg[u]) tmp[a[v]] = 0; printf(\"%d\\n\", ans); } } }}int main() { int T = read(); while (T--) { init(); solve(); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"HDU","slug":"HDU","permalink":"https://old.blog.imyangty.com/tags/HDU/"},{"name":"根号分治","slug":"sqrt-division","permalink":"https://old.blog.imyangty.com/tags/sqrt-division/"},{"name":"分块","slug":"block","permalink":"https://old.blog.imyangty.com/tags/block/"}]},{"title":"CF323C Two permutations","slug":"sol-cf323c","date":"2021-07-19T13:38:04.000Z","updated":"2022-03-23T04:18:30.700Z","comments":true,"path":"sol-cf323c/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf323c/","excerpt":"","text":"题意 给定两个长度为 n 的排列 m 次询问，每次询问在第一个排列的 [l_1, r_1] 中和第二个排列的 [l_2, r_2] 中有多少重合的数字 强制在线 思路 由于排列中的每个数字都为 [1, n] 中的一个数字，所以可以把这些数字看作点，其在第一个排列中的位置为纵坐标，第二个排列中的位置为横坐标。 于是这个问题就被转化成了二维平面内的数点问题。 可以用主席树来实现，具体地，用 r_2 版本的线段树中 [l_1, r_1] 的值减去 l_2 - 1 版本的线段树中 [l_1, r_1] 的值即可。 实现 主席树需要开较大的空间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;il int min(int a, int b) {return a &lt; b ? a : b;}il int max(int a, int b) {return a &gt; b ? a : b;}const int maxn = 1e6 + 5, maxm = 4e7 + 5;int n, posa[maxn], b[maxn];struct node { int ls, rs, sum;} t[maxm];int cnt, root[maxn], last = 0;#define ls(k) t[k].ls#define rs(k) t[k].rs#define M ((i + j) &gt;&gt; 1)int insert(int k, int i, int j, int val) { t[++cnt] = t[k], k = cnt; if (i == j) { ++t[k].sum; return k; } if (val &lt;= M) ls(k) = insert(ls(k), i, M, val); else rs(k) = insert(rs(k), M + 1, j, val); t[k].sum = t[ls(k)].sum + t[rs(k)].sum; return k;}int query(int k, int i, int j, int x, int y) { if (!k) return 0; if (x &lt;= i &amp;&amp; y &gt;= j) return t[k].sum; int ret = 0; if (x &lt;= M) ret += query(ls(k), i, M, x, y); if (y &gt; M) ret += query(rs(k), M + 1, j, x, y); return ret;}il int f(int z) {return (z - 1 + last) % n + 1;}int main() { n = read(); FOR(i, 1, n) posa[read()] = i; FOR(i, 1, n) root[i] = insert(root[i - 1], 1, n, posa[read()]); int m = read(); while (m--) { int a = read(), b = read(), c = read(), d = read(); int l1 = min(f(a), f(b)), r1 = max(f(a), f(b)), l2 = min(f(c), f(d)), r2 = max(f(c), f(d)); printf(\"%d\\n\", last = query(root[r2], 1, n, l1, r1) - query(root[l2 - 1], 1, n, l1, r1)); ++last; } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"主席树","slug":"persistent-segtree","permalink":"https://old.blog.imyangty.com/tags/persistent-segtree/"}]},{"title":"P2305 [NOI2014] 购票","slug":"sol-luogu-p2305","date":"2021-07-11T13:21:18.000Z","updated":"2022-03-23T04:18:30.907Z","comments":true,"path":"sol-luogu-p2305/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2305/","excerpt":"","text":"题意 一棵 n 个节点，根为 1 的有根树（ n\\le 2\\times 10^5 ），给出每条边的长度 s_u （ u 为儿子节点）。 现要从 u 节点前往 1 ，方法为选择一个祖先 v ，支付购票的费用，乘坐交通工具到 v 。然后重复以上过程直到到达 1 。 对于任何一个 u ，有一个交通工具的距离限制 l_u ，即 u 到 v 的距离不超过 l_u 时才可以乘坐交通工具。票价为 p_u\\times d + q_u 。 对于每个 u\\in [2,n] ，求出其到 1 的最小票价费用。 思路 设 f_u 为 u 到 1 的最小费用。设 v 为 u 的祖先， d_u 为 u 到 1 的距离，则有转移： f_u = \\min_{d_u - d_v\\le l_u}\\{f_v + p_u(d_u - d_v) + q_u\\} 化开： f_u = \\min\\{f_v - p_ud_v\\} + p_ud_u + q_u 考虑转移点 i 何时优于 j ： \\begin{aligned} f_i - p_ud_i &amp;&lt; f_j - p_ud_j\\\\ f_i - f_j &amp;&lt; p_u(d_i - d_j)\\\\ \\frac{f_i - f_j}{d_i - d_j} &amp;&lt; p_u \\end{aligned} 所以斜率优化的形式就出来了。 但是这题的转移不是在一个序列上完成的，所以我们需要用一个栈来维护沿途经过的点，而且注意到斜率 p_u 不单调，故使用二分维护。 然后。。。交上去就爆零了。。。 为什么呢？ 考虑 A, B, C, D 四个决策点，其中 B 由于不凸被弹出了，但是当 A 不能作为转移点的时候 B 就可能合法了。 怎么做？考虑点分治。 假设目前正在处理一个以 u 为根的子树。 找到重心 x 。 把 x 到 u 的这段连通块递归处理。 将 x 子树中除 x 以外的点按照其能到达的祖先的最小深度从大到小排序。 依次处理这些节点，把新能达到的祖先加进凸壳中，单调栈维护一下，然后二分最优决策点。 依次分治 x 的子树们。 复杂度 O(n\\log^2n) 。需要注意的细节很多，注意不要写错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])typedef long long ll;typedef double db;namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} ll read() { ll s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;il ll min(ll a, ll b) {return a &lt; b ? a : b;}il ll max(ll a, ll b) {return a &gt; b ? a : b;}const int maxn = 2e5 + 5;int n, head[maxn], to[maxn], nxt[maxn], cnte, fa[maxn];ll p[maxn], q[maxn], dis[maxn], lim[maxn];il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}int maxp[maxn], root, vis[maxn], size[maxn];ll f[maxn];void getRoot(int u, int m) { size[u] = 1, maxp[u] = 0; GO(u) { if (vis[v]) continue; getRoot(v, m); size[u] += size[v]; maxp[u] = max(maxp[u], size[v]); } maxp[u] = max(maxp[u], m - size[u]); if (maxp[u] &lt;= maxp[root]) root = u; return;}void getDis(int u) { GO(u) { dis[v] += dis[u]; getDis(v); } return;}int son[maxn], cnt, stk[maxn], top;void getSon(int u) { son[++cnt] = u; GO(u) if (!vis[v]) getSon(v); return;}il bool cmp(int u, int v) { return dis[u] - lim[u] &gt; dis[v] - lim[v];}il db slope(int u, int v) {return db(f[u] - f[v]) / db(dis[u] - dis[v]);}void insert(int u) { while (top &gt;= 2 &amp;&amp; slope(stk[top - 1], stk[top]) &lt;= slope(stk[top], u)) --top; stk[++top] = u; return;}int query(db x) { int l = 1, r = top, mid, ret = top; while (l &lt; r) { mid = (l + r) &gt;&gt; 1; if (slope(stk[mid], stk[mid + 1]) &lt;= x) r = mid, ret = mid; else l = mid + 1; } return stk[ret];}void solve(int u, int m) { if (m == 1) return; root = 0, maxp[0] = n, getRoot(u, m); int x = root; GO(x) vis[v] = 1, m -= size[v]; solve(u, m); cnt = 0; GO(x) getSon(v); std::sort(son + 1, son + cnt + 1, cmp); int j = x; top = 0; FOR(i, 1, cnt) { int y = son[i]; while (j != fa[u] &amp;&amp; dis[j] &gt;= dis[y] - lim[y]) insert(j), j = fa[j]; if (top) { int x = query(p[y]); f[y] = min(f[y], f[x] + p[y] * (dis[y] - dis[x]) + q[y]); } } GO(x) solve(v, size[v]); return;}int main() { n = read(), read(); FOR(i, 2, n) { add(fa[i] = read(), i); dis[i] = read(), p[i] = read(), q[i] = read(), lim[i] = read(); f[i] = 1e18; } getDis(1); solve(1, n); FOR(i, 2, n) printf(\"%lld\\n\", f[i]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"点分治","slug":"centroid-decomposition","permalink":"https://old.blog.imyangty.com/tags/centroid-decomposition/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P1721 [NOI2016] 国王饮水记","slug":"sol-luogu-p1721","date":"2021-07-11T06:24:55.000Z","updated":"2022-03-23T04:18:30.856Z","comments":true,"path":"sol-luogu-p1721/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1721/","excerpt":"","text":"题意 给定序列 \\{h_i\\} （ 1\\le h_i\\le 10^5 且 h_i 互不相同），进行至多 k 次操作，每次操作选定一些 h_i 然后将这些 h_i 赋为他们的平均值，求最大的 h_1 。 n\\le 8000 ， k\\le 10^9 ，保留 p 位小数（ p\\le 3000 ）。 思路 神仙题，看了很久，都没有头绪。面对这种问题我们先思考性质： 性质一：高度低于 h_1 的肯定是没有用的，为什么？拖后腿啊，肯定不要，一开始就先把小于 h_1 的 h_i 删掉。 根据这个性质，我们先把高度低于 h_1 的水箱删掉，然后考虑别的性质。 现在先想想：如果有 h_1 &lt; h_2 &lt; h_3 ，怎么合并会最优？ \\dfrac{h_1 + h_2 + h_3}{3} 肯定是不够优的（代数据可得）， \\dfrac12\\dfrac{(h_1 + h_2)}2 + \\dfrac12h_3 = \\dfrac14h_1 + \\dfrac14h_2 + \\dfrac12 h_3 &gt; \\dfrac14h_1 + \\dfrac14h_3 + \\dfrac12h_2 。说明两两合并比三三合并优，且合并要从小往大。 性质二：合并要从小往大合并 然后根据这种方法，最多最多只用合并 n - 1 次，所以 k 过大是没有用的，可以看作 k 和 n 同阶。 性质三：合并的区间一定连续 不然的话把左边的往右边移肯定是更优的。 于是可以设状态了： f_{i, j} 表示第 i 次联通，最后一次联通到 j 的最大答案。记排序过 h_i 的前缀和为 s_i ，则转移： f_{i, j} = \\max_{i - 1\\le k&lt; j}\\left\\{\\frac{f_{i - 1, k} + s_j - s_k}{j - k + 1}\\right\\} 右边这坨式子，就很像 (j, s_j) 到 (k - 1, s_k - f_{i - 1, k}) 的斜率。因此维护一个下凸壳，然后打表发现决策单调性，所以直接单调队列上去。 后面用的结论太难了，不太会证。 但是可以保存决策点，然后再用高精度类算一遍答案。就可以了。 实现 为了避免精度出问题，一开始把所有的 h_i （ i &gt; 1 ）先减去 h_1 ，最后计算的时候再加回来即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)using namespace DecimalLib;using std::cin;using std::cout;using std::endl;const int maxn = 8192;int h[maxn], s[maxn];int n, k, p;typedef double db;struct Point { db x, y;} pt[maxn];db slope(Point &amp;a, Point &amp;b) {return (a.y - b.y) / (a.x - b.x);}db f[2][maxn];int q[maxn], head, tail;short g[maxn][maxn];Decimal dfs(int i, int j) { if (i == 0) return Decimal(h[1]); int pos = g[i][j]; Decimal res = dfs(i - 1, pos), tmp; tmp = res + (s[j] - s[pos]); res = tmp / (j - pos + 1); return res;}int main() { cin &gt;&gt; n &gt;&gt; k &gt;&gt; p; int tmp = 0; FOR(i, 1, n) { int x; cin &gt;&gt; x; if (x &lt;= h[1]) continue; h[++tmp] = x; } n = tmp; k = k &lt; n - 1 ? k : n - 1; std::sort(h + 1, h + n + 1); FOR(i, 2, n) h[i] -= h[1], s[i] = s[i - 1] + h[i]; int c = 1; Point now; FOR(i, 1, k) { c ^= 1; q[head = tail = 1] = i; pt[i].x = i - 1, pt[i].y = s[i] - f[c ^ 1][i]; FOR(j, i + 1, n) { now.x = j, now.y = s[j]; while (head &lt; tail &amp;&amp; slope(pt[q[head]], now) &lt; slope(pt[q[head + 1]], now)) ++head; f[c][j] = slope(pt[q[head]], now); g[i][j] = q[head]; pt[j].x = j - 1, pt[j].y = s[j] - f[c ^ 1][j]; while (head &lt; tail &amp;&amp; slope(pt[q[tail - 1]], pt[q[tail]]) &gt; slope(pt[q[tail]], pt[j])) --tail; q[++tail] = j; } } FOR(i, 2, n) h[i] += h[1], s[i] = s[i - 1] + h[i]; Decimal ans = dfs(k, n); cout &lt;&lt; ans.to_string(p) &lt;&lt; endl; return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4027 [NOI2007] 货币兑换","slug":"sol-luogu-p4027","date":"2021-07-09T08:19:49.000Z","updated":"2022-03-23T04:18:30.965Z","comments":true,"path":"sol-luogu-p4027/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4027/","excerpt":"","text":"题意 一家金券交易所。有 A 和 B 两种金券。第 i 天的价值分别是 A_i 和 B_i （元/单位金券）。金券的个数可以是实数。 交易方法有两种： 顾客将名下 OP\\% 的 A 券和 OP\\% 的 B 券卖出，以当天价值兑换人民币（ OP\\in [0, 100] ）。 顾客支付 IP 元人民币，交易所兑换 IP 元对应的金券给用户，第 i 天 A 券和 B 券的比例为 R_i 。 问开始时有 S 元， N 天后最多能有多少钱，保留三位小数。 每天可以多次交易，且存在最优解满足每次卖出操作卖出全部金券，买入操作用完所有人民币。 思路 首先，题面给了我们非常清楚的提示：要卖出就全部卖出，要买入就全部买入。而数据范围提示了我们的时间复杂度是 O(n) 的。 因此，我们设 f_i 为 i 天能获得的最多钱。后效性和最优子结构比较显然，然后考虑转移。一个状态如何得到？无非就是在第 j 天用全部的人民币买入金券，然后在第 i 天卖掉全部的金券换成人民币。 第 j 天的钱为 f_j 元，第 j 天金券的价格分别为 A_j 和 B_j ，A 和 B 的比例应为 R_j 。所以设买入的金券 A 的个数为 x ，B 的个数为 y 。则 \\begin{cases} xA_j + yB_j = f_j\\\\ \\dfrac x y = R_j \\end{cases} 不难解得 y = \\dfrac{f_j}{R_jA_j + B_j} ， x = \\dfrac{R_jf_j}{R_jA_j + B_j} 。卖掉后得到的钱就有了： \\dfrac{(A_iR_j + B_i)f_j}{R_jA_j + B_j} 。 f_i = \\max_{1\\le j&lt; i}\\left\\{\\dfrac{(A_iR_j + B_i)f_j}{R_jA_j + B_j}\\right\\} 让这个式子变得好看点： f_i = B_i\\max\\left\\{\\dfrac{R_jf_j}{R_jA_j + B_j}\\rtimes \\dfrac{A_i}{B_i}+ \\dfrac{f_j}{R_jA_j + B_j}\\right\\} 这东西，长得明显就是 y = kx + b 的形式！直接上李超树来做就可以了。 实现 dp 的初始值为 f_1 = S ，然后记得插入初始直线就可以了。 那么问题来了，李超树里面的坐标是 A_i / B_i ，可能为小数。 我会动态开点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef long double db;const int maxn = 1e5 + 5;const db EPS = 1e-9;int n;db a[maxn], b[maxn], r[maxn];db f[maxn], K[maxn], B[maxn];int t[maxn], ls[maxn], rs[maxn], cnt, root;il db calc(int i, db X) {return K[i] * X + B[i];}il db max(db a, db b) {return a &gt; b ? a : b;}#define M ((i + j) / 2.0)#define L ls[k]#define R rs[k]void insert(db i, db j, int &amp;k, int u) { if (j - i &lt;= EPS) return; if (!k) k = ++cnt; int v = t[k]; db resu = calc(u, M), resv = calc(v, M); if (K[u] &gt; K[v]) { if (resu &gt; resv) insert(i, M, L, v), t[k] = u; else insert(M + 1, j, R, u); } else { if (resu &gt; resv) insert(M + 1, j, R, v), t[k] = u; else insert(i, M, L, u); } return;}db query(db i, db j, int k, db X) { db ret = calc(t[k], X); if (j - i &lt; EPS) return ret; if (X &lt;= M) return max(ret, query(i, M, L, X)); else return max(ret, query(M + 1, j, R, X));}int main() { scanf(\"%d %Lf\", &amp;n, f + 1); FOR(i, 1, n) scanf(\"%Lf %Lf %Lf\", a + i, b + i, r + i); K[1] = (f[1] * r[1]) / (r[1] * a[1] + b[1]), B[1] = f[1] / (r[1] * a[1] + b[1]); insert(0, 10, root, 1); FOR(i, 2, n) { f[i] = max(f[i - 1], b[i] * query(0, 10, root, a[i] / b[i])); K[i] = f[i] * r[i] / (r[i] * a[i] + b[i]), B[i] = f[i] / (r[i] * a[i] + b[i]); insert(0, 10, root, i); //printf(\"i %d %.3Lf\\n\", i, f[i]); } printf(\"%.3Lf\\n\", f[n]); return 0;} 然后只有 40 分。。。 正确的做法是把横坐标 A_i / B_i 离散化，然后再使用李超树来做就绝对不会出现精度问题了。而且常数很小，跑得飞快（比 splay 维护动态凸包和 cdq 分治快得多） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef double db;const int maxn = 1e5 + 5;int n;db a[maxn], b[maxn], r[maxn], c[maxn], d[maxn];db f[maxn], K[maxn], B[maxn];int t[maxn &lt;&lt; 2];il db calc(int i, int u) {return K[i] * c[u] + B[i];}il db max(db a, db b) {return a &gt; b ? a : b;}#define M ((i + j) &gt;&gt; 1)#define L (k &lt;&lt; 1)#define R (L | 1)void insert(int i, int j, int k, int u) { int v = t[k]; db resu = calc(u, M), resv = calc(v, M); if (i == j) { if (resu &gt; resv) t[k] = u; return; } if (K[u] &gt; K[v]) { if (resu &gt; resv) insert(i, M, L, v), t[k] = u; else insert(M + 1, j, R, u); } else { if (resu &gt; resv) insert(M + 1, j, R, v), t[k] = u; else insert(i, M, L, u); } return;}db query(int i, int j, int k, int u) { db ret = calc(t[k], u); if (i == j) return ret; if (u &lt;= M) return max(ret, query(i, M, L, u)); else return max(ret, query(M + 1, j, R, u));}int main() { scanf(\"%d %lf\", &amp;n, f + 1); FOR(i, 1, n) scanf(\"%lf %lf %lf\", a + i, b + i, r + i), c[i] = a[i] / b[i], d[i] = c[i]; std::sort(c + 1, c + n + 1); K[1] = (f[1] * r[1]) / (r[1] * a[1] + b[1]), B[1] = f[1] / (r[1] * a[1] + b[1]); insert(1, n, 1, 1); FOR(i, 2, n) { f[i] = max(f[i - 1], b[i] * query(1, n, 1, std::lower_bound(c + 1, c + n + 1, d[i]) - c)); K[i] = f[i] * r[i] / (r[i] * a[i] + b[i]), B[i] = f[i] / (r[i] * a[i] + b[i]); insert(1, n, 1, i); } printf(\"%.3lf\\n\", f[n]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"P4072 [SDOI2016]征途","slug":"sol-luogu-p4072","date":"2021-07-09T03:50:19.000Z","updated":"2022-03-23T04:18:30.971Z","comments":true,"path":"sol-luogu-p4072/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4072/","excerpt":"","text":"题意 给定一段长度为 n 的序列 x_i ，划分为 m 段，使得每一段的和的方差最小，输出 m^2\\sigma 。 m\\le n\\le 3000 。 思路 方差的计算公式为 \\frac{\\sum(X_i - \\overline X)^2}{m} 然后注意到， \\overline X = \\sum x/ m ，可以提前计算出来。我们继续化简一下式子，先同时乘上 m^2 ，可以发现 \\begin{aligned} &amp;\\frac{\\sum_{i = 1}^m (X_i - \\overline X)^2}{m}\\times m^2\\\\ =&amp;\\sum_{i = 1}^m m(X_i^2 - 2X_i\\overline X + \\overline X^2)\\\\ =&amp;\\sum_{i = 1}^m (mX_i^2 - 2X_i\\sum X + (\\sum X)^2 / m)\\\\ =&amp;\\sum_{i = 1}^m (mX_i^2 - 2X_i\\sum X) + (\\sum X)^2 \\end{aligned} 对于后面一部分 (\\sum X)^2 ，可以直接提前计算好，而对于前面这段东西我们需要对其最小化，考虑 dp。 令 f_{i, k} 为前 i 个路，分成 k 段的最小贡献，则转移不难。直接把 x 做一个前缀和就有： f_{i, k} = \\min_j\\{f_{j, k - 1} + m(x_i - x_j)^2 - 2(x_i - x_j)x_n\\} 这个方程的状态转移为 O(n) ， O(n^2) 个状态，总共 O(n^3) 的复杂度 biss 无疑。这个东西长得有点像斜率优化，那化简一下看看能不能优化到 O(1) 转移。 化简： \\begin{aligned} f_{i, k} &amp;= \\min_j \\{f_{j, k - 1} + mx_i^2 - 2mx_ix_j + mx_j^2 - 2x_nx_i + 2x_nx_j\\}\\\\ &amp;= \\min_j\\{f_{j, k - 1} - 2mx_ix_j + mx_j^2 + 2x_nx_j\\} + mx_i^2 - 2x_nx_i\\\\ &amp;= \\min_j\\{f_{j, k - 1} + 2x_nx_j - 2mx_ix_j + mx_j^2\\} + mx_i^2 - 2x_nx_i \\end{aligned} 考虑决策点 j 何时会优于决策点 k ： \\begin{aligned} f_j + 2x_nx_j - 2mx_ix_j + mx_j^2 &amp;&lt; f_k + 2x_nx_k - 2mx_ix_k + mx_k^2\\\\ \\frac{(f_j + 2x_nx_j + mx_j^2) - (f_k + 2x_nx_k + mx_k^2)}{x_j - x_k} &amp;&lt; 2mx_i \\end{aligned} 横坐标为 x_i ，单调增，斜率为 2mx_i ，也单调增。于是我们可以愉快单调队列。 但是需要注意的是，为了防止在计算 f_{i, 1} 时从奇奇怪怪的东西转移过来，我们需要提前处理出 f_{i, 1} 。 实现 开 long long。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;const int maxn = 3005;typedef long long ll;int n, m;ll x[maxn], f[maxn], g[maxn];int q[maxn], head, tail;il ll X(int i) {return x[i];}il ll Y(int i) {return g[i] + 2 * x[n] * x[i] + m * x[i] * x[i];}int main() { n = read(), m = read(); FOR(i, 1, n) x[i] = read() + x[i - 1]; FOR(i, 1, n) f[i] = m * x[i] * x[i] - 2 * x[i] * x[n]; FOR(k, 2, m) { memcpy(g, f, sizeof f); q[head = tail = 1] = 0; FOR(i, 1, n) { ll k = 2 * m * x[i]; while (head &lt; tail &amp;&amp; Y(q[head + 1]) - Y(q[head]) &lt;= k * (X(q[head + 1]) - X(q[head]))) ++head; int &amp;j = q[head]; f[i] = g[j] + m * (x[i] - x[j]) * (x[i] - x[j]) - 2 * (x[i] - x[j]) * x[n]; while (head &lt; tail &amp;&amp; (Y(q[tail]) - Y(q[tail - 1])) * (X(i) - X(q[tail])) &gt;= (Y(i) - Y(q[tail])) * (X(q[tail]) - X(q[tail - 1]))) --tail; q[++tail] = i; } } printf(\"%lld\\n\", f[n] + x[n] * x[n]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF1303G Sum of Prefix Sums","slug":"sol-cf1303g","date":"2021-07-06T13:24:33.000Z","updated":"2022-03-23T04:18:30.683Z","comments":true,"path":"sol-cf1303g/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1303g/","excerpt":"","text":"题意 在树上找一个路径 \\{x_1, x_2, \\cdots x_k\\} 使得 \\sum_{i = 1}^k\\sum_{j = 1}^ia_{x_i} 最大。 n\\le 1.5\\times 10^5 。 思路 式子可以化简为 \\sum_{i = 1}^k ia_{x_i} 。 路径问题考虑点分治。 那么问题来了，如何合并两段路径的答案？ 假设 x_m 为根，则不难单独求出单看 \\{x_1, x_2,\\cdots x_m\\} 和 \\{x_{m + 1}, x_{m + 2}, \\cdots, x_k\\} 。分别产生的贡献。一个是 \\sum_{i = 1}^mia_{x_i} ，一个是 \\sum_{i = m + 1}^k(i - m)a_{x_i} ，分别记为 v_1 和 v_2 。那么很明显地，是后一段的贡献漏了。 漏了多少呢？显然后半段少了 m\\sum_{i = m + 1}^k a_{x_i} 。我们把 \\sum_{i = m + 1}^ka_{x_i} 记作 s_2 。则我们现在需要最大化的就是 v_1 + ms_2 + v_2 。 稍微化成一个一次函数的形式： y = s_2\\times m + v_2 。所以我们可以先把 y = s_2x + v_2 插入李超树里面，然后用 (m, v_1) 去查询。 具体的实现比较考验人，需要存下每个子树中的路径，然后先查询后插入李超树。具体看代码。 由于该版本的李超树复杂度为 O(n\\log n) ，故总复杂度为 O(n\\log^2n) 。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;typedef long long ll;const int maxn = 150000 + 5;int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;ll a[maxn], ans;il ll max(ll a, ll b) {return a &gt; b ? a : b;}void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}int size[maxn], maxp[maxn], vis[maxn], tot, root;void getrt(int u, int fa) { size[u] = 1; maxp[u] = 0; GO(u) { if (vis[v] || v == fa) continue; getrt(v, u); size[u] += size[v]; maxp[u] = max(maxp[u], size[v]); } maxp[u] = max(maxp[u], tot - size[u]); if (maxp[u] &lt; maxp[root]) root = u; return;}struct LiChaoTree {#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1) struct node { ll a, b; } t[maxn &lt;&lt; 2]; void modify(int i, int j, int k, ll a, ll b) { ll resu = a * M + b, resv = t[k].a * M + t[k].b; if (i == j) { if (resu &gt; resv) t[k].a = a, t[k].b = b; return; } if (a &gt; t[k].a) { if (resu &gt; resv) modify(i, M, L, t[k].a, t[k].b), t[k].a = a, t[k].b = b; else modify(M + 1, j, R, a, b); } else if (a &lt; t[k].a) { if (resu &gt; resv) modify(M + 1, j, R, t[k].a, t[k].b), t[k].a = a, t[k].b = b; else modify(i, M, L, a, b); } else if (resu &gt; resv) t[k].a = a, t[k].b = b; return; } ll query(int i, int j, int k, ll X) { if (X &lt;= 0) return 0; ll ret = t[k].a * X + t[k].b; if (i &gt;= j) return ret; if (X &lt;= M) return max(ret, query(i, M, L, X)); else return max(ret, query(M + 1, j, R, X)); } void build(int i, int j, int k) { t[k].a = t[k].b = 0; if (i &gt;= j) return; build(i, M, L); build(M + 1, j, R); return; }} t;struct node { ll v1, v2, s, m; int from;} x[maxn];int top, dep[maxn], maxd;void dfs(int u, int fa, int from, ll v1, ll v2, ll s) { if (u != root &amp;&amp; !from) from = u; dep[u] = dep[fa] + 1; maxd = max(dep[u], maxd); size[u] = 1; bool son = 0; GO(u) { if (v == fa || vis[v]) continue; son = 1; dfs(v, u, from, v1 + a[v] + s, v2 + dep[u] * a[v], s + a[v]); size[u] += size[v]; } if (!son) { x[++top].from = from; x[top].v1 = v1, x[top].v2 = v2, x[top].m = dep[u], x[top].s = s - a[root]; } return;}void calc(int u) { top = 0, dep[u] = 0; maxd = 0; dfs(u, 0, 0, a[u], 0, a[u]); x[++top].from = 0, x[top].v1 = a[u], x[top].v2 = x[top].s = 0, x[top].m = 1; x[top + 1].from = x[0].from = -1; t.build(1, maxd, 1); for (int i = 1; i &lt;= top;) { int j = i; for (; x[j].from == x[i].from; ++j) ans = max(ans, t.query(1, maxd, 1, x[j].m) + x[j].v1); for (j = i; x[j].from == x[i].from; ++j) t.modify(1, maxd, 1, x[j].s, x[j].v2); i = j; } t.build(1, maxd, 1); for (int i = top; i &gt;= 1;) { int j = i; for (; x[j].from == x[i].from; --j) ans = max(ans, t.query(1, maxd, 1, x[j].m) + x[j].v1); for (j = i; x[j].from == x[i].from; --j) t.modify(1, maxd, 1, x[j].s, x[j].v2); i = j; } return;}void solve(int u) { vis[u] = 1; calc(u); GO(u) { if (vis[v]) continue; maxp[0] = n, tot = size[v], root = 0; getrt(v, u); solve(root); } return;}int main() { n = read(); FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } FOR(i, 1, n) a[i] = read(); maxp[root = 0] = tot = n; getrt(1, 0); solve(root); printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"点分治","slug":"centroid-decomposition","permalink":"https://old.blog.imyangty.com/tags/centroid-decomposition/"},{"name":"李超树","slug":"lc-tree","permalink":"https://old.blog.imyangty.com/tags/lc-tree/"}]},{"title":"李超树学习笔记","slug":"note-lichao","date":"2021-07-04T14:13:16.000Z","updated":"2022-04-14T08:17:33.127Z","comments":true,"path":"note-lichao/","link":"","permalink":"https://old.blog.imyangty.com/note-lichao/","excerpt":"","text":"前言 因为最近在学斜率优化，然后遇到了 CEOI 的那道毒瘤题，被迫来学习李超树。 李超树是一种能维护平面内线段的最大值的数据结构。 模板题 题意 P4097 [HEOI2013]Segment 在平面直角坐标系中，维护两个操作（强制在线） 在平面内插入一条线段，记第 i 条被插入的线段的编号为 i ，端点为 (x_0, y_0) 和 (x_1, y_1) 。（ x_0 可能与 x_1 相等） 给定一个数 k ，询问与直线 x = k 相交的线段中，交点纵坐标最大的线段的编号（若有多条线段与查询直线的交点纵坐标都是最大的，则输出编号最小的线段）。特别地，若不存在线段与给定直线相交，输出 0 。 概述 李超树的精髓在于维护每个区间内有可能成为最优解的线段。 定义一个线段在 x_0 处最优当且仅当其与 x = x_0 的交点纵坐标最大。 我们在区间 [l, r] 维护的最优线段满足如下性质： 该线段完整覆盖 [l, r] 该线段在区间中点最优 因此李超树就是一棵维护上面这样的信息的线段树。 插入 考虑将一条新线段插入的操作。 首先，只有这个线段完整覆盖了 [l, r] ， [l, r] 中维护的最优线段才可能发生改变。 我们简单分类讨论一下，设新插入的线段编号为 u ，原先的最优线段的编号为 v 。 如果 k_u &gt; k_v ，则考虑一下 u 和 v 在 M = (l + r) / 2 的取值。 如果 u 在 M 更优，则 u 在 [M + 1, r] 一定是更优的，而 v 在 [l, M] 可能是最优的。 反之，则 u 在 [M + 1, r] 可能是最优的， v 在 [l, M] 一定是最优的。 画图可以方便理解。 k_u &lt; k_v 的情况类似，请画图分析以加深印象。 这里需要在另一半区间下传 v 的原因是：李超树查询使用的是标记永久化的思想。相当于 [l, r] 的优势线段是 u 的话是不需要继续下传的。所以为了避免 u 把 v 直接覆盖掉，要往另一个区间下传 v 。 所以插入的时间复杂度是 O(\\log^2n) 的。 小补充：如果判定时一个直线已经全部高于/低于当前的最优直线，那么可以暴力直接判，常数会大大减小。 查询 我们就从大区间依次向下，查询一下遇到的区间的 [l, r] 的最优线段是否能更新答案。这样的区间显而易见有 O(\\log n) 个，所以查询的时间复杂度是 O(\\log n) 的 就做完了。 实现 整体的时间复杂度为 O(n\\log^2n) 。需要维护线段的斜截式 y = kx + b 以方便计算。线段树里面就存优势线段的编号就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;typedef double db;const int maxn = 1e5 + 5, mod1 = 39989, mod2 = 1e9;int cnt = 0;struct segment { db k, b;} p[maxn];int t[mod1 &lt;&lt; 2];il db calc(int i, int x) {return p[i].k * x + p[i].b;}il int max(int a, int b) {return a &gt; b ? a : b;}template&lt;typename T&gt; il void swap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}void add(int x0, int y0, int x1, int y1) { ++cnt; if (x0 == x1) p[cnt].k = 0, p[cnt].b = max(y0, y1); else p[cnt].k = db(y0 - y1) / db(x0 - x1), p[cnt].b = y0 - p[cnt].k * x0; return;}#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void update(int k, int i, int j, int x, int y, int u) { if (x &gt; j || y &lt; i) return; int v = t[k]; db resu = calc(u, M), resv = calc(v, M); if (x &lt;= i &amp;&amp; y &gt;= j) { if (calc(u, i) &gt;= calc(v, i) &amp;&amp; calc(u, j) &gt;= calc(v, j)) { t[k] = u; return; } if (calc(u, i) &lt;= calc(v, i) &amp;&amp; calc(u, j) &lt;= calc(v, j)) return; if (p[u].k &gt; p[v].k) { if (resu &gt; resv) t[k] = u, update(L, i, M, x, y, v); else update(R, M + 1, j, x, y, u); } else if (p[u].k &lt; p[v].k) { if (resu &gt; resv) t[k] = u, update(R, M + 1, j, x, y, v); else update(L, i, M, x, y, u); } return; } update(L, i, M, x, y, u); update(R, M + 1, j, x, y, u); return;}il int cmp(int X, int i, int j) {return calc(i, X) &gt; calc(j, X) ? i : j;}int query(int X, int k, int i, int j) { if (i &gt; j) return 0; int ret = cmp(X, 0, t[k]); if (i == j) return ret; if (X &lt;= M) ret = cmp(X, ret, query(X, L, i, M)); else ret = cmp(X, ret, query(X, R, M + 1, j)); return ret;}int main() { int n = read(), last = 0; FOR(i, 1, n) { int op = read(); if (!op) { int k = (read() + last - 1) % mod1 + 1; printf(\"%d\\n\", last = query(k, 1, 1, mod1)); } else { int x0 = (read() + last - 1) % mod1 + 1, y0 = (read() + last - 1) % mod2 + 1; int x1 = (read() + last - 1) % mod1 + 1, y1 = (read() + last - 1) % mod2 + 1; if (x0 &gt; x1) swap(x0, x1), swap(y0, y1); add(x0, y0, x1, y1); update(1, 1, mod1, x0, x1, cnt); } } return 0;} 例题 P4254 [JSOI2008]Blue Mary开公司 这题比较模板，直接插入直线即可，甚至都不需要维护左右端点，所以时间复杂度为 O(n\\log n) 。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)typedef double db;const int maxn = 1e5 + 5, maxt = 5e4 + 5;struct segment{ db k, b;} p[maxn];int cnt = 0, t[maxt &lt;&lt; 2];void add(db s, db k){ ++cnt; p[cnt].k = k; p[cnt].b = s - k; return;}#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)il db calc(int i, int x) {return p[i].k * x + p[i].b;}il db max(db a, db b) {return a &gt; b ? a : b;} void update(int k, int i, int j, int u){ int v = t[k]; db resu = calc(u, M), resv = calc(v, M); if (i == j) { if (resu &gt; resv) t[k] = u; return; } if (p[u].k &gt; p[v].k) { if (resu &gt; resv) t[k] = u, update(L, i, M, v); else update(R, M + 1, j, u); } else if (p[u].k &lt; p[v].k) { if (resu &gt; resv) t[k] = u, update(R, M + 1, j, v); else update(L, i, M, u); } else if (resu &gt; resv) t[k] = u; return;}db query(int X, int k, int i, int j){ db res = 0; res = max(res, calc(t[k], X)); if (i &gt;= j) return res; if (X &lt;= M) res = max(res, query(X, L, i, M)); else res = max(res, query(X, R, M + 1, j)); return res;}int main(){ int n; scanf(\"%d\", &amp;n); char op[10]; while (n--) { scanf(\"%s\", op + 1); if (op[1] == 'Q') { int t; scanf(\"%d\", &amp;t); printf(\"%d\\n\", (int)floor(query(t, 1, 1, maxt) / 100)); } else if (op[1] == 'P') { db s, p; scanf(\"%lf %lf\", &amp;s, &amp;p); add(s, p); update(1, 1, maxt, cnt); } } return 0;} BZOJ#3938. Robot 题意 n 个机器人，一开始分别在 a_i 位置。接下来进行 m 次操作： T_i\\texttt{ command } k_i~x_i ，表示在时间 T_i 时重置 k_i 号机器人的速度为 x_i 单位长度每秒， x_i 可以为负。 T_i\\texttt{ query} ，表示查询时间 T_i 时距离原点最远的机器人的距离。 0\\le T_i\\le 10^9 ，总操作次数不超过 6\\times 10^5 。 思路 分析可得，每个机器人的 x-t 图像都是分段的一次函数，所以可以离线，一开始建出一棵李超树来维护这些分段的一次函数的最值，再统一进行查询。（最大值就直接做，最小值为了方便可以把所有直线的 k 和 b 取相反数之后再做一次）。由于时间过大，所以需要离散化。 总体来说还是比较不好写的，需要注意的细节非常多。需要注意的是离散化之后计算中点的函数值时一定要取离散化后的中点，因为递归下去的时候是以离散化之后的中点为参照的，不然 WA 80。 同时，如果你同时维护了两棵李超树分别维护最大和最小值，修改函数千万要写成两个，否则在更新最大值的时候会更新很多无谓的最小值，会 T 飞掉只剩 40pts。 把思路理清楚就可以写代码了。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef long long ll;const int maxn = 6e5 + 5;int n, m, tot;ll a[maxn], rt[maxn], ans[maxn];struct operation { int op; ll t, i, k;} q[maxn];struct line { ll k, b, t1, t2;//维护时间的编号 line() {k = b = t1 = 0, t2 = maxn;}} L[maxn &lt;&lt; 2];int head[maxn], cnt, t[maxn &lt;&lt; 2];il int find(ll t) {return std::lower_bound(rt + 1, rt + tot + 1, t) - rt;}il ll calc(ll X, int i) {return L[i].k * X + L[i].b;}il ll max(ll a, ll b) {return a &gt; b ? a : b;}#define ls (k &lt;&lt; 1)#define rs (ls | 1)#define M ((i + j) &gt;&gt; 1)void update(int k, int i, int j, int x, int y, int u) { if (x &gt; j || y &lt; i) return; int v = t[k]; ll resu = calc(rt[M], u), resv = calc(rt[M], v); if (x &lt;= i &amp;&amp; y &gt;= j) { if (i == j) { if (resu &gt; resv) t[k] = u; return; } if (L[u].k &gt; L[v].k) { if (resu &gt; resv) t[k] = u, update(ls, i, M, x, y, v); else update(rs, M + 1, j, x, y, u); } else if (L[u].k &lt; L[v].k) { if (resu &gt; resv) t[k] = u, update(rs, M + 1, j, x, y, v); else update(ls, i, M, x, y, u); } else if (resu &gt; resv) t[k] = u; return; } update(ls, i, M, x, y, u); update(rs, M + 1, j, x, y, u); return;}ll query(int k, int i, int j, int x){ ll ret = calc(rt[x], t[k]); if (i &gt;= j) return ret; if (x &lt;= M) ret = max(ret, query(ls, i, M, x)); else ret = max(ret, query(rs, M + 1, j, x)); return ret;}int main() { scanf(\"%d %d\", &amp;n, &amp;m); FOR(i, 1, n) scanf(\"%lld\", a + i), head[i] = ++cnt, L[cnt].t1 = 1, L[cnt].b = a[i]; char tmp[10]; rt[++tot] = 0; FOR(i, 1, m) { scanf(\"%lld\", &amp;q[i].t), rt[++tot] = q[i].t; scanf(\"%s\", tmp); if (tmp[0] == 'q') q[i].op = 1; else scanf(\"%lld %lld\", &amp;q[i].i, &amp;q[i].k); } tot = std::unique(rt + 1, rt + tot + 1) - rt - 1; FOR(i, 1, m) { if (q[i].op == 0) { q[i].t = find(q[i].t); line &amp;last = L[head[q[i].i]], now; last.t2 = q[i].t; ll y = last.k * rt[last.t2] + last.b; now.k = q[i].k, now.t1 = q[i].t; now.b = y - now.k * rt[now.t1]; L[++cnt] = now, head[q[i].i] = cnt; } else q[i].t = find(q[i].t); } FOR(i, 1, n) L[head[i]].t2 = tot; FOR(i, 1, cnt) update(1, 1, tot, L[i].t1, L[i].t2, i); FOR(i, 1, m) if (q[i].op == 1) ans[i] = query(1, 1, tot, q[i].t); memset(t, 0, sizeof t); FOR(i, 1, cnt) L[i].k *= -1ll, L[i].b *= -1ll, update(1, 1, tot, L[i].t1, L[i].t2, i); FOR(i, 1, m) if (q[i].op == 1) printf(\"%lld\\n\", max(ans[i], query(1, 1, tot, q[i].t))); return 0;} P4069 [SDOI2016]游戏 题意 n 个点的树。最初每个点上有一个数 123456789123456789 。进行两种操作： 选一条从 s 到 t 的路径，在这条路径上的每个点都添加一个数字。对于路径上的一个点 r ，若 r 与 s 的距离为 d ，则这个点上添加的数字就是 a\\times d + b 。 从一条从 s 到 t 的路径上的点中选出一个最小的数字。 n\\le 10^6 。 思路 维护树上路径，很自然的可以树链剖分然后使用李超树维护。设 u 到根的距离为 d(u) ，注意到同一条重链上面的 d(u) 是单调递增的，所以可以使用李超树进行维护。 具体地，设 s 与 t 的 LCA 为 w ，分 s 到 w 和 w 到 t 两段讨论。 从 s 到 w 上任意取一点 x ，则 x 上加的数为 a\\times(d(s) - d(x)) + b ，化简开有 -a\\times d(x) + ad(s) + b 。所以这一段要加的直线为 y = -ax + (a\\times d(s) + b) 。 从 t 到 w 上任意取一点 x ，则 x 上加的数为 a\\times(d(x) - d(w) + d(s) - d(w)) + b ，化简开就可以得到这一段的直线为 y = ax + (a(d(s) - 2d(w)) + b) 。 然后对于查询操作：在线段树上的每个区间维护一个该区间中线段能达到的最小值，查询的时候直接输出即可。 实现 首先是插入操作需要注意的细节： 一定要 pushup 插入直线之后要用两个端点来更新最小值 然后是查询操作，注意此时需要同时计算一下当前区间的优势线段能产生的最小答案。 总的来说比较考验代码组织能力，值得一做。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = e[i].to; i; i = e[i].nxt, v = e[i].to)namespace fastIO { const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;template&lt;typename T&gt; il void swap(T &amp;a, T &amp;b) { T t = a; a = b, b = t; return;}typedef long long ll;const int maxn = 100000 + 5;const ll INF = 123456789123456789;il ll min(ll a, ll b) {return a &lt; b ? a : b;}il ll max(ll a, ll b) {return a &gt; b ? a : b;}int n, m, head[maxn], cnte;struct edge { int to, nxt; ll dist;} e[maxn &lt;&lt; 1];void add(int u, int v, int w) { e[++cnte].to = v; e[cnte].dist = w; e[cnte].nxt = head[u]; head[u] = cnte; return;}int fa[maxn], son[maxn], size[maxn], dep[maxn];int dfn[maxn], nfd[maxn], top[maxn], cntDfn;ll dis[maxn];void dfs1(int u, int f) { fa[u] = f, size[u] = 1, dep[u] = dep[f] + 1; GO(u) { if (v == f) continue; dis[v] = dis[u] + e[i].dist; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; } return;}void dfs2(int u, int topf) { dfn[u] = ++cntDfn, top[u] = topf, nfd[dfn[u]] = u; if (son[u]) dfs2(son[u], topf); GO(u) { if (v == fa[u] || v == son[u]) continue; dfs2(v, v); } return;}int LCA(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; } return dep[u] &lt; dep[v] ? u : v;}#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)ll t[maxn &lt;&lt; 2], minv[maxn &lt;&lt; 2];ll K[maxn], B[maxn];int tot;il ll calc(int x, int id) {return K[id] * dis[nfd[x]] + B[id];}il void pushup(int k) {minv[k] = min(minv[k], min(minv[L], minv[R]));}void build(int i, int j, int k) { minv[k] = INF, t[k] = 1; if (i == j) return; build(i, M, L); build(M + 1, j, R); return;}void modify(int i, int j, int k, int x, int y, int u) { if (x &lt;= i &amp;&amp; y &gt;= j) { if (calc(i, u) &lt;= calc(i, t[k]) &amp;&amp; calc(j, u) &lt;= calc(j, t[k])) { t[k] = u; minv[k] = min(minv[k], min(calc(i, u), calc(j, u))); return; } if (calc(i, u) &gt;= calc(i, t[k]) &amp;&amp; calc(j, u) &gt;= calc(j, t[k])) return; if (K[u] &lt; K[t[k]]) { if (calc(M, u) &lt;= calc(M, t[k])) modify(i, M, L, x, y, t[k]), t[k] = u; else modify(M + 1, j, R, x, y, u); } else { if (calc(M, u) &lt;= calc(M, t[k])) modify(M + 1, j, R, x, y, t[k]), t[k] = u; else modify(i, M, L, x, y, u); } return minv[k] = min(minv[k], min(calc(i, u), calc(j, u))), pushup(k); } if (x &lt;= M) modify(i, M, L, x, y, u); if (y &gt; M) modify(M + 1, j, R, x, y, u); pushup(k); return;}ll query(int i, int j, int k, int x, int y) { if (x &lt;= i &amp;&amp; y &gt;= j) return minv[k]; ll ret = INF; if (B[t[k]] != INF) ret = min(ret, min(calc(max(i, x), t[k]), calc(min(j, y), t[k]))); if (x &lt;= M) ret = min(ret, query(i, M, L, x, y)); if (y &gt; M) ret = min(ret, query(M + 1, j, R, x, y)); return ret;}void modify(int u, int v) { while (top[u] != top[v]) modify(1, n, 1, dfn[top[u]], dfn[u], tot), u = fa[top[u]]; modify(1, n, 1, dfn[v], dfn[u], tot); return;}void modify(int s, int t, ll a, ll b) { int lca = LCA(s, t); K[++tot] = -a, B[tot] = a * dis[s] + b; modify(s, lca); K[++tot] = a, B[tot] = a * (dis[s] - 2 * dis[lca]) + b; modify(t, lca); return;}ll query(int s, int t) { ll ret = INF; while (top[s] != top[t]) { if (dep[top[s]] &lt; dep[top[t]]) swap(s, t); ret = min(ret, query(1, n, 1, dfn[top[s]], dfn[s])); s = fa[top[s]]; } if (dep[s] &gt; dep[t]) swap(s, t); return min(ret, query(1, n, 1, dfn[s], dfn[t]));}int main() { n = read(), m = read(); FOR(i, 1, n - 1) { int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); } dfs1(1, 0); dfs2(1, 1); B[tot = 1] = INF; build(1, n, 1); while (m--) { int op = read(), s = read(), t = read(); if (op == 1) { ll a = read(), b = read(); modify(s, t, a, b); } else printf(\"%lld\\n\", query(s, t)); } return 0;} CF1303G Sum of Prefix Sums 点分治与李超树的结合，篇幅较长并且不太适合放在这里，已移出。 P4655 [CEOI2017]Building Bridges 李超树优化 dp，把 dp 方程化为一次函数的形式，就可以使用李超树维护了。 放在单独的博文里面。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"计算几何","slug":"computational-geometry","permalink":"https://old.blog.imyangty.com/tags/computational-geometry/"},{"name":"李超树","slug":"lc-tree","permalink":"https://old.blog.imyangty.com/tags/lc-tree/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"}]},{"title":"CF311B Cats Transport","slug":"sol-cf311b","date":"2021-07-01T14:22:50.000Z","updated":"2022-03-23T04:18:30.697Z","comments":true,"path":"sol-cf311b/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf311b/","excerpt":"","text":"题意 Zxr960115 是一个大农场主。他养了 m 只可爱的猫子,雇佣了 p 个铲屎官。这里有一条又直又长的道路穿过了农场，有n个山丘坐落在道路周围，编号自左往右从 1 到 n 。山丘 i 与山丘 i-1 的距离是 D_i 米。铲屎官们住在 1 号山丘。 一天，猫子们外出玩耍。猫子 i 去山丘 H_i 游玩，在 T_i 时间结束他的游玩，然后在山丘 H_i 傻等铲屎官。铲屎官们必须把所有的猫子带上。每个铲屎官直接从 H_1 走到 H_n ，中间不停下，可以认为不花费时间的把游玩结束的猫子带上。每个铲屎官的速度为一米每单位时间，并且足够强壮来带上任意数量的猫子。 举个栗子，假装我们有两个山丘( D_2=1 )，有一只猫子，他想去山丘 2 玩到时间 3 。然后嘞铲屎官如果在时间 2 或者时间 3 从 1 号山丘出发，他就能抱走猫子。如果他在时间 1 出发那么就不行(猫子还在玩耍)。如果铲屎官在时间 2 出发，猫子就不用等他（ \\Delta T=0 ）。如果他在时间 3 出发，猫子就要等他 1 个单位时间。 你的任务是安排每个铲屎官出发的时间，最小化猫子们等待的时间之和。 2\\le n\\le10^5 ， 1\\le m\\le10^5 ， 1\\le p\\le100 ， 1\\le D_i&lt;10^4 ， 1\\le H_i\\le n ， 0\\le t\\le10^9 ，翻译来源洛谷。 思路 首先很重要的一点就是，我们如果令 t_i = T_i - H_i ，则如果一个铲屎官从时间 x 出发，则第 i 只猫等待的时间就是 x - t_i 。同时要求 x \\ge t_i 。对 t_i 做个前缀和，记作 s_i 。 设 f_{i, k} 为 k 个铲屎官搞定前 i 只猫，最小的等待时间。答案即为 f_{m, p} 。如何 dp？在计算 f_{i, k} 的时候，我们是从 f_{j, k - 1} 转移过来的。所以我们这个铲屎官领走的猫的区间是 [j + 1, i] 。这些猫猫的等待时间即为用 (i - j) 乘上 t_i 再减去 s_i - s_j f_{i,k} = \\min_{j}\\{f_{j, k - 1} + (i - j)t_i - s_i + s_j\\} 稍加化简（把 k 那维滚掉）： f_i = \\min\\{f_j - t_ij + s_j\\} + it_i - s_i 考虑决策点 j 何时比 k 优 \\begin{aligned} f_j - t_ij + s_j &amp;&lt; f_k - t_ik + s_k\\\\ (f_j + s_j) - (f_k + s_k) &amp; &lt; t_i(j - k)\\\\ \\frac{(f_j + s_j) - (f_k + s_k)}{j - k} &amp; &lt; t_i \\end{aligned} 所以横坐标 x_i = i ，纵坐标 y_i = f_i + s_i ，斜率 k = t_i 。 t_i 单调， x_i 单调，简单使用单调队列维护一个下凸壳就可以了。 需要注意的细节： 尽量写乘法 记得滚动数组的时候调用的 dp 值。 式子不要抄错 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO{ const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;typedef long long ll;const int maxn = 1e5 + 5;int n, m, p;ll d[maxn], t[maxn], s[maxn];ll f[maxn], g[maxn];//f[i][j] 前 i 只猫猫用 j 个铲屎官都搞定了的最小时间花费int q[maxn], head, tail;il ll X(int i) {return i;}il ll Y(int i) {return g[i] + s[i];}il ll min(ll a, ll b) {return a &lt; b ? a : b;}int main(){ n = read(), m = read(), p = read(); FOR(i, 2, n) d[i] = d[i - 1] + read(); FOR(i, 1, m) { ll h = read(); t[i] = read() - d[h]; } std::sort(t + 1, t + m + 1); FOR(i, 1, m) s[i] = s[i - 1] + t[i]; memset(f, 0x3f, sizeof f); f[0] = 0; FOR(k, 1, p) { memcpy(g, f, sizeof f); q[head = tail = 1] = 0; FOR(i, 1, m) { int k = t[i]; while (head &lt; tail &amp;&amp; (Y(q[head + 1]) - Y(q[head])) &lt;= k * (X(q[head + 1]) - X(q[head]))) ++head; int j = q[head]; f[i] = g[j] - t[i] * j + s[j] + i * t[i] - s[i]; while (head &lt; tail &amp;&amp; (Y(q[tail]) - Y(q[tail - 1])) * (X(i) - X(q[tail])) &gt;= (Y(i) - Y(q[tail])) * (X(q[tail]) - X(q[tail - 1]))) --tail; q[++tail] = i; } } printf(\"%lld\\n\", f[m]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"P5785 [SDOI2012]任务安排","slug":"sol-luogu-p5785","date":"2021-07-01T12:22:30.000Z","updated":"2022-03-23T04:18:31.029Z","comments":true,"path":"sol-luogu-p5785/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5785/","excerpt":"","text":"题意 n 个任务，从 1, 2, 3, \\cdots, n 连续分组完成任务，第 i 个任务需时间 t_i ，每批任务开始前机器启动 s 时间，完成这批任务的时间是这批任务的 t_i 总和。同一批任务将在同一时刻完成，每个任务的费用是完成时刻乘以一个费用系数 c_i 。 确定一个分组方案使总费用最小。 1\\le n\\le 3\\times 10^5 ， 1\\le s\\le 256 ， |t_i|\\le 256 ， 0\\le c_i\\le 2^8 。 思路 设 f_i 表示前 i 个任务分好组后的最小花费。重新令 T_i 为 t_i 的前缀和， C_i 为 c_i 的前缀和，结合费用提前计算的思想可以得到转移方程 f_i = \\min_j\\{f_j + T_i(C_i - C_j) + s(C_n - C_j)\\} 稍加化简一下： f_i = \\min\\{f_j - (T_i + s)C_j\\} + sC_n + T_iC_i 老套路，考虑 j 比 k 更优会发生什么： \\begin{aligned} f_j - (T_i + s)C_j &amp;&lt; f_k - (T_i + s)C_k\\\\ f_j - f_k &amp;&lt; (T_i + s)(C_j - C_k)\\\\ \\frac{f_j - f_k}{C_j - C_k} &amp;&lt; (T_i + s) \\end{aligned} 所以 Y_i = f_i ， X_i = C_i ， k = T_i + s 。需要注意的的是： c_i 可以等于 0 ，故 C_j - C_k 可能为 0 ，需要注意，而且 Y 的大小直接决定这个斜率是正无穷还是负无穷。 T_i 不一定单调，所以单调队列不能用了，需要在单调栈维护的凸壳上面二分找到最优决策点。 好在这题的 C_i 是（非严格）单调的，因此可以只在凸壳的一边加点，不需要李超树或平衡树来维护。 二分的细节需要特别注意，如果是 l &lt; r 的话 +1 和 -1 一定不能同时出现。凸壳里面如果只有一个点的话就要返回对应的元素。然后如果搜了半天都没搜出来一个斜率大于 k 的点，说明答案就是队尾。 开 long long。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO{ const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;typedef long long ll;const int maxn = 3e5 + 5;ll n, s, T[maxn], C[maxn], f[maxn];il ll X(int i) {return C[i];}il ll Y(int i) {return f[i];}int q[maxn], head, tail;int search(int k){ int l = head, r = tail, mid, ret = tail; while (l &lt; r) { mid = (l + r) &gt;&gt; 1; int i = q[mid], j = q[mid + 1]; if ((Y(j) - Y(i)) &gt;= k * (X(j) - X(i))) ret = mid, r = mid; else l = mid + 1; } return q[ret];}int main(){ n = read(), s = read(); FOR(i, 1, n) T[i] = T[i - 1] + read(), C[i] = C[i - 1] + read(); q[head = tail = 1] = 0; FOR(i, 1, n) { int j = search(s + T[i]); f[i] = f[j] + T[i] * (C[i] - C[j]) + s * (C[n] - C[j]); while (head &lt; tail &amp;&amp; (Y(q[tail]) - Y(q[tail - 1])) * (X(i) - X(q[tail])) &gt;= (Y(i) - Y(q[tail])) * (X(q[tail]) - X(q[tail - 1]))) --tail; q[++tail] = i; } printf(\"%lld\\n\", f[n]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"2021年7月 OI学习记录","slug":"summary-2021-07","date":"2021-07-01T05:43:39.000Z","updated":"2022-04-14T08:17:33.144Z","comments":true,"path":"summary-2021-07/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-07/","excerpt":"","text":"前言 感觉自己是 sb。 学习内容 莫队（带修，树上） cdq 分治 K-D Tree SAM 做题记录 21/07/01 P3648 [APIO2014]序列分割 毒瘤斜率优化，这题是真的卡常，判斜率使用乘法判会快一些且不掉精度。开 long long。 P5785 [SDOI2012]任务安排 卡精度的题，斜率优化随便推一下即可。需要二分单调栈查找最优决策点。 21/07/03 CF311B Cats Transport 斜率优化。 21/07/04 [P4097 HEOI2013]Segment 李超树模板。 21/07/05 P4254 [JSOI2008]Blue Mary开公司 不用维护线段端点的李超树，非常好写。 BZOJ#3938. Robot 将时间离散化之后用李超树维护 x-t 图，统一进行查询。需要注意细节。 21/07/06 P4069 [SDOI2016]游戏 细节十分恶心的李超树 + 树链剖分。 21/07/07 CF1303G Sum of Prefix Sums 点分治 + 李超树 P4655 [CEOI2017]Building Bridges 李超树优化 dp 21/07/08 P2900 [USACO08MAR]Land Acquisition G 斜率优化。注意到有些土地根本不会对答案产生贡献，排除掉即可。 P2120 [ZJOI2007]仓库建设 自己推出来的，简单斜优。 21/07/09 P4360 [CEOI2004]锯木厂选址 自己口胡了一种神奇的更为通用的做法，斜率优化。 P3628 [APIO2010]特别行动队 斜率优化，注意单调性有变化。 P4072 [SDOI2016]征途 斜率优化，需要提前处理出 f_1 的值。 21/07/11 P4027 [NOI2007] 货币兑换 李超树优化 dp P1721 [NOI2016] 国王饮水记 神仙题 21/07/17 之前考试周比较耽误 AtCoder Beginner Contest 210 A + B + C + D + E rk485 P2305 [NOI2014] 购票 点分治 + 斜率优化 21/07/18 P3374 【模板】树状数组 1 cdq 分治做法 CF713C Sonya and Problem Wihtout a Legend 奇怪的数形结合优化 dp 21/07/19 P3157 [CQOI2011]动态逆序对 cdq 分治 CF323C Two permutations 主席树 P1972 [SDOI2009]HH的项链 树状数组 P2709 小B的询问 莫队 CF86D Powerful array 莫队 21/07/20 HDU6756 Finding a MEX 按照度数大小分块 P1903 [国家集训队]数颜色 / 维护队列 带修莫队模板 21/07/21 P1494 [国家集训队]小Z的袜子 莫队 SP10707 COT2 - Count on a tree II 树上莫队 CF940F Machine Learning 带修莫队，由于数字出现次数的 mex 是 O(\\sqrt n) 级别的，所以可以暴力 mex P4137 Rmq Problem / mex 莫队，对值域分块来维护 mex P4148 简单题 卡空间 + 强制在线，KDT 二维数点 P4357 [CQOI2016]K 远点对 KDT 剪枝 + 堆，查询 k 远点 21/07/22 P2042 [NOI2005] 维护数列 用平衡树维护序列 P3835 【模板】可持久化平衡树 板子 P3380 【模板】二逼平衡树（树套树） 板子 P5055 【模板】可持久化文艺平衡树 板子 21/07/26 P4074 [WC2013] 糖果公园 树上带修莫队 21/07/28 UVA10304 Optimal Binary Search Tree 四边形不等式 + 区间dp CF1238E Keyboard Purchase 状压 dp，拆开每个字母的贡献 P2197 【模板】nim 游戏 nim 游戏 21/07/29 P3804 【模板】后缀自动机 (SAM) SAM 模板，parent 树上跑 dp P4070 [SDOI2016]生成魔咒 SAM P3975 [TJOI2015]弦论 SAM 找子串个数。endpos 类的大小 HDU2609 How many 找出每个串的最小表示然后去重计数即可 21/07/30 P4132 [BJOI2012]算不出的等式 其几何意义为直线下数点。注意特判 p = q 的情况。 HDU 4944 FSF’s game 莫反，Sol. BZOJ #3601. 一个人的数论 莫反 + 高斯消元，Sol. 21/07/31 P4783 【模板】矩阵求逆 高斯消元。 P6076 [JSOI2015]染色问题 容斥。 P4718 【模板】Pollard-Rho算法 miller_rabin + pollard-rho P2455 [SDOI2006]线性方程组 高斯消元 AtCoder Beginner Contest 212 A + B + C + D + E 赛后 F P3232 [HNOI2013]游走 高斯消元 + 期望","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"P3648 [APIO2014]序列分割","slug":"sol-luogu-p3648","date":"2021-06-30T14:11:05.000Z","updated":"2022-03-23T04:18:30.960Z","comments":true,"path":"sol-luogu-p3648/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3648/","excerpt":"","text":"题意 对一个长度为 n 的块进行 k 次如下操作： 选取一个长度大于 1 的块并找一个位置切开 答案加上这切开的两个块的元素和的乘积 求最大答案以及构造方案。 思路 首先明确一点：我们切的顺序是不会对答案产生影响的。为什么呢：简单考虑一下 \\{a, b, c\\} ： \\{a, b, c\\}\\rightarrow\\{a\\},\\{b, c\\}\\rightarrow\\{a\\}, \\{b\\}, \\{c\\} 。答案为 a(b + c) + bc = ab + ac + bc 。 \\{a, b, c\\}\\rightarrow\\{a, b\\}, \\{c\\}\\rightarrow \\{a\\},\\{b\\},\\{c\\} 。答案为 (a + b)c + ab = ab + ac + bc 。 所以设计 dp 状态为 f_{i, k} 表示前 i 个元素，切了 k 刀（最后的部分强制断开），能达到的最大价值。 则转移不难： f_{i, k} = \\max_{k\\le j &lt; i}\\{f_{j, k - 1} + s(1, j) \\times s(j + 1, i)\\} 化简了（把 k 那维滚动掉）就是 f_{i} = \\max\\{f_j + s_is_j - s_j^2\\} 这个东西长得就很斜率优化。考虑从 j 转移何时会比从 k 转移优： \\begin{aligned} f_j + s_is_j - s_j^2 &amp;&gt; f_k + s_is_k - s_k^2\\\\ f_j - s_j^2 - (f_k - s_k^2) &amp; &gt; s_i(s_k - s_j)\\\\ \\frac{f_j - s_j^2 - (f_k - s_k^2)}{-s_j - (-s_k)} &amp;&gt; s_i \\end{aligned} 于是横纵坐标就有了： X_i = -s_i ， Y_i = f_i - s_i^2 。每次转移就相当于用一个斜率为 s_i 的直线去碰下凸壳。 维护单调队列即可。注意 s_i 可能出现相同情况，如果求斜率的话要特判成负无穷。 当然这题卡常而且卡精度，所以建议使用乘法，且开 long long。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO{ const int maxc = 1e7 + 5; char buf[maxc], *p1 = buf, *p2 = buf; il char getchar() {return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, maxc, stdin), p1 == p2) ? EOF : *p1++;} int read() { int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s; }}using namespace fastIO;const int maxn = 1e5 + 5, maxk = 205;typedef long long ll;ll s[maxn], f[maxn], g[maxn], n, k;int fa[maxn][maxk];il ll X(int i) {return -s[i];}il ll Y(int i) {return g[i] - s[i] * s[i];}int main(){ n = read(), k = read(); FOR(i, 1, n) s[i] = s[i - 1] + read(); static int q[maxn], head, tail; FOR(t, 1, k) { memcpy(g, f, sizeof f); q[head = tail = 1] = 0; FOR(i, 1, n) { while (head &lt; tail &amp;&amp; (Y(q[head]) - Y(q[head + 1])) &lt;= s[i] * (X(q[head]) - X(q[head + 1]))) ++head; int &amp;j = q[head]; fa[i][t] = j; f[i] = g[j] + s[i] * s[j] - s[j] * s[j]; while (head &lt; tail &amp;&amp; (Y(q[tail - 1]) - Y(q[tail])) * (X(q[tail]) - X(i)) &gt;= (Y(q[tail]) - Y(i)) * (X(q[tail - 1]) - X(q[tail]))) --tail; q[++tail] = i; } } printf(\"%lld\\n\", f[n]); for (int x = fa[n][k]; k; x = fa[x][--k]) printf(\"%d \", x); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"CF704B Ant Man","slug":"sol-cf704b","date":"2021-06-29T14:22:53.000Z","updated":"2022-03-23T04:18:30.728Z","comments":true,"path":"sol-cf704b/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf704b/","excerpt":"","text":"题意 有 n 个元素，第 i 个元素有五个参数 x_i,a_i,b_i,c_i,d_i 。 你需要求出一个 1 \\sim n 的排列 p ，满足 p_1 = s, p_n = e ，同时最小化这个排列的权值。 一个排列的权值为 \\sum_{i=1}^{n-1} f(p_i, p_{i+1}) ，其中 f(i,j) 的值有两种情况： 若 j &lt; i ，则 f(i,j) = |x_i - x_j| + c_i + b_j 。 若 j &gt; i ，则 f(i,j) = |x_i - x_j| + d_i + a_j 。 n \\le 5 \\times 10^3 ， 1 \\le x_i,a_i,b_i,c_i,d_i \\le 10^9 。 translated by xht37 思路 先思考一下一个点 i 如何产生贡献：假设 x &lt; i &lt; y x\\rightarrow i ，贡献为 A_i = x_i + a_i y \\rightarrow i ，贡献为 B_i = -x_i + b_i i\\rightarrow x ，贡献为 C_i = x_i + c_i i\\rightarrow y ，贡献为 D_i = -x_i + c_i 然后考虑我们维护一个链表，从小到大往里面加点，增量构造法。 现在先不考虑其他的，就考虑将 i 插入 x\\rightarrow y ，而且 i &gt; x,y 。分类讨论一下： x &gt; y ，则 x 的贡献由 C_x 变成 D_x ，答案会加上 D_x - C_x 。在此之后 x 的后继一定大于 x ，所以贡献不会发生变化。 x &lt; y ，则 y 的贡献由 A_y 变为 B_y ，答案会加上 B_y - A_y 。 由此，每次操作可以理解为下面的操作： 答案加上 A_i + C_i 。 从数据结构取一个最小值加到答案上，然后删掉这个值。 向数据结构里面加入两个值 B_i - A_i ， D_i - C_i 。 然后考虑 s 和 e 的限制，依据增量构造法，初始答案为 s\\rightarrow e 产生的贡献。 但是，由于 i 不一定大于 s 和 e ，所以当前操作不一定合法。可以如下操作： i &lt; s 时， A_i 不一定被贡献到，但可以把插入 B_i - A_i 提前在 2 操作之前，如此，即便我们从堆里面取出 B_i - A_i ，相当于选了 B_i 为初始答案， i 左侧可能连 s 。 i &gt; e 时，同理。 i = 1 \\land s,e\\not= 1 ，比较难搞，所以提前强制插入 1 。 当然 i = s \\lor i = e 时，只需要插入 D_s - C_s 或 B_e - A_e 表示在计算 s 的时候一开始默认 s\\rightarrow 小，现在提供 s\\rightarrow 大的可能。（ e 同理） 于是就做完了。 1234567891011121314151617181920212223242526272829303132333435363738394041typedef long long ll;ll x[maxn], a[maxn], b[maxn], c[maxn], d[maxn], n, s, e, ans;std::priority_queue&lt;ll, std::vector&lt;ll&gt;, std::greater&lt;ll&gt; &gt; heap;ll calc(int i, int j){ if (i &lt; j) return x[j] - x[i] + d[i] + a[j]; return x[i] - x[j] + c[i] + b[j];}int main(){ n = read(), s = read(), e = read(); FOR(i, 1, n) x[i] = read(); FOR(i, 1, n) a[i] = read(); FOR(i, 1, n) b[i] = read(); FOR(i, 1, n) c[i] = read(); FOR(i, 1, n) d[i] = read(); if (s == 1 || e == 1) ans = calc(s, e); else ans = calc(s, 1) + calc(1, e); FOR(i, 2, n) { ll A = x[i] + a[i], B = -x[i] + b[i], C = x[i] + c[i], D = -x[i] + d[i]; if (i == s) heap.push(D - C); else if (i == e) heap.push(B - A); else { ans += A + C; if (i &lt; s) heap.push(B - A); if (i &lt; e) heap.push(D - C); ans += heap.top(), heap.pop(); if (i &gt; s) heap.push(B - A); if (i &gt; e) heap.push(D - C); } } printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"}]},{"title":"组合数求法小记","slug":"note-comb-number","date":"2021-06-29T11:29:23.000Z","updated":"2022-04-14T08:17:33.154Z","comments":true,"path":"note-comb-number/","link":"","permalink":"https://old.blog.imyangty.com/note-comb-number/","excerpt":"","text":"前言 记录一下常见的求组合数的几种方法 暴力 利用 \\binom n m = \\frac{n!}{(n - m)!m!} 直接做，复杂度与 m 相关，且很容易爆 long long。但是 m 很小的时候很实用！ 递推 利用 \\binom n m = \\binom{n - 1}{m} + \\binom{n - 1}{m - 1} 来进行递推，时空复杂度均为 O(n^2) 12345678c[1][0] = c[1][1] = 1;FOR(i, 1, n){ c[i][0] = 1; FOR(j, 1, i) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;} 适用于 n 较小的情况，需要注意边界条件，当 m = 0 的时候 \\dbinom n m = 1 Lucas 定理 见 Lucas 定理学习笔记。适用于模数较小，而 n 和 m 均很大的情况。 乘法逆元 利用 \\binom n m = \\frac{n!}{(n - m)!m!} 来做。要求模数为质数。 求出 (n - m)!m! 的逆元，然后直接与 n! 相乘即可。适用于模数为质数，且只求少量组合数的情况。 矩阵快速幂 本篇博客的重点。 有些时候（如 LOJ6069），题目会要求我们求很大的组合数，比如此题要求我们求所有的 \\binom{a}{b} 满足 a 为 10^9 级别， b\\in[0, n] ， n 很小。此时就需要利用组合数的递推来构造转移矩阵使用矩阵快速幂求解。 由于递推式是这个样子的： \\binom n m = \\binom{n - 1}{m} + \\binom{n - 1}{m - 1} 所以我们的矩阵应该长这个样子： \\begin{bmatrix} C_{i, 0}\\\\ C_{i, 1}\\\\ \\vdots\\\\ C_{n, 1} \\end{bmatrix} 然后不难构造出转移矩阵 \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0\\\\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0\\\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; \\cdots &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp; \\vdots\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 \\end{bmatrix} 于是就可以用矩阵快速幂求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct matrix{ int a[maxn][maxn]; void id() { FOR(i, 0, n) a[i][i] = 1; return; } matrix() {memset(a, 0, sizeof a);}};matrix operator*(const matrix &amp;a, const matrix &amp;b){ matrix ret; FOR(i, 0, n) FOR(k, 0, n) FOR(j, 0, n) add(ret.a[i][j], 1ll * a.a[i][k] * b.a[k][j] % mod); return ret;}matrix ksm(matrix base, int p){ matrix ret; ret.id(); for (; p; p &gt;&gt;= 1, base = base * base) if (p &amp; 1) ret = base * ret; return ret;}void init(){ matrix trans; trans.a[0][0] = 1; FOR(i, 1, n) trans.a[i][i - 1] = trans.a[i][i] = 1; matrix ret = ksm(trans, l); FOR(i, 0, n) c[0][i] = ret.a[i][0]; FOR(i, l + 1, r) { c[i - l][0] = 1; FOR(j, 1, n) add(c[i - l][j], c[i - l - 1][j] + c[i - l - 1][j - 1]); } return;}","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"}]},{"title":"LOJ#6069. 「2017 山东一轮集训 Day4」塔","slug":"sol-loj6069","date":"2021-06-29T09:06:09.000Z","updated":"2022-03-23T04:18:30.801Z","comments":true,"path":"sol-loj6069/","link":"","permalink":"https://old.blog.imyangty.com/sol-loj6069/","excerpt":"","text":"题意 有一条 [1, L] 的数轴，要在上面的 n 个不同整点处造塔。塔有编号，编号为 i 的塔的高度为 h_i 。每座塔距离它前面/后面塔的距离大于等于自身的高度，问有多少建造方案，答案对 m 取模。 思路 排列 注意到摆塔一定就是摆出一个排列。 比如说 \\{1, 3, 2, 4, 5\\} ，则相邻之间的最小距离即为 \\{3, 3, 4, 5\\} 。于是可以直接把 l 减去这些距离和，用插板法进行求解。 具体地，设得到的排列为 P ，令 S = \\sum\\max\\{P_i, P_{i -1}\\} ，则摆下所有的塔一定会占据 S + 1 个格子，还剩下 L - (s +1) 个剩下的格子。把这些格子放在 n + 1 个空里面，方案数为 \\dbinom{L - S - 1 + n}{n} 。 DP 求排列个数 现在的问题就是求出 S = k 的排列 P 有多少种。 这里有一个值得注意的想法：从小到大加数字 dp。设 f_{i, j, k} 为加到数字 i ，有 j 个连通块（后面解释），当前的 S 为 k 的方案数。连通块的意思就是已经确定了中间不再插入数字的块。例如： \\{1, 2, 3\\},\\{5, 4\\} ，则 \\{1, 2, 3\\} 是一个整体，不能往里面加了。如果要加 6 的话可以在最左边/最右边或者中间加，也可以加出新的连通块或者选择和连通块合并，具体的： 可以自己做一个连通块，这样子对 k 无任何贡献，因为后面加进来的数一定是比 i 大的。 可以让其贴在某个连通块的一侧，此时对 k 产生 i 的贡献，连通块数目不变。 把两个连通块连接起来，此时对 k 贡献为 2i ，连通块数目减一。 这样的状态个数为 O(n^4) ，因为 k 是 O(n^2) 的。而转移显然为 O(1) ，所以 dp 的复杂度为 O(n^4) 。 统计答案 这个 dp 的答案为 f_{n, 1, S} （ S\\in[0, n(n + 1)] ）。答案即为 \\sum_{S}f_{n, 1, S} \\times\\binom{L - S - 1 + n}{ n} 问题就在于求这个组合数。注意到 S \\in[0, n(n + 1)] ，所以组合数上面的上界为 r = L - 1 + n ，下界为 l = \\max\\{L - n^2 - 1, n\\} 。所以可以直接用矩阵快速幂求出 \\dbinom l i ，其中 i\\in[0, n] ，然后利用递推式把剩下所有需要的组合数都求出来。 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define il inlineconst int maxn = 105;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}il int max(int a, int b) {return a &gt; b ? a : b;}int n, L, mod, l, r;int f[maxn][maxn][maxn * (maxn + 1)], c[maxn * (maxn + 1) + 5][maxn * maxn];il void add(int &amp;x, int y) {x = (x + y) % mod;}struct matrix{ int a[maxn][maxn]; void id() { FOR(i, 0, n) a[i][i] = 1; return; } matrix() {memset(a, 0, sizeof a);}};matrix operator*(const matrix &amp;a, const matrix &amp;b){ matrix ret; FOR(i, 0, n) FOR(k, 0, n) FOR(j, 0, n) add(ret.a[i][j], 1ll * a.a[i][k] * b.a[k][j] % mod); return ret;}matrix ksm(matrix base, int p){ matrix ret; ret.id(); for (; p; p &gt;&gt;= 1, base = base * base) if (p &amp; 1) ret = base * ret; return ret;}void init(){ matrix trans; trans.a[0][0] = 1; FOR(i, 1, n) trans.a[i - ][i] = trans.a[i][i] = 1; matrix ret = ksm(trans, l); FOR(i, 0, n) c[0][i] = ret.a[0][i]; FOR(i, l + 1, r) { c[i - l][0] = 1; FOR(j, 1, n) add(c[i - l][j], c[i - l - 1][j] + c[i - l - 1][j - 1]); } return;}int main(){ n = read(), L = read(), mod = read(); f[0][0][0] = 1; int mx = 0; FOR(i, 1, n) { FOR(j, 0, mx) { FOR(k, 0, i - 1) { add(f[i][k + 1][j], 1ll * f[i - 1][k][j] * (k + 1) % mod); add(f[i][k][j + i], 1ll * f[i - 1][k][j] * 2 * k % mod); if (k &gt;= 2) add(f[i][k - 1][j + 2 * i], 1ll * f[i - 1][k][j] * (k - 1) % mod); } } mx += 2 * i; } l = max(L - mx - 1 + n, n), r = L - 1 + n; init(); int ans = 0; FOR(S, 0, mx) { if (S + 1 &gt; L) break; add(ans, 1ll * f[n][1][S] * c[L - S - 1 + n - l][n] % mod); } printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"LOJ","slug":"LOJ","permalink":"https://old.blog.imyangty.com/tags/LOJ/"}]},{"title":"单调队列优化多重背包","slug":"note-mulbackpack","date":"2021-06-26T04:07:14.000Z","updated":"2022-03-23T04:17:42.196Z","comments":true,"path":"note-mulbackpack/","link":"","permalink":"https://old.blog.imyangty.com/note-mulbackpack/","excerpt":"","text":"前言 约定：下文一律使用字母 V 代表价值（value），用字母 W 代表重量（weight）避免引起混淆。 其实我们是已经拥有 O(NW\\sum\\log m_i) 的二进制分组做法的，但是不够优秀，下面介绍一种严格 O(NW) 的单调队列方法。 从基础的多重背包开始 例题：洛谷 P1776 宝物筛选。没什么好说的，模板。 下文用 m_i 代表第 i 个物品最多能选的个数。 首先写出一个最朴素的 O(NW\\sum m_i) 的转移方程： f_{i,j} = \\max\\{f_{i - 1, j - kw_i} + kv_i\\} 把第一维滚动掉可以得到 f_j = \\max\\{f_{j - kw} + kv\\} 然后，把 j 按照模 w 的意义分组，即令 j = k_1w + p ，其中 p\\in[0, w) ，然后转移方程就可以这样进行转化： f_j = \\max\\{f_{k_1w + p - kw} + kv\\} 然后合并一下同类项， f_j = \\max\\{f_{(k_1 - k)w + p} - (k_1 - k)v\\} + k_1v 注意到 k_1 - k 的重复出现，这就意味着有意义的状态只有 \\frac{W -p}{w} 种，故每次总状态为 O(W) 的。 设 g_k = f_{kw + p} - kv ，则我们对于每个 k_1 ，能且仅能从 \\max_{k\\in[\\max\\{0, k_1 - m\\}, k_1]}\\{g_k\\} 处进行转移。这个东西可以使用单调队列进行优化。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)//{...} fastIO omittedil int min(int a, int b) {return a &lt; b ? a : b;}const int maxn = 4e4 + 5;int f[maxn], head, tail;struct node{ int pos, val;} q[maxn];int main(){ int n = read(), W = read(); FOR(i, 1, n) { int v = read(), w = read(), m = read(); m = min(m, W / w); FOR(mod, 0, w - 1) { head = 1, tail = 0; FOR(k, 0, (W - mod) / w) { int x = k, y = f[k * w + mod] - k * v; while (head &lt;= tail &amp;&amp; q[head].pos &lt; k - m) ++head; while (head &lt;= tail &amp;&amp; q[tail].val &lt;= y) --tail; q[++tail].val = y, q[tail].pos = k; f[k * w + mod] = q[head].val + k * v; } } } printf(\"%d\\n\", f[W]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"单调队列","slug":"mono-queue","permalink":"https://old.blog.imyangty.com/tags/mono-queue/"},{"name":"背包","slug":"backpack-dp","permalink":"https://old.blog.imyangty.com/tags/backpack-dp/"}]},{"title":"P5840 [COCI2015]Divljak","slug":"sol-luogu-p5840","date":"2021-06-24T14:12:52.000Z","updated":"2022-03-23T04:18:31.032Z","comments":true,"path":"sol-luogu-p5840/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5840/","excerpt":"","text":"题意 Alice 有 n 个字符串 \\rm S_1,S_2,\\dots,S_n ，Bob 有一个字符串集合 \\rm T ，一开始集合是空的。 接下来会发生 q 个操作，操作有两种形式： 1 P Bob 往自己的集合里添加了一个字符串 \\rm P 。 2 x Alice 询问 Bob，集合 \\rm T 中有多少个字符串包含串 \\rm S_x 我们称串 \\rm A 包含串 \\rm B ，当且仅当 \\rm B 是 \\rm A 的子串）。 思路 观察到字符串集合 \\rm T 是会发生变动的，不方便我们进行处理，所以对 \\rm S_1,S_2,\\dots,S_n 建立 AC 自动机。 考虑对于每次加进来的字符串 \\rm P 对答案产生的贡献。被 \\rm P 包含的字符串的 \\rm endpos 也就肯定在 fail 树上面， \\rm endpos(P) 到根的路径上的每个点 u_1, u_2, \\cdots u_k 到根的链上的点集并。 把 u_1, u_2, \\cdots u_k 按照 dfs 序排序，然后 \\forall 1 \\le i\\le k ，将 u_i 到根的链上所有节点答案 +1 \\forall 1 &lt; i \\le k ，将 \\mathrm{lca}(u_{i - 1}, u_i) 到根的链上所有节点答案 -1 正确性可以通过手玩进行验证。 然后要查询 \\rm S_x 就是查询单点 \\rm endpos(S_x) 的值。树链修改，单点查询，可以使用树上差分让其变为单点修改，子树查询（参见 LOJ dfs 序模板）。 在 dfs 序上维护一个树状数组就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define il inline#define lowbit(x) (x &amp; -x)template&lt;typename T&gt; il void swap(T &amp;a, T &amp;b){ T t = a; a = b, b = t; return;}const int maxn = 2e6 + 5;int n, q, tot, pos[maxn];char s[maxn];struct node{ int ch[26], end, fail;} t[maxn];void insert(char *s, int id){ int u = 0, len = strlen(s + 1); FOR(i, 1, len) { int c = s[i] - 'a'; if (!t[u].ch[c]) t[u].ch[c] = ++tot; u = t[u].ch[c]; } pos[id] = u; return;}int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])void addEdge(int u, int v){ to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void buildAC(){ static int q[maxn], head = 1, tail = 0; FOR(c, 0, 25) if (t[0].ch[c]) q[++tail] = t[0].ch[c], addEdge(0, t[0].ch[c]); while (head &lt;= tail) { int u = q[head++]; FOR(c, 0, 25) if (t[u].ch[c]) t[t[u].ch[c]].fail = t[t[u].fail].ch[c], addEdge(t[t[u].ch[c]].fail, t[u].ch[c]), q[++tail] = t[u].ch[c]; else t[u].ch[c] = t[t[u].fail].ch[c]; } return;}int fa[maxn], dep[maxn], size[maxn], son[maxn];int top[maxn], dfn[maxn], low[maxn], cntdfn;void dfs1(int u, int f){ size[u] = 1, dep[u] = dep[f] + 1, fa[u] = f; GO(u) { if (v == f) continue; dfs1(v, u); size[u] += size[v]; if (!son[u] || size[v] &gt; size[son[u]]) son[u] = v; } return;}void dfs2(int u, int topf){ top[u] = topf, dfn[u] = ++cntdfn; if (son[u]) dfs2(son[u], topf); GO(u) { if (v == son[u] || v == fa[u]) continue; dfs2(v, v); } low[u] = cntdfn; return;}int getLCA(int u, int v){ while (top[u] != top[v]) { if (dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fa[top[u]]; } return dep[u] &lt; dep[v] ? u : v;}struct BIT{ int f[maxn]; void modify(int x, int d) { for (; x &lt;= cntdfn + 3; x += lowbit(x)) f[x] += d; return; } int query(int x) { int ret = 0; for (; x; x -= lowbit(x)) ret += f[x]; return ret; } il int query(int x, int y) {return query(y) - query(x - 1);}} bit;il bool cmp(int a, int b) {return dfn[a] &lt; dfn[b];}void solve(char *s){ static int tmp[maxn]; int u = 0, len = strlen(s + 1), cnt = 0; FOR(i, 1, len) u = t[u].ch[s[i] - 'a'], tmp[++cnt] = u; std::sort(tmp + 1, tmp + cnt + 1, cmp); cnt = std::unique(tmp + 1, tmp + cnt + 1) - tmp - 1; FOR(i, 1, cnt) { bit.modify(dfn[tmp[i]], 1); if (i &gt; 1) bit.modify(dfn[getLCA(tmp[i], tmp[i - 1])], -1); } return;}int main(){ scanf(\"%d\", &amp;n); FOR(i, 1, n) { scanf(\"%s\", s + 1); insert(s, i); } buildAC(); dfs1(0, -1); dfs2(0, 0); scanf(\"%d\", &amp;q); while (q--) { int op; scanf(\"%d\", &amp;op); if (op == 1) scanf(\"%s\", s + 1), solve(s); else { int x; scanf(\"%d\", &amp;x); printf(\"%d\\n\", bit.query(dfn[pos[x]], low[pos[x]])); } } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AC自动机","slug":"acam","permalink":"https://old.blog.imyangty.com/tags/acam/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"推荐阅读","slug":"recommend","date":"2021-06-19T11:05:15.000Z","updated":"2021-12-15T15:26:03.734Z","comments":true,"path":"recommend/","link":"","permalink":"https://old.blog.imyangty.com/recommend/","excerpt":"","text":"主要是学习路途中阅读到的他人撰写的宝藏博客。 大佬们的博文 分治/二分/倍增等基础算法 wqs 二分 洛谷日报 by 小跳蛙 cdq 分治 by __stdcall DP O(NW) 的树形背包 by Planet6174 斜率优化 by 辰星凌 [OI笔记]数位DP合集 &amp; 对数位DP的一点理解 by s_r_f 树上问题 dfs 序 by Planet6174 LOJ 4 道 dfs 序系列的题解 长链剖分小记 by tzc_wk 长链剖分的应用 树分治小记 by command_block 点/边/链分治 + 全局平衡二叉树 一种基于错误的寻找重心方法的点分治的复杂度分析 一个点分治 浅谈虚树 by SSerxhs 虚树的概念和应用 字符串 关于广义 SAM 的讨论 一种易错写法 SAM 学习笔记 史上最通俗的后缀自动机详解 by KesdiaelKen 数学 线性代数 矩阵树定理的证明 on LOJ 非常简短易懂的证明 线性基学习笔记 by Menci 多项式 FFT 学习笔记 by command_block FFT 入门推荐 FFT/NTT复习笔记&amp;多项式&amp;生成函数学习笔记Ⅰ by tzc_wk 有较详细的例题及题解 博弈论 Nim 游戏与 SG 函数 一些小 trick 【小技巧】O(1)快速乘 推荐题单 数据结构 Limit の线段树题单 线段树合并：从入门到精通 【算法】莫队 树链剖分练习题 Marser的整体二分题单 字符串 字符串从提高到省选#1 AC自动机 【字符串】后缀系列 图论 「二分图」の 学习题单 『二分图』从入门到入土 数学 莫比乌斯反演（函数）练习题单 基础矩阵加速 同余方程-从入门到入土 【线性代数】线性代数基础题","categories":[],"tags":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/tags/site-issue/"},{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"CF490F Treeland Tour","slug":"sol-cf490f","date":"2021-06-13T15:39:00.000Z","updated":"2022-03-23T04:18:30.720Z","comments":true,"path":"sol-cf490f/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf490f/","excerpt":"","text":"题意 求树上严格 LIS 的长度。 n\\le 6000 。 题解 比较平凡的 O(n^2\\log n) 做法这里不考虑。 假定一个最朴素的 dp 状态： f_{u, 0/1, x} 表示 u 子树中往上延伸的结尾为 x 的 LIS/LDS 的最大长度。然后我们注意到，一棵子树中有很多这样的 f 值是相等的。所以可以考虑用长链剖分或者线段树合并来优化这个 dp。本题解使用线段树合并。 对于每个节点维护一棵线段树，下标 i 处维护的是结尾为 i 的 LIS/LDS 的最大长度。不难发现其非常通过线段树合并把子树的信息合并到根。 至于统计答案，一条合法的 LIS 路径必然是由上升到下降的两段组成的（虽然可能其中一段不存在）。当我们在处理 u 子树的时候，可以假定 u 就为一段路径的中间必经点，现在就只需要在子树里找到一截尾部小于 w_u 的 LIS，和一截尾部大于 w_u 的 LDS，加起来再加一就行了。 但是，仍然会存在一些没被统计的答案，这个时候就线段树合并的时候边合并边统计就行了。具体地可以看代码的合并部分。 然后处理完一棵子树之后是需要更新以其为端点的最大 LIS/LDS 长度的。详见代码。 (一开始不要忘记离散化) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 6005;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}il int max(int a, int b) {return a &gt; b ? a : b;}int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;il void add(int u, int v){ to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}int n, maxa, a0[maxn], a[maxn];struct node{ int ls, rs, lis, lds;} t[maxn * 50];int root[maxn], cnt;int ans = 0;#define L(k) t[k].ls#define R(k) t[k].rs#define M ((i + j) &gt;&gt; 1)il void pushup(int k){ t[k].lis = max(t[L(k)].lis, t[R(k)].lis); t[k].lds = max(t[L(k)].lds, t[R(k)].lds); return;}void modify(int &amp;k, int i, int j, int pos, int lis, int lds){ if (!k) k = ++cnt; if (i == j) { t[k].lis = max(t[k].lis, lis); t[k].lds = max(t[k].lds, lds); return; } if (pos &lt;= M) modify(L(k), i, M, pos, lis, lds); else modify(R(k), M + 1, j, pos, lis, lds); pushup(k); return;}void query(int k, int i, int j, int x, int y, int &amp;lis, int &amp;lds)//查询结尾数字在 [x, y] 的 LIS/LDS{ if (!k) return; if (x &lt;= i &amp;&amp; y &gt;= j) { lis = max(lis, t[k].lis), lds = max(lds, t[k].lds); return; } if (x &lt;= M) query(L(k), i, M, x, y, lis, lds); if (y &gt; M) query(R(k), M + 1, j, x, y, lis, lds); return;}void merge(int &amp;x, int y){ if (!x || !y) { x |= y; return; } t[x].lds = max(t[x].lds, t[y].lds); t[x].lis = max(t[x].lis, t[y].lis); ans = max(ans, max(t[L(x)].lis + t[R(y)].lds, t[R(x)].lds + t[L(y)].lis));//合并的时候统计答案 merge(L(x), L(y)), merge(R(x), R(y)); return;}void dfs(int u, int fa){ int mlis = 0, mlds = 0; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v == fa) continue; dfs(v, u); int vlis = 0, vlds = 0, tmp; query(root[v], 1, maxa, 1, a[u] - 1, vlis, tmp); query(root[v], 1, maxa, a[u] + 1, maxa, tmp, vlds); ans = max(ans, mlis + vlds + 1); ans = max(ans, mlds + vlis + 1);//统计经过 u 点的路径的答案 mlis = max(mlis, vlis), mlds = max(mlds, vlds); merge(root[u], root[v]); } modify(root[u], 1, maxa, a[u], mlis + 1, mlds + 1);//当然要更新一下，插入答案 return;}int main(){ n = read(); FOR(i, 1, n) a0[i] = a[i] = read(); std::sort(a0 + 1, a0 + n + 1); maxa = std::unique(a0 + 1, a0 + n + 1) - a0 - 1; FOR(i, 1, n) a[i] = std::lower_bound(a0 + 1, a0 + maxa + 1, a[i]) - a0; FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } FOR(i, 1, n) modify(root[i], 1, maxa, a[i], 1, 1); dfs(1, 0); printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"}]},{"title":"动态 DP 学习笔记","slug":"note-ddp","date":"2021-06-05T09:52:20.000Z","updated":"2022-03-23T04:17:42.170Z","comments":true,"path":"note-ddp/","link":"","permalink":"https://old.blog.imyangty.com/note-ddp/","excerpt":"","text":"前言 动态 dp 一般用来解决树上的 dp 问题，同时需要支持修改点权/边权的操作。 前置知识：矩阵乘法，树链剖分 模板题 题意 洛谷 P4719 【模板】动态 DP 带修改点权的树上最大独立集， n 点， m 次操作 不带修改操作 没有上司的舞会嘛不就是。令 f_{i,0} 表示 i 子树内不选 i 点所构成的最大独立集点权之和， f_{i, 1} 表示 i 子树选 i 点构成的最大独立集点权之和。则易得转移： \\begin{cases} f_{u, 0} = \\sum_{v\\in\\operatorname{son}(u)} \\max\\{f_{v, 0}, f_{v, 1}\\}\\\\ f_{u, 1} = \\operatorname{val}_u + \\sum_{v\\in\\operatorname{son}(u) f_{v, 0}} \\end{cases} 答案即为 \\max\\{f_{\\mathrm{root}, 0}, f_{\\mathrm{root}, 1}\\} 。这是普及组的内容。 朴素的暴力 我们注意到，如果带上了修改点权的操作，则只会有从根到该节点的一条链上会产生 dp 值的变化。这是相当重要的一个思考过程。这样的暴力的时间复杂度为 O(nm) （最坏情况下一次操作 O(n) ） 思考一下这个过程：对链进行操作，无非就是树剖。所以我们考虑使用树链剖分解决这个问题。 树链剖分 树剖的原理是使用线段树或者其他的数据结构来维护一条重链。故其维护的信息必须满足结合律。什么是结合律呢？加法显然就是满足结合律的： (A + B) + C = A + (B + C) 然而这个 dp 值一看就不是很好维护出什么结合律的样子。。。 怎么办？矩阵。矩阵乘法是满足结合律的。所以我们来看看如何利用矩阵来解决这个问题。 矩阵乘法 首先对这个 dp 式子进行一下修改。由于每次都要对所有儿子求个和太慢了，所以定义一个 g_{i, 0/1} 来简化 dp 的式子。具体地， g_{i, 0} 表示不选 i 且只可以选 i 的轻儿子所在子树的答案， g_{i, 1} 表示选 i 的最大答案。令 x 表示 u 点的重儿子，则 \\begin{cases} f_{u, 0} = g_{u, 0} + \\max\\{f_{x, 0}, f_{x, 1}\\}\\\\ f_{u, 1} = g_{u, 1} + f_{x, 0} \\end{cases} 统一一下形式，则 \\begin{cases} f_{u, 0} = \\max\\{g_{u, 0} + f_{x, 0}, g_{u, 0} + f_{x, 1}\\}\\\\ f_{u, 1} = \\max\\{g_{u, 1} + f_{x, 0}, g_{u, 1} -\\infty \\} \\end{cases} 如是，我们可构造矩阵 \\begin{bmatrix}f_{u, 0}\\\\ f_{u, 1}\\end{bmatrix} 。然后定义广义矩阵乘法，使得 \\begin{bmatrix} g_{u, 0} &amp; g_{u, 0}\\\\ g_{u, 1} &amp; -\\infty \\end{bmatrix} \\otimes \\begin{bmatrix} f_{x, 0}\\\\ f_{x, 1} \\end{bmatrix} = \\begin{bmatrix} f_{u, 0}\\\\ f_{u, 1} \\end{bmatrix} 这里的广义矩阵乘法实际就是 C_{i, j} = \\max_{k = 1}^n(A_{i,k} + B_{k, j}) 不难发现这样的矩阵乘法也是满足结合律的。 于是我们的矩阵乘法就定义好了。这里将矩阵封装起来就是下面这个样子： 123456789101112131415161718192021222324template&lt;int row, int col&gt;struct Matrix{ int ele[row][col]; Matrix(int _r = 0, int _c = 0) : r(_r), c(_c) {}};template&lt;int m, int n, int p&gt; Matrix&lt;m, p&gt; operator*(Matrix&lt;m, n&gt; m1, Matrix&lt;n, p&gt; m2){ Matrix&lt;m, p&gt; ret;#define RET ret.ele#define M1 m1.ele#define M2 m2.ele memset(ret.ele, 0xcf, sizeof ret.ele); FOR(i, 0, m - 1) FOR(k, 0, n - 1) FOR(j, 0, p - 1) RET[i][j] = max(RET[i][j], M1[i][k] + M2[k][j]); return ret;#undef RET#undef m1#undef m2} 注意到这样子的单位矩阵应为 \\begin{bmatrix} 0 &amp; -\\infty\\\\ -\\infty &amp; 0 \\end{bmatrix} 查询节点的 dp 值 现在回顾一下处理流程。 假设现在要求出 x 节点的 dp 值，怎么办呢？ 明确一点：每个节点的 f 值根本就不重要，完全可以现算现用。我们需要记录的是每个节点的转移矩阵，并用线段树维护转移矩阵的乘积。 于是乎，只需要知道 x 所在重链的底部叶子节点 \\operatorname{end}(x) 的编号，然后获取 f_{\\operatorname{end}(x)} = \\begin{bmatrix}0\\\\ \\operatorname{val}_{\\operatorname{end}(x)}\\end{bmatrix} ，然后连乘上转移矩阵到 x 处就可以了。也就是 query(dfn[x], dfn[end[x]]) * Matrix 就可以了。 修改点权 首先对于转移矩阵，只需要把含 g_{u, 1} 的地方加上 \\Delta\\mathrm{val}_u 就可以了。 但是，这样一来，祖先的 dp 值就会发生改变，而对于 u 的链顶节点，其一定为另一节点的轻儿子，所以 fa[top[u]] 的 g 值是会发生变化的。 fa[top[u]] 的 g 值由链顶节点的 f 值产生，所以就需要查询出链顶的 f 值。 但这样一来，就又需要一条条链往上的一直修改了。。。 总结一下流程吧： 把矩阵 \\begin{bmatrix}g_{u, 0} &amp; g_{u, 0}\\\\ g_{u, 1} &amp; -\\infty\\end{bmatrix} 的左下角加上 \\Delta\\mathrm{val}_u ，记录到矩阵 T 中。 在修改之前，查询一个 F = \\begin{bmatrix}f_{\\operatorname{top}(u), 0}\\\\f_{\\operatorname{top}(u), 1}\\end{bmatrix} 线段树上修改 u 节点的矩阵为 T ，然后查询 F' = \\begin{bmatrix}f_{\\operatorname{top}(u), 0}\\\\f_{\\operatorname{top}(u), 1}\\end{bmatrix} u\\leftarrow \\mathrm{fa}(\\mathrm{top}(u)) ，若 u = 0 ，结束流程 把 u 的矩阵第一行减去 \\max\\{F\\} 加上 \\max\\{F'\\} ，左下角减去 F 的 f_{\\mathrm{top}(u), 1} 加上 F' 的 f_{\\mathrm{top}(u), 1} 回到第二步 具体实现 遇到的坑点： 线段树的查询函数可能会遇到查询 [0, 0] 的情况，故需要在线段树结构体中记录下一个节点对应的区间，避免死循环。 单位矩阵的初始化不要弄错或者忘记。 代码还是相当长的，内含注释。 注意，这段代码里面使用了重载了 operator() 运算符来访问矩阵内部元素的封装，请在自己编写时老老实实写宏定义或者不要偷懒。这种写法在不开 -O2 的情况下常数极大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])const int maxn = 1e5 + 5, INF = 0x3f3f3f3f;int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;il void add(int u, int v){ to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}il int max(int a, int b) {return a &gt; b ? a : b;}template&lt;int row, int col&gt;struct Matrix{ int ele[row][col]; il int &amp;operator()(int a, int b) {return ele[a][b];}};template&lt;int m, int n, int p&gt; Matrix&lt;m, p&gt; operator*(Matrix&lt;m, n&gt; m1, Matrix&lt;n, p&gt; m2){ Matrix&lt;m, p&gt; ret; memset(ret.ele, 0xcf, sizeof ret.ele); FOR(i, 0, m - 1) FOR(k, 0, n - 1) FOR(j, 0, p - 1) ret(i, j) = max(ret(i, j), m1(i, k) + m2(k, j)); return ret;}Matrix&lt;2, 2&gt; ID, g[maxn];int n, m, val[maxn];int fa[maxn], dep[maxn], size[maxn], son[maxn];void dfs1(int u, int f){ fa[u] = f, size[u] = 1, dep[u] = dep[f] + 1; GO(u) { if (v == f) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; } return;}//正常的树剖dfs1int dfnClock, dfn[maxn], nfd[maxn], top[maxn], end[maxn];int f[maxn][2];void dfs2(int u, int topf){ top[u] = topf, dfn[u] = ++dfnClock, nfd[dfnClock] = u;//记录nfd是方便下面的线段树操作 if (!son[u])//叶子节点 { f[u][1] = val[u];//f值很容易得到 g[u] = ID;//g矩阵赋为单位矩阵 end[u] = u;//记录链底部 return; } g[u](1, 0) = val[u], g[u](1, 1) = -INF;//初始化g矩阵 dfs2(son[u], topf); end[u] = end[son[u]];//更新链底 GO(u) { if (v == fa[u] || v == son[u]) continue; dfs2(v, v); g[u](0, 0) = g[u](0, 1) += max(f[v][0], f[v][1]);//更新g g[u](1, 0) += f[v][0];//更新g } f[u][0] = g[u](0, 0) + max(f[son[u]][0], f[son[u]][1]);//利用g更新f，以计算父亲的g和f f[u][1] = g[u](1, 0) + f[son[u]][0]; return;}struct node{ int l, r;//不记录l和r的话对于查询区间为[0,0] 的情况会死循环 Matrix&lt;2, 2&gt; val;} tree[maxn &lt;&lt; 2];#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)il void pushup(int k){ tree[k].val = tree[L].val * tree[R].val; return;}void build(int i, int j, int k){ tree[k].l = i, tree[k].r = j; if (i == j) { tree[k].val = g[nfd[i]];//此处即为nfd的作用 return; } build(i, M, L); build(M + 1, j, R); pushup(k); return;}Matrix&lt;2, 2&gt; query(int k, int x, int y)//查询操作，查询[x, y] 的矩阵连乘积{ int i = tree[k].l, j = tree[k].r; if (x &lt;= i &amp;&amp; y &gt;= j) return tree[k].val; Matrix&lt;2, 2&gt; ret = ID; if (x &lt;= M) ret = query(L, x, y); if (y &gt; M) ret = ret * query(R, x, y);//注意乘的先后 return ret;}void modify(int k, int x, int p)//把线段树 x 点上的值赋为 p 的矩阵{ int i = tree[k].l, j = tree[k].r; if (i == j) { tree[k].val = g[p]; return; } if (x &lt;= M) modify(L, x, p); else modify(R, x, p); pushup(k); return;}Matrix&lt;2, 1&gt; query(int x)//查询 x 点的 dp 值{ Matrix&lt;2, 1&gt; tmp; tmp(0, 0) = 0, tmp(1, 0) = val[end[x]];//最右边，初始化 return query(1, dfn[x], dfn[end[x]]) * tmp;//连乘给上去}void modify(int x, int y)//将 x 的点权修改为 y{ Matrix&lt;2, 1&gt; F0, F1; g[x](1, 0) += y - val[x]; F0 = query(top[x]); val[x] = y; while (x) { modify(1, dfn[x], x);//把线段树上修改了 F1 = query(top[x]); x = fa[top[x]]; g[x](0, 0) = g[x](0, 1) += max(F1(0, 0), F1(1, 0)) - max(F0(0, 0), F0(1, 0)); g[x](1, 0) += F1(0, 0) - F0(0, 0); F0 = query(top[x]); } return;}int main(){ ID(1, 0) = ID(0, 1) = -INF;//单位矩阵 n = read(), m = read(); FOR(i, 1, n) val[i] = read(); FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } dfs1(1, 0); dfs2(1, 1); build(1, n, 1); while (m--) { int x = read(), y = read(); modify(x, y); Matrix&lt;2, 1&gt; ans = query(1); printf(\"%d\\n\", max(ans(0, 0), ans(0, 1))); } return 0;} 序列上的动态 dp 题意 SPOJ GSS3 n 个数， m 次操作， n,m\\le 50000 。每次操作要么修改 A_x 为 y ，要么询问 [l,r] 的最大连续子段和。 |A_i|\\le 10000 。 其他的解法 使用线段树来记录区间和，区间最大子段和，区间最大前/后缀和，然后直接做。 其实这确实是一道线段树的好题，可以和 GSS1 一起食用。 这里不考虑这些做法。 从 dp 方程说起 众所周知，我们可以这样定义 dp 的状态：设 f_i 为以 i 结尾的最大子段和， g_i 为 [1,i] 的最大子段和，则方程易得： \\begin{cases} f_i = \\max\\{f_{i - 1} + a_i, a_i\\}\\\\ g_i = \\max\\{f_i, g_{i - 1}\\} \\end{cases} 然后我们尝试构造一下矩阵 \\begin{bmatrix}f_i\\\\g_i\\end{bmatrix} ，但是发现转移写不出来，故加一行： \\begin{bmatrix}f_i\\\\g_i\\\\0\\end{bmatrix} 则转移就有了： \\begin{bmatrix} a_i &amp; -\\infty &amp; a_i\\\\ a_i &amp; 0 &amp; a_i\\\\ -\\infty &amp; -\\infty &amp; 0 &amp; \\end{bmatrix} \\otimes \\begin{bmatrix} f_{i - 1}\\\\ g_{i - 1}\\\\ 0 \\end{bmatrix} = \\begin{bmatrix} f_{i}\\\\ g_i\\\\ 0 \\end{bmatrix} 这里的 \\otimes 和上文是一样的，都表示 C_{i,j} = \\max_{k = 1}^n\\{A_{i, k} + B_{k, j}\\} 。具体的构造其实不难，自己手玩一下就可以构造出来。 于是我们就用线段树来维护转移矩阵 \\begin{bmatrix}a_i &amp; -\\infty &amp; a_i\\\\a_i &amp; 0 &amp; a_i\\\\-\\infty &amp; -\\infty &amp; 0 &amp;\\end{bmatrix} 的连乘积（但是一定要注意是从右往左乘），每次修改操作就修改矩阵就可以了。查询操作就初始化一下 ，最右边的矩阵肯定是 \\begin{bmatrix}a_l\\\\a_l\\\\0\\end{bmatrix} ，查询出 [l + 1, r] 的连乘积再左乘给初始矩阵就得解了。 单位矩阵易构造为 \\begin{bmatrix} 0 &amp; -\\infty &amp; -\\infty\\\\ -\\infty &amp; 0 &amp; -\\infty\\\\ -\\infty &amp; -\\infty &amp; 0 \\end{bmatrix} 实现 注意，这段代码里面使用了重载了 operator() 运算符来访问矩阵内部元素的封装，请在自己编写时老老实实写宏定义或者不要偷懒。这种写法在不开 -O2 的情况下常数极大。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 1e5 + 5, INF = 0x3f3f3f3f;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int max(int a, int b) {return a &gt; b ? a : b;}template&lt;int row, int col&gt;struct Matrix{ int ele[row][col]; Matrix() {} int &amp;operator()(int a, int b) {return ele[a][b];}};template&lt;int m, int n, int p&gt; Matrix&lt;m, p&gt; operator*(Matrix&lt;m, n&gt; m1, Matrix&lt;n, p&gt; m2){ Matrix&lt;m, p&gt; ret; memset(ret.ele, 0xcf, sizeof ret.ele); FOR(i, 0, m - 1) FOR(k, 0, n - 1) FOR(j, 0, p - 1) ret(i, j) = max(ret(i, j), m1(i, k) + m2(k, j)); return ret;}struct node{ int l, r; Matrix&lt;3, 3&gt; val;} tree[maxn &lt;&lt; 2];int n, a[maxn];Matrix&lt;3, 3&gt; ID;#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void pushup(int k){ tree[k].val = tree[R].val * tree[L].val; return;}Matrix&lt;3, 3&gt; makeMat(int x){ Matrix&lt;3, 3&gt; ret; ret(0, 0) = ret(0, 2) = ret(1, 0) = ret(1, 2) = x; ret(0, 1) = ret(2, 0) = ret(2, 1) = -INF; ret(1, 1) = ret(2, 2) = 0; return ret;}void build(int i, int j, int k){ tree[k].l = i, tree[k].r = j; if (i == j) { tree[k].val = makeMat(a[i] = read()); return; } build(i, M, L); build(M + 1, j, R); pushup(k); return;}Matrix&lt;3, 3&gt; query(int k, int x, int y){ if (x &gt; y) return ID; int i = tree[k].l, j = tree[k].r; if (x &lt;= i &amp;&amp; y &gt;= j) return tree[k].val; Matrix&lt;3, 3&gt; ret = ID; if (x &lt;= M) ret = query(L, x, y); if (y &gt; M) ret = query(R, x, y) * ret; return ret;}void modify(int k, int x, int z){ int i = tree[k].l, j = tree[k].r; if (i == j) { tree[k].val = makeMat(a[i] = z); return; } if (x &lt;= M) modify(L, x, z); else modify(R, x, z); pushup(k); return;}int main(){ ID(0, 1) = ID(0, 2) = ID(1, 0) = ID(1, 2) = ID(2, 0) = ID(2, 1) = -INF; n = read(); build(1, n, 1); int q = read(); while (q--) { int op = read(), x = read(), y = read(); if (!op) modify(1, x, y); else { Matrix&lt;3, 1&gt; ret; ret(0, 0) = ret(1, 0) = a[x], ret(2, 0) = 0; ret = query(1, x + 1, y) * ret; printf(\"%d\\n\", ret(1, 0)); } } return 0;} 当然也有另一种实现，就是只获取所有矩阵的连乘积，然后取 (1, 2) 位置上的元素，不难发现 (1, 2) 上的元素就是 g 。实际上都可以 AC。 NOIP2018 D2T3 保卫王国 题意 题面。给定一棵有点权的树，每次操作选定两个点强制选或不选，问这次操作下整棵树的最小点覆盖。 动态 DP 的思路 总点权 = 最大独立集 + 最小点覆盖。直接用求最大独立集的方法做就行了。 强制选一个点即为这个点不能在最大独立集中出现，将点权设为 -\\infty 即可。 强制不选某个点即为这个点必须在最大独立集中出现，将点权设为 +\\infty 并让总点权也加上 +\\infty 即可。 剩下的就是注意常数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])const int maxn = 1e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte;il void add(int u, int v){ to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}typedef long long ll;const ll INF = 1e15;il ll max(ll a, ll b) {return a &gt; b ? a : b;}template&lt;int row, int col&gt;struct Matrix{ ll ele[row][col]; Matrix() {}};template&lt;int m, int n, int p&gt; Matrix&lt;m, p&gt; operator*(Matrix&lt;m, n&gt; m1, Matrix&lt;n, p&gt; m2){ Matrix&lt;m, p&gt; ret;#define RET ret.ele#define M1 m1.ele#define M2 m2.ele memset(ret.ele, 0xcf, sizeof ret.ele); FOR(i, 0, m - 1) FOR(k, 0, n - 1) FOR(j, 0, p - 1) RET[i][j] = max(RET[i][j], M1[i][k] + M2[k][j]); return ret;#undef RET#undef m1#undef m2}Matrix&lt;2, 2&gt; ID, g[maxn];int n, m;ll p[maxn], sump;int dep[maxn], fa[maxn], size[maxn], son[maxn]; void dfs1(int u, int f){ dep[u] = dep[f] + 1, fa[u] = f, size[u] = 1; GO(u) { if (v == f) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son[u]]) son[u] = v; } return;}int top[maxn], end[maxn], dfn[maxn], nfd[maxn], dfnClock;ll f[maxn][2];void dfs2(int u, int topf){ top[u] = topf, dfn[u] = ++dfnClock, nfd[dfnClock] = u;//记录nfd是方便下面的线段树操作 if (!son[u])//叶子节点 { f[u][1] = p[u];//f值很容易得到 g[u] = ID;//g矩阵赋为单位矩阵 end[u] = u;//记录链底部 return; }#define G g[u].ele G[1][0] = p[u], G[1][1] = -INF;//初始化g矩阵 dfs2(son[u], topf); end[u] = end[son[u]];//更新链底 GO(u) { if (v == fa[u] || v == son[u]) continue; dfs2(v, v); G[0][0] = G[0][1] += max(f[v][0], f[v][1]);//更新g G[1][0] += f[v][0];//更新g } f[u][0] = G[0][0] + max(f[son[u]][0], f[son[u]][1]);//利用g更新f，以计算父亲的g和f f[u][1] = G[1][0] + f[son[u]][0]; return;#undef G}struct node{ int l, r; Matrix&lt;2, 2&gt; val;} tree[maxn &lt;&lt; 2];#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)il void pushup(int k){ tree[k].val = tree[L].val * tree[R].val; return;}void build(int i, int j, int k){ tree[k].l = i, tree[k].r = j; if (i == j) { tree[k].val = g[nfd[i]]; return; } build(i, M, L); build(M + 1, j, R); pushup(k); return;}Matrix&lt;2, 2&gt; query(int k, int x, int y){ int i = tree[k].l, j = tree[k].r; if (x &lt;= i &amp;&amp; y &gt;= j) return tree[k].val; Matrix&lt;2, 2&gt; ret = ID; if (x &lt;= M) ret = query(L, x, y); if (y &gt; M) ret = ret * query(R, x, y); return ret;}void modify(int k, int x, int p){ int i = tree[k].l, j = tree[k].r; if (i == j) { tree[k].val = g[p]; return; } if (x &lt;= M) modify(L, x, p); else modify(R, x, p); pushup(k); return;}Matrix&lt;2, 1&gt; query(int x){ Matrix&lt;2, 1&gt; ret;#define RET ret.ele RET[0][0] = 0, RET[1][0] = p[end[x]]; return query(1, dfn[x], dfn[end[x]]) * ret;#undef RET}void modify(int x, ll y){ Matrix&lt;2, 1&gt; f0, f1;#define G g[x].ele#define F0 f0.ele#define F1 f1.ele G[1][0] += y - p[x]; f0 = query(top[x]); p[x] = y; while (x) { modify(1, dfn[x], x); f1 = query(top[x]); x = fa[top[x]]; G[0][0] = G[0][1] += max(F1[0][0], F1[1][0]) - max(F0[0][0], F0[1][0]); G[1][0] += F1[0][0] - F0[0][0]; f0 = query(top[x]); } return;#undef G#undef F0#undef F1}int main(){ ID.ele[1][0] = ID.ele[0][1] = -INF; n = read(), m = read(), read(); FOR(i, 1, n) p[i] = read(), sump += p[i]; FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } dfs1(1, 0); dfs2(1, 1); build(1, n, 1); FOR(i, 1, m) { int a = read(), x = read(), b = read(), y = read(); if (!x &amp;&amp; !y &amp;&amp; (fa[a] == b || fa[b] == a)) { puts(\"-1\"); continue; } ll a0 = p[a], b0 = p[b], tmp = 0; if (!x) modify(a, INF), tmp += INF - a0; else modify(a, -INF); if (!y) modify(b, INF), tmp += INF - b0; else modify(b, -INF); Matrix&lt;2, 1&gt; ans = query(1);#define ANS ans.ele printf(\"%lld\\n\", sump - max(ANS[0][0], ANS[1][0]) + tmp); modify(a, a0), modify(b, b0);#undef ANS } return 0;} 其他做法 不会，先咕咕咕。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"动态dp","slug":"ddp","permalink":"https://old.blog.imyangty.com/tags/ddp/"}]},{"title":"P3959 [NOIP2017 提高组] 宝藏","slug":"sol-luogu-p3959","date":"2021-06-04T14:37:58.000Z","updated":"2022-03-23T04:18:30.962Z","comments":true,"path":"sol-luogu-p3959/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3959/","excerpt":"","text":"题意 有 n 个点组成的图，可以选择一个点作为出发点，试找到一个生成树使得总代价最小。每加一条边产生的代价为起始点到边的一段的点的个数乘上边长 n\\le 12 。 题解 这里是 O(3^nn) 的状压做法。分析这道题：很重要的一点就是代价是和树高息息相关的。所以有一些做法肯定是不行的。然后考虑这样子进行 dp： f_{S, l} 表示状态为 S ，树高为 l 的最小代价。然后每次转移的时候枚举 S 的子集 S' ，用 f_{S',l - 1} 转移 f_{S, l} 。 转移的计算：令 g_{s_1, S_2} 表示从状态 S_1 到状态 S_2 （其中 S_1\\subset S_2 ）的最小边长总和。很明显这个东西是可以提前计算的，于是转移方程就来了： f_{S, l} = \\min_{S'\\subset S}\\{f_{S', l - 1} + g_{S', S}\\times l\\} 至于 g_{S_1, S_2} 的计算， O(2^n) 枚举 S_2 ，然后枚举 S_2 的子集 S_1 。但是此时需要保证枚举顺序倒序的。就是若 S_1\\subset S_1' ，则 S_1' 必须比 S_1 先枚举到因为这样就可以只考虑单条边的加入。这一部分代码如下： 1234567891011121314FOR(i, 1, (1 &lt;&lt; n) - 1) { int v = 0; for (int s = ((1 &lt;&lt; n) - 1) ^ i, j = s; j; j = (j - 1) &amp; s)//枚举 i 的子集然后倒序记录 nxt[j] = v, v = j; for (int j = v; j; j = nxt[j])//从最小的集合开始枚举 { int x = lg[j &amp; -j] + 1, v = 3e6 + 5;//提出 j 内的最后一个点 x FOR(y, 1, n) if ((1 &lt;&lt; (y - 1)) &amp; i) v = min(v, e[x][y]);//考虑在 i 内的一个点 y，且 y 能与 x 相连 g[i][j] = g[i][j ^ (j &amp; -j)] + v;//这就是为什么要从小枚举。小的要贡献给大的 } } 同时这里有一个枚举 i 的子集的方法：for (int j = i; j; j = (j - 1) &amp; i)。原理比较的妙不可言。 总的代码就出来了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)const int maxn = 13, maxm = 1e3 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int min(int a, int b) {return a &lt; b ? a : b;}int e[maxn][maxn], n;int g[1 &lt;&lt; maxn][1 &lt;&lt; maxn], f[1 &lt;&lt; maxn][maxn], nxt[1 &lt;&lt; maxn], lg[1 &lt;&lt; maxn];int main(){ memset(e, 0x3f, sizeof e), memset(f, 0x3f, sizeof f); n = read(); FOR(i, 1, n - 1) lg[1 &lt;&lt; i] = i; int m = read(); while (m--) { int u = read(), v = read(), w = read(); if (e[u][v] &gt; w) e[u][v] = e[v][u] = w; } FOR(i, 1, (1 &lt;&lt; n) - 1) { int v = 0; for (int s = ((1 &lt;&lt; n) - 1) ^ i, j = s; j; j = (j - 1) &amp; s) nxt[j] = v, v = j; for (int j = v; j; j = nxt[j]) { int x = lg[j &amp; -j] + 1, v = 3e6 + 5; FOR(y, 1, n) if ((1 &lt;&lt; (y - 1)) &amp; i) v = min(v, e[x][y]); g[i][j] = g[i][j ^ (j &amp; -j)] + v; } } FOR(i, 1, n) f[1 &lt;&lt; (i - 1)][0] = 0; FOR(l, 1, n - 1) FOR(i, 1, (1 &lt;&lt; n) - 1) for (int j = i; j; j = (j - 1) &amp; i) f[i][l] = min(f[i][l], f[i ^ j][l - 1] + g[i ^ j][j] * l); int ans = 0x3f3f3f3f; FOR(l, 0, n) ans = min(ans, f[(1 &lt;&lt; n) - 1][l]); printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"2021年6月 OI学习记录","slug":"summary-2021-06","date":"2021-06-01T10:04:58.000Z","updated":"2022-04-14T08:17:33.148Z","comments":true,"path":"summary-2021-06/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-06/","excerpt":"","text":"前言 不再颓废，再战一年 学习内容 状压 dp 动态 dp AC 自动机 + dp AC 自动机与 fail 树 做题记录 21/06/01 P3829 [SHOI2012]信用卡凸包 旋转函数横纵坐标写反了有 50pts。。。 21/06/02 P3303 [SDOI2013] 淘金 设 f_{i, j, 0/1} 表示从小到大第 i 位，当前乘积为 j ，有没有卡着 n 的上界，顺推跑数位 dp。之后给每个元素记录一个指针，放进优先队列里面找结果。 21/06/03 P3694 邦邦的大合唱站队 状压 dp，考虑 S 为乐队排好的状态（0 为没有排，1 为排了），之后从小到大枚举状态，枚举最后一个位置的乐队 P1441 砝码称重 枚举每个状态然后 bitset P3092 [USACO13NOV]No Change G 状压， f_S 为硬币状态 S 能买到最多物品的个数 P3052 [USACO12MAR]Cows in a Skyscraper G 状压，设 f 和 g 两个 dp 数组求解 21/06/04 P2915 [USACO08NOV]Mixed Up Cows G 状压，状态内记入最后一个摆的牛（后效性） O(2^nn^2) P3959 [NOIP2017 提高组] 宝藏 思路比较清奇的状压 21/06/05 P4719 【模板】\"动态 DP\"&amp;动态树分治 动态 dp 21/06/06 SP1716 GSS3 - Can you answer these queries III P5024 [NOIP2018 提高组] 保卫王国 动态 dp 21/06/09 UVA1336 修缮长城 Fixing the Great Wall 区间 dp，注意结果是向下取整 21/06/10 P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并 线段树合并模板，注意一定是边遍历树边合并线段树边统计答案，因为线段树在合并之后就会发生奇怪的改变。 P3521 [POI2011]ROT-Tree Rotations 线段树合并 P3919 【模板】可持久化线段树 1（可持久化数组） 主席树初探 P3834 【模板】可持久化线段树 2（主席树） 静态区间第 k 小。对于每个位置都建上 [1, r] 的权值线段树（使用主席树），然后用差分的思想查询即可。 21/06/11 BZOJ #3545. [ONTAK2010]Peaks 并查集 + 权值树上二分 P2824 [HEOI2016/TJOI2016]排序 二分答案经典题 P5494 【模板】线段树分裂 线段树分裂。注意垃圾回收不要写炸 21/06/12 CF558E A Simple Task 线段树分裂，注意细节。 P5829 【模板】失配树 fail 树上的 lca 21/06/13 P4516 [JSOI2018]潜入行动 重在复杂度分析的树形背包， O(nk) ，转移方程平凡。需要注意细节的处理，要先复制一份 dp 数组，且注意 long long 问题。 CF490F Treeland Tour 线段树合并优化 dp 21/06/14 P3572 [POI2014]PTA-Little Bird 单调队列优化 dp。 P7114 [NOIP2020] 字符串匹配 Z 算法，思维好题。 21/06/15 P3426 [POI2005]SZA-Template KMP + dp，注意到 f_i = i 或 f_i = \\mathrm{fail}_i 。 f_i = \\mathrm{fail}_i 的充要条件是 \\exists j \\le i - \\mathrm{fail}_i 使得 f_j = f_{\\mathrm{fail}_i} 。因为从 j 到 i 最多接上 \\mathrm{fail}_i 个字符串。开桶记录最大位置即可。 P3041 [USACO12JAN]Video Game G AC 自动机 + dp，设 f_{i, u} 为长度为 i ，在 trie 上节点为 u 的最大收益。转移： f_{i, \\mathrm{ch}(u)} = \\max\\{f_{i - 1, u} \\} + \\mathrm{val}_{\\mathrm{ch}(u)} 。 21/06/16 CF808G Anthem of Berland KMP + DP，设 f_i 为到 i 为止的最大匹配数， g_i 为到 i 为止，最后一段强制为 T 的最大匹配数，有 g_i := f_{i - m} + 1 ， g_i = \\max_{j = \\mathrm{fail}(j)}\\{g_{i - m + j} + 1\\} UVA11022 String Factoring 区间 DP 和 KMP。使用 KMP 找子串的循环节，通过循环节进行转移。 P6216 回文匹配 KMP + Manacher 21/06/17 P4555 [国家集训队]最长双回文串 manacher。可以 O(n) 处理以 i 开头的最长回文子串长度 l_i 和以 i 结尾的 r_i ，枚举 \\texttt{#} 为断点统计答案即可。 P4052 [JSOI2007]文本生成器 容斥转化，用 26^m 减去不可读的状态数量。 21/06/18 P2414 [NOI2011] 阿狸的打字机 ACAM + fail 树 + dfs 序 + 树状数组 P3311 [SDOI2014] 数数 ACAM + 数位 dp，还是使用记忆化搜索 CF163E e-Government ACAM + fail 树 + dfs 序 + 树状数组 21/06/19 LOJ#144. DFS 序 1 dfs 序 + 树状数组 LOJ#145. DFS 序 2 dfs 序 + 树状数组 21/06/22 LOJ#146. DFS 序 3，树上差分 1 树上差分，修改路径，单点查询，子树查询。使用两个树状数组维护不同内容实现。 LOJ#147. DFS 序 4 树上前缀和，单点修改，子树修改，路径查询。使用两个树状数组维护不同内容实现。 21/06/23 CF1207G Indie Album 同阿狸的打字机 CF1202E You Are Given Some Strings... 枚举 T 的分界点，记作 f_1(i) 和 f_2(i) ，对模式串正反建 AC 自动机求出 f_1 和 f_2 。然后乘法原理合并答案得解。 P2444 [POI2000]病毒 在 Trie 图上面找环 21/06/24 P2292 [HNOI2004]L语言 AC 自动机 + dp，使用状压将长度为 10 压进 int 里面。 P5840 [COCI2015]Divljak 好题，fail 树 + 树链并 21/06/25 [P2150 NOI2015] 寿司晚宴 状压好题。由于大于 19 的质因子只可能有 1 个，所以把前八个质数状压起来，后面的单独进行考虑来 dp 就可以了。具体地，使用 f_1(S_1, S_2) 和 f_2(S_1, S_2) 两个数组，分别代表这个大质数选/不选的方案数。每处理完一种大质数就合并一下答案就行了。 21/06/26 [P4547 THUWC2017]随机二分图 妙不可言的状压期望 dp。由于期望的线性性，对于第 1 和第 2 种类型的边组，可以拆成两条概率为 1/2 的边和一组概率为 \\pm 1/4 的边组。这样子做是因为对于单条边，1/2 的贡献是一定有的，而对于边组，分别会少了和多出 1/4 的贡献。总状态数为 \\sum_{i = 1}^{n}\\binom n i^2 = \\binom{2n}n ，可以用 map 记录状态配合记忆化搜索卡过去。 ABC207 A + B + C 21/06/28 [ARC096D] Sweet Alchemy 树上差分之后变为价值很小，体积很大的多重背包，使用大范围贪心，小范围多重背包求解。 21/06/29 LOJ#6069. 「2017 山东一轮集训 Day4」塔 一种加数字 dp 的思想，矩阵快速幂求组合数。 CF704B Ant Man 神仙贪心题，增量构造法","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"ABC202F - Integer Convex Hull","slug":"sol-abc202f","date":"2021-05-27T13:34:21.000Z","updated":"2022-03-30T00:03:29.480Z","comments":true,"path":"sol-abc202f/","link":"","permalink":"https://old.blog.imyangty.com/sol-abc202f/","excerpt":"","text":"Description 平面内 N 个坐标均为整数的点，其中任意三点不共线，令所有点 P_i 构成一个全集 U ，子集 S\\subseteq U 且 |S|\\ge 3 。问凸包面积为整数的子集 S 的个数模 10^9 + 7 的值。 3\\le N\\le 80 。 Solution 比较神奇的题目。 考虑 Andrew 算法的执行流程：将所有点按照先 x 轴升序后 y 轴升序排序，然后从左往右弄出下凸包，再从右往左弄出上凸包。本题可以利用类似的思路。 然后我们由叉积计算面积的方法知道，整点三角形的面积乘二之后必然是整数。于是我们考虑依次用三角形弄出凸包，具体地，可以 dp： O(n) 枚举凸包最左端的端点 P_{s} 。 \\mathrm{upper}_{i,jk} ：凸包满足如下条件的点集 S 的数量： 从 P_s 顺时针考虑每个点，最后两个分别是 P_i 和 P_j ； 所有的点都在直线 P_sP_j 以上； 面积乘以二之后模二为 k 。 \\mathrm{lower}_{i,j,k} ：凸包满足如下条件的点集 S 的数量： 从 P_s 逆时针考虑每个点，最后两个分别是 P_i 和 P_j ； 所有的点都在直线 P_sP_j 以下； 面积乘以二之后模二为 k 。 确定每个最右端的点 P_j ，然后枚举 i 和 k 统计答案： \\mathrm{ans}_s = \\sum_{j = s + 1}^n\\sum_{k \\in \\{0, 1\\}}\\left(\\sum_{i}\\mathrm{upper}_{i,j,k} \\times \\sum_{i}\\mathrm{lower_{i,j,k}} \\right) 这样做的原理其实就是合并上下凸壳：根据上面设计的 dp 状态可知我们确定了左端点 P_s 和右端点 P_j 后，满足上凸壳的点集个数即为枚举倒数第二个点 i 然后求和的结果 \\sum_{i}\\mathrm{upper}_{i,j,k} ，满足下凸壳的点集个数即为 \\sum_i\\mathrm{lower}_{i,j,k} 。 怎么计算 \\mathrm{upper} 和 \\mathrm{lower} 呢？我们可以通过 \\mathrm{upper}_{i,j,k} 递推出 \\mathrm{upper}_{j,l,k} ，其原理就是判断 P_l 能否被加入凸壳中，能则更新，不能就更新 \\mathrm{lower}_{j,l,k} （加入下凸壳）。新加入的部分即为 \\triangle P_sP_jP_l ，需要根据这个面积的二倍的奇偶性判断更新哪个 k 。 这个做法要求我们提前预处理每个三角形的面积的二倍的奇偶性 \\mathrm{parity}_{i,j,k} 和三角形内点的个数 \\mathrm{inside}_{i,j,k} 。总时间复杂度 O(n^4) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 85;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}struct Point{ int x, y; Point() {} Point(int _x, int _y) {x = _x, y = _y;} il bool operator&lt;(const Point &amp;b) const {return x == b.x ? y &lt; b.y : x &lt; b.x;}} P[maxn];typedef Point Vector;struct modint{ typedef long long ll; const static ll mod = 1e9 + 7; ll val; modint(int _val = 0) {val = _val;} modint operator+(const modint &amp;b) const {return modint((val + b.val) % mod);} modint operator-(const modint &amp;b) const {return modint((val - b.val + mod) % mod);} modint operator*(const modint &amp;b) const {return modint((val * b.val) % mod);} modint operator+=(const modint &amp;b) {return *this = *this + b;} modint operator*=(const modint &amp;b) {return *this = *this * b;} modint operator-=(const modint &amp;b) {return *this = *this - b;} modint operator+(const int &amp;b) const {return modint((val + b) % mod);} modint operator-(const int &amp;b) const {return modint((val - b + mod) % mod);} modint operator*(const int &amp;b) const {return modint((val * b) % mod);} modint operator+=(const int &amp;b) {return *this = *this + b;} modint operator-=(const int &amp;b) {return *this = *this - b;} modint operator*=(const int &amp;b) {return *this = *this * b;}};il Vector operator-(const Point &amp;a, const Point &amp;b) {return Point(b.x - a.x, b.y - a.y);}il int operator^(const Vector &amp;a, const Vector &amp;b) {return a.x * b.y - a.y * b.x;}//叉积int area2(Point x, Point y, Point z)//返回面积的二倍{ return abs((y - x) ^ (z - x));}int n, parity[maxn][maxn][maxn], inside[maxn][maxn][maxn];modint pow2[maxn], upper[maxn][maxn][2], lower[maxn][maxn][2];int main(){ n = read(); FOR(i, 1, n) P[i].x = read(), P[i].y = read(); std::sort(P + 1, P + n + 1);//对点进行排序 FOR(i, 1, n) FOR(j, 1, n) FOR(k, 1, n) { if (i == j || j == k || i == k) continue; parity[i][j][k] = area2(P[i], P[j], P[k]) % 2;//更新面积奇偶性 FOR(l, 1, n)//枚举每个 l 点判断 l 在不在三角形内 if (l != i &amp;&amp; l != j &amp;&amp; l != k &amp;&amp; area2(P[i], P[j], P[k]) == area2(P[l], P[j], P[k]) + area2(P[i], P[l], P[k]) + area2(P[i], P[j], P[l])) inside[i][j][k] += 1; } pow2[0] = 1; FOR(i, 1, n) pow2[i] = pow2[i - 1] * 2;//预处理二的次幂 modint ans = 0; DEC(must, n, 1)//枚举最左边的端点 { FOR(i, must, n) FOR(j, must, n) FOR(k, 0, 1) upper[i][j][k] = lower[i][j][k] = 0;//清空数组 FOR(i, must + 1, n) upper[must][i][0] = lower[must][i][0] = 1;//边界条件 FOR(i, must, n) FOR(j, must + 1, n) FOR(k, 0, 1) FOR(l, j + 1, n) if (((P[l] - P[j]) ^ (P[j] - P[i])) &gt; 0)//加入上凸壳 upper[j][l][k ^ parity[must][j][l]] += upper[i][j][k] * pow2[inside[must][j][l]];//乘法原理 else lower[j][l][k ^ parity[must][j][l]] += lower[i][j][k] * pow2[inside[must][j][l]]; FOR(j, must + 1, n)//枚举最右端点 FOR(k, 0, 1) { modint up = 0, lo = 0;//上下凸壳 FOR(i, must, j - 1) up += upper[i][j][k], lo += lower[i][j][k]; ans += up * lo; } } printf(\"%d\\n\", (ans - n * (n - 1) / 2).val);//最后要去除线段的贡献 return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"计算几何","slug":"computational-geometry","permalink":"https://old.blog.imyangty.com/tags/computational-geometry/"},{"name":"凸包","slug":"convex-hull","permalink":"https://old.blog.imyangty.com/tags/convex-hull/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"AGC010C Cleaning","slug":"sol-agc010c","date":"2021-05-21T14:41:29.000Z","updated":"2022-03-30T00:04:02.585Z","comments":true,"path":"sol-agc010c/","link":"","permalink":"https://old.blog.imyangty.com/sol-agc010c/","excerpt":"","text":"Description 给定一棵树，每次操作选定两叶子节点并将路径上点权减一（操作前路径上的点权必须大于 0 ），问最后是否能使所有点权为 0 。 Solution 考虑一棵以 u 为根的子树。经过 u 节点的路径，无非两种：往上延伸的和内部配对的。我们设往上延伸的路径条数为 f_u ，内部消化的路径条数为 y 。则我们很容易发现： \\sum_{v\\in \\operatorname{son}(u)}f_v = 2y + f_u 而且 a_u = f_u + y 这样子，整棵树的 f_u 是唯一确定的。 判断合法性： 0\\le f_u\\le a_i 是必须满足的。其次对于我们内部两两配对的对数 y ，一定要满足： y \\le \\min(\\lfloor \\frac{\\sum{f_v}}{2}, \\sum f_v - \\max f_v) 这是一个经典结论，可以这么理解：下界肯定是很容易证明的，上界的存在是因为子树内不可能存在自己匹配自己的情况。所以要减去。 最后，根的 f 值必须为 0 ，叶的 f 值即为 a 值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])const int maxn = 1e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int max(int a, int b) {return a &gt; b ? a : b;}inline int min(int a, int b) {return a &lt; b ? a : b;}int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte, deg[maxn];int a[maxn], f[maxn], root;void add(int u, int v){ ++deg[v]; to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void dfs(int u, int fa){ if (deg[u] == 1) { f[u] = a[u]; return; } int s = 0, y, maxf = 0; GO(u) { if (v == fa) continue; dfs(v, u); s += f[v]; maxf = max(f[v], maxf); } y = s - a[u]; f[u] = s - 2 * y; if (f[u] &lt; 0 || f[u] &gt; a[u]) puts(\"NO\"), exit(0); if (y &gt; min(s - maxf, s / 2)) puts(\"NO\"), exit(0);}int main(){ n = read(); FOR(i, 1, n) a[i] = read(); if (n == 2) printf(\"%s\\n\", a[1] == a[2] ? \"YES\" : \"NO\"), exit(0); FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } FOR(i, 1, n) if (deg[root = i] &gt; 1) break; dfs(root, 0); if (f[root] != 0) puts(\"NO\"), exit(0); puts(\"YES\"); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"}]},{"title":"2019 CSP-S 题解","slug":"sol-csps2019","date":"2021-05-14T14:13:06.000Z","updated":"2022-03-23T04:18:30.748Z","comments":true,"path":"sol-csps2019/","link":"","permalink":"https://old.blog.imyangty.com/sol-csps2019/","excerpt":"","text":"前言 这场没来打，但看上去很不好打的样子。 已完结 on 2021/09/23 21:20。 D1T1 格雷码 Description 略 Solution 直接按照题意递归模拟即可，注意 2^{64} 超出了 long long 的范围，需要特判。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef unsigned long long ull;ull tmp[65];void work(ull n, ull k){ if (n == 1) return (void)printf(\"%d\", k); if (k &gt;= (1llu &lt;&lt; (n - 1))) printf(\"1\"), work(n - 1, tmp[n] - k); else printf(\"0\"), work(n - 1, k); return;}int main(){ FOR(i, 1, 63) tmp[i] = (1llu &lt;&lt; i) - 1; tmp[64] = (ull)(-1); ull n, k; scanf(\"%llu %llu\", &amp;n, &amp;k); work(n, k); return 0;} D1T2 括号树 Description 给定一棵树，每个节点上有一个括号 ( 或 )，定义 s_i 为根到 i 节点的简单路径上的括号组成的字符串，求出其连续子段中括号序列的数量 k_i ，输出 \\operatorname{xor}_{i = 1}^n (i\\times k_i) Solution 经典的括号匹配模型上了树。 让我们从根往下一步步走，并按照之前常用的括号匹配问题的套路把沿途的左括号压进栈里面。现在考虑一个点 u 是怎么贡献出合法的括号序列的，分 u 上为 ( 和 ) 两种情况讨论： 当 u 括号为 ( 的时候，不难发现 u 的答案肯定是从 fa_u 继承下来的，因为 ( 不可能再贡献出多的合法的序列，同时使这个括号入栈。 当 u 括号为 ) 的时候，让我们思考一下这个右括号加进来之后会有什么影响。首先如果栈里面还有括号，说明它可以匹配到一个合法的左括号，记为 x ，先退栈。然后这个 [x,u] 很明显会对之前的括号序列产生贡献。假设 x 之前有连续的 k 段括号序列，那么不难发现 u 的这个 ) 就会产生 k + 1 的贡献。把这个 k 在代码里面用 lst[u] 体现，就大致可以写出一个框架了。 但是要注意的是回溯问题。这个栈我们是进行动态调整的，所以如果在 u 的时候一开始退了栈那么回溯的时候就要把这个元素补回去，如果一开始有元素入了栈那么回溯的时候就要把这个元素退掉，否则就会对 u 的姐妹节点产生错误的贡献。 那么这题就做完了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cstring&gt;typedef long long ll;const int maxn = 5e5 + 5;char str[maxn];int n, fa[maxn];int head[maxn], to[maxn], nxt[maxn], cnt;int s[maxn], top;ll ans, lst[maxn], sum[maxn];void add(int u, int v){ to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return;}void dfs(int u){ int tmp = 0; if (str[u] == ')' &amp;&amp; top) lst[u] = lst[fa[tmp = s[top--]]] + 1; else if (str[u] == '(') s[++top] = u; sum[u] = sum[fa[u]] + lst[u]; for (int i = head[u]; i; i = nxt[i]) dfs(to[i]); if (tmp) s[++top] = tmp; else if (top) --top; return;}int main(){ scanf(\"%d\", &amp;n); scanf(\"%s\", str + 1); for (int i = 2; i &lt;= n; i++) { scanf(\"%d\", fa + i); add(fa[i], i); } dfs(1); for (ll i = 1; i &lt;= n; i++) ans ^= (sum[i] * i); printf(\"%lld\\n\", ans); return 0;} D1T3 树上的数 Description 给定一棵大小为 n 的树，节点从 1 到 n 编号，每个节点上有一个数字，这些数字构成一个 1 到 n 的排列。 进行 n - 1 次删边操作，每次删边都交换两个节点上的数字。最后所有边都被删掉，按照数字从小到大得到一个节点编号的排列 P ，最小化 P 的字典序。 Solution 10pts Brute Force O(n!) 枚举删边的顺序，然后暴力判断。 代码就不写了。 25pts Chain 首先不难发现这肯定是一个字典序贪心。我们可以依次从小到大依次考虑每个数字最后的点最小可以到哪里。然后就是想这个数字的移动有什么性质了。 假设我们要把数字 x 从点 a 移到点 b ，那么不难发现以下的条件需要得到满足： 首先 a 和 b 要联通 对于出发点 a ，我们必须保证 x 最先走的边最先被删去。因为如果其他边先被删的话 x 就跑到其他地方去了。 对于中间的任意点 u ，设入边为 i ， x 要走的出边为 j ，那么 j 必须紧挨着 i 之后被删，原因同理。 对于结束点 b ，我们必须保证 x 进来的入边最后被删去，原因同理。 不难发现，这是一系列关于选边顺序的条件。 而对于链这种点度至多为 2 的树，每个点无非就是两种选择：左边的边先删还是右边的边先删，对于这个性质打个标记，然后 O(n) 从小到大枚举数字，然后就让这个数字往左/往右一直走，找到合法的最优解然后打上标记就可以了。加上之前的暴力可以获得 35 分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define clr(__x) memset(__x, 0, sizeof __x)const int maxn = 2e3 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int min(int a, int b) {return a &lt; b ? a : b;}int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte, deg[maxn];int p[maxn], tag[maxn];void add(int u, int v){ ++deg[v]; to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void init(){ n = read(), cnte = 0; FOR(i, 1, n) p[i] = read(), head[i] = deg[i] = tag[i] = 0; FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } return;}int pos[maxn], id[maxn], cnt;void dfs(int u, int fa){ id[++cnt] = u, pos[u] = cnt; GO(u) if (v != fa) dfs(v, u); return;}int main(){ int T = read(); while (T--) { init(); if (n == 1) { printf(\"1\\n\"); continue; } int root = 0; FOR(i, 1, n) if (deg[i] == 1) root = i; cnt = 0; dfs(root, 0); FOR(i, 1, n) { int x = p[i], b = pos[x]; int to = n + 1; if (tag[b] != 1) { FOR(j, b + 1, n) { if (tag[j] != 1) to = min(to, id[j]); if (tag[j] == 2) break; } } if (tag[b] != 2) { DEC(j, b - 1, 1) { if (tag[j] != 2) to = min(to, id[j]); if (tag[j] == 1) break; } } if (pos[to] &gt; b) { FOR(j, b + 1, pos[to] - 1) tag[j] = 1; tag[b] = tag[pos[to]] = 2; } else { FOR(j, pos[to] + 1, b - 1) tag[j] = 2; tag[b] = tag[pos[to]] = 1; } tag[1] = tag[n] = 0; printf(\"%d \", to); } puts(\"\"); } return 0;} 25pts Star 然后考虑菊花图的部分分。我们还是考虑一个数字 x 从 a 到 b 的情况。 如果 a 和 b 均不为根，那么 x 经过的点即为 a\\to r\\to b ，其中 r 为根。假设这两条边分别为 i 和 j ，那么有一个很显然的结论就是 j 必须紧接着 i 后面删掉。 如果 a 为根，那么这条边必须是第一个被删掉的。 如果 b 为根，那么这条边必须是最后一个被删掉的。 这样子一列出来就可以看得出，这些删边顺序是可以用一个双向链表来进行维护的。而且为了这个链表中途不接出环来，我们需要一个并查集来维护连通性。时间复杂度 O(n^2\\alpha(n)) 。 细节比较繁冗，注意实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])#define clr(__x) memset(__x, 0, sizeof __x)const int maxn = 2e3 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int min(int a, int b) {return a &lt; b ? a : b;}int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte, deg[maxn];int p[maxn], pre[maxn], suf[maxn];int anc[maxn];inline int find(int u) {return u == anc[u] ? u : anc[u] = find(anc[u]);}void add(int u, int v){ ++deg[v]; to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void init(){ n = read(), cnte = 0; FOR(i, 1, n) p[i] = read(), head[i] = deg[i] = 0; FOR(i, 1, n + 1) anc[i] = i, pre[i] = suf[i] = 0; FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); } return;}int main(){ int T = read(); while (T--) { init(); if (n == 1) { printf(\"1\\n\"); continue; } int root; FOR(i, 1, n) if (deg[i] == n - 1) root = i; FOR(i, 1, n) { int from = p[i]; FOR(to, 1, n) { bool ok = 1; if (from != root &amp;&amp; to != root) { if (pre[to] || suf[from]) ok = 0; if (find(from) == find(to) &amp;&amp; i &lt; n) ok = 0; if (ok) pre[to] = from, suf[from] = to, anc[find(from)] = find(to); } else if (from == root &amp;&amp; to != root) { if (pre[to] || suf[n + 1]) ok = 0; if (find(to) == find(n + 1)) ok = 0; if (ok) pre[to] = n + 1, suf[n + 1] = to, anc[find(to)] = find(n + 1); } else if (from != root &amp;&amp; to == root) { if (suf[from] || pre[n + 1]) ok = 0; if (find(from) == find(n + 1)) ok = 0; if (ok) suf[from] = n + 1, pre[n + 1] = from, anc[find(from)] = find(n + 1); } else if (from == to &amp;&amp; from == root) ok = 0; if (ok) { printf(\"%d \", to); break; } } } puts(\"\"); } return 0;} 40pts Normal Tree 最后拔刀抽向正解。通过上面的分析我们已经知道我们需要解决的无非是对于一个点而言： 某边最先被删 某边挨着某边被删 某边最后被删 依次枚举，问这个约束是否有解。 我们可以依旧像之前那样，但现在我们需要对每个节点开一个链表+并查集，然后就考虑这个点的约束能否满足。实现就变得复杂了起来。 具体地，每次考虑一个数字能到达的最小编号的点。就在从这个数字开始 dfs 的过程中依次判断。判断的过程跟之前的其实也类似： 对于出发点，其出发边必须是第一个被删掉的 对于中间的点， j 必须紧挨着 i 被删掉 对于结束点，入边必须是最后一个被删掉的 但是还有需要补充的点：就是删边的这个链表的长度必须等于点度，不能出现“提前自闭”的情况，否则有一些边就不会被删了。所以 在处理出发点时，出发边的后面如果接有结束边，注意其不能提前自闭（体现在代码里面就是只能有一条边没有删去） 在处理结束点时，结束边的前面如果接有出发边，注意其不能提前自闭 在中间点时，如果要把 i 和 j 连接，且 i 与出发边相连， j 与结束边相连，则同样注意不能自闭（体现在代码里面就是只能有两条边没有删去） 我们来总结一下这个比较复杂的算法流程： 从 1 到 n 枚举每个数字 从该数字一开始的位置开始 dfs 结束点显然不可能在起始点 对于已经到达的 u ，判断能否成为结束点，能的话存进临时答案 从 u 枚举出边，判断这条出边是否合法 作为出发边 首先出发边前面不能接其他边 出发边后面接结束边的话不能提前自闭 作为中间边 首先初始边不能接在结束边之后 i 和 j 不能已经连起来 i 后面不能连边， j 前面不能连边 i 和 j 不能提前自闭 找到结束点之后，再次 dfs，更新每个节点对应的链表和并查集，同时删边 输出结束点编号 然后就是写代码了。这个算法的复杂度是 O(n^2\\alpha(n)) ，虽然比较慢但是写着还算方便，代码内有详细注释。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define GO(u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])const int maxn = 2e3 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int min(int a, int b) {return a &lt; b ? a : b;}int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte, deg[maxn];int p[maxn];void add(int u, int v){ ++deg[v]; to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}struct node{ int fi, la; int pre[maxn], suf[maxn], anc[maxn]; void clear() { fi = la = 0; FOR(i, 1, n) pre[i] = suf[i] = anc[i] = 0, anc[i] = i; } int find(int u) {return anc[u] == u ? u : anc[u] = find(anc[u]);} bool ask(int u, int v) {return find(u) == find(v);} void uni(int u, int v) {if (!ask(u, v)) anc[find(v)] = find(u);}} t[maxn];void init(){ n = read(); FOR(i, 1, n) p[i] = read(), head[i] = deg[i] = 0, t[i].clear(); cnte = 1; FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v), add(v, u); }}int dfs(int u, int fa){ int res = n + 1; if (fa != n + 1 &amp;&amp; !t[u].la &amp;&amp; !t[u].suf[fa] &amp;&amp; !(t[u].fi &amp;&amp; deg[u] &gt; 1 &amp;&amp; t[u].ask(fa, t[u].fi))) res = u; //判断作为结束点。首先结束边不能确定过，而且 fa 不能有后继边 //后面一句是判断提前自闭的情况，因为如果确定它为结束边，且它与起始边相连，则可能中间会有没有考虑到的边 GO(u) { if (v == fa) continue; if (fa == n + 1)//u 为起始点 { if (!t[u].fi)//首先初始边不能已经指定过 { if (t[u].pre[v]) continue;//v边也不能有前驱 if (t[u].la &amp;&amp; deg[u] &gt; 1 &amp;&amp; t[u].ask(v, t[u].la)) continue;//提前自闭的情况 res = min(res, dfs(v, u)); } else continue; } else { if (t[u].fi == v || t[u].la == fa || t[u].ask(v, fa)) continue;//初始边肯定不能接在结束边后，而且这两条边不能已经连起来 if (t[u].pre[v] || t[u].suf[fa]) continue;//如果不能接起来 if (t[u].fi &amp;&amp; t[u].la &amp;&amp; deg[u] &gt; 2 &amp;&amp; t[u].ask(t[u].fi, fa) &amp;&amp; t[u].ask(t[u].la, v)) continue;//两者接起来之后不能提前自闭 res = min(res, dfs(v, u)); } } return res;}bool update(int u, int fa, int dest){ if (u == dest) { t[u].la = fa; return true; } GO(u) { if (v == fa) continue; if (update(v, u, dest)) { if (fa == n + 1) t[u].fi = v; else t[u].uni(fa, v), t[u].suf[fa] = v, t[u].pre[v] = fa, --deg[u]; return true; } } return false;}int main(){ int T = read(); while (T--) { init(); if (n == 1) { printf(\"1\\n\"); continue; } FOR(i, 1, n) { int ans = dfs(p[i], n + 1); update(p[i], n + 1, ans); printf(\"%d \", ans); } puts(\"\"); } return 0;} D2T1 Emiya 家的饭 Description Emiya 会 n 种烹饪方法和处理 m 种主要食材。Emiya 做菜一定会用一种烹饪方法和一种主要食材，具体地，用第 i 种方法处理 j 号主要食材可以做出 a_{i,j} 种菜。现在他要做 k 道菜，需要满足： k\\ge1 每道菜的烹饪方法互不相同 每种主要食材最多使用 \\lfloor k/2\\rfloor 次 求所有满足要求的做菜方案数。 Solution Analysis 注意到 k 至少为 2，然后第二个要求非常好处理，而第三个要求比较困难。 正难则反，先求出一共能做出多少种搭配，然后减去不合法的方案即可。由加法原理和乘法原理知一共能做出来的即为 \\displaystyle\\prod_{i=1}^n(\\sum_{j=1}^ma_{i,j}+1)-1 。（减去的 1 为什么都不做） 接下来就可以考虑怎么处理第三个要求了。 84pts O(n^3m) 然后，我们可以发现不满足要求的食材有且仅有一样（显然），所以可以枚举这个不满足要求的食材，然后进行 dp 求解。 设 f_{i,j,k} 为正在处理第 p 样食材，考虑前 i 个方法，使用其余食材做了 j 道菜，用第 p 样食材做了 k 道菜的方案数。 则由乘法原理和加法原理得到 f_{i,j,k}=f_{i-1,j,k}+f_{i-1,j-1,k}\\times (s_i-a_{i,p})+f_{i-1,j,k-1}\\times a_{i,p} 其中 s_i=\\sum_j a_{i,j} 然后只需要枚举 j 和 k 并减掉不合要求的方案数即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;//...ll a[maxn][maxm], s[maxn]; //n 方法，m食材ll ans = 1;ll f[maxn][maxn][maxn]; //考虑到第 a 种食材，前 i 种方法，其余做了 j 道菜，剩下 k 道是用当前食材做的int main(){ n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) a[i][j] = read(), s[i] = (s[i] + a[i][j]) % mod; ans = ans * (s[i] + 1) % mod; } ans = (ans - 1ll) % mod; //先减掉全部选的方案 for (int gg = 1; gg &lt;= m; ++gg) //枚举每一种食材 { memset(f, 0, sizeof f); f[0][0][0] = 1; //边界 for (int i = 1; i &lt;= n; ++i) for (int j = 0; j &lt;= n; ++j) for (int k = 0; k &lt;= n; ++k) { if (j + k &gt; i) break; ll tmp1 = 0, tmp2 = 0, tmp3 = 0; tmp1 = f[i - 1][j][k]; if (j &gt; 0) //防止访问负下标而 RE tmp2 = f[i - 1][j - 1][k] * (s[i] - a[i][gg]) % mod; if (k &gt; 0) //防止访问负下标而 RE tmp3 = f[i - 1][j][k - 1] * a[i][gg] % mod; f[i][j][k] = tmp1 + tmp2 + tmp3; f[i][j][k] %= mod; } ll tmp = 0; //记录不合法方案数 for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= n; ++j) { ll tot = i + j; if (tot &gt; n) break; if (j &lt;= (tot &gt;&gt; 1)) continue; tmp += f[n][i][j], tmp %= mod; } ans = (ans - tmp + mod) % mod; //取模注意防止负数出现 } printf(\"%lld\\n\", ans); return 0;} 100pts O(n^2m) 考虑优化之前 O(n^3m) 的 dp，注意到我们如果想要判断一个方案合不合法，根本就不需要知道 j 和 k 具体的值，只需知道用 p 做出来的菜比其他的多多少，只要这个差量 \\Delta&gt;0 ，说明就是不合法的。 定义 f_{i,j} 为考虑前 i 种烹饪方法，用 p 做出来菜的数量比用其他菜做的数量多 j 道的方案数， j 可能为负，需要防止数组越界 转移方程： f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\\times a_{i,p}+f_{i-1,j+1}\\times(s_i-a_{i,p}) 最后不合法的方案数就是 \\sum_{j&gt;0}f_{n,j} 。 1234567891011121314151617181920212223242526272829303132//...#define f(i, j) f[i][j + maxn]//...ll a[maxn][maxm], s[maxn]; //n 方法，m食材ll ans = 1;ll f[maxn][maxn &lt;&lt; 1];int main(){ n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) a[i][j] = read(), s[i] = (s[i] + a[i][j]) % mod; ans = ans * (s[i] + 1) % mod; } ans = (ans - 1ll) % mod; for (int gg = 1; gg &lt;= m; ++gg) { memset(f, 0, sizeof f); f(0, 0) = 1; for (int i = 1; i &lt;= n; ++i) for (int j = -i; j &lt;= i; ++j) f(i, j) = (f(i - 1, j) + f(i - 1, j - 1) * a[i][gg] + f(i - 1, j + 1) * (s[i] - a[i][gg])) % mod; for (int j = 1; j &lt;= n; ++j) ans = (ans - f(n, j) + mod) % mod; } printf(\"%lld\\n\", ans); return 0;} D2T2 划分 Description 给定 n 和 \\{a_i\\} 。找到一些分界点 1\\le k_1 &lt; k_2 &lt; k_3 &lt; \\cdots &lt; k_p &lt; n ，使得 \\sum_{i = 1}^{k_1}a_i\\le \\sum_{i = k_1 + 1}^{k_2}a_i\\le \\cdots\\le \\sum_{i = k_p + 1}^n a_i 注意 p 可能为 0 ， k_0 = 0 。 请最小化 \\left(\\sum_{i = 1}^{k_1}a_i\\right)^2 + \\left(\\sum_{i = k_1 + 1}^{k_2}a_i\\right)^2 + \\cdots + \\left(\\sum_{i = k_p + 1}^{n}a_i\\right)^2 2\\le n\\le 4\\times 10^7 ，答案不一定在 unsigned long long 范围内。 Solution 首先 O(n^3) 的暴力不难想到，令 f(i, j) 为前 i 个数，最后一个划分点为 j 的最小代价，则 f(i, j) = \\min\\{f(j, k) + (s_i - s_j)^2\\} 于是 36pts 到手。 123456789101112131415161718192021int main() { read(n); int type; read(type); if (!type) FOR(i, 1, n) read(a[i]), a[i] += a[i - 1]; else gen(); memset(f, 0x3f, sizeof f); f[0][0] = 0; FOR(i, 1, n) { FOR(j, 0, i - 1) { FOR(k, 0, j) { if (a[i] - a[j] &gt;= a[j] - a[k]) f[i][j] = min(f[i][j], f[j][k] + (a[i] - a[j]) * (a[i] - a[j])); } } } ll ans = 4e18; FOR(i, 0, n - 1) ans = min(ans, f[n][i]); print(ans); return output(), 0;} O(n^2) 的做法：考虑优化上面的那个 dp。 根据完全平方公式 a^2 + b^2 &lt; (a + b)^2 ，我们可以感性理解一下：最后一段越小越优。令 g_i 为将 [1, i] 最优划分后，最后一段的 (j, i] 的 j 。即 g_i = \\max_{s_i - s_j\\ge s_j - s_{g_j}}\\{j\\} 每次求 g_i 的过程是 O(n) 的，然后可以直接用 g_i 求 f_i ，64pts 到手。 123456789101112131415161718int main() { read(n); int type; read(type); if (!type) FOR(i, 1, n) read(a[i]), a[i] += a[i - 1]; else gen(); f[1] = a[1] * a[1], g[1] = 0; FOR(i, 2, n) { DEC(j, i - 1, 1) if (a[i] - a[j] &gt;= a[j] - a[g[j]]) { g[i] = j; break; } f[i] = f[g[i]] + (a[i] - a[g[i]]) * (a[i] - a[g[i]]); } print(f[n]); return output(), 0;} 能想到这里之后离 100pts 就很近了。 \\begin{aligned} s_i - s_j &amp;\\ge s_j - s_{g_j}\\\\ s_i &amp;\\ge 2s_j - s_{g_j} \\end{aligned} 令 w(i) = 2s_i - s_{g_i} ，我们每次需要找的就是最大的 j 使得 w(j)\\le s_i 。发现对其维护一个单调递减的单调队列就行了。但是答案会爆 long long，用 __int128 可能会被卡空间，所以需要精细实现下，只记录每个转移点 g_i ，最后统一算答案。 严谨的证明就咕了吧。 12345678910111213141516171819202122232425262728293031323334353637383940using int128 = __int128;using ll = long long;using uint = unsigned int;const int maxn = 4e7 + 5;int n, m, g[maxn], q[maxn], head, tail;ll s[maxn];uint b[maxn], x, y, z;void gen() { static const uint msk = (1ll &lt;&lt; 30) - 1; read(x), read(y), read(z), read(b[1]), read(b[2]), read(m); FOR(i, 3, n) b[i] = (x * b[i - 1] + y * b[i - 2] + z) &amp; msk; int i = 1; FOR(j, 1, m) { int p, l, r; read(p), read(l), read(r); for (; i &lt;= p; ++i) s[i] = s[i - 1] + b[i] % (r - l + 1) + l; } return;}il ll w(int i) {return 2 * s[i] - s[g[i]];}int main() { read(n); int type; read(type); if (!type) FOR(i, 1, n) read(s[i]), s[i] += s[i - 1]; else gen(); q[head = tail = 1] = 0; FOR(i, 1, n) { while (head &lt; tail &amp;&amp; w(q[head + 1]) &lt;= s[i]) ++head; g[i] = q[head]; while (head &lt;= tail &amp;&amp; w(q[tail]) &gt;= w(i)) --tail; q[++tail] = i; } int128 ans = 0, one = 1; for (int now = n; now; now = g[now]) ans += one * (s[now] - s[g[now]]) * (s[now] - s[g[now]]); print(ans); return output(), 0;} D2T3 树的重心 Description 定义一棵节点数为 n 树的重心为 c 当且仅当删去 c 后分裂出的各个子树的大小均不大于 \\lfloor n/ 2\\rfloor 。一棵树的重心只可能有一个或两个。 给定大小为 n 的树 S ，枚举每条边 (u, v) ，求单独删去每条边后分裂出的两子树的重心编号之和之和。即： \\sum_{(u, v)\\in E}\\left(\\sum_{\\substack{1\\le x\\le n\\\\x\\text{ is the centroid of }S_{u'}}}x + \\sum_{\\substack{1\\le y\\le n\\\\y\\text{ is the centroid of }S_{v'}}}y\\right) 7\\le n\\le 3\\times 10^5 - 1 。 Solution n^2 暴力比较显然，就不说了。考虑断开 (x, y) 边（ \\operatorname{dep}(x) &gt; \\operatorname{dep}(y) ）。 接着这个 n^2 暴力，我们发现这题似乎很换根？因为子树和非子树都会产生贡献。 有一个很重要的性质：若考虑 x 子树，若 x 的重心不在 x ，则其一定在 x 的重链上（若其不在 x 的重链上，则其显然不满足重心的性质）。 那么我们要找 x 子树的重心，就直接维护一个倍增数组然后往重链下面跳就行了。现在问题就是如何找 x 子树往上的重心。 换根。把根换到 y 。用完全一样的方法维护就可以了。具体地，需要维护一下次重儿子，然后如果 x 是 y 的重儿子，那么就用次重儿子和 \\operatorname{fa}(y) 去更新 y 的重儿子，否则用 y 的重儿子去更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)#define GO(i, u) for (int i = head[u], v = to[i]; i; i = nxt[i], v = to[i])namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}void read(char *s) { int p = 0; char c = getchar(); while (!isdigit(c) &amp;&amp; !isalpha(c)) c = getchar(); while (isalpha(c) || isdigit(c)) s[p++] = c, c = getchar(); return;}char obuf[maxc], *__pO = obuf;il void putchar(char c) {*__pO++ = c;}template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return;}void output() {fwrite(obuf, __pO - obuf, 1, stdout);}} // namespace fastIOusing namespace fastIO;const int maxn = 3e5 + 5;int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt;int son1[maxn], son2[maxn], size[maxn], f[maxn][19];long long ans;il void add(int u, int v) { to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return;}void reset(int u) { for (int d = 1; f[u][d]; ++d) f[u][d] = 0; f[u][0] = son1[u]; for (int d = 1; f[u][d - 1]; ++d) f[u][d] = f[f[u][d - 1]][d - 1]; return;}void dfs1(int u, int fa) { size[u] = 1; son1[u] = son2[u] = 0; GO(i, u) { if (v == fa) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; size[son1[u]]) son2[u] = son1[u], son1[u] = v; else if (size[v] &gt; size[son2[u]]) son2[u] = v; } reset(u); return;}void calc(int u) { int d, p = u; for (d = 0; f[u][d]; ++d); while ((--d) &gt;= 0) { if ((size[f[p][d]] &lt;&lt; 1) &gt; size[u]) p = f[p][d]; } ans += p; if (f[p][0] &amp;&amp; (size[f[p][0]] &lt;&lt; 1) &gt;= size[u]) ans += f[p][0]; return;}void dfs2(int u, int fa) { int son0 = son1[u], size0 = size[u]; GO(i, u) { if (v == fa) continue; calc(v); size[u] = n - size[v]; son1[u] = son0 == v ? son2[u] : son0; if (size[son1[u]] &lt; n - size0) son1[u] = fa; reset(u); calc(u); dfs2(v, u); } son1[u] = son0, size[u] = size0; reset(u);}int main() { int T; read(T); while (T--) { memset(head, 0, sizeof head); cnt = 0, ans = 0; read(n); FOR(i, 1, n - 1) { int u, v; read(u), read(v); add(u, v), add(v, u); } dfs1(1, 0); dfs2(1, 0); print(ans), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"单调队列","slug":"mono-queue","permalink":"https://old.blog.imyangty.com/tags/mono-queue/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"},{"name":"倍增","slug":"binary-lifting","permalink":"https://old.blog.imyangty.com/tags/binary-lifting/"},{"name":"树的重心","slug":"centroid","permalink":"https://old.blog.imyangty.com/tags/centroid/"},{"name":"换根dp","slug":"root-changing-dp","permalink":"https://old.blog.imyangty.com/tags/root-changing-dp/"}]},{"title":"Lucas 定理","slug":"note-lucas","date":"2021-05-10T13:25:50.000Z","updated":"2022-04-14T08:17:33.152Z","comments":true,"path":"note-lucas/","link":"","permalink":"https://old.blog.imyangty.com/note-lucas/","excerpt":"","text":"本文停止维护，更多内容详见数论总结。 前言 本文主要介绍了 Lucas 定理及其扩展，并附以若干道相关习题。 鉴于作者没有 MO 背景，写出来的东西可能更偏向 OI 的做题应用，望各位大佬海涵 qwq。 公式可能偏多，但是只要静下心来慢慢读还剩可以读得懂的 qwq。 本文用到了的前置知识： 简单的排列组合 普及~提高的数论知识 二项式定理 简单的生成函数知识 乘法逆元 中国剩余定理（CRT） 欧拉定理（可选，习题涉及） 整除分块（习题涉及其思想） 普通 Lucas（模数为质数） 问题描述 求 \\binom n m\\bmod p 的值，其中 n 和 m 可以很大， p 为一个不大的质数。 结论（Lucas 定理） \\binom n m \\equiv \\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor}\\cdot \\binom{n\\bmod p}{m\\bmod p}\\pmod p 体现在程序中就是： \\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor} 可以递归求解， \\binom{n\\bmod p}{m\\bmod p} 可以直接算，时间复杂度为 O(f(p) + g(n)\\log n) ，其中 f(p) 为预处理组合数的时间复杂度， g(n) 为单次询问组合数的时间复杂度。 证明 参考了 OI-Wiki 的证明并加以了自己的说明和补充。 引理 首先考虑 \\binom p n \\bmod p 的取值，注意到展开组合数之后其为如下形式： \\frac{p!}{n!(p-n)!}\\bmod p 而显然，由于分子中 p! 是一定有质因子 p 的，所以只有当 n = 0\\lor n = p 的时候（即 p! 能被消干净）整体的结果为 1 ，否则为 0 。即 \\binom p n\\bmod p = [n = 0\\lor n = p] 进而我们可以得到 \\begin{aligned} (a + b)^p&amp;=\\sum_{n = 0}^p\\binom p na^nb^{p - n}\\\\ &amp;\\equiv \\sum_{n= 0}^p[n = 0\\lor n = p]a^nb^{p - n}\\\\ &amp;\\equiv a^p + b^p\\pmod p \\end{aligned} 然后将其推广到二项式的情况， \\begin{aligned} (ax^n + bx^m)^p&amp;\\equiv a^px^{np} + b^px^{mp}\\\\ &amp;\\equiv ax^{np} + bx^{mp} \\end{aligned} 即我们可以直接把指数 p 给提进来。 证明 代码实现 123456int lucas(int n, int m){ if (!m) return 1; return 1ll * lucas(n / p, m / p) * C(n % p, m % p) % p;} 写的时候注意边界 m = 0 即可，然后对于 \\displaystyle\\binom{\\lfloor\\frac n p\\rfloor}{\\lfloor\\frac m p\\rfloor} 用 Lucas 定理继续递归计算，而右边的 \\displaystyle\\binom{n\\bmod p}{m\\bmod p} 因为 p 较小，直接求即可。 总的实现：洛谷 P3807 【模板】卢卡斯定理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}const int maxn = 3e5 + 5;int n, m, p, fact[maxn];int qpow(int base, int p, int mod){ int ret = 1; for (; p; p &gt;&gt;= 1, base = 1ll * base * base % mod) if (p &amp; 1) ret = 1ll * ret * base % mod; return ret;}int C(int n, int m){ if (m &gt; n) return 0; return 1ll * fact[n] * qpow(1ll * fact[m] * fact[n - m] % p, p - 2, p) % p;}int lucas(int n, int m){ if (!m) return 1; return 1ll * lucas(n / p, m / p) * C(n % p, m % p) % p;}int main(){ int T = read(); while (T--) { m = read(), n = read() + m, p = read(); fact[0] = 1; FOR(i, 1, 3e5) fact[i] = 1ll * i * fact[i - 1] % p; printf(\"%d\\n\", lucas(n, m)); } return 0;} Lucas 定理的另一种证明 参考了**冯志刚版《初等数论》**第37页。这个应该是大多数 MOer 先接触到的 Lucas 定理的版本。 Lucas 定理的另一形式 对于整数 a ， b 和素数 p ，若 \\begin{aligned} a &amp;= \\sum_{i = 0}^k a_ip^i\\\\ b &amp;= \\sum_{i = 0}^k b_ip^i \\end{aligned} （相当于把 a 和 b 在 p 进制下表示）则 \\binom ab\\equiv\\prod_{i = 0}^k\\binom{a_i}{b_i}\\pmod p 那么它和之前提到的 \\binom a b\\equiv\\binom{\\lfloor\\frac ap\\rfloor}{\\lfloor\\frac bp\\rfloor}\\binom{a\\bmod p}{b\\bmod p}\\pmod p 为什么是等价的呢？ 这样子考虑，对 p 取模相当于取了 p 进制下的最低位，而除以 p 向下取整就相当于 p 进制下去掉最后一位，反复套用就发现两个形式是等价的了。 证明 记号约定：设 \\displaystyle f(x) = \\sum_{i = 0}^na_ix^i ， \\displaystyle g(x) = \\sum_{i = 0}^nb_ix^i 均为整系数多项式，若对于 \\forall 0\\le i\\le n ，都有 a_i\\equiv b_i\\pmod m ，则称 f(x) 与 g(x) 对模 m 同余，记作 f(x)\\equiv g(x)\\pmod m 。注意到若 f(x)\\equiv g(x)\\pmod m ，则对于 \\forall a\\in \\mathbb Z ，都有 f(a)\\equiv g(a)\\pmod m 。 由于 p 为素数，可知对于 1\\le j\\le p - 1 ，都有 \\binom p j = \\frac pj\\binom{p - 1}{j - 1}\\equiv0\\pmod p 所以 \\begin{aligned} (1 + x)^p &amp;= 1 + \\binom p1x + \\cdots + \\binom{p}{p - 1}x^{p - 1} + x^p\\\\ &amp;\\equiv 1 + x^p\\pmod p \\end{aligned} 利用这个结论，有 \\begin{aligned} (1 + x)^a &amp;= (1 + x)^{a_0}((1 + x)^p)^{a_1}\\cdots((1 + x)^{p^k})^{a_k}\\\\ &amp;\\equiv (1 + x)^{a_0}(1 + x^p)^{a_1}\\cdots(1 + x^{p^k})^{a_k}\\pmod p \\end{aligned} 观察右边展开后得到的结果。发现每个括号中有且仅有一项对 x^b 的系数产生了贡献（根据 p 进制数的性质），再结合二项式定理，故 \\binom ab\\equiv\\prod_{i = 0}^k\\binom{a_i}{b_i}\\pmod p exLucas（模数不一定为质数） 继续之前，假定读者已熟练掌握乘法逆元和 CRT。 这个东西除了和 Lucas 定理长得像之外和 Lucas 就没有半毛钱关系了，而且比 Lucas 阴间 n 多倍 问题描述 求 \\binom nm\\bmod p 的值。其中 p 不一定为质数且 p 较小。 问题求解 参考了 OI-Wiki 并加以自己的说明和补充。 Part 1 使用唯一分解定理分解模数 p 得到： p = \\prod_{i = 1}^rq_i^{k_i} 然后由于 q_i^{k_i} 和 q_j^{k_j} 两两互质，所以可以构造如下的同余方程组 \\begin{cases}x\\equiv\\dbinom n m\\pmod{q_1^{k_1}}\\\\x\\equiv\\dbinom n m\\pmod{q_2^{k_2}}\\\\\\quad\\cdots\\\\x\\equiv\\dbinom n m\\pmod{q_r^{k_r}}\\end{cases} 然后用 CRT 合并解即可。 Part 2 现在的问题变成了求 \\displaystyle\\binom n m \\bmod{q^k} （ q 为质数）的值。拆开组合数的式子，我们发现： \\binom n m \\equiv \\frac{n!}{m!(n - m)!}\\pmod{q^k} 然而下面那个东西不一定能算模 q^k 意义下的乘法逆元，那么我们就把所有的 q 提出来： \\frac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\frac{(n - m)!}{q^z}}q^{x - y - z}\\bmod q^k 其中 x 表示 n! 中质因子 q 的次数， y 和 z 同理。这样子分数线下面的式子由于与 q^k 互质，就可以求逆元了。 Part 3 现在需要解决的就是求 f(n) \\equiv \\frac{n!}{q^x}\\pmod{q^k} 的值。 先考虑 n!\\bmod q^k 的值。以一个最常见的例子： n = 22 ， q = 3 ， k = 2 为例： \\begin{aligned} 22! = 1\\times2\\times3\\times4\\times5\\times6\\times7\\times8\\times9\\times10\\times11\\times12\\\\\\times13\\times14\\times15\\times16\\times17\\times18\\times19\\times20\\times21\\times22 \\end{aligned} 把所有 q 的倍数提取出来，即为 \\begin{aligned} 22! =&amp; (3\\times6\\times9\\times12\\times15\\times18\\times21)\\times1\\times2\\times4\\times5\\times7\\\\&amp;\\times8\\times10\\times11\\times13\\times14\\times16\\times17\\times19\\times20\\times22\\\\ =&amp;3^7\\times(1\\times2\\times3\\times4\\times5\\times6\\times7)\\times1\\times2\\times4\\times5\\times7\\\\&amp;\\times8\\times10\\times11\\times13\\times14\\times16\\times17\\times19\\times20\\times22\\\\ \\end{aligned} 注意一下这个分组 3^7 即为 q^{\\lfloor n/q\\rfloor} 还剩下一个 7! 即为 \\lfloor n/q\\rfloor! ，这一部分可以递归进行求解。 最后剩下来的就是 n! 中与 q 互质的部分的乘积。可以发现 1\\times2\\times4\\times5\\times7\\times8\\equiv10\\times11\\times13\\times14\\times16\\times17\\pmod{3^2} 所以其相当于就是一个循环节，我们再重新写一下 22! 的展开： 22! \\equiv 3^7\\times7!\\times(1\\times2\\times4\\times5\\times7\\times8)^2\\times(19\\times20\\times22)\\pmod{3^2} 关于循环节，可以这样理解： \\prod_{i,i\\perp q}^{q^k}i\\equiv\\prod_{i,i\\perp q}^{q^k}(i + tq^k)\\pmod{q^k} 其中 t\\in\\mathbb N^* 。这个循环节循环了 \\displaystyle\\left\\lfloor\\frac{n}{q^k}\\right\\rfloor 次，所以考虑暴力把 \\displaystyle\\prod_{i,i\\perp q}^{q^k}i 求出来然后快速幂求一波 \\displaystyle\\left\\lfloor\\frac{n}{q^k}\\right\\rfloor 次幂。当然最后是需要乘上余项 \\displaystyle\\prod_{i,i\\perp q}^{n\\bmod q^k}i （对应上面的 19\\times20\\times22 ），暴力就可以了。 总结下来就是 n!\\equiv q^{\\lfloor n/q\\rfloor}\\cdot\\left(\\left\\lfloor\\frac n q\\right\\rfloor\\right)!\\cdot\\left(\\prod_{i, i\\perp q}^{q^k}i\\right)^{\\lfloor n / q^k\\rfloor}\\cdot \\left(\\prod_{i, i\\perp q}^{n\\bmod q^k}i\\right)\\pmod{q^k} 而我们需要求的是 \\displaystyle\\frac{n!}{q^x}\\bmod q^k 。 变形一下上面的式子得到 f(n)\\equiv f\\left(\\left\\lfloor\\frac n q\\right\\rfloor\\right)\\cdot\\left(\\prod_{i, i\\perp q}^{q^k}i\\right)^{\\lfloor n / q^k\\rfloor}\\cdot \\left(\\prod_{i, i\\perp q}^{n\\bmod q^k}i\\right)\\pmod{q^k} （注意此时 n! 中的质因子 q 会在递归的过程中全部被消掉），此时我们就求得 f(n) 的值了。 这一部分的代码如下： 123456789101112ll calc(ll n, ll q, ll qk)//传入的参数不再赘述{ if (!n) return 1;//边界条件 ll ret = 1; FOR(i, 1, qk) if (i % q) ret = ret * i % qk;//处理循环节的部分 ret = qpow(ret, n / qk, qk);//给循环节进行快速幂 FOR(i, n / qk * qk + 1, n) if (i % q) ret = ret * (i % qk) % qk;//暴力合并余项，注意这里一定要先取模再乘不然会去世 return ret * calc(n / q, q, qk) % qk;//递归继续求解} Part 4 那么回到刚才的问题：求 \\frac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\frac{(n - m)!}{q^z}}q^{x - y - z}\\bmod q^k 左边分数的分子可以求，分母由于必然与 q^k 互质是可以求逆元的，现在问题就是如何去求这个 q^{x - y - z} 。 不妨设 g(n) = x ，则由刚才的推导过程可以知道 g(n) = \\left\\lfloor\\frac n q\\right\\rfloor + g\\left(\\left\\lfloor\\frac n q\\right\\rfloor\\right) （其实就是考虑当前求 n! 中 q 的倍数产生的贡献和下面求 \\lfloor n / q\\rfloor! 中 q 的倍数产生的贡献） 当然我们其实有一种更加简洁的去求 x - y - z 的方法： 12345ll cnt = 0;for (ll i = n; i; i /= q) cnt += i / q;for (ll i = m; i; i /= q) cnt -= i / q;for (ll i = n - m; i; i /= q) cnt -= i / q; 这样做的道理其实也很简单，完全就是把递归式的 g(n) 换成了非递归式而已。 那么所有的问题就已经搞定了。 这一部分的代码如下： 123456789ll multiLucas(ll n, ll m, ll q, ll qk)//求 \\binom n m \\pmod{q ^ k} 的值{ int cnt = 0; for (ll i = n; i; i /= q) cnt += i / q; for (ll i = m; i; i /= q) cnt -= i / q; for (ll i = n - m; i; i /= q) cnt -= i / q; return qpow(q, cnt, qk) * calc(n, q, qk) % qk * inv(calc(m, q, qk), qk) % qk * inv(calc(n - m, q, qk), qk) % qk;} 流程回顾 对于 p 分解质因数得到每个质因子 q^k 。 对于每个质因子，求出 \\binom n m\\equiv \\frac{f(n)}{f(m)f(n - m)}\\cdot q^{g(n) - g(m) - g(n - m)}\\pmod{q^k} 用 CRT 合并所有答案。 代码实现 细节非常的繁冗，一定要注意关于取模/long long/是否爆范围之类的问题。 洛谷 P4720 【模板】扩展卢卡斯 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;cstdio&gt;#define FOR(i, a, b) for (ll i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (ll i = a; i &gt;= b; --i)typedef long long ll;ll mod;void exgcd(ll a, ll b, ll &amp;x, ll &amp;y){ if (!b) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; return;}inline ll inv(ll n, ll p){ ll x, y; exgcd(n, p, x, y); return (x + p) % p;}ll qpow(ll base, ll p, ll mod){ ll ret = 1; for (; p; p &gt;&gt;= 1, base = base * base % mod) if (p &amp; 1) ret = ret * base % mod; return ret;}ll CRT(int n, ll *a, ll *m){ ll M = 1, ret = 0; FOR(i, 1, n) M *= m[i]; FOR(i, 1, n) { ll w = M / m[i]; ret = (ret + a[i] * w % mod * inv(w, m[i]) % mod) % mod; } return (ret + mod) % mod;}ll calc(ll n, ll q, ll qk){ if (!n) return 1; ll ret = 1; FOR(i, 1, qk) if (i % q) ret = ret * i % qk; ret = qpow(ret, n / qk, qk); FOR(i, n / qk * qk + 1, n) if (i % q) ret = ret * (i % qk) % qk; return ret * calc(n / q, q, qk) % qk;}ll multiLucas(ll n, ll m, ll q, ll qk){ int cnt = 0; for (ll i = n; i; i /= q) cnt += i / q; for (ll i = m; i; i /= q) cnt -= i / q; for (ll i = n - m; i; i /= q) cnt -= i / q; return qpow(q, cnt, qk) * calc(n, q, qk) % qk * inv(calc(m, q, qk), qk) % qk * inv(calc(n - m, q, qk), qk) % qk;}ll exLucas(ll n, ll m, ll p){ int cnt = 0; ll qk[20], a[20];//存放所有的 q^k 和待合并答案的结果 for (ll i = 2; i * i &lt;= p; ++i)//质因数分解 { if (p % i == 0) { qk[++cnt] = 1; while (p % i == 0) qk[cnt] *= i, p /= i; a[cnt] = multiLucas(n, m, i, qk[cnt]); } } if (p &gt; 1) qk[++cnt] = p, a[cnt] = multiLucas(n, m, p, p); return CRT(cnt, a, qk);//CRT 合并答案}int main(){ ll n, m, p; scanf(\"%lld %lld %lld\", &amp;n, &amp;m, &amp;p); mod = p; printf(\"%lld\\n\", exLucas(n, m, p)); return 0;} 习题 两个模板 P3807 【模板】卢卡斯定理 P4720 【模板】扩展卢卡斯 接下来就是应用到 Lucas 定理的习题了，难度应该是递增的，请放心食用。 [国家集训队]礼物 洛谷 P2183 Description n 件礼物，送给 m 个人，送给第 i 个人礼物的数量为 w_i 。请计算出送礼物的方案数（两个方案被认为是不同的，当且仅当存在某个人在这两种方案中收到的礼物不同）模 P 后的结果。 数据范围：令 P = \\prod_{i = 1}^tp_i^{c_i} ，其中 p_i 为质数，有 1\\le n\\le10^9 ， 1\\leq m\\leq 5 ， 1\\leq p_i^{c_i}\\leq 10^5 ， 1\\leq w_i \\leq P\\leq 10^9 。 Hint 直接考虑组合意义。 Solution 分析题意：直接一波乘法原理可得答案为 \\binom{n}{w_1}\\times\\binom{n - w_1}{w_2}\\times\\binom{n - w_1 - w_2}{w_3}\\times\\cdots\\bmod P （组合意义就是对于每个人看能取多少，第一个人取了 w_1 个了所以第二个人能取的就只有 n - w_1 个，以此类推） 剩下就是套一个 exLucas 板子的事情了（因为 P 不一定为质数）。 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#define FOR(i, a, b) for (ll i = a; i &lt;= b; ++i)typedef long long ll;ll P, n, m, w[6];//.......//int main(){ scanf(\"%lld\", &amp;P); scanf(\"%lld %lld\", &amp;n, &amp;m); ll W = 0; FOR(i, 1, m) scanf(\"%lld\", w + i), W += w[i]; if (W &gt; n) { puts(\"Impossible\"); return 0; } ll ans = 1; FOR(i, 1, m) { ans = ans * exLucas(n, w[i], P) % P; n -= w[i]; } printf(\"%lld\\n\", ans); return 0;} [SDOI2010]古代猪文 洛谷 P2480 Description 远古时期猪文文字总个数为 n 。 iPig 打算研究古时某个朝代的猪文文字。该朝代流传的猪文文字恰好为远古时期的 1/k ，其中 k 是 n 的一个正约数（可以是 1 或 n ）。 iPig 觉得只要符合文献，每一种 k|n 都是有可能的。他打算考虑到所有可能的 k 。显然当 k 等于某个定值时，该朝的猪文文字个数为 n/k 。然而从 n 个文字中保留下 n/k 个的情况也是相当多的。iPig 预计，如果所有可能的 k 的所有情况数加起来为 p 的话，那么他研究古代文字的代价将会是 g^p 。 现在他想知道猪王国研究古代文字的代价是多少。由于 iPig 觉得这个数字可能是天文数字，所以你只需要告诉他答案除以 999911659 的余数就可以了。 数据范围 1\\le n,g \\le 10^9 。 Hint 考虑欧拉定理，将模数拆开，计算后用 CRT 合并答案。 Solution 答案实际就为 g^{\\sum_{k\\mid n}\\binom n k}\\bmod 999911659 然后为了求这个东西，需要套一个欧拉定理： g^{\\sum_{k\\mid n}\\binom n k\\bmod 999911658}\\bmod 999911659 现在问题的关键就是求出 \\sum_{k\\mid n}\\binom n k\\bmod 999911658 这波，这波啊直接 exLucas，尝试一下分解 999911658=4679\\times3\\times2\\times35617 ，每一个质因子的次数都是 1 ，所以只需要用 CRT 求解如下方程组 \\begin{cases}p \\equiv \\sum_{k\\mid n}\\dbinom n k\\pmod{2}\\\\p \\equiv \\sum_{k\\mid n}\\dbinom n k\\pmod{3}\\\\p \\equiv \\sum_{k\\mid n}\\dbinom n k\\pmod{4679}\\\\p \\equiv \\sum_{k\\mid n}\\dbinom n k\\pmod{35617}\\end{cases} 最后求一波快速幂，于是这题就做完了，注意代码细节即可。 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#define FOR(i, a, b) for (ll i = a; i &lt;= b; ++i)typedef long long ll;const ll mod[5] = {999911659, 2, 3, 4679, 35617};const int maxp = 40005;ll fact[maxp];ll qpow(ll base, ll p, ll mod){ ll ret = 1; for (; p; p &gt;&gt;= 1, base = base * base % mod) if (p &amp; 1) ret = ret * base % mod; return ret;}void init(ll p){ fact[0] = 1; FOR(i, 1, p) fact[i] = fact[i - 1] * i % p; return;}ll C(int n, int m, ll p){ if (n &lt; m) return 0; return fact[n] * qpow(fact[m], p - 2, p) % p * qpow(fact[n - m], p - 2, p) % p;}ll Lucas(ll n, ll m, ll p){ if (n &lt; m) return 0; if (!n || !m) return 1; return Lucas(n / p, m / p, p) * C(n % p, m % p, p) % p;}ll a[5];int main(){ ll n, g; scanf(\"%lld %lld\", &amp;n, &amp;g); if (g % mod[0] == 0)//特判 { printf(\"0\\n\"); return 0; } FOR(k, 1, 4) { init(mod[k]); for (ll i = 1; i * i &lt;= n; ++i) { if (n % i) continue; a[k] = (a[k] + Lucas(n, i, mod[k])) % mod[k]; if (i * i != n) a[k] = (a[k] + Lucas(n, n / i, mod[k])) % mod[k]; } } ll M = mod[0] - 1, ans = 0; FOR(i, 1, 4) { int w = M / mod[i]; ans = (ans + a[i] * w % M * qpow(w, mod[i] - 2, mod[i]) % M) % M; } printf(\"%lld\\n\", qpow(g, ans, mod[0])); return 0;} [SHOI2015]超能粒子炮·改 洛谷 P4345 Description t 组数据（ 1\\le t\\le 10^5 ），给定 n ， k （ 1\\le n,k\\le 10^{18} ），求 \\sum_{i = 0}^k\\binom n k\\bmod{2333} 的值。 Hint 考虑拆开式子，然后利用类似整除分块的思想处理，递归来做。 Solution 由于数据组数很大并且 n 和 k 都很大，所以不能直接卢卡斯然后简单相加，时间会爆炸。考虑令 f(n, k) = \\sum_{i = 0}^k\\binom n k\\bmod p 其中 p 即为 2333 。然后使用卢卡斯定理拆开 \\begin{aligned}f(n,k) &amp;\\equiv \\sum_{i = 0}^k\\binom n k\\\\&amp;\\equiv \\sum_{i = 0}^k\\binom{n\\bmod p}{i\\bmod p}\\binom{\\lfloor\\frac np\\rfloor}{\\lfloor\\frac ip\\rfloor}\\pmod p\\end{aligned} 现在化简成了这样之后，注意到 p 其实很小，可以类似整除分块的做法，按照 \\displaystyle\\left\\lfloor\\frac ip\\right\\rfloor 的值分开来处理： f(n,k) \\equiv \\binom{\\lfloor\\frac np\\rfloor}{0}\\sum_{i = 0}^{p - 1}\\binom{n\\bmod p}{i} + \\binom{\\lfloor\\frac np\\rfloor}{1}\\sum_{i = 0}^{p - 1}\\binom{n\\bmod p}{i} + \\cdots+\\binom{\\lfloor\\frac np\\rfloor}{\\lfloor\\frac kp\\rfloor}\\sum_{i = 0}^{k\\bmod p}\\binom{n\\bmod p}{i}\\pmod p 前面有从 0 到 \\displaystyle\\left\\lfloor\\frac kp\\right\\rfloor - 1 的整块，把前面整块的部分拎出来化简： \\begin{aligned}&amp;\\binom{\\lfloor\\frac np\\rfloor}{0}\\sum_{i = 0}^{p - 1}\\binom{n\\bmod p}{i} + \\binom{\\lfloor\\frac np\\rfloor}{1}\\sum_{i = 0}^{p - 1}\\binom{n\\bmod p}{i} + \\cdots + \\binom{\\lfloor\\frac np\\rfloor}{\\left\\lfloor\\frac kp\\right\\rfloor - 1}\\sum_{i = 0}^{p - 1}\\binom{n\\bmod p}{i}\\\\=&amp;\\left(\\sum_{i = 0}^{p - 1}\\binom{n\\bmod p}{i}\\right)\\cdot\\left(\\sum_{i = 0}^{\\left\\lfloor\\frac kp\\right\\rfloor - 1}\\binom{\\lfloor\\frac np\\rfloor}{i}\\right)\\\\=&amp;f(n\\bmod p, p - 1)\\times f(\\lfloor n/p\\rfloor, \\lfloor k/p\\rfloor - 1)\\end{aligned} 后面的余项即为 \\begin{aligned}&amp;\\binom{\\lfloor\\frac np\\rfloor}{\\lfloor\\frac kp\\rfloor}\\sum_{i = 0}^{k\\bmod p}\\binom{n\\bmod p}{i}\\\\=&amp;\\binom{\\lfloor\\frac np\\rfloor}{\\lfloor\\frac kp\\rfloor}f(n\\bmod p, k\\bmod p)\\end{aligned} 最后我们得到 f(n, k) =f(n\\bmod p, p - 1)\\times f(\\lfloor n/p\\rfloor, \\lfloor k/p\\rfloor - 1) +\\binom{\\lfloor\\frac np\\rfloor}{\\lfloor\\frac kp\\rfloor}f(n\\bmod p, k\\bmod p)\\bmod p \\displaystyle\\binom{\\lfloor\\frac np\\rfloor}{\\lfloor\\frac kp\\rfloor} 可以直接 Lucas 定理，剩下的递归做就行，预处理 p 以内的 f 就可以很快的做了。 主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#define int long long#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)const int p = 2333;int C[p + 5][p + 5], f[p + 5][p + 5];int lucas(int n, int m){ if (!m) return 1; return C[n % p][m % p] * lucas(n / p, m / p) % p;}int F(int n, int k){ if (k &lt; 0) return 0; if (!k || !n) return 1; if (n &lt; p &amp;&amp; k &lt; p) return f[n][k]; return (lucas(n / p, k / p) * f[n % p][k % p] % p + f[n % p][p - 1] * F(n / p, k / p - 1) % p) % p;}signed main(){ int t = read(); C[0][0] = 1; FOR(i, 1, p) { C[i][0] = C[i][i] = 1; FOR(j, 1, i - 1) C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p; } f[0][0] = 1; FOR(i, 1, p) f[i][0] = 1; FOR(i, 0, p) FOR(j, 1, p) f[i][j] = (C[i][j] + f[i][j - 1]) % p; while (t--) { int n = read(), k = read(); printf(\"%lld\\n\", F(n, k)); } return 0;} 需要注意预处理 f 的时候 f(0, i) = 1 ，如果这里没处理的话会只有 55pts。 [清华集训2016] 组合数问题 洛谷 P6669 Description 给定 n 、 m 和 k ，问 \\forall 0\\le i\\le n, 0\\le j\\le \\min(i, m) 有多少对 (i, j) 满足 k\\mid \\dbinom i j 答案对 10^9 + 7 取模， t 组数据， k 为一个素数， 1\\le n,m\\le 10^{18} ， 1\\le t,k \\le 100 。 Hint 考虑 Lucas 定理在 p 进制下的那种形式。 Solution 总而言之就是 p 进制下 i 的每一位都不能小于 j ，这个东西可以数位 dp！ 代码很短！ 12345678910111213141516171819202122232425262728293031typedef long long ll;const ll mod = 1e9 + 7;ll t, k, n, m, bn[66], bm[66];ll f[66][2][2][2][2];ll solve(int cur, bool ok, bool dif, bool fn, bool fm) { if (!cur) return ok; ll &amp;res = f[cur][ok][dif][fn][fm]; if (~res) return res; res = 0; int upn = fn ? k - 1 : bn[cur], upm = fm ? k - 1 : bm[cur]; FOR(i, 0, upn) for (int j = 0; (j &lt;= i || dif) &amp;&amp; j &lt;= upm; ++j) res = (res + solve(cur - 1, ok | (i &lt; j), dif | (i != j), fn | (i &lt; upn), fm | (j &lt; upm))) % mod; return res;}int main() { read(t), read(k); while (t--) { read(n), read(m); ll mx = n &gt; m ? n : m, len = 0; memset(f, -1, sizeof f); while (mx) mx /= k, ++len; FOR(i, 1, len) bn[i] = n % k, n /= k; FOR(i, 1, len) bm[i] = m % k, m /= k; print(solve(len, 0, 0, 0, 0)), putchar('\\n'); } return output(), 0;} 其他的好题 篇幅限制，不放在这里了。下面给出题解链接： 51nod1778 小Q的集合 推式子好题 洛谷P3301 [SDOI2013]方程 容斥 + 扩展 Lucas 总结 那么对于 Lucas 定理及其扩展的学习就告一段落了，除了这些列出来的习题外，Lucas 定理还可能出现在某些毒瘤组合题要你求组合数取模的值的时候，总的来说 Lucas 定理本身还是一个比较清新优美的定理的。 省选爆炸没进省队的蒟蒻祝各位 NOI 加油。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"Lucas定理","slug":"lucas","permalink":"https://old.blog.imyangty.com/tags/lucas/"}]},{"title":"博客搬迁公告","slug":"new-blog-post","date":"2021-05-09T12:57:32.000Z","updated":"2022-03-23T04:07:24.688Z","comments":true,"path":"new-blog-post/","link":"","permalink":"https://old.blog.imyangty.com/new-blog-post/","excerpt":"","text":"所有算法竞赛相关文章已经全部搬迁至此。 原博客 imyangty.com 中会记录一些生活残片和杂想。 此公告。","categories":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/categories/site-issue/"}],"tags":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/tags/site-issue/"}]},{"title":"testblog","slug":"testblog","date":"2021-05-09T05:35:19.000Z","updated":"2022-04-01T02:05:06.723Z","comments":true,"path":"testblog/","link":"","permalink":"https://old.blog.imyangty.com/testblog/","excerpt":"","text":"testing This is a test article. 无序列表测试 测试 测试 有序列表测试 测试 测试 引言测试 行内 latex 测试：我们考虑一个公式 E = mc^2 。 行间公式测试 x = \\frac{-b\\pm\\sqrt\\Delta}{2a} 剩余测试 环境测试 \\boldsymbol{A} = \\begin{pmatrix} 1 &amp; 2 &amp; 3\\newline 4 &amp; 5 &amp; 6 \\end{pmatrix} CRT： \\begin{cases} x\\equiv 3\\pmod{p_1}\\\\ x\\equiv 5\\pmod{p_2}\\\\ \\cdots\\\\ x\\equiv y\\pmod{p_n} \\end{cases} aligned： \\begin{aligned} H_j(x) &amp;= \\prod_{k=1}^jG_k(x)\\\\ \\ln H_j(x) &amp;= \\sum_{k=1}^j\\ln G_k(x)\\\\ &amp;= -\\sum_{k=1}^j\\ln(1 - x^k)\\\\ &amp;= \\sum_{k=1}^j\\sum_{i=1}^{+\\infty}\\frac{x^{ki}}{i} \\end{aligned} 文章目录测试 下面进行文章目录的测试 三级标题1 此处为内容。 内容。 三级标题2 此处为内容 四级标题1 四级标题测试 四级标题2 三级标题3 Volantis 特性测试 带 {% del 删除线 %} 的文本 经典用法 {% note, 可以在配置文件中设置默认样式，为简单的一句话提供最的简便写法。 %} {% note quote, note quote 适合引用一段话 %} {% note info, note info 默认主题色，适合中性的信息 %} {% note warning, note warning 默认黄色，适合警告性的信息 %} {% note danger, note error/danger 默认红色，适合危险性的信息 %} {% note success, note done/success 默认绿色，适合正确操作的信息 %} 更多图标 这些都是默认样式，可以手动加上颜色： {% note radiation, note radiation 默认样式 %} {% note radiation yellow, note radiation yellow 可以加上颜色 %} {% note bug red, note bug red 说明还存在的一些故障 %} {% note link green, note link green 可以放置一些链接 %} {% note paperclip blue, note paperclip blue 放置一些附件链接 %} {% note todo, note todo 待办事项 %} {% note guide clear, note guide clear 可以加上一段向导 %} {% note download, note download 可以放置下载链接 %} {% note message gray, note message gray 一段消息 %} {% note up, note up 可以说明如何进行更新 %} {% note undo light, note undo light 可以说明如何撤销或者回退 %} HTML 嵌入","categories":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/categories/site-issue/"}],"tags":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/tags/site-issue/"}]},{"title":"2021年5月 OI学习记录","slug":"summary-2021-05","date":"2021-05-07T13:53:30.000Z","updated":"2022-04-14T08:17:33.143Z","comments":true,"path":"summary-2021-05/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-05/","excerpt":"","text":"前言 暂时的离开是为了更好的开始 学习内容 一些贪心 一些奇怪的 dp 一些数位 dp 做题记录 21/05/07 P5021 [NOIP2018 提高组] 赛道修建 二分答案+贪心 21/05/08 [AGC032E] Modulo Pairing 调整法，贪心，二分查找分界点 21/05/09 ARC118 A 状态奇差 21/05/10 [ARC118C] Coprime Set 基于神奇的引理：在满足条件的序列后面继续加满足条件的数的倍数，仍然满足 21/05/11 [AGC037E] Reversing and Concatenating 字符串贪心，直接贪心，注意代码的实现细节。 21/05/12 [ARC118B] Village of M People 二分答案+贪心 21/05/13 P5657 [CSP-S2019] 格雷码 直接模拟 21/05/16 ARC119 A + B 21/05/17 [ARC119C] ARC Wrecker 2 利用奇下标和偶下标的性质，巧妙做题。 21/05/18 [ARC119D] Grid Repainting 3 二分图 21/05/20 P5659 [CSP-S2019] 树上的数 神仙题，贪心 21/05/21 [AGC010C] Cleaning 比较神奇的结论题，考虑内部和伸出去的路径 21/05/22 ABC202 A-E E题被降智 21/05/23 ARC120 A + B + C 21/05/24 P2742 [USACO5.1]圈奶牛Fencing the Cows /【模板】二维凸包 凸包模板题，Graham，Andrew 21/05/27 [ABC202F] Integer Convex Hull 凸包 + 计数 dp [AGC020C] Median Sum bitset 优化背包，中位数的对称性 21/05/30 CF280C Game on Tree 期望的线性性，答案为 \\sum_u \\frac 1{d_u} P1297 [国家集训队]单选错位 期望， \\sum_{i}\\frac{1}{\\max(a_i, a_{i + 1})} P4317 花神的数论题 二进制的数位 dp P2602 [ZJOI2010]数字计数 数位 dp，设 f[len][lim][sum][zero]，考虑顶着最高位和前导零两种特殊情况 P4124 [CQOI2016]手机号码 数位 dp，需要记录后两位和是否已经合法，以及不能同时有 4 和 8。 21/05/31 hdu2089 不要62 数位 dp P3413 SAC#1 - 萌数 数位 dp CF55D Beautiful numbers 数位 dp，观察到 \\operatorname{lcm}_{1\\le i\\le 9} = 2520 ，所以状态只存储到 2520 个，设 f[len][cur][_lcm]。 P4999 烦人的数学作业 数位 dp，可以分位考虑，从 0 到 9 ，答案为 \\sum_{0\\le i\\le 9}f_i \\times i 。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"AtCoder 比赛日记/杂题选做","slug":"summary-atcoder","date":"2021-04-23T04:38:59.000Z","updated":"2022-04-13T12:27:28.338Z","comments":true,"path":"summary-atcoder/","link":"","permalink":"https://old.blog.imyangty.com/summary-atcoder/","excerpt":"","text":"ABC 补题表 近期目标：ABC 稳定 30min 过 4 题，争取赛时过 G，尽量补全套 ABC。 Round Rank Perf Sol A B C D E F G H ABC202 1095 1437 4 🉑 🉑 🉑 🉑 🉑 🉑 ABC207 956 1484 3 🉑 🉑 🉑 👀 🉑 👀 ABC210 485 1823 5 🉑 🉑 🉑 🉑 🉑 👀 ABC212 856 1536 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC213 1031 1485 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC214 742 1647 4 🉑 🉑 🉑 🉑 👀 👀 👀 👀 ABC217 1320 1383 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 ABC219 1153 1375 4 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC222 425 1880 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC223 1573 1074 3 🉑 🉑 👀 🉑 👀 👀 👀 👀 ABC224 426 1828 5 🉑 🉑 🉑 🉑 🉑 👀 👀 👀 ABC231 571 1665 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC232 762 1518 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC233 659 1660 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC234 1553 1224 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC235 913 1525 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 😅 ABC237 534 1790 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC244 333 1788 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👅 ABC246 703 1656 5 🉑 🉑 🉑 🉑 🉑 🉑 🉑 🉑 ABC247 640 1703 6 🉑 🉑 🉑 🉑 🉑 🉑 🉑 一些新见到的 trick ABC212E：补集思想优化 dp。 ABC212H：FWT 的线性性。 ABC219E：网格很小所以直接将护城河的状态和格子双射。 ABC231G：期望线性性推大式子。 ABC232G：对于模 M 类问题建环。 ABC233Ex：曼哈顿转切比雪夫然后主席树二维数点。 ABC235G：逆向考虑问题→二项式反演→棋盘路径计数的递推。 ABC237E：点高度直接满足势能性质→直接 Dijkstra。 ABC237Ex：串的包含关系转为偏序关系👉求最大反链。 ABC212 A + B + C + D + E。A - D 略。 ABC212E - Safety Journey 补集思想优化 DP ： f_{i, j} = \\sum_{j'\\text{ is connected with j}}f_{i - 1, j'} 可以转化为 f_{i, j} = \\sum_{j' = 1}^n f_{i - 1, j'} - \\sum_{j'\\text{ isn't connected with j}}f_{i - 1, j'} 没连边的数量是总共 O(m) 的，总复杂度 O((n + m)k) ABC212F - Greedy Takahashi 建模成森林然后直接树上倍增求解。码力要求较高。 ABC212G - Power Pair 给定质数 p ，问数对 (x, y) 的个数模 998244353 ： 0\\le x, y\\le p - 1 \\exists n, x^n\\equiv y\\pmod p 2\\le p\\le 10^{12} 。 回顾原根的概念。 r 为模 p 的原根当且仅当最小的使得 r^e\\equiv 1\\pmod p 的正整数为 e = p - 1 。本题需要用到的性质： r^i\\bmod p, i\\in[0, p - 1] 的值两两不同，且对于一个质数，一定有原根存在。 设 x\\equiv r^a\\pmod p ， y\\equiv r^b\\pmod p ，不难发现 (x, y) 总能有一个 (a, b) 与之对应。于是就有 an\\equiv b\\pmod{p - 1} 。现在就是需要找满足上式的 (a, b) 的数量。 枚举 a ，则上式有解的条件是 \\gcd(a, p - 1)\\mid b （裴蜀定理）。那对于所有的 a 就可以写成： \\sum_{a = 1}^{p - 1}\\frac{p - 1}{\\gcd(a, p - 1)} 然后 O(p) 是过不去的，要考虑优化。优化它的方法明显是寻找 \\gcd(a, p - 1) 相同的 a 的个数。根据 p - 1 的因数个数 为 O(\\sqrt p) 的，故这些 \\gcd 也只有 O(\\sqrt p) 个。我们枚举 \\gcd(a, p - 1) = g ，有 \\sum_{g\\mid p - 1}\\frac{p - 1}{g}\\times\\phi\\left(\\frac{p - 1}{g}\\right) \\phi(n) 可以暴力计算。 O(\\sqrt p\\log p) ，因为 \\log 的上界很松，轻松通过。 ABC212H - Nim Counting 给定 n ， k 和 (A_1, \\cdots, A_k) 。可以如下安排石子：每堆石子数量必须是 A_i 之一，且石子堆数量小等于 n 。问安排石子使得先手 Nim 必胜的方案数。 1\\le n\\le 2\\times 10^5 ， 1\\le k, A_i\\le 2^{17} ， A_i 两两不同。 不难发现问题转化为求 \\bigoplus_{i = 1}^m B_i\\not=0 的 B_i 的方案数。 先考虑固定 m 。则构造序列 C 使得 TeX parse error: Undefined control sequence \\exist，定义卷积 * 为异或卷积，则 C * C * \\cdots * C （ m 个 C ）的第 i 项系数即为异或和为 i 的方案数。这个过程是可以 FWT 做的，具体地，给 \\operatorname{FWT}(C)_i 的每一项做一下快速幂再 IFWT 回去，把除了第 0 项之外的求个和，就得到了石子堆数为 m 的答案。 然后，不固定 m 怎么做呢？因为 FWT 是线性变换，而我们需要求的是 \\operatorname{IFWT}(\\operatorname{FWT}(C)_i + \\operatorname{FWT}(C)_i^2 + \\operatorname{FWT}(C)_i^3 + \\cdots \\operatorname{FWT}(C)_i^n) ，所以定义 C'_i = \\operatorname{FWT}(C)_i ，然后求出 D_i = C_i' + C_i'^2 + \\cdots + C_i'^n 再求 \\operatorname{IFWT}(D) 把除了第 0 项外的系数累加即可。 12345678910111213141516171819202122modint calc(modint x, modint n) { if (x == 1) return n; if (x == 0) return 0; return x * (qPow(x, n) - 1) * qPow(x - 1, mod - 2);}int main() { read(n), read(k); int tmp; FOR(i, 1, k) read(tmp), maxa = tmp &gt; maxa ? tmp : maxa, f[tmp] = 1; ++maxa; int lim; for (lim = 1; lim &lt;= maxa; lim &lt;&lt;= 1); XOR(f, lim, 1); FOR(i, 0, lim - 1) f[i] = calc(f[i], n); XOR(f, lim, inv2); modint ans = 0; FOR(i, 1, lim - 1) ans += f[i]; print(ans); return output(), 0;} ABC213 A + B + C + D + F ABC213E - Stronger Takahashi 0-1 bfs，因为边权只为 0 或 1 。 ABC213F - Common Prefixes 令 \\operatorname{LCP}(S_i, S_j) 为 i 开头子串和 j 开头子串的最长公共前缀。对每个 k\\in[1, n] 求 \\sum_{i = 1}^n\\operatorname{LCP}(S_k, S_i) SA 板子。 ABC213G - Connectivity 2 对于每个 k ，求 1 和 k 联通的子图个数。 2\\le n\\le 17 ， m 很小。 状压 dp。 令 g(S) 表示点集 S 中有连边的数量。这可以 O(2^nm) 的时间内完成。 设 f(S) 为保证 S 内点联通的连边方案数，则我们可以考虑容斥，随便选一个点 x ，然后考虑这个点所在的连通分量 T ，其中 T\\subset S 。则有如下转移 f(S) = g(S) - \\sum_{x\\in T, T\\subset S} f(T) 然后对于答案， k 号点的答案即为： \\sum_{1\\in S, k\\in S} f(S) 这题就做完了。 ABC213H - Stroll n 个点， m 对点 (a_i, b_i) 间有连边，长度为 d 的有 p_{i, d} 条。问从 1 点出发，在 1 点结束的长度为 T 的路径方案数。 先把最朴素的 DP 方程写出来：设 f_{u, s} 为结束点为 u ，长度为 s 的路径条数。 则最朴素的方程：对于每条边进行转移 f_{u_i, s} := f_{u_i, s} + \\sum_{t = 0}^sf_{v_i, t}p_{i, t} 写成生成函数的形式就是 F_{u_i}(x) := F_{u_i}(x) + F_{v_i}(x)P_i(x) 这个东西看似可以 NTT 优化，但是你会发现存在反复横跳的情况。所以直接去做肯定是不行的。 考虑在长度的维度分治。考虑当前分治区间为 [l, r] ，然后首先处理一下 [l, mid] 内部，把这些算完，然后处理 [l, mid] 到 [mid + 1, r] 的贡献。即 f_{u_i, s} := f_{u_i, s} + \\sum_{t = l}^{mid}f_{v_i, t}p_{i, s - t}\\quad s\\in[mid + 1, r] 类似分治 NTT 处理即可。 123456789101112131415161718192021222324252627282930313233343536373839Poly f[11], p[11], t1, t2;int n, m, T, u[11], v[11];void solve(Poly &amp;f, Poly &amp;g, Poly &amp;ret, int l, int r) { int mid = (l + r) &gt;&gt; 1; t1 = {f.begin() + l, f.begin() + mid + 1}; t2 = {g.begin() + 1, g.begin() + r - l + 1}; t1 = t1 * t2; FOR(i, mid + 1, r) ret[i] = (ret[i] + t1[i - l - 1]) % mod; return;}void solve(int l, int r) { int mid = (l + r) &gt;&gt; 1; if (l == r) return; solve(l, mid); FOR(i, 1, m) { solve(f[u[i]], p[i], f[v[i]], l, r); solve(f[v[i]], p[i], f[u[i]], l, r); } solve(mid + 1, r); return;}int main() { read(n), read(m), read(T); lim = T + 1; FOR(i, 1, m) { read(u[i]), read(v[i]); p[i].resize(T + 1); FOR(j, 1, T) read(p[i][j]); } FOR(i, 1, n) f[i].resize(T + 1); f[1][0] = 1; solve(0, T); print(f[1][T]); return output(), 0;} ABC217 A + B + C + D + E ABC217F - Make Pair 给定 2n 个学生，其中只有 m 对关系好。每次选择相邻两个关系好的进行配对并从序列中删除，问把所有学生配对的方案。 一眼就是区间 dp。设 f_{l, r} 为将 [l, r] 里面的人配对的方案数。 然后至于转移，考虑 l 与谁配对，设其为 x 。则首先， [l, x] 的长度一定是偶数，并且 l 和 x 的关系好。然后我们需要的就是 f_{l + 1, x - 1} 和 f_{x + 1, r} 。注意到移除 [l + 1, x - 1] 和 [x + 1, r] 是两个独立的过程，并且 [l + 1, x - 1] 必须在配对 l 和 x 之前完成。 现在的问题就是，合并 [l, x] 和 [x + 1, r] 是两个独立的过程，所以考虑一共进行了 (r - l + 1) / 2 次合并，而我们需要确定有哪几次是 [x + 1, r] 里面的在做，不难发现就是 \\binom{(r - l + 1) / 2}{(r - x) / 2} 转移的时候乘上这个系数即可。 代码。 ABC217G - Groups 给定 n 个数，要求划分成 k 个非空组，若 i\\equiv j\\pmod m ，则 i 和 j 不能在一组。对于 k = 1,\\cdots, n 输出方案数模 998244353 的结果。 原来的组是非空且无标号的，方案数设为 f(k) ，先考虑可以为空并且有标号的情况，设为 g(k) 设 S_r 为 [1, n] 中模 m 的余数为 r 的数字构成的集合，则对于每个 S_r ，我们都要将其划分在 k 个不同的组里面去，每个组里面最多 1 个数。 设 P(n, m) = \\displaystyle\\frac{n!}{(n - m)!} 为 n 选 m 的排列数： g(k) = \\prod_{i = 0}^{m - 1 }P(k, |S_i|) 这是不要求放满的。而如果知道恰好放满的，除以 k! 就是不带标号的了。 恰好放满可以用容斥。去掉的是 \\sum_{p = 0}^{k - 1}\\binom kpf(p)p! 即为有序非空组数不到 k 的，所以 f(k) = \\frac{\\prod_{i = 0}^{m - 1}P(k, |S_i|) - \\sum_{p = 0}^{k - 1}\\binom k p f(p)p!}{k!} 递推可做，前面那一段可以快速预处理然后用快速幂 O(\\log n) 来算。 代码。 ABC219 状态差。A + B + C + D。 ABC219E - Moat 一个 4\\times 4 的网格，要求在网格边上修一个护城河，使得护城河是一个合法多边形并且包含了所有的村庄。 比较神奇的思路，鉴于网格只有 16 个，而且一个护城河必定和一种状态（一个格子有没有被包含）一一对应，所以可以直接枚举这 O(2^{16}) 个状态然后判断网格是否合法。 判断网格是否合法这个，首先需要判断每个村庄是不是被包含，其次需要避免中间被挖空的情况，然后要避免 1 的格子被割裂开的情况，综上即整张图（把边界外的考虑进去）只能有两个连通块，dfs 染色即可。 ABC222 A + B + C + D + G，rk 425。 ABC222E - Red and Blue Tree 给定 m 条树上路径，每次会覆盖若干边。 如果我设第 i 条边的被覆盖次数为 c_i 的话，那么我们每次都会给途径的 c_i 增加 1 。 要求覆盖完之后访问红边的次数-访问蓝边的次数= k ，问染色方案数。 n 很小，所以可以暴力给边染色。 染完之后不难发现 R 和 B 是确定的。所以直接背包一下就可以了。 ABC222F - Expensive Expense 树，定义 E_{i, j} 为 i 到 j 路径上边权和加上 j 的点权，对于每个 i 找到最大的 E_{i, j} ，点数在 2\\times 10^5 级别。 简单换根 dp。 ABC231 A + B + C + D + F，rk571 ABC231E - Minimal payments 由于 A_{i - 1}\\mid A_i ，所以对于一个 A_i 可以只考虑两种方案：用这个 A_i 尽可能凑，或者用更大的面值付然后要找零。 1234567891011121314151617181920212223using ll = long long;int n;ll a[65], x, ans;unordered_map&lt;ll, unordered_map&lt;ll, ll&gt; &gt; f;ll dfs(ll x, int now) { if (now == 1) return x; if (f[x][now] &gt; 0) return f[x][now]; ll r = x % a[now], q = x / a[now], p = a[now] - r; if (r == 0) return q; ll w1 = q + 1ll + dfs(p, now - 1); ll w2 = q + dfs(r, now - 1); return f[x][now] = min(w1, w2);}int main() { read(n, x); FOR(i, 1, n) read(a[i]); ans = x; print(dfs(x, n)); return output(), 0;} ABC231G - Balls in Boxes 期望牛逼题。大体思路就是拆开期望的式子，利用线性性进行化简。 N 个盒子，第 i 个盒子一开始有 A_i 个球， K 次操作，每次操作随机选一个盒子加一个球，最后每个盒子有 B_i 个球，问 S = \\prod B_i 的期望，对 998244353 取模。 答案为 E[S] ，令 X_i 为表示第 i 个盒子被选中次数的随机变量，则我们要的最终答案就是 E[\\prod_i(A_i + X_i)] 。考虑 N = 2 的情况，即为 E[(A_1 + X_1)(A_2 + X_2)] = E[A_1A_2] + E[A_1X_2] + E[A_2X_1] + E[X_1X_2] 。 推而广之，对于 n 个不一样的下标 i_1,\\cdots, i_n ，容易知道 E[\\prod_{j = 1}^n X_{i_j}] = E[\\prod_{i = 1}^nX_i] 。所以提出这个公因式，有 E\\left[\\prod_{i =1}^N(A_i + X_i)\\right] = \\sum_{n = 0}^NS_{N, n}(A_1,\\cdots, A_N)E\\left[\\prod_{i =1}^{N - n}X_i\\right] 其中 S_{N, n} 表示 N 个变量的 n 次对称多项式。 现在只需要对于每个 n 算出 S_{N, n}(A_1,\\cdots, A_N) 和 E[\\prod_{i = 1}^nX_i] 即可。 前者， S_{N, n}(A_1,\\cdots, A_N) = [x^n]\\prod_{i =1}^N(A_ix + 1) 。这个东西一个分治 NTT 碾过去应该是 O(n\\log^2n) 的。 然后是后者。我们考虑随机变量 X_{i, j} 表示第 i 个盒子在第 j 次操作是否会被选中（0/1）。则 X_i = \\sum_{j = 1}^KX_{i, j} 。枚举一下下标，发现 E\\left[\\prod_{i = 1}^n X_i \\right] = \\sum_{j_1, j_2,\\cdots, j_n}E\\left[\\prod_{i = 1}^nX_{i, j_i}\\right] 然后当 i_1\\not= i_2 的时候，显然 X_{i_1, j}X_{i_2, j} = 0 。故 E\\left[\\prod_{i = 1}^nX_{i, j_i}\\right] = \\begin{cases} \\left(\\frac 1N\\right)^n \\quad&amp; \\text{if }j_i\\text{ are pairwise different}\\\\ 0\\quad&amp; \\text{otherwise} \\end{cases} 于是 E\\left[\\prod_{i = 1}^n X_i \\right] = \\left(\\prod_{i = 1}^n(K + 1 - i)\\right)\\left(\\frac1N\\right)^n 这个可以 O(n) 算，于是 O(n\\log^2n) 解决了。 ABC232 A，B 略。 C 建出一张图的邻接矩阵然后用 next_permutation 枚举排列判断是否能建立映射即可。 D 简单网格 dp，注意边界条件。 ABC232E - Rook Path H \\times W 的网格，你初始在 (x_1, y_1) ，要求做 K 次操作后位置变为 (x_2, y_2) 。每次操作形如： 移动横坐标，从 (x, y) 移动到 (x', y) ，其中 1\\le x'\\le H\\land x'\\neq x 。 移动纵坐标，从 (x, y) 移动到 (x, y') ，其中 1\\le y'\\le W\\land y'\\neq y 。 （就是车的移动方式）问有多少种可能的操作方案，两种操作方案不同当且仅当中间某一步经过的点不同。答案对 998244353 取模。 根据套路，这个东西的横向移动和纵向移动是可以分开来考虑的。即，我们可以考虑横向上走 m 步的方案，再乘上纵向上走 K - m 步的方案，再乘上组合系数 \\dbinom K m 。考虑计算在一个方向上走 m 步的方案数。 可以 DP，设 f_{0/1, i} 表示横向移动（纵向的类似）回到出发点与否，走 i 步的方案数，其中初始边界是 f_{1,0} = 1 ，即走 0 步，终点在原点的方案数为 1 。转移如下： \\begin{cases} f_{1, i} = (H - 1)f_{1, i - 1}\\\\ f_{0, i} = f_{1, i - 1} + (H - 2)f_{0, i - 1} \\end{cases} 转移的意义还是很显然的。于是我们 O(n) 求出 dp 数组，这题就做完了，评测记录。 ABC232F - Simple Operations on Sequence 给定两个长度为 N （ 2\\le N\\le 18 ）： A_i 和 B_i （ 1\\le A_i, B_i\\le 10^8 ）。可以进行如下两种操作，问最小的使得 A 变成 B 的操作代价： 对 A_i 加一/减一，代价为 X （ 1\\le X\\le 10^8 ） 交换 A 中的相邻元素，代价为 Y （ 1\\le Y\\le 10^{16} ） 毫无疑问，两个操作是相互独立的，可以分开考虑。如果我们先交换，出一个 P_1, P_2,\\cdots,P_N 的排列，然后再统计第一个的答案。令 \\operatorname{inv}(P) 为 P 的逆序对数，则总代价为： \\sum_{i = 1}^N|A_{P_i} - B_i|\\cdot X + \\operatorname{inv}(P)\\cdot Y 把逆序对的这个关于 i 的贡献拆开，则我们可以得到 \\sum_{i = 1}^N(|A_{P_i} - B_i|\\cdot X + |\\{p:p\\in\\{1,2,\\cdots, N\\} \\backslash \\{P_1, \\cdots, P_{i - 1}\\}, p &lt; P_i\\}|\\cdot Y) 然后会发现一个很关键的地方：后面那个东西只和 \\{P_1, \\cdots, P_i\\} 这个集合有关，而这个集合很小，所以不妨考虑将其状压起来，令 f(x, S) 表示 |p:p\\in\\{1, \\cdots, N\\}\\backslash S, p &lt; x| 。然后式子改写为： \\sum_{i = 1}^N(|A_{P_i} - B_i|\\cdot X + f(P_i, \\{P_1, \\cdots, P_{i - 1}\\})\\cdot Y) 于是发现，这个东西可以状压 dp，具体地，设 dp_S 表示排列的前 |S| 项是 S 内的元素，则转移应该是很好转移的。这题就做完了，评测记录。 ABC232G - Modulo Shortest Path 给定一张 N 个点的有向完全图，其中， i 到 j 的有向边边权为 (A_i + B_j)\\bmod M 。问 1 到 N 的最短路。 2\\le N\\le 2\\times 10^5 ， 2\\le M\\le 10^9 。 首先如果我们直接连边跑 Dij，那么必然会寄，边数是 O(n^2) 级别的，要想办法少下来。 考虑一个技巧，建一张新图： 构建 [0, M) 的虚点 \\overline{0},\\overline 1,\\cdots,\\overline{M - 1} 。 然后 \\forall k\\in[0, M - 1) ，连边 \\overline k\\to \\overline{k + 1} ，边权为 1 。 \\forall i\\in [1, N] ，连边 i\\to \\overline{-A_i\\bmod M} ，边权为 0 。 \\forall i\\in [1, N] ，连边 \\overline{B_i} ，边权为 0 。 这样一来，从 i 走到 j 就相当于，从 i 走到 \\overline{-A_i\\bmod M} ，然后一步步走到 \\overline{B_j} ，再走到 j 。发现中间的路程刚好就是 (A_i + B_j)\\bmod M ，于是问题就得到了转化，我们求新图上 1 到 N 的最短路即可。 可是， O(n + m) 似乎也必死无疑。 然而我们可以发现，环上的很多点是没有用的，我们可以将其缩起来，会和原来的点连接的虚点只有 2n 个，这样子点数和边数就都控制在了 O(n) 级别，直接跑 Dij 便可通过，时间复杂度 O(n\\log n) ，评测记录。 ABC232H - King's Tour 不知道组题人怎么想的。。。这个题居然放在 H。 给定 H\\times W 棋盘，一个国王初始在 (1, 1) 。国王每步可以走到与其八连通的格子，请构造一个方案使得国王不重复地走完了每个格子，且终点为 (a, b) 。 2\\le H, W\\le 100 ， (a, b)\\neq (1, 1) 。 我们考虑减治构造。考虑如下几种情况： H = 2 或 W = 2 ： 如果 H = 2 ，那么就可以像下面这样构造方案（图源 AtCoder 官方题解）： 即，轨迹为： (1, 1)\\to (2, 1)\\to\\cdots\\to(1, b)\\to (1, b + 1)\\to \\cdots \\to(1, W)\\to (2, W)\\to \\cdots\\to (2, b) 。如果 W= 2 ，那么将行列调换之后是一样的。 H &gt; 2 且 W &gt; 2 ： 考虑下面这个方案： 绿色圈出来的点集为 S ，分类讨论： (a, b)\\notin S ，则我们可以走完 S 内的点，然后垂直翻转一下坐标系，就变成了一个一模一样的子问题，递归处理即可。 (a, b)\\in S ，则我们交换行列之后，就变成了 (a,b)\\notin S 的情况。 然后就可以递归地去解决这道题了。这种代码写的很巧妙： 1234567891011121314151617181920212223242526272829using pii = pair&lt;int, int&gt;; vector&lt;pii&gt; solve(int h, int w, int a, int b) { vector&lt;pii&gt; ret; if (h == 2) { FOR(i, 1, b - 1) ret.push_back(pii(1, i)), ret.push_back(pii(2, i)); ret.push_back(pii(3 - a, b)); FOR(i, b + 1, w) ret.push_back(pii(1, i)); DEC(i, w, b + 1) ret.push_back(pii(2, i)); ret.push_back(pii(a, b)); } else if ((h &gt; 2 &amp;&amp; w == 2) || b == 1 || (a == h &amp;&amp; b == 2)) { ret = solve(w, h, b, a); for (auto &amp;p : ret) myswap(p.first, p.second); } else { FOR(i, 1, h) ret.push_back(pii(i, 1)); auto res = solve(h, w - 1, h + 1 - a, b - 1); for (auto &amp;p : res) p.first = h + 1 - p.first, ++p.second; ret.insert(ret.end(), res.begin(), res.end()); } return ret;} int main() { int h, w, a, b; read(h, w, a, b); auto ans = solve(h, w, a, b); for (auto p : ans) print(p.first, p.second); return output(), 0;} ABC233 ABC233F - Swap and Sort 简要题意：给定排列 P ， n\\le 1000 。同时给定 m 组关系 (a_i, b_i) ，每次可以交换 P_{a_i} 和 P_{b_i} 。构造一个最多 5\\times 10^5 步的方案使得 P 为升序。 整个问题可以抽象成一张图。然后可以发现，当且仅当数字 p_i 和点 i 在一个连通分量内时整个问题有解，这个问题可以写一个并查集之类的东西判断一下。 然后构造方案。由于不要求最优性，所以我们可以直接考虑建出一个生成树，然后从点度为 1 的点开始逐个复位并删点。操作次数最多为 999 + 998 + \\cdots + 1 = 499500 。评测记录。 ABC233G - Strongest Takahashi 简要题意：给定一张 N\\times N （ 1\\le N\\le 50 ）网格，里面若干个格子有障碍。每次可以选择一个 D\\times D 的区域然后消耗 D 点体力将其中的障碍消去。问将所有障碍消去的最小体力消耗。 这种高维度的 dp 一直是我的弱点。。。考虑一个 A\\times B 的矩形区域（子问题），我们显然需要 C = \\max(A,B) 的体力来覆盖整个矩形。然而可能存在更少的体力消耗就能覆盖。具体地，当存在一个空行/空列时，我们就可以考虑将子矩形划开，变成两个独立子问题，看一下有没有更优解。 所以设一个 f_{l,u,r,d} 来进行 dp（使用记搜转移）即可，转移复杂度似乎是 O(n^5) 的，评测记录。 ABC233Ex - Manhattan Christmas Tree 简要题意：给定平面内 n 个点， q 次询问到 (a, b) 第 k 近的点到 (a, b) 的距离，这里的距离指曼哈顿距离。 5\\times 10^5 ，7s。 首先我们发现曼哈顿距离很不好处理第 k 近之类的问题，因为既要考虑两个维度又有绝对值。所以考虑将每个点 (x, y) 变成 (x + y, x - y) ，这样原图的曼哈顿距离就可以被转化为切比雪夫距离。 于是我们对于每个询问就可以二分一下第 k 近的距离，查询有多少个点到 (a,b) 的切比雪夫距离 \\le d ，这个查询其实就是一个二维数点（查询矩形和），可以通过写一个主席树来实现。复杂度为 O((n + Q)\\log^2X) ， X 为点的值域。主席树写着有点心烦，要注意细节，评测记录。 ABC234 A，B 略。 C 考虑将 K 二进制表示下的每个 1 换成 2 即可。 D 维护一个小根堆在线维护前 K 大元素即可。 E 发现首项只可能是 a_1 或 a_1 + 1 ，随后枚举公差判断是否可行即可，细节略多。 ABC234F - Reordering 题意：给定一个字符串 S ，问选出里面的部分字母并重排后能得到多少种不同字符串。 |S|\\le 5000 ，模 998244353 。 考虑能构成的字符串只与字符集合有关。我们不妨从 \\texttt a 开始，一个个的加字符。设 f_{i, j} 表示前 i 种字符中，填满了 j 个格子的方案数。转移的时候考虑第 i 个字符我们填 k 个进去，就相当于是 j - k + 1 个不同的桶里面放 k 个相同球，可以有空桶，所以转移如下： f_{i,j} = \\sum_{k = 0}^{\\min(j, g(i))}\\binom k jf_{i- 1, j - k} g(i) 为第 i 种字符在原串中的出现次数。 那么 \\sum f_{26, i} 就是答案。 1234567891011121314151617181920212223242526272829const int maxn = 5005;char s[maxn];modint f[26][maxn], fac[maxn], ifac[maxn];int buc[27];modint binom(int n, int m) {return fac[n] * ifac[m] * ifac[n - m];}int main() { read(s + 1); int n = strlen(s + 1); FOR(i, 1, n) ++buc[s[i] - 'a']; fac[0] = 1; FOR(i, 1, n) fac[i] = i * fac[i - 1]; ifac[n] = qPow(fac[n], mod - 2); DEC(i, n - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; FOR(j, 0, buc[0]) f[0][j] = 1; FOR(i, 1, 25) { FOR(j, 0, n) { FOR(k, 0, min(buc[i], j)) { f[i][j] += binom(j, k) * f[i - 1][j - k]; } } } modint ans = 0; FOR(j, 1, n) ans += f[25][j]; print(ans); return output(), 0;} ABC234G - Divide a Sequence 给定长为 N 的数列 A ，有 2^{N - 1} 种方法将其划分为若干个非空序列 B_1,\\cdots, B_k ，求出对于每种划分方式，下面这个式子的和，对 998244353 取模， N\\le 3\\times 10^5 。 \\prod_{i = 1}^k(\\max\\{B_i\\} - \\min\\{B_i\\}) 考虑一个 dp： f_i 为 A_1, \\cdots, A_i 的答案，边界为 f_0 = 1 。则我们可以知道： f_i = \\sum_{j = 0}^{i - 1}f_j(\\max_{k = j + 1}^i\\{A_i\\} - \\min_{k = j + 1}^i\\{A_i\\}) 这个式子看似是 O(n^2) 的，拆开来： f_i = \\sum_{j = 0}^{i - 1}f_j\\max_{k = j + 1}^i\\{A_i\\} - \\sum_{j = 0}^{i - 1}f_j\\min_{k = j + 1}^i\\{A_i\\} 然后我们维护一下 \\max_{k = j + 1}^i\\{A_k\\} ，以及对应的 dp 值之和，使用单调栈就可以完成这题了。答案即为 f_n ，实现细节见代码。 1234567891011121314151617181920212223242526272829303132333435363738const int maxn = 3e5 + 5;modint f[maxn];int a[maxn], n;struct node { int a; modint v;} st1[maxn], st2[maxn];int top1, top2;int main() { read(n); FOR(i, 1, n) read(a[i]); f[1] = 1; modint maxsum = 0, minsum = 0; FOR(i, 1, n) { modint sumv = f[i]; while (top1 &amp;&amp; st1[top1].a &lt; a[i]) { maxsum -= st1[top1].a * st1[top1].v; sumv += st1[top1].v; --top1; } maxsum += sumv * a[i]; ++top1, st1[top1] = {a[i], sumv}; sumv = f[i]; while (top2 &amp;&amp; st2[top2].a &gt; a[i]) { minsum -= st2[top2].a * st2[top2].v; sumv += st2[top2].v; --top2; } minsum += sumv * a[i]; ++top2, st2[top2] = {a[i], sumv}; f[i + 1] = maxsum - minsum; } print(f[n + 1]); return output(), 0;} ABC234Ex - Enumerate Pairs 给定二维平面上的 N 个点 (x_i, y_i) 和一个正整数 K 。请列出所有欧几里得距离小于等于 K 的点对。 1\\le N\\le 2\\times 10^5 ， 1\\le K\\le 1.5\\times 10^9 。保证最多 4\\times 10^5 对点对将被枚举。 以下题解参考了 AtCoder 官方题解，传送门。神仙结论题，先给出结论： 对于每个点 (x_i, y_i) ，将其分配到集合 (\\lfloor x_i/K\\rfloor, \\lfloor y_i/K\\rfloor) 中。 然后对于任意一个点，若其被分配到了 (X, Y) 集合中，则能与其配对的点一定在 (X + m, Y + l) 集合中，其中 -1\\le m,l\\le 1 。直接枚举即可得到答案。 然后，其时间复杂度为 O(N + M) ，其中 M 为输出的答案个数（忽略了使用数据结构产生的 \\log ）。 1234567891011121314151617181920212223242526272829303132333435using ll = long long;using pii = pair&lt;int, int&gt;;using pll = pair&lt;ll, ll&gt;;const int maxn = 2e5 + 5;const ll big = 2000000000;int n; ll K;pll p[maxn];map&lt;ll, vector&lt;int&gt; &gt; mp;vector&lt;ll&gt; delta = {-big - 1, -big, -big + 1, -1, 0, 1, big - 1, big, big + 1};int main() { read(n, K); FOR(i, 1, n) { read(p[i].first, p[i].second); ll id = (p[i].first / K) * big + (p[i].second / K); mp[id].push_back(i); } vector&lt;pii&gt; ans; FOR(i, 1, n) { ll id = (p[i].first / K) * big + (p[i].second / K); for (auto &amp;d : delta) { ll curid = id + d; for (auto &amp;j : mp[curid]) { if (j &gt;= i) continue; ll dis = (p[i].first - p[j].first) * (p[i].first - p[j].first) + (p[i].second - p[j].second) * (p[i].second - p[j].second); if (dis &lt;= K * K) ans.push_back(pii(j, i)); } } } sort(ans.begin(), ans.end()); print(ans.size()); for (auto &amp;p : ans) print(p.first, p.second); return output(), 0;} 上述做法得解的正确性较为显然，这里不说明。下面对时间复杂度给出证明。 令 B_{X, Y} 为集合 (X,Y) 中的点的数量， f(x) 为“含 x 个点的集合内最少的距离小于等于 K 的点对数”。 f(x) 的上界显然为 O(n^2) ，下面证明其下界为 \\Omega(n^2) ： 在一个边长小于 \\dfrac{K}{\\sqrt 2} 的子正方形区域中，每一对点对的距离都小于 K 。而一个 K\\times K 的正方形区域能由 4 个小的边长为 \\dfrac{K}{\\sqrt 2} 的小正方形覆盖。考虑往大区域中放 4n 个点，则至少一个小区域包含至少 n 个点。该小区域有 \\dfrac{n(n - 1)}{2} 个点对，所以 f(x) 的下界为 \\Omega(n^2) 。 而 \\sum_{X,Y}f(B_{X,Y}) \\le M ，故 \\sum_{X,Y}B^2_{X,Y} 的上界为 O(N + M) 。 然后我们的算法里面，要枚举的点对数为 \\sum_{X,Y}\\sum_{m = -1}^1\\sum_{l = -1}^1B_{X,Y}B_{X+m,Y+l} 。因为 \\sum_{X,Y}B^2_{X,Y} 的上界为 O(N + M) ，然后，根据均值不等式， B_{X,Y}B_{X + m,Y+l}\\le \\dfrac12(B_{X,Y}^2 + B_{X + m, Y + l}^2) ，所以整体的上界也是 O(N + M) 。 证毕。 ABC235 A, B, C 略。 D 考虑一个 BFS，每次变换看作一次转移，由于有效状态最多 10^7 个，所以是正确的。 ABC235F - Variety of Digits 给 m 个数位 c_i ，问 [1, n] 中十进制下包含了全部 c_1,\\cdots, c_m 数位的整数的和（前导 0 不算），答案对 998244353 取模。 1\\le n\\le 10^{10^4} ， 1\\le m\\le 10 ， 0\\le c_1&lt;\\cdots&lt;c_m\\le 9 。 数位 DP。考虑到我们可以将数位集合压起来，所以设 f_{i, S} 表示从低到高第 i 位，从高到低已经选的数位集合为 S 的数字个数和数字和（注意这两个东西需要同时维护）。 那么转移应该是比较好想的，注意前导 0 不应计算在 S 内。 123456789101112131415161718192021222324252627282930313233343536const int maxn = 1e4 + 5;char s[maxn];int n, m, c[11], S0, a[maxn];pair&lt;modint, modint&gt; f[maxn][1 &lt;&lt; 10];modint pow10[maxn];bool vis[maxn][1 &lt;&lt; 10];pair&lt;modint, modint&gt; dfs(int pos, int S, int lim, int zero) { if (pos == -1) { if ((S &amp; S0) == S0) return {1, 0}; else return {0, 0}; } if (!lim &amp;&amp; !zero &amp;&amp; vis[pos][S]) return f[pos][S]; int up = lim ? a[pos] : 9; pair&lt;modint, modint&gt; ret = {0, 0}; FOR(i, 0, up) { pair&lt;modint, modint&gt; tmp; if (zero &amp;&amp; !i) tmp = dfs(pos - 1, S, lim &amp;&amp; i == up, zero); else tmp = dfs(pos - 1, S | (1 &lt;&lt; i), lim &amp;&amp; i == up, 0); ret.first += tmp.first; ret.second += tmp.second + tmp.first * pow10[pos] * i; } if (!lim &amp;&amp; !zero) vis[pos][S] = 1, f[pos][S] = ret; return ret;}int main() { read(s + 1), n = strlen(s + 1); pow10[0] = 1; FOR(i, 1, n) a[i - 1] = s[n - i + 1] - '0', pow10[i] = 10 * pow10[i - 1]; read(m); FOR(i, 1, m) read(c[i]), S0 |= (1 &lt;&lt; c[i]); print(dfs(n - 1, 0, 1, 1).second); return output(), 0;} ABC235G - Gardens 三种颜色的球分别有 A, B, C 个，同种颜色的球不区分，现将其放入 N 个有标号的箱子内，要求 每个箱子至少有 1 个球。 每个箱子内至多有 1 个同种球。 不必放完所有的球。 求方案数模 998244353 ， 1\\le N\\le 5\\times 10^6 ， 0\\le A,B,C\\le N 。 朴素的 DP 容易想到， O(NABC) = O(N^4) ，铁定过不去。不妨反着考虑问题，发现“为空”比“不为空”要好想得多，考虑对于一个 i ，计算“至少有 i 个箱子为空”的方案数，不难发现其就为 \\binom{N}{i}\\left(\\sum_{a=0}^{\\min\\{N- i, A\\}}\\binom{N - i}{a}\\right)\\left(\\sum_{b=0}^{\\min\\{N- i, B\\}}\\binom{N - i}{b}\\right)\\left(\\sum_{c=0}^{\\min\\{N- i, C\\}}\\binom{N - i}{c}\\right) 解释：首先选 i 个一定为空的箱子，然后分别枚举三种颜色的球放的个数并放入 N - i 个可能不为空的箱子。 答案为“恰好有 0 个箱子为空”，二项式反演一下（中间推导过程省略，就是一个简单容斥）得到答案为 \\sum_{i=0}^N(-1)^i\\binom{N}{i}\\left(\\sum_{a=0}^{\\min\\{N- i, A\\}}\\binom{N - i}{a}\\right)\\left(\\sum_{b=0}^{\\min\\{N- i, B\\}}\\binom{N - i}{b}\\right)\\left(\\sum_{c=0}^{\\min\\{N- i, C\\}}\\binom{N - i}{c}\\right) 化的好看点就是 \\sum_{i=0}^N(-1)^{N - i}\\binom{N}{i}\\left(\\sum_{a=0}^{\\min\\{i, A\\}}\\binom{i}{a}\\right)\\left(\\sum_{b=0}^{\\min\\{i, B\\}}\\binom{i}{b}\\right)\\left(\\sum_{c=0}^{\\min\\{i, C\\}}\\binom{i}{c}\\right) 然而直接计算还是需要 O(N^2) ，继续优化计算过程。 设 f_{M}(N) = \\displaystyle\\sum_{i=0}^{\\min\\{N, M\\}}\\binom N i ，则答案可以改写为 \\sum_{i=0}^N(-1)^{N-i}\\binom Ni f_{A}(i)f_{B}(i)f_C(i) 如果我们知道了 f_M(N) 的值后能 O(1) 推出 f_{M}(N + 1) 的值，整个问题就可以 O(N) 解决了。 当 N+ 1\\le M 的时候， \\min\\{N+1,M\\} = N+1 ，所以根据二项式定理， f_{M}(N+1)=2f_M(N) 。 下面的解法参考 AtCoder 官方题解，推荐去学习一下这个思想。 实际上， f_M(N) 就可以看作从左下角出发，每一步往上/右走一格，走到橙色点的方案数（总步数都是 N ，我们枚举了横向走的步数 i 而已）。 于是 f_M(N) 与 f_M(N + 1) 的关系就变成了求走到橙色点的方案数与走到蓝色点的方案数之间的关系。发现，我们在一个橙色点的时候总可以往上/右走一格到达蓝色点，除去最右下角那个点即可。所以 f_M(N+ 1) = 2f_M(N) - \\binom{N}{M} 发现对于上面的情况，只需定义 N&lt;M 的 \\dbinom NM 为 0 ，下面的公式也是完全适用的。 f_M(0) = 0 。 于是这道题 O(N) 解决了。 12345678910111213141516171819202122232425262728293031const int maxn = 5e6 + 5;modint fac[maxn], ifac[maxn];int n, A, B, C;modint binom(int n, int m) { if (n &lt; m) return 0; return fac[n] * ifac[m] * ifac[n - m];}int main() { read(n, A, B, C); fac[0] = 1; FOR(i, 1, n) fac[i] = fac[i - 1] * i; ifac[n] = qPow(fac[n], mod - 2); DEC(i, n - 1, 0) ifac[i] = (i + 1) * ifac[i + 1]; modint ans = 0, a = 1, b = 1, c = 1; FOR(i, 0, n) { modint tmp = ((n - i) &amp; 1) ? -1 : 1; tmp *= binom(n, i); if (i &gt; 0) { a = 2 * a - binom(i - 1, A); b = 2 * b - binom(i - 1, B); c = 2 * c - binom(i - 1, C); } tmp *= a * b * c; ans += tmp; } print(ans); return output(), 0;} ABC235Ex - Painting Weighted Graph 给定 N 点 M 边带边权无向图， 2\\le N\\le 10^5 ， 0\\le M\\le 10^5 。一开始，每个节点上涂黑色，可以进行如下操作至多 K 次： 选择一个节点 v 和一个数 x ，将所有的从 v 出发，不经过任何权值大于 x 的边能到达的点涂为红色。 问可能的红色点集的数量，模 998244353 。图可能有重边和自环。 咕，以后有空来补。 ABC237 A 可以投机取巧一下强制转为 int 之后是否与原来相等。 B 略，C 随便观察一下即可，略。D 可以实现一个 deque 或者倒序考虑问题，略。 E 建出图后发现是一个带有负权边的最短路模型，跑个 SPFA 可以过，略。 ABC237E - Skiing 滑雪场有 n 个地点，有 m 个坡，保证图连通。每个节点有高度 h_u 。当从边 u\\to v 通过时， 若 h_u &gt; h_v ，则快乐指数增加 h_u - h_v 。 否则，快乐指数减小 2(h_v - h_u) 。 从 1 出发，初始快乐指数为 0 ，问能达到的最大快乐指数。 n, m 均为 2\\times 10^5 级别。 首先对边权取相反数建模成最短路模型，发现其有负权边，无法直接使用 Dijkstra，而数据范围又极有可能卡死 SPFA（事实证明 SPFA 能过）。 考虑势能 Dijkstra，为每个点增加一个势能 h_u ，然后对边 u\\to v 的权值加上 h_u - h_v ，使得所有边权非负，最后每个点的答案就为 d_u + h_u - h_1 。但是求势能的过程仍然需要 SPFA，怎么办呢？ 注意到本题中的“高度”就是一个现成的势能，满足了势能之差只和相对高度有关这一性质，所以直接将其当作势能来做就可以了，时间复杂度 O(m\\log n) ，评测记录。 ABC237F - |LIS| = 3 给定 N 和 M ，求满足以下条件的正整数序列的个数： 长度为 N ，每个元素 \\in[1, M] 。 其 LIS 的长度恰好为 3 。 3\\le N\\le 1000 ， 3\\le M\\le 10 。 考虑经典的 O(n\\log n) 的 LIS 的做法，发现 f_i 为“长度为 i 的 LIS 的最小结尾数字”，而 DP 数组的长度即为 LIS 的长度，所以干脆考虑令 f_{i, a, b, c} 表示当前考虑到 [1, i] ，LIS 的 DP 数组为 a, b, c 的序列个数。不难发现这个状态是没有后效性的，转移就考虑当前填什么数，然后仿照 O(n\\log n) LIS 的转移方式进行转移。时间复杂度 O(NM^4) ，可以通过。 1234567891011121314151617modint f[1005][15][15][15];int n, m;int main() { read(n, m); f[0][m + 1][m + 1][m + 1] = 1; FOR(i, 1, n) FOR(j, 1, m + 1) FOR(k, j, m + 1) FOR(l, k, m + 1) FOR(t, 1, m) { if (t &lt;= j) f[i][t][k][l] += f[i - 1][j][k][l]; else if (t &lt;= k) f[i][j][t][l] += f[i - 1][j][k][l]; else if (t &lt;= l) f[i][j][k][t] += f[i - 1][j][k][l]; } modint ans = 0; FOR(i, 1, m) FOR(j, i + 1, m) FOR(k, j + 1, m) ans += f[n][i][j][k]; print(ans); return output(), 0;} ABC237G - Range Sort Query 给定长度为 N 的排列， Q 次操作，操作为选定一区间 [l, r] 然后升序/降序排序，问元素 X 最后的下标在哪里。 1\\le N, Q\\le 2\\times 10^5 。 这是一个经典问题（HEOI 排序）的变式。最强大的解法显然为线段树合并/分裂，但是在这里不需要。 注意到，0-1 序列的区间排序很好使用线段树来完成，只需要实现区间染色和区间求和。所以我们考虑将其转为 0-1 序列。 具体地，将 &lt; X 的元素变为 0 ，其他变为 1 ，操作，得到一个结果。将 \\le X 的元素变为 0 ，其他变为 1 ，操作，得到另一个结果，然后然后然后发现这两个序列唯一一个不一样的地方显然就是 X 最后的位置。 所以复杂度为 O(N\\log N) ，视 N 和 Q 同阶。评测记录。 ABC237Ex - Hakata 给定长度 \\le 200 的字符串 S ，问最多能从里面选出多少个回文子段，使得一个子段不是另一个子段的子段。子段指连续的。 我们发现，不同回文子串的个数 \\le |S| ，然后子串间的包含关系是一种偏序关系，可以形成一个 DAG，而原问题问的就是其的最大反链。 复习一下 P4298 [CTSC2008]祭祀 便知道最大反链 = 最小链覆盖（Dilworth 引理），而最小链覆盖可以通过拆点二分图匹配来求。 放到本题里面，就对于每个不同回文子段（这部分顶天 O(|S|^3) ），为其标号，然后对于 i 为 j 的子串，连边 i_{\\mathrm {left}}\\to j_{\\mathrm{right}} ，然后跑二分图最大匹配，用回文串数量减去匹配即得到答案。时间复杂度就不分析了， 400 个点的二分图匹配并不慢，评测记录。 ABC244 ABC244D - Swap Hats 大胆猜结论。 发现若相同的位置有 3 个或 0 个时为 Yes，否则为 No，下面给出简要说明。 为 3 个的时候就把两个反复横跳即可，为 0 个的话可以构造方案在操作两次后转化为 3 个一样的情况。 否则相同的位置只可能有 1 个，做任意一次交换后都会变成上面两种情况，所以寄了。 ABC244F - Shortest Good Path 给定 N 点 M 边无向图，令长度为 K 的路径 A_{1,\\cdots, K} 对长度为 K 的 0-1 串 S 为合法的当且仅当 i 的出现次数模 2 后等于 S_i 。对于 2^n 种不同的 S ，求出最小的合法的路径的 K 之和。 n\\le 17 。 范围让我们想到状压 dp。 对于这种图上有链的，就令 f_{i,S} 为以 i 结尾，点集为 S 的链的什么什么。然后注意到这个状态是没法转移的，因为接上一个在 S 里面存在的点之后， S' 是小于 S 的。 那就考虑翻转一下状态和值，令 f_{i,k,S} 为以 i 结尾，长度为 k ，点集为 S 的链是否存在。然后转移就很好做到了，毛估估复杂度为 O(n^32^n) ，有点勉强但是实现的好的话可以通过。 解释一下为什么长度上界是 4n ，因为 G 题说了上界是 4n 。 123456789101112131415161718192021222324252627282930const int maxn = 18, maxS = (1 &lt;&lt; 17) | 5;int n, m, G[maxn][maxn];bool f[maxn][4 * maxn][maxS];int vis[maxS];int main() { read(n, m); FOR(i, 1, m) { int u, v; read(u, v); G[u][v] = G[v][u] = 1; } memset(vis, 0x3f, sizeof vis); FOR(i, 1, n) f[i][1][1 &lt;&lt; (i - 1)] = 1; int ans = 0; vis[0] = 0; FOR(k, 1, 4 * n) { // length FOR(i, 1, n) { FOR(S, 0, (1 &lt;&lt; n) - 1) { FOR(j, 1, n) if (G[i][j]) { f[i][k + 1][S] |= f[j][k][S ^ (1 &lt;&lt; (i - 1))]; if (f[i][k + 1][S]) break; } chkmin(vis[S], f[i][k][S] ? k : (int)1e9); } } } FOR(i, 0, (1 &lt;&lt; n) - 1) ans += vis[i]; print(ans); return output(), 0;} 但是这还不是最优的，而且这个拿结论来推的想法很不优美。我们注意到，若将 dp 状态 (i, S) 看作点，转移看作边，那么问题就变成了最短路。 时间复杂度会少一个 n ， O(n^22^n) 跑的还是很快的，而且少了 4 倍常数。 ABC244G - Construct Good Path 全部继承 F 的定义，将范围改成 N\\le 10^5 ， M\\le 2\\times 10^5 ，并给定 S 然后让你构造一个合法的 A 。要求长度不超过 4N ，保证有解。 首先将这个问题放到生成树上。然后就从根节点往下走。对于 u ，若从他的子树出来后还是不对头，那就反复横跳一次。 对于根节点特判一下即可。 12345678910111213141516171819202122232425262728293031const int maxn = 1e5 + 5;char s[maxn];int n, m, vis[maxn];vector&lt;int&gt; G[maxn], ans;void dfs(int u) { ans.push_back(u), ++vis[u]; for (int &amp;v : G[u]) { if (vis[v]) continue; dfs(v); if ((vis[v] &amp; 1) != s[v] - '0') ans.push_back(u), ++vis[u], ans.push_back(v), ++vis[v]; ans.push_back(u), ++vis[u]; } return;}int main() { read(n, m); FOR(i, 1, m) { int u, v; read(u, v); G[u].push_back(v), G[v].push_back(u); } read(s + 1); dfs(1); if ((vis[1] &amp; 1) != s[1] - '0') ans.pop_back(); print(ans.size()); for (int &amp;x : ans) print(x, ' '); return output(), 0;} ABC244Ex - Linear Maximization（未写代码） 维护二维平面上的点集 S = \\{(x, y)\\} ，初始为空。下面进行 Q 次操作，每次往 S 中加入点 (x, y) 并给定 a,b 并查询 \\max_{(x,y)\\in S}\\{ax + by\\} 。 Q\\le 2\\times 10^5 ，坐标绝对值 \\le 10^9 。 解法 1 ：考虑 ax + by = b(\\frac ab\\cdot x + y) ，看出一次函数的形式之后无脑李超树即可。但是需要注意特判符号， b=0 等情况。而且浮点误差似乎有点心烦所以我没写。 解法 2 ：拿平衡树维护动态凸包，然后在凸包上三分查询。 不想写代码了。 ABC246 A 直接随便做。 B 输出 \\cos(\\theta) 和 \\sin(\\theta) 即可。 C 先按照物品大小贪一次心，然后再将剩下部分（ a_i\\bmod x 的部分）重新排序再做一次贪心。容易说明其正确性。 D 发现 (a+b)(a^2+b^2)\\le 10^{18} ，钦定 a\\ge b 的话发现 a 的上界只能为 10^6 ，所以枚举 a 然后二分 b 即可。 ABC246E - Bishop 2 场上调这题调到最后都寄了。。。 发现整个就是一个 0-1 bfs 的模型，每次看成走一格，同向走相当于比边权为 0 ，转向相当于边权为 1 。 复杂度就是 bfs 的复杂度，容易说明其为 O(n^2) 。 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;const int maxn = 1505, fx[] = {1, 1, -1, -1}, fy[] = {1, -1, 1, -1};queue&lt;pair&lt;int, int&gt;&gt; q;char mp[maxn][maxn];int n, sx, sy, tx, ty, f[maxn][maxn];int main() { cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty; FOR(i, 1, n) cin &gt;&gt; &amp;mp[i][1]; f[sx][sy] = 1, q.push({sx, sy}); auto check = [](int x, int y) {return x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n &amp;&amp; mp[x][y] == '.';}; while (!q.empty()) { auto now = q.front(); q.pop(); FOR(k, 0, 3) { int x = now.first, y = now.second; while (true) { x += fx[k], y += fy[k]; if (!check(x, y)) break; if (!f[x][y]) f[x][y] = f[now.first][now.second] + 1, q.push({x, y}); else if (f[x][y] &lt;= f[now.first][now.second]) break; } } } cout &lt;&lt; f[tx][ty] - 1 &lt;&lt; endl; return 0;} ABC246F - typewriter 考虑对单个串我们怎么计数，不难发现是 \\text{字母个数}^L 字 母 个 数 。 那么多个串来了，我们就需要去重。具体地，我们取两个串字母的交，然后扣掉这一部分的答案。 那么扩展一下就是最基本的容斥，看到 n\\le 18 就枚举所有串的子集，算其交的答案，贡献乘上容斥系数 (-1)^{|S|} 。时间复杂度 O(2^nc) ， c 为某和字符集大小有关的常数（懒得分析了）。 ABC246G - Game on Tree 3 点带权 1 根树，初始有一个指针在 1 点，每轮游戏中先青木选择一个非根点并将其权置零，然后高桥将指针移向其所在位置的任意儿子。高桥可以在任意时刻结束游戏（但当指针移到叶子节点后游戏强制结束）。分数为指针最后指向的点的权。青木想最小化分数，高桥想最大化分数，两人绝顶聪明，问最后的分数。 直接做似乎不太可能，我们考虑二分答案，即“最优策略下，高桥能否至少拿到 c 分”。 下面是一个转化：将 \\ge c 的权看作 1 ， &lt; c 的权看作 0 ，然后发现，只要高桥君走到了一个 1 点，那么他就赢了，否则输了。 那么，显然，若高桥将指针移向一个点 u 后，青木会选择在 u 子树内将一个 1 变成 0 。树形 dp，设 f_u 为 u 子树内高桥君能走到的 1 点个数，则 f_u = \\max(\\sum f_v - 1, 0) + [a_u\\ge c] 。 f_1 &gt; 0 时合法。 ABC246Ex - 01? Queries 给定长为 n\\le 10^5 的包含 0，1 和 ? 的串 S ，以及 q\\le 10^5 次操作 (x_i, c_i) ，其中 x_i 为下标， c_i 为字符集中的某字符。按照 1,\\cdots, q 的顺序，每次将 S_{x_i}\\leftarrow c_i ，然后计算 S 的 0-1 子串个数（? 视为通配符），答案对 998244353 取模。 先思考对于一个固定的 0-1 串如何计数。 可以设计一个 dp 状态 f_{i,0/1} 表示考虑 [1, i] ，结尾为 0/1 的子序列数量，则答案显然为 f_{n, 0} + f_{n,1} ，现在考虑转移：发现可以对于 s_i 为 0，1 还是 ? 分类讨论： \\begin{aligned} f_{i,0} &amp;= \\begin{cases} f_{i - 1, 0} + (f_{i - 1, 1} + 1) &amp; S_i = \\texttt 0\\lor S_i = \\texttt{?}\\\\ f_{i - 1, 0} &amp; S_i = \\texttt 1\\\\ \\end{cases} \\\\ f_{i,1} &amp;= \\begin{cases} f_{i - 1, 1} + (f_{i - 1, 0} + 1) &amp; S_i = \\texttt 1 \\lor S_i = \\texttt{?}\\\\ f_{i - 1, 1} &amp; S_i = \\texttt 0 \\end{cases} \\end{aligned} 那么我们会发现，dp 数组的转移是很有规律的，而且我们每次修改都是修改一个点处的转移方式，而且询问 f_{n,0} + f_{n, 1} 。 这让你想到什么！动态 dp。具体地，令向量 \\boldsymbol F_i = \\begin{bmatrix} f_{i, 0}\\\\ f_{i, 1}\\\\ 1 \\end{bmatrix} （最下面的 1 是因为常数项需要转移）那么就可以写出三个转移矩阵： \\boldsymbol A_{\\texttt 0} = \\begin{bmatrix} 1 &amp; 1 &amp; 1\\\\ 0 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}, \\boldsymbol A_{\\texttt 1} = \\begin{bmatrix} 1 &amp; 0 &amp; 0\\\\ 1 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}, A_{\\texttt{?}} = \\begin{bmatrix} 1 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix} 于是就有 \\boldsymbol F_i = \\boldsymbol A_{S_i}\\times \\boldsymbol F_{i - 1} = A_{S_i}A_{S_{i-1}}\\cdots \\boldsymbol F_0 线段树维护矩阵连乘积，单点修改一下。时间复杂度 O((n + q)\\log n) 。 ABC247 ABC247Ex - Rearranging Problem 题意：给定值域为 [1, n] 的序列 c_i ，进行 k 次操作：每次选定任意 i\\ne j 然后交换 c_i 和 c_j 。显然这样会得到一个下标的新排列，问有多少种这样的排列使得最后的序列和原来的 c_i 相同。 n\\le 2\\times 10^5 ， k\\le 10^9 。 应该是比较经典但我不会的计数套路。发现其实最后相当于只在相同的 c_i 形成的连通块内部做交换，即排列的每个置换环内 c_i 要相同。 Lemma 1：交换两个数，置换环的个数会 +1/-1 。 这个引理应该不难证明（随便画图分讨一下即可），而且貌似是个经典结论。 Lemma 2：一个排列能在交换 k 次后得到当且仅当 n - c\\le k\\land (n - c)\\equiv k\\pmod 2 ，其中 c 为置换环个数。 这个引理可以用 Lemma 1 证明。注意到到一开始有 n 个环，然后奇偶性讨论一下即可。 所以我们现在要求的就是对于每个合法的 c 求出合法的置换个数。 可以 dp，设 f_{i,j} 为考虑 [1, i] 的排列，置换环个数为 j 的合法排列个数。转移的话考虑添加 i 的时候其是形成了新环还是塞入了某个老环。 f_{i, j} = f_{i, j - 1} + f_{i - 1, j}\\times |\\{x\\mid 1\\le x&lt; i, c_i = c_x\\}| 这个东西类似于第一类斯特林数的转移，所以可以分治 NTT，时间复杂度 O(n\\log^2n) 。偷懒用了他给的 NTT。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#include &lt;atcoder/modint&gt;#include &lt;atcoder/convolution&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using mint = atcoder::modint998244353;using atcoder::convolution;const int maxn = 2e5 + 5;vector&lt;vector&lt;mint&gt;&gt; P;int cnt[maxn], n, k;int main() { cin &gt;&gt; n &gt;&gt; k; FOR(i, 1, n) { int x; cin &gt;&gt; x; P.push_back({cnt[x]++, 1}); } while (P.size() &gt;= 2) { decltype(P) nxt; for (int i = 0; i &lt; P.size() - 1; i += 2) nxt.push_back(convolution(P[i], P[i + 1])); if (P.size() &amp; 1) nxt.push_back(P.back()); nxt.swap(P); } auto &amp;f = P.front(); mint ans = 0; FOR(c, 0, (int)f.size() - 1) if (n - c &lt;= k &amp;&amp; ((n - c) &amp; 1) == (k &amp; 1)) ans += f[c]; cout &lt;&lt; ans.val() &lt;&lt; endl; return 0;} ARC ARC 补题表 近期目标：ARC 稳定做出 3 题，尽力补完 A-D。 Round Rank Perf Sol A B C D E F ARC116 vp vp 3 🉑 🉑 🉑 👀 😅 😅 ARC117 597 1736 3 🉑 🉑 🉑 🉑 😅 😅 ARC118 1679 807 3 🉑 🉑 🉑 👀 😅 😅 ARC119 1141 1180 2 🉑 🉑 🉑 🉑 😅 😅 ARC120 785 1345 2 🉑 🉑 🉑 🉑 😅 😅 ARC123 608 1756 3 🉑 🉑 🉑 👀 😅 😅 ARC124 1276 1004 2 🉑 🉑 👀 👀 😅 😅 ARC125 463 1850 3 🉑 🉑 🉑 🉑 😅 😅 ARC126 876 1371 2 🉑 🉑 🉑 👀 😅 😅 ARC128 340 1998 3 🉑 🉑 🉑 👀 😅 😅 ARC131 220 2230 4 🉑 🉑 🉑 👀 🉑 😅 ARC132 566 1728 3 🉑 🉑 🉑 🉑 😅 😅 ARC134 877 1538 3 🉑 🉑 🉑 🉑 😅 😅 ARC137 281 2148 3 🉑 🉑 🉑 🉑 🉑 😅 ARC138 246 2242 4 🉑 🉑 🉑 🉑 👀 😅 一些新见到的 trick ARC116B：将 \\max\\times \\min 拆开贡献。 ARC125D：子序列自动机 dp。 ARC128C：线性规划的最值一定在边界取到。 ARC134C：某种元素至少占一半，考虑先强行配对，然后正常做。 ARC137D：模 2 意义下的 Lucas → 高维前缀和。 ARC137E：最小费用循环流的建图。 ARC116 VP。 ARC116A - Odd vs Even 给定 T （ T\\le 2\\times 10^5 ）个正整数 n （ 1\\le n\\le 10^{18} ），问 n 的奇约数多还是偶约数多。（约数均为正约数） 很明显，如果 n\\bmod 2 = 1 ，则答案为奇约数多。 否则考察约数们怎么来的。对于一个偶数 n 我们总能将其这样拆分： n = 2^k\\times p （ p 为奇数）。那么如果 k = 1 ，则不难发现奇偶约数一样多，否则肯定是偶约数多。 ARC116B - Products of Min-Max 给定一含正整数的集合 A ，求 \\sum_{S\\subseteq A}\\max_{a\\in S}\\lbrace a\\rbrace\\min_{a\\in S}\\lbrace a\\rbrace\\bmod{998244353} 的值。 比较妙的题。 首先考虑把最大值和最小值拎出来考虑贡献：将其 A 从小到大排序。 然后假设此时 i&lt;j ，则 a_i\\le a_j ，这一对元素贡献的子集个数为 2^{j - i - 1} 。所以答案就为 \\sum_{i = 1}^{n - 1}\\sum_{j = i + 1}^na_ia_j\\cdot2^{j - i} + \\sum_{i = 1}^na_i^2 化简下来可以得到 \\sum_{i = 1}^{n - 1}\\left(a_i\\cdot 2^{-i}\\sum_{j = i + 1}^na_j\\cdot2^{j - 1}\\right) + \\sum_{i = 1}^na_i^2 预处理 a_i2^{i - 1} 的后缀和就可以直接做了，复杂度 O(n\\log n) 。 ARC116C - Multiple Sequences 给定 n 和 m （ 1\\le n,m\\le 2\\times 10^5 ），求满足下列条件的长度为 n 的整数序列 A 的个数。 1\\le A_i\\le m A_{i + 1} 为 A_i 的整数倍 结果模 998244353 。 很妙的计数题。 考虑从 1 到 m 枚举 A_n 的值。我们可以发现其就是把 A_n 每个质因子给安排在 n 个不同的位置上，求方案数。但是此时需要对每个质因子分开考虑，假设 A_n = \\prod p_i^{c_i} ，则我们需要对每个质因子都用插板法然后再乘起来得到总方案，即 f(A_n) = \\prod\\binom{n + c_i - 1}{c_i} 最后把所有的结果加起来即为答案。 ARC117 A + B + C + D ARC117C - Tricolor Pyramid 题目 比较妙的题。首先把颜色分别看成 0,1,2 ，那么上一层的方块就由 -(a_1 + a_2) \\bmod 3 可以得到。把所有的一直累加上去就是杨辉三角的形式： 图源 AtCoder 官方题解。 所以求二项式系数即可，使用 Lucas 定理。 ARC117D - Miracle Tree 给一棵树的每个顶点标号，满足 E_i \\ge 1 ，且 |E_i - E_j|\\le \\operatorname{dist}(i, j) 。寻找一种最大标号最小的方案并输出。 相当好的思维题。 首先考虑随便标一个图。 图源 AtCoder 官方题解。 不难发现我们标的号应该为： \\lbrace1, 2, 3, 5, 8, 9\\rbrace 是最优的。相当于就是遇到一个点，首先走一条子链，然后回溯回来的时候仍然需要统计回溯链长，然后加到下一条子链的贡献里面去（因为要 |E_i - E_j|\\le \\operatorname{dist}(i, j) ）。我们自然希望的是尽可能回溯的少，所以做的时候从直径的一端开始走，然后遇到分叉就优先走非直径的边。 ARC118 A ARC118A - Tax Included Price 打表可做。 ARC118B - Village of M People 给定 K ， N 和 M 以及 K 个 A_i ，构造 B_i ，使得 \\sum B_i = M 且 \\max_i\\left|\\frac{B_i}{M} - \\frac{A_i}{N}\\right| 最小。 “最大的最小”，二分答案即可。 要让 \\max_i\\left|\\frac{B_i}{M} - \\frac{A_i}{N}\\right| 最小，即为让 \\max_i|B_iN - A_iM| 最小，设为 x 即可。 然后我们可以得到 \\forall i, \\left\\lceil \\frac{MA_i-x}{N}\\right\\rceil\\leq B_i\\leq \\left\\lfloor\\frac{MA_i+x}{N}\\right\\rfloor 。这样子 B_i 的上界和下界就出来了，设为 L_i 和 R_i 。 然后，如果 \\sum L_i\\le M\\le \\sum R_i ，则答案一定是可以被构造出来的。这样子我们就可以完成对于一个 x 的 check。 如何构造这个答案呢？把所有的 B_i 设为 L_i ，然后依次上调来补齐余量 M - \\sum L_i 。 这题就做完了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define int long longconst int maxn = 1e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}int k, a[maxn], n, m;int L[maxn], R[maxn], suml, sumr;inline int max(int a, int b) {return a &gt; b ? a : b;}inline int min(int a, int b) {return a &lt; b ? a : b;}bool check(int x){ memset(L, 0, sizeof L), memset(R, 0, sizeof R); suml = sumr = 0; FOR(i, 1, k) { L[i] = max(0, (m * a[i] - x + n - 1) / n); R[i] = (m * a[i] + x) / n; suml += L[i], sumr += R[i]; } return suml &lt;= m &amp;&amp; m &lt;= sumr;}signed main(){ k = read(), n = read(), m = read(); FOR(i, 1, k) a[i] = read(); int l = 0, r = n * m, x; while (l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if (check(mid)) x = mid, r = mid - 1; else l = mid + 1; } check(x); int sumb = suml; FOR(i, 1, k) { int x = min(R[i] - L[i], m - sumb); sumb += x; printf(\"%d \", x + L[i]); } return 0;} ARC118C - Coprime Set 给定 N （ 3\\le N\\le 2500 ），构造 N 个正整数 A_i 使得： A_i 互不相同且 A_i\\in[1, 10000] \\forall i \\not= j, \\gcd(A_i, A_j) &gt; 1 \\gcd_i\\{A_i\\} = 1 这个题需要一个引理：对于一系列已经满足条件的 A_i ，将任意 A_i 的倍数加进去，新得到的集合也是满足条件的。 正确性比较显然，不证。所以从 \\{6, 10, 15\\} 出发，就可以构造出所有的合法答案。 1234567891011121314151617#include &lt;cstdio&gt;int vis[10005];int main(){ int n = 0; scanf(\"%d\", &amp;n); for (int i = 1; i * 6 &lt;= 10000; ++i) vis[i * 6] = 1; for (int i = 1; i * 10 &lt;= 10000; ++i) vis[i * 10] = 1; for (int i = 1; i * 15 &lt;= 10000; ++i) vis[i * 15] = 1; int cnt = 4; printf(\"%d %d %d\\n\", 6, 10, 15), vis[6] = vis[10] = vis[15] = 0; for (int i = 6; i &lt;= 10000 &amp;&amp; cnt &lt;= n; ++i) if (vis[i]) printf(\"%d \", i), ++cnt; return 0;} ARC119 A + B ARC119B - Electric Board 给定两个 01 串 S 和 T ，每次对 S 的操作可以选取 (l,r) ，满足 S_l = 0\\land S_{l+ 1} = S_{l + 2} = \\cdots = S_{r} = 1 S_l = S_{l + 1} = \\cdots = S_{r - 1} = 1 \\land S_r = 0 然后交换 S_l 和 S_r 。问最少多少次操作之后可以将 S 变成 T 。 我们不妨将每次操作看为 0 的移动操作，因为 1 是连续动的，不好考虑。那么就只需要从左往右进行贪心，把 S 的每个 0 依次往右移直到与 T 的 0 对应。记录下每个 0 的位置然后直接贪心就可以了。 ARC119C - ARC Wrecker 2 给定长度为 n 的序列 A_i ，对于区间 [l,r] ，每次可选择 [l, r - 1] 间的一个整数 x ，然后将 A_x 和 A_{x + 1} 同时加一或减一。问有多少个 [l,r ] 可以在有限次操作之后变为全 0 。 比较妙的思路。 每次操作相当于是给奇数下标的数和偶数下标的数同时加减 1 ，所以为了最后得到全 0 ，一开始选的区间中奇下标和偶下标数的和必须相等。 注意到这条性质之后记录一下前缀和，然后用 map 随便记录以下就可以做了。 123456789101112131415161718int n;ll ans, a[maxn], s[maxn];std::map&lt;ll, ll&gt; m;int main(){ n = read(); FOR(i, 1, n) a[i] = read() * ((i &amp; 1) ? -1 : 1); FOR(i, 1, n) s[i] = a[i] + s[i - 1], ++m[s[i]]; ++m[0]; for (std::map&lt;ll, ll&gt;::iterator it = m.begin(); it != m.end(); ++it) ans += (*it).second * ((*it).second - 1ll) / 2; printf(\"%lld\\n\", ans); return 0;} 答案的上界是会爆 int，要开 long long。 ARC119D - Grid Repainting 3 给定一 H 行 W 列的方格，每个方格一开始涂了红色或者蓝色。进行如下操作：对于当前的每个红色格子，可以选择它并将其所在的一行或一列全部涂满白色。问最后最多多少个格子可以是白色并构造方案。 对于这种方格并且操作是对于整行或整列的题，很容易想到构建一张二分图来解决问题。左部的点代表每行，右部的点代表每列，一个红格子代表一条边。 然后我们分析这个涂色方案。涂掉一整行/列相当于废掉这一个点，同时把这个点相关的所有边全部废掉（即为废掉在这行/列上的红格子）。当然废掉这个点的条件是它能引出至少一条边（即必须有至少一个红格子在这行/列上面）。依据这个想法，我们肯定希望一个连通分量内，废掉的点（即涂掉的行/列）越多越好，考虑如何使它最多。 注意到，一个连通分量删到最后一定会剩下一个点（至于为什么可以自己思考一下）。我们尝试构造一下方案：假设我们剩点 u ，那么就可以从 u 构建这个连通分量的 dfs 生成树，然后从叶子节点往上删点，这样一定可以保证是合法而且除了 u ，其他的点会被删干净。 一张图是有很多个连通分量的，而我们需要对每个连通分量进行决策：留下哪个点最优。我们要涂白的格子最多，假设涂了 r 行 c 列，则剩下的蓝格子为 (h - r)(w - c) 个，我们需要将其最小化。不难发现我们可以直接枚举留下来的行点和列点的个数，然后找到最优解就直接决策每个连通分量剩下行还是列（反正哪一行哪一列不重要），这题就做完了。 主要的流程： 染色标记连通分量 决策剩下多少列点和多少行点 dfs 记录答案 输出 ARC120 A + B ARC120B - Uniformly Distributed 给定 H \\times W 的方格，其中一些涂了红色，一些涂了蓝色，一些什么都没涂。问对于剩余的格子，有多少种涂色的方案使得从 (1,1) 到 (H,W) 上的所有路径经过的红格子数量都相等。 不难发现，对于一个从右上到左下的副对角线，其要么全为红色，要么全为蓝色。大体的理由如下：（非严格证明） 从 (1,1) 到 (H,W) 一定是会经过 H + W - 1 条如上面这样的副对角线的，所以我们一定要保证无论怎么穿过一条副对角线，其经过的红格子数量都是相同的。 所以直接做就行了，对于一条有红格子的副对角线，其对答案的贡献是 1 ；对于一条全空的副对角线，其对答案的贡献为 2 （两种涂色方案）；对于既有蓝色又有红色的副对角线，其对答案的贡献为 0 。把这些贡献用乘法原理合并即可。 ARC120C - Swaps 2 给定两个长度为 N 的序列 A 和 B 。问对 A 进行有限次如下操作后能否使 A 变成 B ： 选择一个正整数 i 使得 1\\le i\\lt N 交换 A_i 和 A_{i+ 1} 的值 使 A_i 加一 使 A_{i + 1} 减一 如果能，问最少操作步数。 先考虑解的存在性。 我们观察一个数移动的情况：显然是往右走就减小，往左走就增大。设 A_i 的新位置为 D_i ，则必然有： B_{D_i} = A_i + i - D_i 移项， B_{D_i} + D_i = A_i + i 发现两边的形式很像，所以我们只需要建立两个新序列 \\{A_i + i\\} 和 \\{B_i + i\\} 然后将其值排序判断其能不能一一对应就可以判断有没有解了。 然后考虑解的最优性。 刚才的排序中，若按照值为第一关键字排序，原下标为第二关键字排序，则我们不难证明，此时一一对应的结果是最优的。这样子 D_i 就找到了。 然后我们把 A_i 移到 A_{D_i} 的过程很像冒泡排序，用线段树维护一下 A 中元素的下标就可以做了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define int long longconst int maxn = 2e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}struct node{ int val, id; bool operator&lt;(const node &amp;b)const { return val == b.val ? id &lt; b.id : val &lt; b.val; }} ai[maxn], bi[maxn];int a[maxn], b[maxn], n;inline int myabs(int x){ return x &gt;= 0 ? x : -x;}int f[maxn &lt;&lt; 2], tag[maxn &lt;&lt; 1], d[maxn];#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void build(int i, int j, int k){ if (i == j) return void(f[k] = i); build(i, M, L); build(M + 1, j, R); f[k] = f[L] + f[R]; return;}void pushdown(int i, int j, int k){ tag[L] += tag[k], tag[R] += tag[k]; f[L] += (M - i + 1) * tag[k]; f[R] += (j - M) * tag[k]; tag[k] = 0; return;}void modify(int i, int j, int k, int x, int y, int d){ if (x &gt; y) return; if (i &gt;= x &amp;&amp; j &lt;= y) { f[k] += d * (j - i + 1); tag[k] += d; return; } pushdown(i, j, k); if (x &lt;= M) modify(i, M, L, x, y, d); if (y &gt; M) modify(M + 1, j, R, x, y, d); f[k] = f[L] + f[R]; return;}int query(int i, int j, int k, int x){ if (i == j) return f[k]; pushdown(i, j, k); if (x &lt;= M) return query(i, M, L, x); else return query(M + 1, j, R, x);}signed main(){ n = read(); FOR(i, 1, n) a[i] = read(), ai[i].val = a[i] + i, ai[i].id = i; FOR(i, 1, n) b[i] = read(), bi[i].val = b[i] + i, bi[i].id = i; std::sort(ai + 1, ai + n + 1); std::sort(bi + 1, bi + n + 1); FOR(i, 1, n) if (ai[i].val != bi[i].val) return printf(\"-1\\n\"), 0; else d[bi[i].id] = ai[i].id; build(1, n, 1); int ans = 0; FOR(i, 1, n) { ans += abs(query(1, n, 1, d[i]) - i); modify(1, n, 1, 1, d[i], 1); } printf(\"%lld\\n\", ans); return 0;} ARC120D - Bracket Score 2 给定一个长度为 2N 的整数序列 A_i ，依照其构造一个长度为 2N 的合法括号序列，使得其分数最大，分数的计算方式： 对于每一对匹配的括号 S_i 和 S_j ，其贡献为 |A_j - A_i| 将每一对匹配的括号的分数加起来得到总分 眼前一亮的构造。 不难发现，让大的尽量大，小的尽量小就可以使得总分最大。因此选出最大的 N 个 A_i ，标记为黑色，剩余的标记为白色。然后根据一黑一白配对的原则直接构造括号序列即可。 ARC123 A + B + C ARC123B - Increasing Triples 3 个 10^5 级别的序列，可以任意排列，问最多能有多少 i 满足 A_i &lt; B_i &lt; C_i 。 用堆实现的贪心。 ARC123C - 1, 2, 3 - Decomposition 给定 n ，需要求出最小的 k 使得存在长度为 k 的序列 \\{A_i\\} 满足 \\sum A_i = n 且 A_i 的每个数位都为 1 ， 2 或 3 之一。 T （ 1000 ）组数据， n\\le 10^{18} 。 考虑数位 dp。 12345678910111213141516171819202122232425int solve() { static int f[20][25][25]; memset(f, 0, sizeof f); f[1][a[1] - '0'][0] = 1; int n = strlen(a + 1); FOR(i, 1, n - 1) { FOR(j, 1, 20) { FOR(k, 0, 20) { if (f[i][j][k]) { FOR(l, max((j + 2) / 3, k), min(j, a[i + 1] - '0')) f[i + 1][a[i + 1] - '0'][l] = 1; FOR(l, max((j + 1) / 3, k), min(j - 1, a[i + 1] - '0' + 10)) f[i + 1][a[i + 1] - '0' + 10][l] = 1; } } } } int ans = 1e9; FOR(i, 1, 20) FOR(j, 0, 20) if (f[n][i][j]) ans = min(ans, max((i + 2) / 3, j)); return ans;} ARC124 状态很差 A + B ARC125 A + B + C ARC125A - Dial Up 直接贪心即可，细节略多。 ARC125B - Squares 求有序数对 (x, y) 其中 1\\le x, y\\le n （ n\\le 10^{12} ） x^2 - y 为完全平方数 的数量模 998244353 的值。 考虑令 x^2 - y = z^2 ，然后平方差怼过去就是 (x + z)(x - z) = y 。令 x + z = p ， x - z = q 。则问题化为求 (p, q) 的数量： p\\ge q ； x = \\dfrac{p + q}{2} 为整数； 1\\le x = \\dfrac{p + q}{2}\\le n ； 1 \\le y = pq\\le n ； 考虑 O(\\sqrt n) 枚举 q ，然后 p 要满足 q\\le p\\le n 且 p\\equiv q\\pmod 2 。这个东西可以 O(1) 算。于是总复杂度 O(\\sqrt n) 。 ARC125C - LIS to Original Sequence 构造题。 给定 k 个单调增整数 \\{a_1, \\cdots, a_k\\} ，构造字典序最小的排列 \\{p_1, \\cdots, p_n\\} 使得 \\{a_i\\} 为 \\{p_i\\} 的 LIS 之一。 考虑子问题。 k = 1 时，答案显然为 \\{n, n - 1, n - 2, \\cdots, 1\\} 。 k \\ge 2 时，考虑到 LIS 的性质， p_1 = a_1 ，然后如果 p_1\\not= 1 ，为了使得字典序最小且不破坏最长 LIS 的性质， p_2 = 1 。然后就可以依次类推下去推导。 结论是，对于 1\\le i\\le k - 1 ，可以在 a_i 和 a_{i + 1} 中插入至多一个 x 满足 x &lt; a_i 且 x &lt; a_{i + 1} 。最后的所有元素降序排列即可。 ARC125D - Unique Subsequence 给定 \\{a_1, \\cdots, a_n\\} ，问出现次数为 1 的子序列的数量。 考虑 a_0 = 0 ， a_{n + 1} = n + 1 ，然后设计一个 dp 状态 f_i 表示 \\{a_0, \\cdots, a_i\\} 且 a_i 强制选的答案，则最终答案为所有数字最后出现位置的 f 之和。 注意到我们一定不能让 a_i 上一个出现的位置 lst_i 前的 f 对 f_i 产生贡献，否则选取子序列的方式就不唯一了。然后一定要保证是最后一个出现的数产生贡献，所以用一个 BIT 维护就行了。 123456789101112131415161718192021int main() { read(n); FOR(i, 1, n) read(a[i]); FOR(i, 1, n) { last[i] = now[a[i]]; now[a[i]] = i; } add(0, 1); FOR(i, 1, n) { f[i] = sum(i - 1) - sum(last[i] - 1); add(last[i], -f[last[i]]); add(i, f[i]); } modint ans = 0; FOR(i, 1, n) if (now[i]) ans += f[now[i]]; print(ans); return output(), 0;} ARC126 状态差。A + B。 ARC126C - Maximize GCD 给定一个正整数序列 (A_1, \\cdots, A_n) ，每次操作可以选择一个 A_i 然后 A_i\\gets A_i + 1 ，问最多 k 次操作之后能达到的最大的 \\gcd_i\\{A_i\\} 。 1\\le A_i, n\\le 3\\times 10^5 ， 1\\le k\\le 10^{18} 。 考虑从 [1, A_\\max] 先枚举这个 \\gcd\\{A_i\\} ，那么我们要做的就是计算对于每个 A_i 要进行多少次操作。 不妨设当前这个 \\gcd 为 x ，则我们枚举 k ，对于 (k - 1)x &lt; A_i \\le kx 的 A_i ，这个代价是很好算的，随便前缀和优化一下就可以了。所以对于一个 x ，计算其操作次数的时间复杂度为 O(A_\\max / x) 。 如果到了最后每个数都变成 A_\\max 了，还有剩余的操作次数，则考虑继续往上走 \\lfloor k / n\\rfloor 个。总时间复杂度为 O(n + A_\\max\\ln A_\\max) 。 ARC128 A + B + C，rk 340。 ARC128C - Max Dot \\begin{aligned} \\text{maximize } \\sum_{i = 1}^nA_ix_i\\\\ \\text{s.t. } \\begin{cases} 0\\le x_1\\le x_2\\\\ 0\\le x_2\\le x_3\\\\ \\cdots\\\\ 0\\le x_n\\le m\\\\ x_1 + x_2 + \\cdots x_n = S \\end{cases} \\end{aligned} 考虑线性规划的解一定在可行域的端点处取到。所以前几个取 0 ，后几个取 m ，中间几个取平均数。枚举前后缀端点即可。 O(n^2) 。 ARC131 A + B + C + E，rk220。 ARC131B - Grid Repainting 4 由四色定理知直接构造即可。 ARC131C - Zero XOR 牛逼题。给定一数集，两人博弈，一步可以删除一个数字。删到剩下数集的异或和为 0 时获胜。两人都最优方案，问先手是否必胜。 结论：所有数字异或和 x 若 \\in S ，则先手必胜，否则若 n \\equiv 1\\pmod 2 ，先手必胜，否则后手必胜。 x\\in S 的情况非常好理解，先手只需要取出 S 即可。 否则，游戏将在两人取完所有数字之后结束。最后一个取的人将为赢家。 ARC131E - Christmas Wreath 题意：给完全图的边染色 (R,B,W) ，要求三种颜色出现的频率相等，且任意一个三元环不能出现三边颜色不一样，求构造方案或输出无解。 考虑邻接矩阵，发现每一行颜色相同就能满足第二个条件。 第一个条件就随便构造即可。 ARC132 ARC132A - Permutation Grid 比较妙的思路。考虑初始构造出一个状态然后根据排列变换。结论为 R_x +C_y\\ge n 。 ARC132B - Shift and Reverse 可以注意到翻转操作至多进行两次。 直接分类讨论然后做做就行了。 ARC132C - Almost Sorted 比较好的状压题。 给定一个序列 a_i ， a_i\\in\\{-1, 1, 2, 3,\\cdots, n\\} ，和一个整数 d 。问满足如下条件的排列 p_i 的个数模 998244353 。 p_1,\\cdots,p_n 为 [1,n] 排列。 若 a_i\\ne -1 ，则 p_i = a_i 。 \\forall i ，满足 |p_i - i|\\le d 。 1\\le d\\le 5 ， d &lt; n\\le 500 。 首先我们注意到， p_i\\in[i - d, i + d] ，值域区间长度最大为 11 ，所以可以考虑状压起来。我们令 f_{i, S} 表示 [i - d, i + d] 的值域区间的占用情况为 S 的方案数。 然后我们就可以进行转移了，每次就枚举第 i 格填的数，细节比较多，参见如下代码。时间复杂度为 O(4^ddn) ，可以通过本题。 12345678910111213141516171819202122232425262728293031const int maxn = 505;int a[maxn], n, d, vis[maxn];modint f[maxn][1 &lt;&lt; 12];int getfirst() { int ans = 0; FOR(i, 1, d) { ans |= (1 &lt;&lt; (i + d)) * vis[i]; } return ans;}int main() { read(n, d); FOR(i, 1, n) read(a[i]); FOR(j, 1, n) FOR(i, 1, n) if (a[i] == j) vis[j] = 1; f[0][getfirst()] = 1; FOR(i, 1, n) { FOR(S, 0, (1 &lt;&lt; (2 * d + 1)) - 1) { int now = (S &gt;&gt; 1) | (vis[i + d] &lt;&lt; (2 * d)); if (~a[i]) f[i][now] += f[i - 1][S]; else FOR(j, -d, d) { if (i + j &lt; 1 || i + j &gt; n || now &amp; (1 &lt;&lt; (j + d))) continue; f[i][now | (1 &lt;&lt; (j + d))] += f[i - 1][S]; } } } print(f[n][(1 &lt;&lt; (d + 1)) - 1]); return output(), 0;} ARC132D - Between Two Binary Strings 设 S_{n,m} 为所有的长度为 n+ m ，且包含恰好 n 个 0 和 m 个 1 的字符串的集合。定义一个字符串的美丽程度为相邻两位相同的个数，定义 S_1 与 S_2 的编辑距离 d_{S_1, S_2} 为将 S_1 变成 S_2 的操作次数，其中每次操作能交换相邻的两个字符，且 S_1, S_2\\in S_{n,m} 。 定义 S_2 在 S_1 与 S_3 间当且仅当 d_{S_1, S_3} = d_{S_1, S_2} + d_{S_2, S_3} 。给定 S 和 T ，问在 S 与 T 间的字符串的最大美丽程度。 这题是一道比较妙的结论题：当确定第一个字母时，整个字符串可以贪心的进行构造，只需保证前 x 个里面 1 的个数处于 S 和 T 的中间。然后我们又要最大化美丽值，依此构造即可。 证明：考虑一个字符串就是二维平面上一条从 (0, 0) 走到 (n, m) 的路径。某一位是 1 表示向上走一格，某一位是 0 表示向右走一格。同时，一个字符串的美丽值就是长度减一再减拐点个数。 而我们发现，交换两个相邻的 01 相当于是将一个拐点翻折，故在平面上处于 S 和 T 中间的路径都是可行的。那么我们其实就是，能不拐就不拐。 123456789101112131415161718192021222324252627282930const int maxn = 3e5 + 5;char s[maxn], t[maxn];int n, m;int main() { read(n, m); read(s + 1), read(t + 1); int ans = 0, len = n + m; FOR(init, 0, 1) { int s0 = 0, t0 = 0, x0 = 0; if (init != s[1] - '0' &amp;&amp; init != t[1] - '0') continue; int cnt = 0; int now = init; FOR(i, 1, len) { s0 += (s[i] == '0'), t0 += (t[i] == '0'); if (now == 0) { if (x0 + 1 &lt;= max(s0, t0)) ++cnt; else now = 1; } else { if (x0 &gt;= min(s0, t0)) ++cnt; else now = 0; } if (now == 0) ++x0; } chkmax(ans, cnt - 1); } print(ans); return output(), 0;} ARC134 ARC134C - The Majority K 个有标号盒子，初始全为空。有 N 种颜色的球，第 i 种颜色有 a_i 个球，同种颜色的球不区分。现要将所有球放入盒子里，要求每个盒子里面，颜色 1 的球的个数要占到一半以上（严格）。问方案数。 比较巧妙的计数套路（雾），即我们考虑将 1 颜色的球和其他的球一一配对，即将 a_1:=a_1 - \\sum_{i = 2}^na_i ，然后将 [2, n] 颜色的球放入 K 个盒子里（可以有空盒），求出方案数，然后再乘上将 1 颜色的球放入 K 个盒子的方案数（不允许有空盒），即 \\binom{a_1 - \\sum_{i = 2}^na_i}{K + 1}\\prod_{i=2}^n\\binom{a_i + K + 1}{K+1} 正确性显然，思想较为重要，marked。 ARC134D - Concatenate Subsequences 给定长度为 2N 的正整数序列 a 。现要构造 a 的一个子序列，方案为：从 1, 2, \\cdots, N 中取出一个子序列 x_1, \\cdots, x_k ，然后取出 a_{x_1}, a_{x_2},\\cdots, a_{x_k}, a_{x_1 + N}, a_{x_2 +N},\\cdots, a_{x_k + N} 。要求构造出来的这个序列字典序最小，输出这个序列。 字典序问题一般考虑贪心。我们令 A = a_1, a_2, \\cdots, a_N ， B = a_{N+ 1},\\cdots, a_{2N} ，取 A 中的最小值为 X 。 则如果存在一个 A_i 使得 A_i = X\\land B_i\\le A_i ，则把只最小的 B_i 取走就一定是最优的。 下面我们假设对于所有的 A_i = X 都有 A_i&lt;B_i ，可以证明把他们全部取走是最优的，而后就需要考虑取剩下的元素了。令所有 A_i = X 的 i 升序构成序列 y_1,\\cdots, y_k 。接下来考虑的就是满足 y_k&lt;j\\le N\\land A_j\\le B_{y_1} 的 j 。 可以发现，将其按照 (A_j, j) 升序排序之后，我们会优先取走所有的 A_j &lt; B_{y_1} 的 j ，最后就是考虑 A_j = B_{y_1} 的情况，这时候就需要考虑第一个 B_{y_m} 满足 B_{y_m}\\ne B_{y_1} ，即如果加进去能使得字典序更小，那就加，否则就不要加。 于是这题就做完了，细节有点烦，评测记录。 ARC137 A + B + D，rk281。 ARC137A - Coprime Pair 题意：给定 1\\le L &lt; R\\le 10^{18} ，求一对 (x,y) 满足 L\\le x\\le y\\le R 使得 \\gcd(x,y) = 1 。 由于在题目约束下，素数间隔至多为 K= 1500 左右，所以直接从 L 右边和 R 左边暴力找答案即可。时间复杂度 O(K^2\\log R) 。 然而这个东西似乎有更紧的界，但是 atcoder 官方题解我看不懂。 ARC137B - Count 1's 题意：给定一个 0-1 串，可以将一个子段翻转一次，问最后能达到多少种不同的 1 。 首先可以观察到最后达到的 1 的个数肯定是连续的一段。 所以考虑求出 0 的个数减 1 的个数 的最大值和最小值。发现 \\max + \\min + 1 即为答案。 ARC137C - Distinct Numbers 题意：给定 N 个元素的数集 S ，保证元素两两不同。先手后手博弈，轮到每人操作时，将最大的数取出，换成一个更小的非负整数再塞回去，需保证元素两两不同的性质不被破坏。第一个没办法进行操作的玩家输。问赢家。 结论题（？）。分类讨论： a_n - a_{n-1}&gt;1 。 考虑 a_1, a_2,\\cdots, a_{n-1}, a_{n-1} +1 的局面。 若其为必胜态，那么其可以转移到一个必败态，原序列也可以直接转移到那个必败态。 若其为必败态，那么原序列可以直接转移到他。 所以 Alice 必胜。 a_n - a_{n-1} = 1 。 发现双方都要尽可能维持这个状态，否则就变成对手必胜。 每次操作的时候 a_{n} - a_{n-1} 都是 1 。每次操作后会发现原来的次大值变成了新的最大值。判断 a_n - n 的奇偶性即可。 123456789101112const int maxn = 3e5 + 5;int a[maxn], n;int main() { read(n); FOR(i, 1, n) read(a[i]); if (a[n] - a[n - 1] &gt; 1) print(\"Alice\"); else if ((n + a[n] + 1) &amp; 1) print(\"Alice\"); else print(\"Bob\"); return output(), 0;} ARC137D - Prefix XORs 题意：给定整数序列 A ， N\\le 10^6 ，以及整数 m 。对每个 k=1,2,\\cdots, m ，求出经过下面操作 k 次之后 A_n 的值。 对于每个 i ，令 B_i = \\displaystyle\\bigoplus_{i=1}^i A_i ，其中 \\oplus 代表异或。 然后令 A = B 。 那么很显然，我们可以考虑对于一个固定的 k ， A_i 对 A_n 贡献了多少次，下面假定 i 从 0 开始编号。 然后你发现 A_i 对 A_n 会贡献 \\dbinom{n - i + k - 1}{k - 1} 次。你会注意到我们只需要知道他的奇偶性，其为奇数就会产生贡献。 考虑卢卡斯定理的 p 进制形式，发现当且仅当 n - i + k - 1 为 k - 1 在二进制表示下的超集时，Lucas 的式子里面才不会有 0 项，才会产生 \\dbinom{n - i + k - 1}{k - 1} 的贡献。 然后注意到，因为 n - i + k - 1 为 k - 1 的超集，所以 n - i 按位与上 k - 1 必然是 0 。那么就考虑做一个高维前缀和，然后对每个 k - 1 查询的时候把 k - 1 取补集即可。 123456789101112const int maxn = (1 &lt;&lt; 20) | 5;int a[maxn], n, m;int main() { read(n, m); FOR(i, 0, n - 1) read(a[i]); reverse(a, a + n); FOR(j, 0, 19) FOR(i, 0, (1 &lt;&lt; 20) - 1) if (i &amp; (1 &lt;&lt; j)) a[i] ^= a[i ^ (1 &lt;&lt; j)]; FOR(k, 1, m) print(a[(k - 1) ^ ((1 &lt;&lt; 20) - 1)], ' '); return output(), 0;} ARC137E - Bakery 题意：规划面包店，天数为 1,2,\\cdots, N 。有 M 个面包师，编号从 1 到 M ，雇用 i 的开支是 C_i ，然后其会在 L_i,\\cdots, R_i 每天做一个面包。第 i 天面包师一共做了 x_i 个面包的话，售出的就是 \\min(A_i,x_i) 个面包。每个面包获利 D ，求最大利润（售出面包的获利减去雇佣面包师的开支） 1\\le N,M\\le 2000 ， 1\\le D,C_i\\le 10^9 。 第一眼考虑建费用流，然而用面包来流似乎不好处理面包师的开支。 那么只能拿面包师来流了，对于面包的贡献，就考虑在天数之间流。具体地：建立图，编号从 0 到 N 。 j\\to(j - 1) ，流量 A_j ，费用 -D 。这部分处理产生贡献的面包。 j\\to (j-1) ，流量 M - A_j ，费用 0 。这部分要让剩下产生不了贡献的流过去。 (L_{i} - 1)\\to R_i ，流量 1 ，费用 C_i 。这部分处理面包师的费用。 上图的最小费用循环流的费用就是答案。然而我们不会直球做费用循环流，所以考虑一下怎么转化。 首先，选一个面包师相当于选了一个环，我们肯定是会选负环（否则不如不选）。那么就对所有的负权边 (u,v,w,c) 进行如下处理：加边 (s, v, w, 0) ， (u, t, w, 0) 和 (v, u, w, -c) ，然后费用预先加上 c 。剩下的正权和 0 权边照旧不变，然后跑一个流量为 M 的最小费用流。 这样做的正确性是：先假设负权边全部流满，然后若流了 s\\to v\\to u\\to t 相当于退掉原来的流。剩下就是和正权边连环计算了。 具体地，在本题里面，由于图结构的特殊性， (s,v,w,0) 和 (u,t,w,0) 是没必要加的，因为对于一个点，其一定会同时连 s 和 t ，最小费用最大流告诉我们会优先流满 s\\to u\\to t ，对费用不产生影响。所以我们甚至可以丢掉超级源汇。 综上，连边方式如下：对每个天连 (j-1,j,A_j,D) ， (j-1,j,M - A_j,0) ，再对每个面包师连 (L_i - 1, R_i, 1, C_i) ，跑 0 到 N 的流量为 M 的最小费用流即可。 本题卡朴素的 EK + SPFA 费用流，正解是原始对偶算法，时间复杂度 O(N^2\\log N) ，视 N 与 M 同阶。如果你是和我一样的懒狗的话可以用一下 ACL 官方的费用流，用的就是原始对偶，很快。 123456789101112131415161718192021using ll = long long;const int maxn = 2005;int N, M, D;int main() { read(N, M, D); atcoder::mcf_graph&lt;ll, ll&gt; G(N + 1); ll ans = 0; FOR(i, 1, N) { int a; read(a); G.add_edge(i - 1, i, a, D), G.add_edge(i - 1, i, M - a, 0); ans += 1ll * D * a; } FOR(i, 1, M) { int l, r, c; read(l, r, c); G.add_edge(l - 1, r, 1, c); } print(ans - G.flow(0, N, M).second); return output(), 0;} ARC138 ARC138C - Rotate and Play Game 第一步通过观察大样例发现，Snuke 一定会取走最大的 n / 2 个元素。 那么我们考虑对于一个静态的序列，Snuke 如何能够成功取走最大的 n/2 个元素。 发现若视最大的（要取走的） n/2 个元素为 -1 ，剩余的为 1 的话，相当于对于每一个位置，前缀和都不能为负（虽然只是充分，但不必要）。证明：每一轮中，Snuke 取走最靠前的 -1 （肯定要避免他被抢走），然后 Mr. Min 照常取一个 +1 ，于是乎原序列前缀和的性质肯定还是满足的。 现在问题就变为如何求循环位移的偏移量。注意到根据括号序列的性质，其一定有解。 那么就将这个序列复制一份，然后看 [i, i + n - 1] 中的前缀和最小值是否 \\ge S_i 即可。可以使用 ST 表或者滑动窗口一类的来做。 123456789101112131415161718192021222324252627282930313233#include &lt;bits/stdc++.h&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;using ll = long long;const int maxn = 2e5 + 5;int n, st[20][maxn &lt;&lt; 1], lg[maxn &lt;&lt; 1];struct Node { ll val; int id;} a[maxn &lt;&lt; 1];int main() { cin &gt;&gt; n; FOR(i, 1, n) cin &gt;&gt; a[i].val, a[i].id = i; sort(a + 1, a + n + 1, [](const Node &amp;a, const Node &amp;b) {return a.val &gt; b.val;}); ll sum = 0, tmp = a[n &gt;&gt; 1].val; FOR(i, 1, n &gt;&gt; 1) sum += a[i].val, a[i].val = 1; FOR(i, (n &gt;&gt; 1) + 1, n) a[i].val = -1; sort(a + 1, a + n + 1, [](const Node &amp;a, const Node &amp;b) {return a.id &lt; b.id;}); FOR(i, 1, n) a[n + i] = a[i]; lg[0] = -1; FOR(i, 1, n &lt;&lt; 1) st[0][i] = st[0][i - 1] + a[i].val, lg[i] = lg[i &gt;&gt; 1] + 1; FOR(j, 1, 19) FOR(i, 1, (n &lt;&lt; 1) - (1 &lt;&lt; j) + 1) st[j][i] = max(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]); const int s = 31 - __builtin_clz(n); FOR(i, 1, n) if (a[i].val == 1) { int ret = max(st[s][i], st[s][i + n - (1 &lt;&lt; s)]); if (ret &lt;= st[0][i]) return cout &lt;&lt; i - 1 &lt;&lt; ' ' &lt;&lt; sum &lt;&lt; endl, 0; } return 0;} 注意代码里面的 \\pm 1 和 \\min/\\max 性似乎和题解相反（反正是对称的，不管了）。 ARC138D - Differ by K bits 撞了洛谷原题 P7949。 本题中，暴力的复杂度貌似是对的，具体原因不详。 12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;const int maxn = 1 &lt;&lt; 20 | 5;int n, k, vis[maxn];vector&lt;int&gt; a, b;void dfs(int x) { a.push_back(x); vis[x] = 1; if (a.size() == (1 &lt;&lt; n)) { puts(\"Yes\"); for (auto &amp;x : a) cout &lt;&lt; x &lt;&lt; \" \"; exit(0); } for (auto &amp;c : b) if (!vis[c ^ x]) dfs(c ^ x); return;}int main() { cin &gt;&gt; n &gt;&gt; k; if (k % 2 == 0) return puts(\"No\"), 0; FOR(i, 0, (1 &lt;&lt; n) - 1) if (__builtin_popcount(i) == k) b.push_back(i); dfs(0); return puts(\"No\"), 0;} 考虑正解：首先我们注意到，若 k 为偶数，其一定无解。因为不可能所有数的 \\mathrm{popcount} 都是偶数。且 k = n 的情况也无解。 而我们若是将 \\mathrm{popcount}(x) = k 的 x 插入线性基 \\mathfrak B ，则可以将成功插入的数看作一组基底，而若 |\\mathfrak B|&lt;n 显然也无解。否则我们总能构造出答案：只需要满足构成相邻两个数的线性组合中，有一项不一样即可，具体这个可以用格雷码实现： 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)using namespace std;int n, k, a[22], p[22], cnt;void insert(int x0) { int x = x0; DEC(j, n - 1, 0) if ((x &gt;&gt; j) &amp; 1) { if (!p[j]) { p[j] = x, a[cnt++] = x0; break; } else x ^= p[j]; } return;}int main() { cin &gt;&gt; n &gt;&gt; k; FOR(i, 0, (1 &lt;&lt; n) - 1) if (__builtin_popcount(i) == k) insert(i); if (cnt &lt; n) return puts(\"No\"), 0; cout &lt;&lt; \"\" &lt;&lt; endl; FOR(i, 0, (1 &lt;&lt; n) - 1) { int g = i ^ (i &gt;&gt; 1), now = 0; FOR(j, 0, n - 1) if ((g &gt;&gt; j) &amp; 1) now ^= a[j]; cout &lt;&lt; now &lt;&lt; ' '; } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"FWT","slug":"FWT","permalink":"https://old.blog.imyangty.com/tags/FWT/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"后缀数组","slug":"SA","permalink":"https://old.blog.imyangty.com/tags/SA/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Lucas定理","slug":"lucas","permalink":"https://old.blog.imyangty.com/tags/lucas/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"博弈论","slug":"game-theory","permalink":"https://old.blog.imyangty.com/tags/game-theory/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"FFT","slug":"FFT","permalink":"https://old.blog.imyangty.com/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"树的直径","slug":"diameter-of-tree","permalink":"https://old.blog.imyangty.com/tags/diameter-of-tree/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"区间dp","slug":"interval-dp","permalink":"https://old.blog.imyangty.com/tags/interval-dp/"},{"name":"cdq分治","slug":"cdq","permalink":"https://old.blog.imyangty.com/tags/cdq/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"},{"name":"素数与筛法","slug":"prime","permalink":"https://old.blog.imyangty.com/tags/prime/"},{"name":"费用流","slug":"mincostflow","permalink":"https://old.blog.imyangty.com/tags/mincostflow/"},{"name":"二分图","slug":"bi-graph","permalink":"https://old.blog.imyangty.com/tags/bi-graph/"},{"name":"原根","slug":"primitive-root","permalink":"https://old.blog.imyangty.com/tags/primitive-root/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://old.blog.imyangty.com/tags/prefix-sum/"},{"name":"高维前缀和","slug":"sosdp","permalink":"https://old.blog.imyangty.com/tags/sosdp/"},{"name":"动态dp","slug":"ddp","permalink":"https://old.blog.imyangty.com/tags/ddp/"},{"name":"线性基","slug":"linear-basis","permalink":"https://old.blog.imyangty.com/tags/linear-basis/"},{"name":"换根dp","slug":"root-changing-dp","permalink":"https://old.blog.imyangty.com/tags/root-changing-dp/"},{"name":"单调栈","slug":"mono-stack","permalink":"https://old.blog.imyangty.com/tags/mono-stack/"}]},{"title":"斜率优化学习笔记","slug":"note-slope-dp","date":"2021-04-22T12:25:59.000Z","updated":"2022-04-14T08:17:33.154Z","comments":true,"path":"note-slope-dp/","link":"","permalink":"https://old.blog.imyangty.com/note-slope-dp/","excerpt":"","text":"前言 有些时候，我们会碰到形如 f_i = \\min/\\max\\{f_j + g(i)h(j)\\} 的状态转移方程，此时朴素的做的时间复杂度是 O(n^2) 乃至 O(n^3) 的。而我们可以按照线性规划的思想，把其建模成 y = kx + b 的形式去截一个凸壳来使截距最大，达到 O(\\log n) 甚至 O(1) 的转移从而使复杂度降低到 O(n\\log n) 或 O(n) 。 这个方法就叫做斜率优化。具体的实现难度取决于题目性质。 一般来说，只要转移方程中出现类似一次函数的东西，都可以考虑斜率优化。 例题 先来看一道斜率优化的模板题。 题意 P3195 [HNOI2008]玩具装箱 将一段序列 c_i 分成若干段，每一段的代价为 (j-i+\\sum_{k=i}^jc_k-L)^2 ，求最小总代价。 从状态转移方程说起 不难发现状态转移方程为（如果有困难建议先去补 dp 的基础知识） f_i=\\min_{j&lt;i}\\lbrace f_j+(s_i-s_j+i-j-1-L)^2\\rbrace 其中 s_i=\\sum_{k=1}^ic_k 。时间复杂度为 n^2 ，考虑进行优化。 为了简化方程，不妨采用参变分离的思想，将只与 i 有关的 s_i+i 令为 a_i ，将只与 j 有关的 s_j+j+L+1 令为 b_j ，现在的方程为 f_i=\\min_{j&lt;i}\\lbrace f_j+(a_i-b_j)^2\\rbrace 理一下思路：现在我们需要找到一个最优的 j ，使得 f_i 达到最优，注意到此时所有关于 i 的量都是确定的。 去掉 min 然后化简转移方程可得： 2a_ib_j+f_i-a_i^2=f_j+b_j^2 第一种理解：数形结合 斜率优化的精髓，就是要把转移方程化为直线方程 y=kx+b 的形式然后使用数据结构维护一个凸壳。下面来实现这个过程。如果没有学过高一数学线性规划的话建议先去了解或者是直接看第二种更好理解的方式。 一般地，我们将所有只跟 j 有关的项 f_1(j) 看作 y ，将所有只跟 i 有关的项 f_2(i) 看作截距 b ，会剩下一项 f_3(i)f_4(j) ，考虑将 f_3(i) 看作斜率 k ， f_4(j) 看作 x 。 这里就是 f_j+b_j^2=y ， b_j=x 方程化作 2a_ix+f_i-a_i^2=y 注意到除 f_i 以外的与 i 有关的项都是确定的，所以现在的问题就是在坐标系中找到这个 (x,y) 使直线的截距最小（因为要最小化 f_i ）。用含 j 的形式方便理解的话就是找到过确定点 (b_j,f_j+b_j^2) 的斜率为 2a_i 的直线的最小截距。 怎么找呢？看下面的图： 很显然， B 点是我们的最优选择，至于 A 点，因为我们的斜率 k=2a_i 满足单调递增，所以可以让 A 点滚蛋了，至于 C 点，如果我们当前的斜率足够大： 则 B 点这辈子以后也不可能用到了，可以让他拜拜了。 定义 \\operatorname{slope}(A,B) 为直线 AB 的斜率 我们不难发现这样的性质：为了让我们使用的决策点 (b_j,f_j+b_j^2) 最优，我们需要让这些可供选择的决策点形成一个凸壳，即形式化地，设我们维护的这些点序列为 \\lbrace P_i\\rbrace ，且要求 P_1 为需要的决策点，则一定要有 \\operatorname{slope}(P_{i-1},P_i)&lt;\\operatorname{slope}(P_i,P_{i+1}) ，即相邻两点间的斜率要单调递增。 同时如果 \\operatorname{slope}(P_1,P_2)&lt;k ，则选择 P_1 一定不优（在坐标系里面画图可以感受一下），需要弹掉这些点。 做完决策（即求出 f_i 之后），我们需要将 (b_i,f_i+b_i^2) 放入这个序列的末尾，但是还是要满足凸壳的性质。因此考虑用单调队列维护这些点。 12345678910for (int i = 1; i &lt;= n; ++i) { while (head &lt; tail &amp;&amp; slope(q[head], q[head + 1]) &lt; 2 * a[i])//这里是一开始的弹点操作 ++head; int j = q[head]; f[i] = f[j] + (a[i] - b[j]) * (a[i] - b[j]);//进行决策 while (head &lt; tail &amp;&amp; slope(i, q[tail - 1]) &lt; slope(q[tail - 1], q[tail]))//弹尾部的点维护凸性 --tail; q[++tail] = i;//加入凸壳} 整道题的代码就是： 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cctype&gt;const int maxn = 5e4 + 5;int n;double a[maxn], b[maxn], f[maxn], sum[maxn], L;int q[maxn], head, tail;inline double X(int x) { return b[x]; }inline double Y(int x) { return f[x] + b[x] * b[x]; }inline double slope(int a, int b) { return (Y(a) - Y(b)) / (X(a) - X(b)); }inline int read() {...}int main() { n = read(), L = read(); for (int i = 1; i &lt;= n; ++i) { sum[i] = sum[i - 1] + read(); a[i] = sum[i] + i; b[i] = sum[i] + i + L + 1; } b[0] = sum[0] + 0 + L + 1;//注意，$b_0$ 不等于 0 head = tail = 1; for (int i = 1; i &lt;= n; ++i) { while (head &lt; tail &amp;&amp; slope(q[head], q[head + 1]) &lt; 2 * a[i]) ++head; int j = q[head]; f[i] = f[j] + (a[i] - b[j]) * (a[i] - b[j]); while (head &lt; tail &amp;&amp; slope(i, q[tail - 1]) &lt; slope(q[tail - 1], q[tail])) --tail; q[++tail] = i; } printf(\"%lld\\n\", (long long)f[n]);//观察数据范围发现这东西会爆int return 0;} 第二种理解方式：代数 现在的方程是 f_i = \\min\\{f_j + a_i^2 - 2a_ib_j + b_j^2\\} ，首先肯定是将与决策点无关的项提出来，方程化为 f_i = \\min\\{f_j - 2a_ib_j + b_j^2\\} + a_i^2 现在需要最小化的，就是 f_j - 2a_ib_j + b_j^2 。那么我们考虑一下决策点 j 何时会比决策点 k 更优： \\begin{aligned} f_j - 2a_ib_j + b_j^2 &amp;&lt; f_k - 2a_ib_k + b_k^2\\\\ (f_j + b_j^2) - (f_k + b_k^2) &amp;&lt; 2a_i(b_j - b_k)\\\\ \\frac{(f_j + b_j^2) - (f_k + b_k^2)}{b_j - b_k} &amp;&lt; 2a_i \\end{aligned} 第二行是参变分离，把带有 i 的移到一边。第三行就是化为斜率的形式。 不难发现这样子更加好找斜率和坐标的定义。 f_i + b_i^2 就是纵坐标， b_i 就是横坐标， 2a_i 即为斜率。 因此我们知道了，如果一个决策点 j 优于 k ，那么 j 所代表的点到 k 所代表的点的连线的斜率一定小于 2a_i 。而我们就是要在 [1, i) 这些决策点里面找到一个最优的决策点，相当于斜率刚刚好好小于等于 2a_i 。由于横坐标 b_i 递增，这个过程是可以在凸包上面二分实现的。 然而我们注意到每次查询的斜率 2a_i 是单调增的，所以我们可以把那些斜率小于 2a_i 的点先删掉，因为他们肯定不会最优。而且我们要维护一个斜率递增的决策点序列（就是一个凸包），所以算完了 f_i 并加点的时候要维护凸包后端的斜率单调性。这可以解释上面的一系列过程。 总结 对于形如 f_i=\\min_{j&lt;i}\\lbrace f_j-a_id_j\\rbrace ，且 a_i 和 d_i 满足单调递增的状态转移方程，我们可以使用斜率优化将其从朴素的 O(n^2) 优化到 O(n) 。 具体地，我们将其看作一条直线方程的形式： f_j=f_i+a_id_j ，将 f_j 看作 y ， d_j 看作 x ， a_i 看作斜率 k ， f_i 看作截距。我们就可以利用其单调性维护一个凸壳，来起到加速转移的效果。 步骤一般是如下三步： 弹出队首的点，找到最优决策点 j 根据转移方程算出 f_i 维护凸壳的右端 一些需要注意的点 有些时候需要使用 long double，一部分题卡精度卡的很凶，所以建议使用乘法来判断斜率，当然一定要看清楚不等号的方向（负数乘过去要变号）。 大多数时候需要 long long。 大多数时候，队列中一开始需要有初始转移点 0 。 在删点的时候的判定一定是基于两个点的斜率的，所以队列中必须有两个或以上的元素。 关于要维护的东西的单调性是增还是减：一定自己推式子看清楚，不要觉得是什么就是什么。 有些毒瘤题的斜率或横坐标没有单调性，这时候需要在凸壳上二分（斜率不单调）或者李超树（都不单调）。一般推荐使用李超树，十分好理解且代码不难写。 有些复杂度为 O(nk) 的题（相当于做 k 次 O(n) 的 dp），一定要处理好滚动数组，要清楚调用的是哪个 dp 值。 其他例题 一般比较有代表性，篇幅问题，只给出详细的题解。 P5785 [SDOI2012]任务安排 斜率不一定单调的题目，需要在凸壳上二分。 P4655 [CEOI2017]Building Bridges 斜率和横坐标都不单调，需要 cdq 分治或者李超树。 P5017 摆渡车 比较经典的斜优模型。 习题 P3648 [APIO2014]序列分割 经典卡常卡精度毒瘤题。 CF311B Cats Transport 和摆渡车类似的经典模型。 P2120 [ZJOI2007]仓库建设 经典套路模型。 P4360 [CEOI2004]锯木厂选址 经典套路模型。 P3628 [APIO2010]特别行动队 简单推推式子。 P4072 [SDOI2016]征途 要注意 dp 值的初始化。 上面的几道题难度递增，都是比较好想的经典斜优题。敲完了这几道就上手斜优了。 然后是一些较难的题。 P4027 [NOI2007] 货币兑换 其实也没多难，只是不单调。 P1721 [NOI2016] 国王饮水记 神仙结论题。 P2305 [NOI2014] 购票 树上转移，需要点分治。 CF932F Escape Through Leaf 使用李超树的线段树合并非常好写。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"}]},{"title":"后缀数组","slug":"note-sa","date":"2021-04-21T13:12:47.000Z","updated":"2022-03-23T04:17:42.203Z","comments":true,"path":"note-sa/","link":"","permalink":"https://old.blog.imyangty.com/note-sa/","excerpt":"","text":"基础 定义 本文的字符串下标从 1 开始。“后缀 i ”指代从第 i 个字母开始的后缀。 后缀数组由两个数组构成，一个是 sa[]，一个是 rk[]。 sa[i] 表示的是后缀排名后第 i 小的后缀的编号，rk[i] 表示的是后缀 i 的排名。 即 sa 告诉我们排第几的是谁，rk 告诉我们谁排第几。 不难发现 sa[rk[i]] = rk[sa[i]] = i，这是一个比较好玩的性质。 求法 最暴力的办法就是枚举所有的后缀然后排序，复杂度 O(n^2\\log n) ，妥妥的炸掉。下面要讲的倍增法可以做到在 O(n\\log n) 的时间内求出一个字符串的后缀数组。 首先，我们很容易求得每个长度为 1 的子串（每个字符）的排名。然后考虑倍增。假设已经知道了长度为 k 的子串的排名们 rk[k][i]。（rk[k][i] 表示从 i 开始长度为 k （或者已经到底了，长度不足 k ）的子串在所有这些长度为 k 的子串中的排名），那么如果我们以 rk[k][i] 为第一关键字，rk[k][i + k] 为第二关键字（若 i + k &gt; n 则为无穷小）进行排序，就可以求得 rk[2k][i] 在所有长度为 2k 的子串们的排名了。 这样子一直倍增下去，当 k = n 时不难发现此时后缀数组就已经被求出来了。但是，排序的复杂度为 O(n\\log n) ，按理来说总复杂度为 O(n\\log^2n) ，那我们有什么神奇的办法可以将其优化到 O(n\\log n) 呢？ 基数排序。 双关键字排序，所以我们可以使用 O(n) 的基数排序使总复杂度降低为一个 \\log 。 但是说是这么说，真要写起来后缀数组真的短小精悍但是对于初学者来说十分难以理解。下面看看其具体实现。 实现 先来看看这短小的实现：（洛谷 P3809 【模板】后缀排序） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 1e6 + 5;int n, m, sa[maxn], rank[maxn];char s[maxn];int x[maxn], y[maxn], c[maxn];void SA(){ FOR(i, 1, n) ++c[x[i] = s[i]]; FOR(i, 1, m) c[i] += c[i - 1]; DEC(i, n, 1) sa[c[x[i]]--] = i; for (int k = 1; k &lt;= n; k &lt;&lt;= 1) { int num = 0; FOR(i, n - k + 1, n) y[++num] = i; FOR(i, 1, n) if (sa[i] &gt; k) y[++num] = sa[i] - k; memset(c, 0, sizeof c); FOR(i, 1, n) ++c[x[i]]; FOR(i, 1, m) c[i] += c[i - 1]; DEC(i, n, 1) sa[c[x[y[i]]]--] = y[i]; std::swap(x, y); num = 1, x[sa[1]] = 1; FOR(i, 2, n) { if (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) x[sa[i]] = num; else x[sa[i]] = ++num; } if (num == n) break; m = num; } return;}int main(){ scanf(\"%s\", s + 1); n = strlen(s + 1); m = 122; SA(); FOR(i, 1, n) printf(\"%d \", sa[i]); return 0;} 不科学，这么这么短。没错，其就是这么短，但是仔细一看会一脸懵逼，发现什么都看不懂。所以还是从头来，慢慢看： 12345int n, sa[maxn];char s[maxn];int x[maxn], y[maxn], c[maxn]; 这些数组中，n 和 s[] 就不解释了，再强调一下 sa[i] 的意义：排名为 i 的是谁。然后 c[] 是基数排序要用到的桶，x[] 是第一关键字，y[] 是第二关键字，具体的意义下面会解释。 首先看看 SA() 函数的前三行： 1234 FOR(i, 1, n) ++c[x[i] = s[i]]; FOR(i, 2, m) c[i] += c[i - 1]; DEC(i, n, 1) sa[c[x[i]]--] = i; 第一行，x[i] = s[i] 表示我们把字符直接赋值到第一关键字里面，相当于获取了个相对的位置，同时加进桶里面。 第二行是做前缀和，获取所有关键字的排名， m 表示字符集的大小（因为桶的下标是字符的 ASCII 码）。 第三行就是把对应的排名为 c[x[i]]-- 的是谁给记录起，为什么要 -- 呢？因为字符可以有重复的，此时倒序循环就可以保证先出现的子串排在前面 接下来开循环了： 12 for (int k = 1; k &lt;= n; k &lt;&lt;= 1) k 表示第一/二关键字的长度，这里就开始倍增了。 下面开始对第二关键字进行操作： 123 int num = 0; FOR(i, n - k + 1, n) y[++num] = i; 此时 y[i] 的意义是第二关键字排名为 i 的数对应的第一关键字的位置，注意排名是下标。 [n - k + 1, n] 是没有第二关键字的，所以他们的排名在最前面。 12 FOR(i, 1, n) if (sa[i] &gt; k) y[++num] = sa[i] - k; 此时枚举的 i 是排名，如果该排名对应的下标大于 k ，说明它可以接在前面做第二关键字，然后把其对应的第一关键字的位置 sa[i] - k 加进 y[] 数组。回顾一下 y[i] 的定义：第二关键字排名为 i 的数对应的第一关键字的位置。 然后就是基数排序了，这里需要着重理解： 12345 memset(c, 0, sizeof c);//清空桶 FOR(i, 1, n) ++c[x[i]]; FOR(i, 2, m) c[i] += c[i - 1]; DEC(i, n, 1) sa[c[x[y[i]]]--] = y[i]; 前三行没有什么好说的，就是获取第一关键字的排名。主要是第四行的那个循环。这里是什么意思呢？注意到我们貌似只对第一关键字进行了所谓的排序，但是这样做就是对的，这是为什么呢？ x[] 数组里面存着本次的第一关键字排序（上次的结果，即为 rk[] 数组），即**x[i] 表示 i 开头的子串的排名**，而我们通过 y[] 先对第二关键字进行了排序，以此保证**第一关键字相同的时候，出现在前面的第二关键字出现在前面。**换句话说，这个基数排序实际上就是先根据 x[] 的值排序，x[] 相同的时候再根据 y[] 排序。 建议看到这里的时候结合 x[]，y[] 的下标和值的意义进行多次脑补： 首先我们把排名为 i 的第二关键字对应的第一关键字的起始位置填到了 y[i] 里面。 首先我们把所有第一关键字的排名搞出来，存进了 c[] 数组 然后先从第二关键字排名低（倒序循环）的开始处理，让第二关键字排名低的第一关键字先被处理，此时整个第一、二关键字合起来形成的子串的排名就是 c[x[y[i]]]--，所以存进 sa[] 数组里面。 理清楚这部分最难了的之后就可以继续了： 12 std::swap(x, y); 这里的交换两个数组没有什么意思，只是因为我们需要生成新一轮的名次数组（x[] 数组）了，所以暂时把其交换一下下。 1234567 num = 1, x[sa[1]] = 1; FOR(i, 2, n) { if (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) x[sa[i]] = num; else x[sa[i]] = ++num; } 此时就是根据 sa[] 来生成 rk[]（即 x[]）的过程了。注意一下这个 y[] 就是上一轮倍增中的 rk[] 数组，第三行这个 if 实际上就是判断第一、二关键字是不是相等，是的话排名就一样，所以 x[sa[i]] = num。否则的话就说明排名要变，即 x[sa[i]] = ++num。 到这里，其实一个倍增的过程就已经结束了。当然不要忘记下面的小优化： 123 if (num == n) break; m = num; 第一个是既然都已经搞出来互异的排名了，就没有必要继续倍增下去了。第二个是现在桶的上界已经不是字符集大小了，而是最大的排名 num。 于是 SA 的代码实现就讲完了。我们回顾一下算法流程： 开始倍增之前，求出每个字符对应的排名，存进 sa[] 数组和 x[] 数组里面。 开始倍增，关键字长度为 k 。 先根据上一轮求出的 sa[] 数组，求出这一轮的 y[] 数组：第二关键字排名为 i 对应的第一关键字的位置。 对于区间 [n - k + 1, n] 来说，他们是不配拥有第二关键字的（即第二关键字小得离谱），只管往低了搞即可，即 y[++num] = i。 对于剩余的来说，从排名从小到大遍历一下上一轮求出的 sa[] 数组（相当于从小到大遍历第二关键字），如果当前这个子串可以成为第二关键字（sa[i] &gt; k）那么就加入。 然后根据上一轮求出的排名数组 x[]，进行基数排序。注意这行：DEC(i, n, 1) sa[c[x[y[i]]]--] = y[i];，其意义是从排名靠后的第二关键字开始进行操作，保证第一关键字相同的第二关键字大的排在后面（sa[] 的下标大，毕竟是 --）。并清空、 把 x[] 和 y[] 进行交换，因为现在要求出新的 x[] 出来了。 初始化：num = 1, x[sa[1]] = 1。 然后判断如果 if (y[sa[i]] == y[sa[i - 1]] &amp;&amp; y[sa[i] + k] == y[sa[i - 1] + k]) 成立，即两个关键字都相等的话，排名不增加，否则新增加一个排名。 最后，如果所有排名已经互异，直接结束战斗。 若没有结束，把桶的枚举范围缩小到排名的个数。 Height 数组 LCP（最长公共前缀） 字面意思，下面定义 lcp(i, j) 表示后缀 i 和后缀 j 的最长公共前缀的长度。 Height 数组的定义 height[i] = lcp(sa[i], sa[i - 1]) ，即排名为 i 的后缀与他前一名的后缀的 LCP 的长度。 height[1] = 0 。 一个引理 height[rk[i]] \\ge height[rk[i - 1]] - 1 理解：后缀 i 与排名在其前一位的后缀（后缀 sa[rk[i] - 1] ）的 LCP 的长度大于等于后缀 i - 1 与排名在其前一位的后缀（后缀 sa[rk[i - 1] - 1] ）减一。（排名为 rk[i] 的后缀就是后缀 i ） 证明：（参考 OI-Wiki） 当 height[rk[i - 1]]\\le 1 时，显然成立，因为右边小于等于 0 。 当 height[rk[i - 1]] \\gt 1 时： 设后缀 i - 1 为 aAD （ A 是一个长度为 height[rk[i - 1]] - 1 的字符串），那么后缀 i 就是 AD 。设后缀 sa[rk[i - 1] - 1] 为 aAB ，则 lcp(i - 1, sa[rk[i - 1] - 1]) = aA 。由于后缀 sa[rk[i - 1] - 1] + 1 是 AB ，其一定排在后缀 i 的前面，所以后缀 sa[rk[i] - 1] 一定有前缀 A ，故 lcp(i, sa[rk[i] - 1]) 至少是 height[rk[i - 1]] - 1 。 我们这样理解： i - 1 ： aAD i ： AD sa[rk[i - 1] - 1] ： aAB （也就是后缀 i - 1 的前一名后缀） lcp(i - 1, sa[rk[i - 1] - 1]) = aA sa[rk[i - 1] - 1] + 1 ： AB （也就是上面那个后缀的后缀） sa[rk[i] - 1] ： A[B/C] （也就是 AD 上一名的后缀） lcp(i, sa[rk[i] - 1]) ： AX （ X 可能为空） 所以， lcp(i, sa[rk[i] - 1]) \\ge lcp(i - 1,sa[rk[i - 1] - 1]) - 1 ，即 height[rk[i]] \\ge height[rk[i - 1]] - 1 ，得证。 O(n) 求出 Height 数组 根据上面的引理，直接暴力： 1234567for (int i = 1, k = 0; i &lt;= n; ++i){ if (k) --k; while (s[i + k] == s[sa[rk[i] - 1] + k]) ++k; ht[rk[i]] = k;} 复杂度？ k 最大到 n ，最多减 n 次，最多加 2n 次，总的复杂度 O(n) 。 LCP 与 RMQ 注意下面的两条性质： 性质一（LCP Lemma） \\forall i\\le k\\le j, lcp(sa[i], sa[j]) = \\min\\{lcp(sa[i], sa[k]), lcp(sa[k], sa[j])\\} 画出图来之后应该很容易理解这个性质，非常的显然，因为都是已经排好序了的后缀。它的重要之处在于可以推导下面的这个性质： 性质二（LCP Theorem） lcp(sa[i], sa[j]) = \\min_{i &lt; k\\le j}\\{height[k]\\} 为什么呢，我们展开一下下： lcp(sa[i], sa[j]) = \\min_{i \\lt k\\le j}\\{lcp(sa[k], sa[k - 1])\\} 发现有了第一个性质之后这个性质就是显然的了。 这意味着我们如果需要查找两个后缀的 LCP，就只需要在 height 数组上做 RMQ 就可以了，使用 ST 表可以做到 O(n\\log n) 预处理 O(1) 查询。 应用 寻找最小循环移动位置 洛谷 P4051 [JSOI2007]字符加密 把字符串复制一遍之后直接跑后缀排序就可以了。 在字符串中寻找模式串 给定字符串 S ，多次在线查找模式串 T 。构造 S 的后缀数组。考虑 T 出现的情况：其必然是 S 的某个后缀的前缀。由于我们已经将所有的后缀排过序了，所以可以在 sa[] 数组中二分来查找 T 。复杂度 O(|T|\\log |S|) 最小化从字符串首尾取字符构成新串的字典序 洛谷 P2870 [USACO07DEC]Best Cow Line G 题意：每次从首尾取一个字符，拼接成一个新字符串，最小化其字典序。 很贪心的想就是每次取字典序最小的一端的字符，现在的问题主要就是如果两端的字符相等了话怎么办。不难发现我们实际上就是在比较原串的后缀和反串的后缀的大小，所以把原串的反串接在原串背后跑后缀排序即可。 两个子串的最长公共前缀 正如上文所说，对 height 做 RMQ 即可。 结合单调栈 P4248 [AHOI2013]差异","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"后缀数组","slug":"SA","permalink":"https://old.blog.imyangty.com/tags/SA/"}]},{"title":"Link-Cut Tree 学习笔记","slug":"note-lct","date":"2021-04-16T11:57:23.000Z","updated":"2022-03-23T04:17:42.183Z","comments":true,"path":"note-lct/","link":"","permalink":"https://old.blog.imyangty.com/note-lct/","excerpt":"","text":"参考资料 https://www.zybuluo.com/xzyxzy/note/1027479 https://www.cnblogs.com/candy99/p/6271344.html https://www.cnblogs.com/flashhu/p/8324551.html https://oi-wiki.org/ds/lct/ 鸣谢以上博客的作者们。 简介 Link/Cut Tree（简称 LCT），是一种可以解决动态树问题的数据结构。具体地，它可以维护一个动态的森林，实现如下操作（洛谷模板题） 询问 x 到 y 上路径的异或和 连接 x 和 y 删除边 (x,y) 更改 x 的权值为 v 学习 LCT 之前，首先需要对树链剖分有一定的认识，然后需要熟练掌握 Splay。因为 LCT 是一种十分精巧的数据结构，生来就是需要和 Splay 配合（如果使用别的平衡树时间复杂度会多一个 log，使用 Splay 的话均摊下来还是 O(n\\log n) 的）。 实链剖分 上述操作如果没有连接和删除操作的话，就是一个裸的树剖题。我们回想一下树剖是怎么做的：把整棵树按照子树大小剖分成若干条链，并重新标号使得这些链上面的标号连续，然后使用数据结构（线段树等）在这些链上搞事情。 至于现在的动态树问题，假设我们能把需要的路径抽出来，然后直接进行序列操作，岂不美哉。所以我们考虑动态地进行剖分，即实链剖分。 一个点有若干连向儿子的边，我们自己选择一条边进行剖分（即自己选定“重儿子”），这条被选择的边就称为实边，其他边称为虚边。 实边连接的儿子称为实儿子（类似于重链剖分中的重儿子） 实边组合成的链称为实链（类似于重链和长链） 选择实链剖分的好处就是实和虚可以互相进行转化。 虚者实之，实者虚之。——《东周列国志》 针对这样灵活多变的实链，我们使用 Splay 进行维护。 主要性质 每一棵 Splay 维护的是一条实链 每棵 Splay 中序遍历得到的点在原树中深度单调递增（即对应这条实链从上往下走） 虚边由一棵 Splay 指向另外一棵 Splay 上面的性质告诉我们，LCT 其实本质上是一个森林，我们可以把组成这个森林的树称为辅助树，一定要搞清楚辅助树和原树的关系，否则极其容易想错问题。 我们可以知道 原树与辅助树中的节点一一对应 若干棵 Splay 组成了一棵辅助树 辅助树中的 Splay 不是互相独立的 通常来说，一棵 Splay 的根的父亲节点应该为空，但是在 LCT 中一棵 Splay 的根的父亲节点指向原树中这棵 Splay 维护的实链的父亲节点（即链顶的父节点），对应了原树中的一条虚边。其具有认父不认子的特点，即儿子存储了父亲，但是父亲不存储儿子。 所以所有的操作都可以在辅助树上进行而不需要动原树。 上面这样说可能有些抽象，我们看看图 上图是一棵剖好了的原树，虚线代表虚边，实线代表实边，可见图中有两条实链： \\{1,2,4\\} 和 \\{5,6\\} 。现在我们按照这样子建出来的 LCT 应该是如下的样子： 每个绿色圈内是一棵 Splay，每棵 Splay 内的红边对应了原图的实边。黑色的单向边对应了原图的虚边，在 Splay 中的体现就是 fa[5] = 1，而 ch[1][0] 和 ch[1][1] 都不等于 5，在 2 号点上也有体现：其左/右儿子都储存有值，但是 3 的父亲指向了 2 。而且我们发现每棵 Splay 的中序遍历在原图中都是深度单调递增的。 了解了上述性质之后，就可以开始学习如何写出一棵 LCT 了。 代码基础定义 以下代码均以洛谷模板题（维护路径异或和）为例进行讲解。 变量/宏声明 首先是 Splay 的结构体： 12345struct Node{ int ch[2], fa, size, tag, val, res;} t[maxn]; 分别维护左/右儿子，父亲，子树大小，翻转标记，节点的值，路径权值和。 然后是一些宏定义： 123#define ls(u) t[u].ch[0]#define rs(u) t[u].ch[1] 接下来需要用到的函数如下： 基础函数（字面意思） void pushUp(int u) void pushDown(int u) 不解释，分别是合并信息和懒标记下传。 Splay 的基础函数 void rotate(int u) void splay(int u) int get(int u) rotate() 和 splay() 是经过魔改了的版本，下面会进行说明。 LCT 的特有函数 int isRoot(int u) 判断 u 是否为根 void pushAll(int u) 把 u 一直到根的路径上的点的标记全部下传 void access(int u) 打通根到 u 的一条实链 void makeRoot(int u) 将原树换根为 u int findRoot(int u) 找到 u 所在的树的根节点的编号 void link(int u, int v) 连边 (u, v) void cut(int u, int v) 删边 (u, v) void split(int u, int v) 提取出 u 到 v 的路径以方便进行区间操作 函数讲解 从简单的开始： pushUp() 和 pushDown() 和 pushAll() 12345678910111213141516171819202122232425il void pushUp(int u){ t[u].size = t[ls(u)].size + t[rs(u)].size + 1; t[u].res = t[ls(u)].res ^ t[rs(u)].res ^ t[u].val; return;}il void pushDown(int u){ if (t[u].tag) { if (ls(u)) t[ls(u)].tag ^= 1, swap(ls(ls(u)), rs(ls(u))); if (rs(u)) t[rs(u)].tag ^= 1, swap(ls(rs(u)), rs(rs(u))); t[u].tag ^= 1; } return;}il void pushAll(int u){ if (!isRoot(u)) pushAll(t[u].fa); pushDown(u); return;} 此时 pushup() 维护异或和，pushdown() 维护翻转标记。 splay() 和 rotate() 和普通 Splay 的有些不一样： 12345678910111213141516171819202122232425262728293031#define get(u) (rs(t[u].fa) == u)#define isRoot(u) (ls(t[u].fa) != u &amp;&amp; rs(t[u].fa) != u)il void pushAll(int u){ if (!isRoot(u)) pushAll(t[u].fa); pushDown(u); return;}il void rotate(int u){ int fa = t[u].fa, gfa = t[fa].fa, k1 = get(u), k2 = get(fa); if (!isRoot(fa)) t[gfa].ch[k2] = u; t[fa].ch[k1] = t[u].ch[k1 ^ 1], t[t[u].ch[k1 ^ 1]].fa = fa; t[u].fa = gfa, t[fa].fa = u, t[u].ch[k1 ^ 1] = fa; pushUp(fa), pushUp(u); return;}il void splay(int u){ pushAll(u); for (int fa; fa = t[u].fa, !isRoot(u); rotate(u)) { if (!isRoot(fa)) rotate(get(fa) == get(u) ? fa : u); } return;} 要注意的就是： rotate 的时候一定要先判断 fa 是不是根在进行下一步操作。 splay 只需要传入一个参数，因为不存在要把某个点旋转到另一个点下面这种操作了。而且进行之前要把其到根上的懒标记先全部下传。 access() 这个操作的目的是打通从原树的树根到 u 节点的一条实链，代码很短但是不太好理解： 12345678il int access(int u){ int p; for (p = 0; u; p = u, u = t[u].fa) splay(u), rs(u) = p, pushUp(u); return p;} 总的来说，操作分为下面几个步骤： 把当前的节点 u 旋转到当前 Splay 的根（splay(u)） 把 u 的右儿子替换成之前的节点 rs(u) = p（对应了”化实为虚“的过程） 更新当前点的信息 pushup(u) 重复以上步骤 解释一下：我们要拉通这条实链的话，是自底而上逐步更新 Splay 来进行操作的。首先肯定是把 u 旋转到 Splay 的根，然后注意到这个 u （可能）有两个实儿子，以及一个父亲（一条虚边），现在我们既然要打通实链，那么肯定有虚实的转化，注意到认父不认子的特点，我们可以直接把 u 的右儿子更新为之前更新过的点 p ，然后 pushup，再更新 p ，把 u 更新为其父亲，继续进行操作。 makeRoot() makeRoot(int u) 是把 u 点设为该连通块的根节点。 步骤 access(u) splay(u) 反转整棵 Splay 第一步之后， u 节点会在当前连通块根节点所在 Splay 的最右下角（因为深度最大），第二步我们把它提到根节点之后就可以注意到其右儿子为空（仍是由于深度最大），第三步把 Splay 反转之后 u 点变到了最左端，这样子整棵树的深度就完全倒过来了， u 点变为了深度最浅的点。这样就达到了我们把 u 变成根的目的。 至于下面的这种实现，结合上面的代码可以发现 access() 的返回值就是这棵 Splay 的根，所以我们直接对其进行操作即可。 12345678il void makeRoot(int u){ u = access(u); swap(ls(u), rs(u)); t[u].tag ^= 1; return;} finRoot() findRoot(int u) 是寻找 u 节点所在的连通块的根节点。可以判断两个点的连通性，findRoot(x) == findRoot(y) 表示 x 和 y 联通。具体来说，我们需要把 u 的实链打通，然后将其搞到 Splay 的根，再一路向左下不停走，就能找到我们可爱的根节点了。找到之后一定要 Splay 一下以保证复杂度。 走的时候一定要一路 pushDown 12345678il int findRoot(int u){ access(u), splay(u); while (ls(u)) pushDown(u), u = ls(u); splay(u); return u;} link() link(int u, int v) 的作用是连接一条边 (u,v) ，当然前提是 u 和 v 不联通。 首先需要让 u 成为该连通块的根并 Splay 到辅助树的根（不难发现其肯定没有向上的虚边），然后暴力把 u 的父亲设成 v 即可（连一条虚边）。 至于判断，只需在 makeRoot() 之后 findRoot(v) == u 即可。 123456789il void link(int u, int v){ makeRoot(u); if (findRoot(v) == u) return; splay(u); t[u].fa = v; return;} cut() cut(int u, int v) 的作用是切断原有的边 (u,v) 。当然数据有可能不合法， 当数据不合法的时候我们就需要进行判断。 如果数据保证合法，就先把 u 设为连通块的根，然后 access(v) 使得 u 到 v 拉通一条实链，再 splay(u) 把 u 拉到根处。不难发现如果 (u, v) 有连边而且相邻的话 v 一定是 u 的右儿子，所以双向断开 t[v].fa = rs(u) = 0 即可。 但是如果数据不合法，我们就需要思考一下数据怎么样能合法： u 和 v 在同一连通块内 makeRoot(u) 之后， u 为 v 的直接父亲 v 没有左儿子（想一下为什么不可以） 123456789il void cut(int u, int v){ makeRoot(u); if (findRoot(v) != u || t[v].fa != u || ls(v)) return; t[v].fa = rs(u) = 0; pushUp(u); return;} 如果 v 有左儿子，那么按照中序遍历的原则， u 和 v 的深度差就不是 1 了。 最后更不更新信息都无所谓其实。但是既然右边的儿子都没了，还是上传一下标记比较好。 split() split(int u, int v) 可以把 u 到 v 的路径抽出来变成一条实链（即放进一棵 Splay 里面）方便我们进行处理。代码很简单： 让 u 成为根 打通 u （此时的根）到 v 的实链 把 v 变成 Splay 的树根方便进行处理 12345678il void split(int u, int v){ makeRoot(u); access(v); splay(v); return;} 总的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define il inlineint read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}template&lt;typename T&gt; il void swap(T &amp;a, T &amp;b){ T t = a; a = b, b = t; return;}const int maxn = 1e5 + 5;int n, m;struct Node{ int ch[2], fa, size, tag, val, res;} t[maxn];#define ls(u) t[u].ch[0]#define rs(u) t[u].ch[1]il void pushUp(int u){ t[u].size = t[ls(u)].size + t[rs(u)].size + 1; t[u].res = t[ls(u)].res ^ t[rs(u)].res ^ t[u].val; return;}il void pushDown(int u){ if (t[u].tag) { if (ls(u)) t[ls(u)].tag ^= 1, swap(ls(ls(u)), rs(ls(u))); if (rs(u)) t[rs(u)].tag ^= 1, swap(ls(rs(u)), rs(rs(u))); t[u].tag ^= 1; } return;}#define get(u) (rs(t[u].fa) == u)#define isRoot(u) (ls(t[u].fa) != u &amp;&amp; rs(t[u].fa) != u)il void pushAll(int u){ if (!isRoot(u)) pushAll(t[u].fa); pushDown(u); return;}il void rotate(int u){ int fa = t[u].fa, gfa = t[fa].fa, k1 = get(u), k2 = get(fa); if (!isRoot(fa)) t[gfa].ch[k2] = u; t[fa].ch[k1] = t[u].ch[k1 ^ 1], t[t[u].ch[k1 ^ 1]].fa = fa; t[u].fa = gfa, t[fa].fa = u, t[u].ch[k1 ^ 1] = fa; pushUp(fa), pushUp(u); return;}il void splay(int u){ pushAll(u); for (int fa; fa = t[u].fa, !isRoot(u); rotate(u)) { if (!isRoot(fa)) rotate(get(fa) == get(u) ? fa : u); } return;}il int access(int u){ int p; for (p = 0; u; p = u, u = t[u].fa) splay(u), rs(u) = p, pushUp(u); return p;}il void makeRoot(int u){ u = access(u); swap(ls(u), rs(u)); t[u].tag ^= 1; return;}il int findRoot(int u){ access(u), splay(u); while (ls(u)) pushDown(u), u = ls(u); splay(u); return u;}il void link(int u, int v){ makeRoot(u); if (findRoot(v) == u) return; splay(u); t[u].fa = v; return;}il void cut(int u, int v){ makeRoot(u); if (findRoot(v) != u || t[v].fa != u || ls(v)) return; t[v].fa = rs(u) = 0; pushUp(u); return;}il void split(int u, int v){ makeRoot(u); access(v); splay(v); return;}int main(){ n = read(), m = read(); FOR(i, 1, n) t[i].val = read(); while (m--) { int opt = read(), x = read(), y = read(); if (opt == 0) split(x, y), printf(\"%d\\n\", t[y].res); else if (opt == 1) link(x, y); else if (opt == 2) cut(x, y); else if (opt == 3) splay(x), t[x].val = y, pushUp(x); } return 0;} 应用 https://www.cnblogs.com/flashhu/p/9498517.html https://www.zybuluo.com/xzyxzy/note/1027479 https://www.luogu.com.cn/blog/command-block/lct-xiao-ji 维护","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"LCT","slug":"LCT","permalink":"https://old.blog.imyangty.com/tags/LCT/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"}]},{"title":"CCF NOI 2021 统一省选退役记（GZOI2021）","slug":"travels-gzoi2021","date":"2021-04-10T12:33:33.000Z","updated":"2022-03-23T04:20:07.486Z","comments":true,"path":"travels-gzoi2021/","link":"","permalink":"https://old.blog.imyangty.com/travels-gzoi2021/","excerpt":"","text":"前言 可能要退役了。 upd on 4/13 也许不会退役吧。 背景：弱省 GZ，全校只有两人 OI，水平很菜菜/kk 迁移之后格式炸了，不想管了。 Day -2 晚上一点多睡的，这一个星期都没睡好，药丸。 Day -1 困 Day 0 睡了个正常点的觉但是还是困。 写了下后缀数组的板子，复习了下单调栈，平衡树和 NTT。 希望第二天考点我会的，慌的一批，参赛名单出来发现是 12 人争 4 个省队，我真的危。 但是转念一想，CSP 和 NOIP 我貌似都还能排在靠前的位置（ 应该不至于去世吧。但要是真去世了就。。。 不说了睡觉。 Day 1 早早到了，遵义四中好多人啊 /kk 他们那个绿色校服已经成一个大队了 orz。去了趟厕所，那个 nt 冲水器居然会把水往外射，差点被溅一脚。进了考场发现用了新机子，真不错，但是键盘还是难用（指软趴趴的）就对了。 打开压缩包，card，graph 和 pair，怎么感觉有点奇奇怪怪的呢？？？ 发下密码，没看出什么东西出来，貌似真就随机的。 但是题目画风真的挺诡异的。。。。。。开写 T1，发现调和 log 直接日过去就可以了。中间调了好几次，8:33 才写完然后造了组数据把自己给日掉了。原来写的是假的啊可恶。大概 8:40 A 掉了。 T2 和 T3 画风极其诡异。想 T2，无果。想 T3，无果。T2 注意到了 a\\_i 只增不减的性质然后也想到了诸如二分答案和从左/右往中间贪等接近正解的想法我TM为什么不写呢？。最后枚举贡献极差的两张纸牌然后 O(n^3) 混 40pts 走人。 T3 读完题的时候那个点心态已经有小点慌了，就没有怎么想着去思考题目的性质，而是直接写了个第二个样例会严重 WA 和 TL 的暴力，但是最后还是就交了。 下考场的我真心觉得自己是sb。。。大概翻了翻遵义四中的代码，有写出 T2 正解来的。。。我思维怎么就这么差啊。。。。。。 心态小崩，之前复习的东西一样没考，感觉这个赛季就没做过稍微正常一点的题。晚上在床上心态崩干净了。 看 Day2 能不能翻盘了/kk Day 2 起的比较晚，有小点困。到了考场背了下 SA，Splay 和网络流的板子，奶一口要考（考NMLGB）。 电脑清空了一波。打开压缩包，gem，mod 和 ranklist。“gem”不会是 geometry 的缩写的（计算几何去世？）又可能是宝石？mod 貌似是数论题？翻盘有望？ 拿到随机的解压密码，输入， 发现好像事情不是这样的。。。 mod 的题意是求 \\\\max\\_{1\\\\le i\\\\lt j\\\\lt k\\\\le n}\\\\lbrace (a\\_i + a\\_j) \\\\bmod a\\_k\\\\rbrace ，一看像是 CF 的题，不是很可做的样子？赶紧写了 40pts 的 O(n^3) 暴力。然后读后面的题面。T2 树上问题貌似很可做的样子，T3 像是很不可做的数数，不管那么多了，想 T1。 8：55 还是没想出来一个靠谱的 T1 的做法，然后考虑了个比较神奇的算法：先排序，然后从大到小枚举模数，再枚举第一个加数并二分找到另一个加数。然后关键是这个算法跑极限的随机数据跑得飞快而且我也想不到怎么去卡了。最后的结局是和暴力拍了千把组没有发现任何问题（说明其在随机数据下表现良好）就没有管了。 T2 一开始还读错题了以为是树上 LIS 问题，敲暴力敲完了才发现题读假了，好在我发现其实正确的题意貌似更好写，于是过掉了三组样例，拿住了 25 pts。期间把树给剖了（好像也不用剖？）然后往 dsu on tree 和点分的方向想了想，发现想不到合适的点分而且莫队啊主席树之类的我不会/kk。遂放弃，想 T3。 T3 暴力一开始由于码力不够还差点爆炸掉了，好在后面是写对了。但是貌似只能拿 40pts 的样子， O(n!) 枚举全排列已经是下界了，关键是我还特别蠢到写了个 O(？) ？ 的 dfs 来判断。 然后就到 12:45 了，真就啥都写不动了，遂检查。 下考场之后回家大概测了测，发现没有什么问题，但是 T3 的暴力跑的飞慢。 这个 60ots 暴力不是 O(n\\\\cdot n!) 的吗？ 草原来我写的是假的暴力，可以。 找到了洛谷民间数据，大概测了测，算上标准分我应该可以卡线进队 GZ-04 吧。 但愿了。 晚上又是补作业，路上 szx 跟我讲了个卡的掉我 D2T1 的数据： 12335001 10000 15000 我的程序会输出 1 ，然而正确答案应该是 4996 。 好，去世。 但是随机数据下他表现良好（雾） 不管了，就这样吧。 Day 3 文化课无聊。 颓废。 成绩估计要好久才能出来555. Day 4 无聊文化课。、 颓废 貌似明天出成绩？省内教练群用另外的数据测了测，发现我单省选成绩居然卡到 rk3 了？不可思议。 Day ? D2T1 被毒瘤数据卡死成 10pts，直接 rk6 去大世。 心态放平。 从零开始。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"游记","slug":"OI/travels","permalink":"https://old.blog.imyangty.com/categories/OI/travels/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"}]},{"title":"树上问题笔记（点分治，dsu，长链剖分）","slug":"note-treeproblem","date":"2021-04-08T11:19:32.000Z","updated":"2022-03-23T04:17:42.214Z","comments":true,"path":"note-treeproblem/","link":"","permalink":"https://old.blog.imyangty.com/note-treeproblem/","excerpt":"","text":"点分治 概述 用来处理树上路径问题，对于一棵树，指定一个根 rt 之后，所有的路径无非分为两类： 经过根的路径 不经过根的路径 当我们处理完所有经过根的路径之后，删除根，不难发现可以这样子对于每棵子树继续分治下去，所有的路径都能划归到第一种情况。 算法的流程： 找到当前树的重心，设为根节点 处理所有经过根的路径 删除根节点 对于所有的子树，重复上述步骤 每次处理路径的复杂度是 O(n) 的，而每次选根在重心保证递归的层数为 O(\\log n) 级别，故总复杂度为 O(n\\log n) 。 具体写法 首先不论如何，树的重心是一定要找到的： 1234567891011121314151617void getrt(int u, int fa){ size[u] = 1; maxp[u] = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) continue; getrt(v, u); size[u] += size[v]; maxp[u] = max(maxp[u], size[v]); } maxp[u] = max(maxp[u], tot - size[u]);//***注意 tot 是当前处理到的子树大小 if (maxp[u] &lt; maxp[root]) root = u; return;} 一次树形 dp 即可，唯一需要注意的一点是需要维护一个 tot 变量来存储当前子树的大小，不然如果用 n 来减的话会导致错误。 然后是分治的部分： 123456789101112131415void solve(int u)//传入的 u 要为根节点{ vis[u] = judge[0] = 1;//暂时不需要管 judge 是什么 calc(u);//先统计经过 u 的答案 for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (vis[v]) continue; maxp[0] = n, tot = size[v], root = 0;//注意这里 dp 数组的初值以及维护新子树的大小 getrt(v, u); solve(root); } return;} 至于 calc() 函数，每道题都是不一样的，下面看这道例题 洛谷 P3806。 题意： m （ m\\le 100 ）次查询 k ，问树上是否存在长度为 k 的路径。 可以考虑每次把到达的根节点当作 LCA，然后处理不经过其的路径即可。具体来说，当 solve() 到 u 为根的子树时，先依次遍历 u 的一棵子树 v 的所有节点 x ，每次把 x 到 u 的距离记录到桶 rem 里面，然后对于每个询问 query[k]，在桶（judge 数组）中查询在遍历到 v 之前的节点中有没有距离为 query[k] - rem[j] 的点，之后再把 rem 中的贡献与前面的合并（即加入 judge 数组）。 但是，每次 calc(u) 结束之后，如果不清空 judge 数组就会出大问题——影响到以后的状态。但是 memset 来清空太慢了，很容易直接 TLE，所以把每次遍历到的距离加进一个队列 q 里面，calc() 结束的时候按照 q 里面清就行了。 1234567891011121314151617181920212223242526272829303132333435void getdis(int u, int fa){ rem[++rem[0]] = dis[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) continue; dis[v] = dis[u] + e[i].w; getdis(v, u); } return;}void calc(int u){ int p = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (vis[v]) continue; rem[0] = 0;//表示桶里元素个数 dis[v] = e[i].w;//一定要初始化 getdis(v, u); DEC(j, rem[0], 1) FOR(k, 1, m) if (query[k] &gt;= rem[j]) ans[k] |= judge[query[k] - rem[j]]; DEC(j, rem[0], 1) q[++p] = rem[j], judge[rem[j]] = 1; } FOR(i, 1, p) judge[q[i]] = 0; return;} 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 1e4 + 5, maxm = 105, maxk = 1e7 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline int max(int a, int b) {return a &gt; b ? a : b;}int n, m, query[maxm], ans[maxk];int head[maxn], cnte;struct edge{ int to, nxt, w;} e[maxn &lt;&lt; 1];inline void add(int u, int v, int w){ e[++cnte].to = v; e[cnte].nxt = head[u]; e[cnte].w = w; head[u] = cnte; return;}int size[maxn];int maxp[maxn], vis[maxn], root, tot, rem[maxn];int tmp[maxk], judge[maxk], q[maxn], dis[maxn];void getrt(int u, int fa){ size[u] = 1; maxp[u] = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) continue; getrt(v, u); size[u] += size[v]; maxp[u] = max(maxp[u], size[v]); } maxp[u] = max(maxp[u], tot - size[u]); if (maxp[u] &lt; maxp[root]) root = u; return;}void getdis(int u, int fa){ rem[++rem[0]] = dis[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa || vis[v]) continue; dis[v] = dis[u] + e[i].w; getdis(v, u); } return;}void calc(int u){ int p = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (vis[v]) continue; rem[0] = 0; dis[v] = e[i].w; getdis(v, u); DEC(j, rem[0], 1) FOR(k, 1, m) if (query[k] &gt;= rem[j]) ans[k] |= judge[query[k] - rem[j]]; DEC(j, rem[0], 1) q[++p] = rem[j], judge[rem[j]] = 1; } FOR(i, 1, p) judge[q[i]] = 0; return;}void solve(int u){ vis[u] = judge[0] = 1; calc(u); for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (vis[v]) continue; maxp[0] = n, tot = size[v], root = 0; getrt(v, u); solve(root); } return;}int main(){ n = read(), m = read(); FOR(i, 1, n - 1) { int u = read(), v = read(), w = read(); add(u, v, w), add(v, u, w); } FOR(i, 1, m) query[i] = read(); maxp[root = 0] = tot = n; getrt(1, 0); solve(root); FOR(i, 1, m) puts(ans[i] ? \"AYE\" : \"NAY\"); return 0;} 例题 2 洛谷 P4178 给定 k ，问树上距离小于等于 k 的点对数量。 对于这道题，我们也可以使用类似于上题的方法。首先很明显需要点分治，每次分治的时候考虑统计经过根的路径的贡献。在处理 u 子树的时候，假设我们正在处理 u 的儿子 v ，先把所有距离求出来记录进一个桶 rem[j] 里面，然后我们对于每一个 rem[j] 需要查询别的子树里面距离小于等于 k - rem[j] 的点有几个，所以考虑实现一个树状数组（因为这里值域只有 4\\times 10^7 ，否则就需要实现一个平衡树了）来进行查询。查询完之后把所有 rem[j] 加入树状数组。当然不要忘记处理完之后清空树状数组（不能用 memset，需要记录下插入的点然后一个个对应删除） 总复杂度为 O(n\\log^2n) 。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int maxdis = 4e7 + 5;int bit[maxdis], ans;int dis[maxn], rem[maxdis], q[maxn];void ins(int x, int v){ for (; x &lt; maxdis; x += lowbit(x)) bit[x] += v; return;}int query(int x){ if (x &lt;= 0) return 0; int ret = 0; for (; x; x -= lowbit(x)) ret += bit[x]; return ret;}//上面是树状数组void getdis(int u, int fa){ rem[++rem[0]] = dis[u];//把距离加入桶里面 GO(u) { if (v == fa || vis[v]) continue; dis[v] = dis[u] + e[i].w; getdis(v, u); } return;}void calc(int u){ int p = 0; GO(u) { if (vis[v]) continue; rem[0] = 0; dis[v] = e[i].w; getdis(v, u); DEC(j, rem[0], 1) { ans += query(k - rem[j]);//树状数组查询 if (k &gt;= rem[j]) ++ans;//这里需要格外注意点对中其中一个点为根的情况 } DEC(j, rem[0], 1) q[++p] = rem[j], ins(rem[j], 1);//记录下插入树状数组的点 } FOR(i, 1, p) ins(q[i], -1);//清空树状数组 return;}void divide(int u){ vis[u] = 1; calc(u); GO(u) { if (vis[v]) continue; maxp[0] = n, tot = size[v], root = 0; getrt(v, u); divide(root); } return;} 其他习题 P6626 [省选联考 2020 B 卷] 消息传递 比较板，问的是到一个点距离为 k 的点的个数 P4149 [IOI2011]Race 问距离为 k 的点对间最少的边数，需要同时维护两个信息 树上启发式合并/静态链分治 概述 lxl 管这个东西叫“静态链分治”，而网上又广为流传一个名字叫做 dsu on tree。这里保留如上所有说法。 这个算法可以以 O(n\\log n) 的优秀复杂度处理树上不带修的离线子树问题，其核心思想在于把小的往大的上合并。例如，对于一个节点，把它所有小儿子上面的信息往大儿子上面合并。这个大儿子就是轻重链剖分中的重儿子。 算法的流程： 剖一下这棵树，但只需要知道重儿子是谁就可以了（对应 dfs1() 函数） 对于递归到的每个节点 u ： 处理好所有轻儿子及他们的答案并删除他们对 u 的贡献 处理好重儿子及答案并保留贡献 暴力合并所有轻儿子和 u 节点的贡献累加到上一步算出重儿子的贡献上，得到答案 其伪代码如下： 123456789101112void dfs2(int u, int keep)//keep = 1/0 表示是否保留贡献{ for (v : u 的轻儿子) dfs2(v, 0); if (u 有重儿子) dfs2(son[u], 1); calc(u);//合并贡献 if (!keep)//如果贡献不用保留 del(u);//删除贡献 return;} 例题 1 洛谷 U41492 树上数颜色（作者来自这篇洛谷日报） 题意：给定每个节点的颜色 c_i ，对于每个询问，求出对应子树的颜色数。 很明显可以先求出所有节点的答案然后离线来做。 如果记录了所有节点的桶，空间复杂度就是 O(n^2) 的，很明显过不去。那么考虑 dsu on tree。 具体的，动态记录桶数组 cnt[i] 和当前颜色种数 tmp。按照上面的流程跑 dsu on tree 即可。 123456789101112131415161718192021222324252627282930313233void calc(int u, int val){ if (val &gt; 0)//加上贡献的情况 { if (!vis[c[u]])//如果有了新颜色的点 ++tmp; ++vis[c[u]]; } else { if (vis[c[u]] &lt;= 1)//如果这个颜色要被删干净了 --tmp; --vis[c[u]]; } for (int i = head[u]; i; i = nxt[i]) if (to[i] != fa[u] &amp;&amp; to[i] != flag) calc(to[i], val); return;}void dfs2(int u, int keep){ for (int i = head[u]; i; i = nxt[i]) if (to[i] != fa[u] &amp;&amp; to[i] != son[u]) dfs2(to[i], 0);//处理轻儿子 if (son[u]) dfs2(son[u], 1), flag = son[u]; calc(u, 1);//合并一下贡献 flag = 0; ans[u] = tmp; if (!keep) calc(u, -1); return;} 注意 flag 变量：这里是因为执行 calc 函数的时候我们不能遍历 u 的重儿子，但是其儿子的重儿子是可以访问的，所以记录 flag 标记一下不能走的点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 1e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}int n, c[maxn];int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt;int son[maxn], size[maxn], fa[maxn];inline void add(int u, int v){ to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return;}void dfs1(int u, int father){ size[u] = 1, fa[u] = father; int maxson = -1; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v == father) continue; dfs1(v, u); size[u] += size[v]; if (size[v] &gt; maxson) maxson = size[v], son[u] = v; } return;}int vis[maxn], ans[maxn], flag, tmp;void calc(int u, int val){ if (val &gt; 0) { if (!vis[c[u]]) ++tmp; ++vis[c[u]]; } else { if (vis[c[u]] &lt;= 1) --tmp; --vis[c[u]]; } for (int i = head[u]; i; i = nxt[i]) if (to[i] != fa[u] &amp;&amp; to[i] != flag) calc(to[i], val); return;}void dfs2(int u, int keep){ for (int i = head[u]; i; i = nxt[i]) if (to[i] != fa[u] &amp;&amp; to[i] != son[u]) dfs2(to[i], 0); if (son[u]) dfs2(son[u], 1), flag = son[u]; calc(u, 1); flag = 0; ans[u] = tmp; if (!keep) calc(u, -1); return;}int main(){ n = read(); FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v); add(v, u); } FOR(i, 1, n) c[i] = read(); dfs1(1, 0); dfs2(1, 0); int m = read(); while (m--) printf(\"%d\\n\", ans[read()]); return 0;} 例题 2 CF600E Lomsat gelral dsu on tree 的模板。 题意：求出子树中众数颜色的编号之和。 和上道题基本没有改变，只是需要记录一下众数的出现次数，同时要判断众数出现了多次的情况。 1234567891011121314151617181920212223242526272829int flag, maxc, cnt[maxn];ll sum, ans[maxn];void calc(int u, int val){ cnt[c[u]] += val; if (val &gt; 0 &amp;&amp; cnt[c[u]] &gt; maxc) maxc = cnt[c[u]], sum = c[u]; else if (val &gt; 0 &amp;&amp; cnt[c[u]] == maxc) sum += c[u]; for (int i = head[u]; i; i = nxt[i]) if (to[i] != fa[u] &amp;&amp; to[i] != flag) calc(to[i], val); return;}void dfs2(int u, int keep){ for (int i = head[u]; i; i = nxt[i]) if (to[i] != fa[u] &amp;&amp; to[i] != son[u]) dfs2(to[i], 0); if (son[u]) dfs2(son[u], 1), flag = son[u]; calc(u, 1); ans[u] = sum; flag = 0; if (!keep) calc(u, -1), sum = maxc = 0; return;} 例题 3 CF570D Tree Requests 题意：每个节点上有一字符（小写英文字母），每次查询 u 的子树内深度为 b 的节点上的字母重排列之后能否排成回文串。 不难发现出现次数为奇数的字符只能有一种，定义一个桶 cnt[dep][ch] 来存储出现次数即可。 而我们可以把所有的询问先读进来然后按照 u 分类，遍历每个询问然后 check 一下对应的深度能否完成即可。 123456789101112131415161718192021222324252627282930313233343536int flag, cnt[maxn][26];void calc(int u, int val){ cnt[dep[u]][s[u] - 'a'] += val; for (int i = head[u]; i; i = nxt[i]) if (to[i] != flag) calc(to[i], val); return;}bool check(int dep){ int ret = 0; FOR(i, 0, 25) { ret += (cnt[dep][i] &amp; 1); if (ret &gt; 1) return 0; } return 1;}void dfs2(int u, int keep){ for (int i = head[u]; i; i = nxt[i]) if (to[i] != son[u]) dfs2(to[i], 0); if (son[u]) dfs2(son[u], 1), flag = son[u]; calc(u, 1); flag = 0; for (int i = 0; i &lt; query[u].size(); ++i)//处理所有 u 的询问 ans[query[u][i].i] = check(query[u][i].dep);//依次check if (!keep) calc(u, -1); return;} 长链剖分 暂时烂尾了","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"点分治","slug":"centroid-decomposition","permalink":"https://old.blog.imyangty.com/tags/centroid-decomposition/"},{"name":"长链剖分","slug":"lld","permalink":"https://old.blog.imyangty.com/tags/lld/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://old.blog.imyangty.com/tags/dsu-on-tree/"}]},{"title":"2021年4月 OI学习记录","slug":"summary-2021-04","date":"2021-04-01T08:22:57.000Z","updated":"2022-03-23T04:19:24.325Z","comments":true,"path":"summary-2021-04/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-04/","excerpt":"","text":"前言 NOIOL 有点小爆炸 省选爆炸了。。。AFO 学习内容 Link-Cut Tree 线性基 后缀数组 做题记录 21/04/01 P3565 [POI2014]HOT-Hotels P5904 [POI2014]HOT-Hotels 加强版 长链剖分优化 dp P5384 [Cnoi2019]雪松果树 长链剖分 21/04/02 P3899 [湖南集训]谈笑风生 长链剖分 CF208E Blood Cousins 长链剖分 21/04/03 CF246E Blood Cousins Return dsu on tree 21/04/04 P6625 [省选联考 2020 B 卷] 卡牌游戏 sb 贪心 P4178 Tree 点分治，使用树状数组维护贡献 P6626 [省选联考 2020 B 卷] 消息传递 点分治 P3690 【模板】Link Cut Tree （动态树） LCT P6136 【模板】普通平衡树（数据加强版） 新码风 Splay 21/04/06 P3203 [HNOI2010]弹飞绵羊 LCT。建边，然后找根到该节点的路径长（一遍 access 和一遍 splay 即可） P1501 [国家集训队]Tree II 注意标记的下传即可 21/04/07 P2870 [USACO07DEC]Best Cow Line G SA。 21/04/08 P2852 [USACO06DEC]Milk Patterns G SA，求出现超过 k 次的子串的最大长度，即为寻找每 k - 1 个相邻的 ht[i] 的最小值的最大值。可以使用 multiset&lt;int&gt; 维护。 P4149 [IOI2011]Race 点分治 P3812 【模板】线性基 线性基 HDU3949 XOR 线性基求异或 k 大 BZOJ#3513. [MUTC2013]idiots 求随机选三个数边长可以组成三角形的概率。正难则反，算不能拼成三角形的方案数。考虑自身卷积，并去重，得到两个木棍能拼出的方案数，然后再做一下前缀和，得到两边之和小于等于该边的方案数，对于所有木棍长度求个和就得到了不能的方案数，直接算即可。 BZOJ#2194. 快速傅立叶之二 推式子， C\\_k = \\\\sum\\_{k\\\\le i\\\\lt n} a\\_ib\\_{i - k} ，推完之后换元化为卷积形式然后 FFT。 21/04/09 P2659 美丽的序列 单调栈 [AGC005B] Minimum Sum 单调栈 P4248 [AHOI2013]差异 SA 与单调栈 21/04/10 省选 Day 1 100 + [40, ?] + [0, 16] = [140, 156?] 炸干净了，T3 暴力爆炸了，希望 Day 2 能翻盘吧 21/04/11 省选 Day 2 21/04/15 省选出分，没进队 21/04/18 ARC117 A + B + D rk597 21/04/19 ARC117C Tricolor Pyramid 很巧的杨辉三角二项式系数题 P3807 【模板】卢卡斯定理 Lucas 定理 AGC023A - Zero-Sum Ranges 前缀和水题 P4720 【模板】扩展卢卡斯 exLucas 21/04/20 P2480 [SDOI2010]古代猪文 欧拉定理 + Lucas + CRT P4345 [SHOI2015]超能粒子炮·改 Lucas + 推式子 P2183 [国家集训队]礼物 exLucas 21/04/22 VP ARC116 A + B + C 21/04/26 SP5971 LCMSUM - LCM Sum 莫比乌斯反演 + 欧拉函数 21/04/27 P5091 【模板】扩展欧拉定理 欧拉降幂 P4139 上帝与集合的正确用法 扩展欧拉定理求 TeX parse error: Missing open brace for superscript。 21/04/28 CF906D Power Tower 扩展欧拉定理，因为 \\\\phi(n) 是 \\\\log 级别衰减，所以复杂度 O(q\\\\log p) 。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"LOJ#6669. Nauuo and Binary Tree","slug":"sol-loj6669","date":"2021-03-30T18:06:00.000Z","updated":"2022-03-23T04:18:30.814Z","comments":true,"path":"sol-loj6669/","link":"","permalink":"https://old.blog.imyangty.com/sol-loj6669/","excerpt":"","text":"题意 交互题。 一棵根为 1 ， n （ n\\le 3000 且一开始给定）个节点的二叉树，每次可以向交互库询问两点间的距离，求出每个节点的父亲。 思路 首先可以处理出每个节点的深度，即每次向交互库询问 (1,i) 的距离。 然后就是按照深度从小到大来尝试确定每个节点：保证处理到的每个节点的祖先都已知。 每次找节点的时候都暴力重新剖一遍已知的树，然后如果正在 u 为根的子树中查找 k ，那么就先询问出 k 到 bot_u （ u 的链底）的距离，然后找到链上可以引出 k 所在子树的节点 v ，有 dep_v = (dep_k + dep_{bot_u} - d) / 2 ，此时如果 v 只有一个儿子，那么 k 的父亲必然为 v ，否则就递归查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x = (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}const int maxn = 3005;int dep[maxn], n, id[maxn], fa[maxn];int ch[maxn][2];int size[maxn], son[maxn], bot[maxn];int query(int u, int v){ printf(\"? %d %d\\n\", u, v); fflush(stdout); return read();}void dfs(int u){ if (ch[u][0]) dfs(ch[u][0]); if (ch[u][1]) dfs(ch[u][1]); size[u] = size[ch[u][0]] + size[ch[u][1]] + 1; if (ch[u][1]) son[u] = (size[ch[u][0]] &lt; size[ch[u][1]]); else son[u] = 0; if (ch[u][son[u]]) bot[u] = bot[ch[u][son[u]]]; else bot[u] = u;}void setfather(int u, int v){ fa[v] = u; if (ch[u][0]) ch[u][1] = v; else ch[u][0] = v; return;}void solve(int u, int k){ if (!ch[u][0]) { setfather(u, k); return; } int d = query(k, bot[u]); int v = bot[u]; while (dep[v] &gt; (dep[k] + dep[bot[u]] - d) / 2) v = fa[v]; int w = ch[v][son[v] ^ 1]; if (w) solve(w, k); else setfather(v, k); return;}int main(){ n = read(); FOR(i, 2, n) { dep[i] = query(1, i); id[i] = i; } std::sort(id + 2, id + n + 1, [](int x, int y) {return dep[x] &lt; dep[y];}); FOR(i, 2, n) { dfs(1); solve(1, id[i]); } printf(\"!\"); FOR(i, 2, n) printf(\" %d\", fa[i]); printf(\"\\n\"), fflush(stdout); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"LOJ","slug":"LOJ","permalink":"https://old.blog.imyangty.com/tags/LOJ/"}]},{"title":"P5903 【模板】树上 k 级祖先","slug":"sol-luogu-p5903","date":"2021-03-30T10:15:16.000Z","updated":"2022-03-23T04:18:31.036Z","comments":true,"path":"sol-luogu-p5903/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5903/","excerpt":"","text":"题意 求树上 k 级祖先 题解 长链剖分。 长链剖分： 1234567891011121314151617181920212223242526272829303132void dfs1(int u){ dep[u] = dep[fa[u][0]] + 1; FOR(i, 1, 19) fa[u][i] = fa[fa[u][i - 1]][i - 1]; h[u] = -1; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; dfs1(v); if (h[v] &gt; h[u]) h[u] = h[v], hson[u] = v; } ++h[u]; if (!h[u]) h[u] = 1;}void dfs2(int u, int topf){ top[u] = topf; if (hson[u]) dfs2(hson[u], topf); for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v != hson[u]) dfs2(v, v); } return;} 其中 h\\_u 表示 u 到叶子的路径上的节点个数， u 为叶子时答案为 1 。 然后需要记录倍增数组 fa[maxn][20]，对于长链剖分的链顶需要记录其 len 个祖先和后代。 查询的时候先跳到 f\\_{u,{\\\\log k}} 处，然后跳到链顶，此时剩余深度使用记录了的链来补齐即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 5e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x = (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}#define ui unsigned intui s;inline ui get(ui x) { x ^= x &lt;&lt; 13; x ^= x &gt;&gt; 17; x ^= x &lt;&lt; 5; return s = x; }#undef uiint n, q;int head[maxn], to[maxn], nxt[maxn], cnt;int dep[maxn], hson[maxn], h[maxn], top[maxn], fa[maxn][20], root, lg[maxn];std::vector&lt;int&gt; down[maxn], up[maxn];inline void add(int u, int v){ to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return;}void dfs1(int u){ dep[u] = dep[fa[u][0]] + 1; FOR(i, 1, 19) fa[u][i] = fa[fa[u][i - 1]][i - 1]; h[u] = -1; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; dfs1(v); if (h[v] &gt; h[u]) h[u] = h[v], hson[u] = v; } ++h[u]; if (!h[u]) h[u] = 1;}void dfs2(int u, int topf){ down[topf].push_back(u); if (u == topf) { int now = u; FOR(i, 1, h[u]) up[u].push_back(now), now = fa[now][0]; } top[u] = topf; if (hson[u]) dfs2(hson[u], topf); for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v != hson[u]) dfs2(v, v); } return;}int ask(int u, int k){ if (!k) return u; int tod = dep[u] - k; u = top[fa[u][lg[k]]]; int nowd = dep[u]; if (nowd &gt; tod) return up[u][nowd - tod]; else return down[u][tod - nowd];}int main(){ n = read(), q = read(), s = read(); lg[0] = -1; FOR(i, 1, n) lg[i] = lg[i &gt;&gt; 1] + 1; FOR(u, 1, n) { fa[u][0] = read(); if (!fa[u][0]) root = u; else add(fa[u][0], u); } dfs1(root); dfs2(root, root); long long ans = 0, lastans = 0; FOR(i, 1, q) { int x = (get(s) ^ lastans) % n + 1, k = (get(s) ^ lastans) % dep[x]; lastans = ask(x, k); ans ^= 1ll * lastans * i; } printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"长链剖分","slug":"lld","permalink":"https://old.blog.imyangty.com/tags/lld/"}]},{"title":"CF888G Xor-MST","slug":"sol-cf888g","date":"2021-03-30T06:18:31.000Z","updated":"2022-03-23T04:18:30.734Z","comments":true,"path":"sol-cf888g/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf888g/","excerpt":"","text":"题意 给定 n 个点的完全图，边 (i,j) 的边权定义为 a_i\\oplus a_j ，求最小生成树。 即最小异或生成树模板 题解 考虑 Boruvka 算法，每次合并两个连通块，这样合并次数就是 O(\\log n) 级别的。由于要使异或的结果尽量小，所以考虑对于每一位分治。按照第 i 位为 0 或 1 分为两个集合，易知两个集合间只连一条边是最优的，然后对于这两个集合继续分治，递归处理即可。 两集合之间的连边使用 0-1 Trie 寻找异或最小值即可，详见代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef long long ll;const int maxn = 2e5 + 5;int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x = (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}inline ll min(ll a, ll b) {return a &lt; b ? a : b;}int n;int ch[maxn * 32][2], tot;ll ans = 0;void insert(int x){ int p = 0; DEC(i, 30, 0) { int tmp = (x &gt;&gt; i) &amp; 1; if (!ch[p][tmp]) ch[p][tmp] = ++tot, ch[tot][0] = ch[tot][1] = 0; p = ch[p][tmp]; } return;}int query(int x){ int p = 0, ret = 0; DEC(i, 30, 0) { int tmp = (x &gt;&gt; i) &amp; 1; if (ch[p][tmp]) p = ch[p][tmp]; else if (ch[p][tmp ^ 1]) p = ch[p][tmp ^ 1], ret += (1 &lt;&lt; i); else break; } return ret;}ll work(std::vector&lt;int&gt; a, int dep){ if (dep &lt; 0 a.empty()) return 0; std::vector&lt;int&gt; b[2]; ll ret = 0; FOR(i, 0, a.size() - 1) b[(a[i] &gt;&gt; dep) &amp; 1].push_back(a[i]);//按照该位 0/1 分类 if (b[0].size() &amp;&amp; b[1].size()) { tot = ch[0][0] = ch[0][1] = 0; ret = 1e9; FOR(i, 0, b[0].size() - 1) insert(b[0][i]); FOR(i, 0, b[1].size() - 1) ret = min(ret, query(b[1][i])); } return ret + work(b[0], dep - 1) + work(b[1], dep - 1);}int main(){ n = read(); std::vector&lt;int&gt; a; FOR(i, 1, n) a.push_back(read()); printf(\"%lld\\n\", work(a, 30)); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"Trie","slug":"Trie","permalink":"https://old.blog.imyangty.com/tags/Trie/"},{"name":"最小生成树","slug":"mst","permalink":"https://old.blog.imyangty.com/tags/mst/"}]},{"title":"多项式全家桶笔记","slug":"note-poly","date":"2021-03-13T04:41:09.000Z","updated":"2022-03-23T04:17:42.201Z","comments":true,"path":"note-poly/","link":"","permalink":"https://old.blog.imyangty.com/note-poly/","excerpt":"","text":"前言 upd：笔者写这篇文章的时候水平不足，在省选后可能会考虑重构，并将生成函数计数和形式幂级数科技分开。 多项式全家桶的总结笔记。篇幅极长，善用 TOC 进行跳转。 如有错漏之处烦请指出。 开始全家桶之前 形式化定义 约定： f_i （或者 [x^i]f(x) ）表示 f(x) 在 x^i 处的系数，即一个多项式可以表示为 \\displaystyle\\sum_{i = 0} f_ix^i 的形式。 两个多项式的加减法定义为 f(x) \\pm g(x) = \\sum_{i = 0}(f_i \\pm g_i)x^i 复杂度 O(n) 两个多项式的乘法（加法卷积）定义为： f(x)*g(x) = \\sum_{i = 0}x^i\\sum_{j = 0}f_jg_{i - j} 不难发现其正确性。可以手动模拟一下多项式的乘法看看是不是这样子的。其本质也就是卷完之后合并同类项。朴素的做的话复杂度是 O(n^2) 的，下面要讲的 FFT/NTT 可以加速到 O(n\\log n) 界 有些时候，题目只对多项式的前若干项感兴趣，所以我们给运算设定一个上界，即 \\pmod{x^n} 。意思就是只考虑这个多项式的前 n 项，从 x^n 开始以后的全部舍掉。 不难发现由加法和乘法是从低位到高位贡献的，所以 \\begin{aligned} (f(x) \\bmod{x^n} \\pm g(x)\\bmod{x^n})\\bmod{x^n} &amp;= (f(x) \\pm g(x))\\bmod{x^n}\\\\ (f(x) \\bmod{x^n}) * (g(x)\\bmod{x^n})\\bmod{x^n} &amp;= (f(x) * g(x))\\bmod{x^n}\\\\ \\end{aligned} 下面我们就开始学习多项式的各种操作吧 快速傅里叶变换（FFT) FFT 可以加速卷积，让时间复杂度从 O(n^2) 降到 O(n\\log n) ，学习 FFT 的基础操作前，需要先了解复数，因为 FFT 就是基于单位复数根的良好性质实现的。 复数基础 （数学旧人教选修 2-2 内容） 定义虚数单位 \\mathrm i = \\sqrt{-1} ，把形如 a + b\\mathrm i\\:(a,b\\in\\mathbb R) 的数称为复数，所有复数的集合称为复数集 \\mathbb C 。 复数一般使用 z 表示，表示为 z = a + b\\mathrm i ，这种形式称为复数的代数形式。 a 被称为复数的实部， b 称为复数的虚部，未加说明的情况下一般认为 a,b\\in\\mathbb R 。很明显地，当 a = 0\\land b\\not=0 时，这个复数为纯虚数，当 b=0 时，这个复数为实数。 每个复数 a + b\\mathrm i 都能对应平面直角坐标系里面的一个点 (a,b) ，同样的也可以对应一个向量 (a,b) 。故定义复数的模为 \\sqrt{a^2 + b^2} 。 定义复数的加法与乘法： \\begin{aligned} &amp;(a + b\\mathrm i) + (c + d\\mathrm i)\\\\ =&amp;(a + c) + (b + d)\\mathrm i \\end{aligned} \\begin{aligned} &amp;(a+b\\mathrm i)(c + d\\mathrm i)\\\\ =&amp;ac + ad\\mathrm i + cb\\mathrm i + bd\\mathrm i^2\\\\ =&amp;(ac - bd) + (ad + bc)\\mathrm i \\end{aligned} 这都是比较显然的。 容易看出复数满足很多实数的运算律。 定义复数 z=a+b\\mathrm i 的共轭复数为 \\overline{z} = a - b\\mathrm i ，不难发现 z 与 \\overline{z} 关于实轴对称。 z\\overline z=(a+b\\mathrm i)(a-b\\mathrm i) = a^2 + b^2=|z|^2 复数既然可以对应平面直角坐标系中的向量，不难发现其可以使用其模长与辐角来表示： z=a+b\\mathrm i\\iff z = r(\\cos\\theta+\\mathrm i\\sin\\theta) 其中 r 为 z 的模长， \\theta 为其辐角。即我们可以把一个复数表示成二元组 (r,\\theta) 的形式。 现在考虑两个复数 (r_1,\\theta_1) 与 (r_2,\\theta_2) 相乘得到的结果： \\begin{aligned} (r_1,\\theta_1)\\times(r_2,\\theta_2) &amp;= r_1(\\cos\\theta_1 + \\mathrm i\\sin\\theta_1)r_2(\\cos\\theta_2 + \\mathrm i\\sin\\theta_2)\\\\ &amp;=r_1r_2(\\cos\\theta_1\\cos\\theta_2 - \\sin\\theta_1\\sin\\theta_2 + \\mathrm i\\sin\\theta_1\\cos\\theta_2 + \\mathrm i\\sin\\theta_2\\cos\\theta_1)\\\\ &amp;=r_1r_2\\left(\\cos(\\theta_1 + \\theta_2) + \\mathrm i\\sin(\\theta_1 + \\theta_2)\\right)\\\\ &amp;=(r_1r_2,\\theta_1 + \\theta_2) \\end{aligned} 于是我们可以概括复数乘法的法则：模长相乘，辐角相加。（上述推导需要掌握基本的三角恒等变换） 从欧拉公式到单位圆 给出复数指数幂的定义： \\mathrm e^{x +y\\mathrm i} = e^x(\\cos y + \\mathrm i\\sin y) 这个公式是基于如下事实（可以理解为这几个函数在 x = 0 处的泰勒展开）： \\begin{aligned} \\sin(x) &amp;= x - \\frac{x^3}{3!}+\\frac{x^5}{5!} - \\frac{x^7}{7!} + \\frac{x^9}{9!} + \\cdots = \\sum_{k = 1}^\\infty\\frac{(-1)^{k - 1}x^{2k - 1}}{(2k-1)!}\\\\ \\cos(x) &amp;= 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\frac{x^6}{6!} + \\frac{x^8}{8!} + \\cdots = \\sum_{k = 0}^\\infty\\frac{(-1)^{k} x^{2k}}{(2k)!}\\\\ \\mathrm e^x &amp;= 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\frac{x^4}{4!} + \\cdots = \\sum_{k = 0}^\\infty\\frac{x^k}{k!} \\end{aligned} 将 x + y\\mathrm i 代入进去即可推导。 如果 x = 0 ，我们就得到大名鼎鼎的欧拉公式： \\mathrm e^{x\\mathrm i} = \\cos x + \\mathrm i\\sin x 更特殊地，如果 x = \\pi ，得到的就是下面这个神奇的式子： \\mathrm e^{\\pi\\mathrm i} = -1 复平面上我们可以定义类似于平面直角坐标系上的单位圆，单位圆上的所有复数构成集合 \\{z: |z| = 1\\} 。这些复数都可以表示为 \\cos\\theta + \\mathrm i\\sin\\theta 或 e^{\\theta \\mathrm i} 的形式。 多项式的表示法 系数表示法：顾名思义 f(x) = a_0 + a_1x + a_2x^2 + \\cdots + a_nx^n\\iff f(x) = \\{a_0,a_1,a_2,\\cdots,a_n\\} = \\begin{bmatrix} x^0 &amp; x^1 &amp; x^2 &amp;\\cdots &amp; x^n \\end{bmatrix} \\begin{bmatrix} a_0\\\\a_1\\\\a_2\\\\\\vdots\\\\a_n \\end{bmatrix} 点值表示法： 我们知道由一个多项式在 n + 1 个点上的取值是可以唯一确定一个多项式的，其本质也就是线性方程组的解。所以一个 n 次多项式可以用 n + 1 个点表示： f(x) = \\{(x_0,y_0),(x_1,y_1),\\cdots,(x_n,y_n)\\} 或者： \\begin{bmatrix} x_0^0 &amp; x_0^1 &amp; x_0^2 &amp;\\cdots &amp;x_0^n\\\\ x_1^0 &amp; x_1^1 &amp; x_1^2 &amp;\\cdots &amp; x_1^n\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp;\\vdots\\\\ x_n^0 &amp; x_n^1 &amp; x_n^2 &amp; \\cdots &amp; x_n^n \\end{bmatrix}\\begin{bmatrix} a_0\\\\a_1\\\\ \\vdots \\\\ a_n \\end{bmatrix} =\\begin{bmatrix} y_0\\\\y_1\\\\ \\vdots\\\\ y_n \\end{bmatrix} 通过下面的这个形式我们看得出来其就是一个典型的线性方程组的形式，不难证明其解的唯一性。 并且我们发现点值表示法有一个很明显的优势：可以在 O(n) 的时间内将两个多项式乘起来，只需把对应点的 y 乘起来即可。 通俗的来说，FFT 实现的就是快速求多项式乘法的过程：先把系数表示法转成点值表示法（DFT，离散傅里叶变换），乘完之后再把点值还原为插值（IDFT，离散傅里叶逆变换）。可是朴素的 DFT 需要的时间复杂度为 O(n^2) ，IDFT 还回其系数需要高斯消元是 O(n^3) 的。而 FFT 利用了一些很特殊很特殊的值加速了 DFT 和 IDFT 的过程，使得总时间复杂度降低到了 O(n\\log n) 。 单位复数根 解这个方程： x^n = 1 我们会发现这个方程在实数范围内只有 1 或者 2 个解。然而代数基本定理告诉我们这样的方程有 n 个复数域上的解。由模长相乘辐角相加我们知道因为最终 x^n = 1 ，所以这些满足条件的 x 的模长必定也是 1 。然后需要满足他们的辐角的 n 倍能被 2\\pi 整除。 不难发现其就是 n 等分单位圆： 我们记 n 次单位根的第 k 个记为 \\omega_n^k ，不难发现 \\omega_k^n = \\mathrm e^{\\frac{2k\\pi i}{n}} 。由此可见，单位复数根具有一些非常好的性质比如： \\begin{aligned} \\omega_n^0 = \\omega_n^n &amp;= 1\\\\ \\omega_n^k &amp;= \\omega_{2n}^{2k}\\\\ \\omega_{2n}^{k + n} &amp;= -\\omega_{2n}^k\\\\ \\left(\\omega_{2n}^{k + n}\\right)^2 &amp;=\\omega_n^k \\end{aligned} 利用这些性质，我们可以加速 DFT 的过程。FFT 就是利用分治思想加速求每个 f(\\omega_n^k) 的值 DFT 此时 DFT 的分治思想就是分开考虑奇次项和偶次项： 考虑 f(x) = a_0x^0 + a_1x^1 + a_2x^2 + \\cdots 将其分为两个多项式 \\begin{aligned} f(x) &amp;= a_0x^0 + a_2x^2 + a_4x^4 + a_6x^6 + a_8x^8 + \\cdots +a_1x^1 + a_3x^3 + a_5x^5 + a_7x^7 + a_9x^9 + \\cdots\\\\ &amp;= a_0x^0 + a_2x^2 + a_4x^4 + a_6x^6 + a_8x^8+\\cdots +x(a_1x^0 + a_3x^2 + a_5x^4 + a_7x^6 + \\cdots) \\end{aligned} 考虑两个新多项式： \\begin{aligned} f_0(x) &amp;= a_0x^0 + a_2x^1 + a_4x^2 + a_6x^3 + \\cdots\\\\ f_1(x) &amp;= a_1x^0 + a_3x^1 + a_5x^2 + a_7x^3 + \\cdots \\end{aligned} 不难发现 f(x) = f_0(x^2) + xf_1(x^2) 利用单位复数根的性质： \\begin{aligned} \\mathrm{DFT}(f(\\omega_n^k)) &amp;= \\mathrm{DFT}(f_0(\\omega_n^{2k})) + \\omega_n^k\\mathrm{DFT}(f_1(\\omega_n^{2k}))\\\\ &amp;=\\mathrm{DFT}(f_0(\\omega_\\frac n2^k)) + \\omega_n^k\\mathrm{DFT}(f_1(\\omega_\\frac n2^k)) \\end{aligned} \\begin{aligned} \\mathrm{DFT}(f(\\omega_n^{k + \\frac n2})) &amp;= \\mathrm{DFT}(f_0(\\omega_n^{2k + n})) + \\omega_{n}^{k + \\frac n2}\\mathrm{DFT}(f_1(\\omega_n^{2k + n}))\\\\ &amp;=\\mathrm{DFT}(f_0(\\omega_n^n\\omega_n^{2k})) - \\omega_n^k\\mathrm{DFT}(f_1(\\omega_n^n\\omega_n^{2k}))\\\\ &amp;=\\mathrm{DFT}(f_0(\\omega_\\frac n2^k)) - \\omega_n^k\\mathrm{DFT}(f_1(\\omega_\\frac n2^k)) \\end{aligned} 其中 k &lt; \\displaystyle\\frac n2 。不难发现只要我们求得出 \\mathrm{DFT}(f_0(\\omega_\\frac n2^k)) 与 \\mathrm{DFT}(f_1(\\omega_\\frac n2^k)) 的话，就可以同时求出 \\mathrm{DFT}(f(\\omega_n^k)) 和 \\mathrm{DFT}(f(\\omega_n^{k + \\frac n2})) 。接下来再对 f_0 与 f_1 递归 DFT 即可。其时间复杂度函数是形如下面这样的： T(n) = T(n/2) + O(n) 所以总复杂度为 \\Theta(n\\log n) 实际实现的时候一定要注意传进去的系数一定要是 2^m 个的，不然分治的过程中左右不一样会出问题。第一次传进去的时候就高位补 0 ，补成最高项次数为 2^{m - 1} 的多项式。 1234567891011121314151617void dft(int lim, complex *a){ if (lim == 1) return;//常数项直接返回 complex a1[lim &gt;&gt; 1], a2[lim &gt;&gt; 1]; for (int i = 0; i &lt; lim; i += 2) a1[i &gt;&gt; 1] = a[i], a2[i &gt;&gt; 1] = a[i + 1];//把系数按照奇偶分开 dft(lim &gt;&gt; 1, a1, type);//求 DFT(f_0()) dft(lim &gt;&gt; 1, a2, type);//求 DFT(f_1()) complex Wn = complex(cos(2.0 * pi / lim), sin(2.0 * pi / lim)), w = complex(1, 0); for (int i = 0; i &lt; (lim &gt;&gt; 1); ++i, w = w * Wn) { a[i] = a1[i] + w * a2[i];//求 DFT(f(\\omega_n^k)) a[i + (lim &gt;&gt; 1)] = a1[i] - w * a2[i];//求 DFT(f(\\omega_n^{k+\\fracn2})) } return;} IDFT 好了现在假装我们已经求出了两个多项式的点值表达并已经将他们乘起来，但是我们最终还是要把他还原回去到系数表示的。这个过程就叫做 IDFT。 其实就是我们需要求解下面关于 a 的线性方程组： \\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; (\\omega_n^0)^2 &amp;\\cdots &amp;(\\omega_n^0)^n\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; (\\omega_n^1)^2 &amp;\\cdots &amp; (\\omega_n^1)^n\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp;\\vdots\\\\ (\\omega_n^{n})^0 &amp; (\\omega_n^{n})^1 &amp; (\\omega_n^{n})^2 &amp; \\cdots &amp; (\\omega_n^n)^n \\end{bmatrix} \\begin{bmatrix} a_0\\\\a_1\\\\ \\vdots \\\\ a_n \\end{bmatrix}=\\begin{bmatrix} y_0\\\\y_1\\\\ \\vdots\\\\ y_n \\end{bmatrix} 我们将其乘上左边矩阵的逆： \\begin{bmatrix} a_0\\\\a_1\\\\ \\vdots \\\\ a_n \\end{bmatrix}=\\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; (\\omega_n^0)^2 &amp;\\cdots &amp;(\\omega_n^0)^n\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; (\\omega_n^1)^2 &amp;\\cdots &amp; (\\omega_n^1)^n\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp;\\vdots\\\\ (\\omega_n^{n})^0 &amp; (\\omega_n^{n})^1 &amp; (\\omega_n^{n})^2 &amp; \\cdots &amp; (\\omega_n^n)^n \\end{bmatrix}^{-1} \\begin{bmatrix} y_0\\\\y_1\\\\ \\vdots\\\\ y_n \\end{bmatrix} 模相同的正交列向量构成的矩阵的逆是转置的模分之一倍，所以： \\begin{bmatrix} (\\omega_n^0)^0 &amp; (\\omega_n^0)^1 &amp; (\\omega_n^0)^2 &amp;\\cdots &amp;(\\omega_n^0)^n\\\\ (\\omega_n^1)^0 &amp; (\\omega_n^1)^1 &amp; (\\omega_n^1)^2 &amp;\\cdots &amp; (\\omega_n^1)^n\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp;\\vdots\\\\ (\\omega_n^{n})^0 &amp; (\\omega_n^{n})^1 &amp; (\\omega_n^{n})^2 &amp; \\cdots &amp; (\\omega_n^n)^n \\end{bmatrix}^{-1} =\\frac {1}{n+1} \\begin{bmatrix} (\\omega_n^{-0})^0 &amp; (\\omega_n^{-0})^1 &amp; (\\omega_n^{-0})^2 &amp;\\cdots &amp;(\\omega_n^{-0})^n\\\\ (\\omega_n^{-1})^0 &amp; (\\omega_n^{-1})^1 &amp; (\\omega_n^{-1})^2 &amp;\\cdots &amp; (\\omega_n^{-1})^n\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; &amp;\\vdots\\\\ (\\omega_n^{-n})^0 &amp; (\\omega_n^{-n})^1 &amp; (\\omega_n^{-n})^2 &amp; \\cdots &amp; (\\omega_n^{-n})^n \\end{bmatrix} 所以不难发现，IDFT 其实就是再做了一遍 DFT，只不过是反起来的。只是算出来最后的系数结果都要除以点值的个数，反映在代码里面就是那个 lim 变量。 不难发现 \\omega_n^k 的共轭就是虚部取反，所以可以在 DFT 函数里面传一个参数表示是否为 IDFT。 这样子一个递归版的 FFT 就写完了，总体的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)const int maxn = 2e6 + 5;const double pi = acos(-1.0);inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}struct complex{ double x, y; complex(double xx = 0, double yy = 0) { x = xx, y = yy; }} a[maxn], b[maxn];complex operator+(const complex &amp;a, const complex &amp;b) {return complex(a.x + b.x, a.y + b.y);}complex operator-(const complex &amp;a, const complex &amp;b) {return complex(a.x - b.x, a.y - b.y);}complex operator*(const complex &amp;a, const complex &amp;b) {return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}void dft(int lim, complex *a, int type)//type = 1 DFT；type = -1 IDFT{ if (lim == 1) return;//返回常数项 complex a1[lim &gt;&gt; 1], a2[lim &gt;&gt; 1]; for (int i = 0; i &lt; lim; i += 2) a1[i &gt;&gt; 1] = a[i], a2[i &gt;&gt; 1] = a[i + 1]; dft(lim &gt;&gt; 1, a1, type); dft(lim &gt;&gt; 1, a2, type); complex Wn = complex(cos(2.0 * pi / lim), type * sin(2.0 * pi / lim)), w = complex(1, 0); for (int i = 0; i &lt; (lim &gt;&gt; 1); ++i, w = w * Wn) { a[i] = a1[i] + w * a2[i]; a[i + (lim &gt;&gt; 1)] = a1[i] - w * a2[i]; } return;}int main(){ int n = read(), m = read(); FOR(i, 0, n) a[i].x = read(); FOR(i, 0, m) b[i].x = read(); int lim = 1; while (lim &lt;= n + m) lim &lt;&lt;= 1;//lim一定要大于 n + m dft(lim, a, 1); dft(lim, b, 1); FOR(i, 0, lim) a[i] = a[i] * b[i];//点值乘起来 dft(lim, a, -1);//IDFT还回去 FOR(i, 0, n + m) printf(\"%d \", (int)(a[i].x / lim + 0.5));//最后要除那个数然后还原回去，四舍五入 return 0;} 位逆序置换 然而，上面的代码连模板都跑不过去…… 考虑继续优化 DFT 的过程。递归的过程中开了大量的空间并且常数巨大，考虑非递归写法。 只考虑我们对 0 到 7 操作： 递归的过程： 1234567original 0 1 2 3 4 5 6 7recursion#1 0 2 4 6 1 3 5 7recursion#2 0 4 2 6 1 5 3 7recursion#3 0 4 2 6 1 5 3 7original bin 000 001 010 011 100 101 110 111now bin 000 100 010 110 001 101 011 111 可见递归到最后的结果无非就是一个二进制反转。 所以我们可以考虑非递归，一开始就先把所有的数放到最后的位置，然后迭代的时候一步步还回去即可。这个过程就是位逆序置换（蝴蝶变换） 考虑处理出 x 二进制位翻转之后的数 R(x) 。易知 R(0) = 0 。我们可以从小到大求 R(x) 。很明显， \\lfloor x/2\\rfloor 的二进制位是 x 右移一位，那么如果知道了 R(\\lfloor x/2\\rfloor) 就可以很容易的求出 R(x) ，再分 x 的奇偶性判断就可以了。 R(x) = \\left\\lfloor\\frac{R(\\lfloor x/2\\rfloor)}{2}\\right\\rfloor + (x\\bmod 2)\\times\\frac{len}2 举个例子：翻转 (10101110)_2 ，首先我们知道它的二分之一倍为 (01010111)_2 ，其翻转结果为 (11101010)_2 ，除以二变为 (01110101)_2 ，由于它是偶数所以前面不用补 1 。不难发现其就是一开始要求的翻转结果。 预处理翻转结果的代码： 1234while (lim &lt;= n + m) lim &lt;&lt;= 1;FOR(i, 0, lim - 1) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | (((i &amp; 1) ? (lim &gt;&gt; 1) : 0))); 然后在处理翻转的时候只需要下面几行： 1234FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(a[i], a[rev[i]]); 不难验证其正确性。 而且观察我们在求 \\mathrm{DFT}(f(\\omega_n^k)) 时我们需要算两遍 \\omega_n^k\\mathrm{DFT}(f_1(\\omega_\\frac n2^k)) ，复数的乘法常数很大，考虑使用临时变量记录以降低常数。 这样子的话迭代版的 DFT 过程就很好写了： 1234567891011121314151617181920212223void DFT(int lim, complex *a, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(a[i], a[rev[i]]);//先预处理翻转完了的结果 for (int p = 2; p &lt;= lim; p &lt;&lt;= 1)//模拟合并答案的过程，即为所谓的 n { int len = p &gt;&gt; 1;//即上面的 n / 2 complex Wp = complex(cos(2 * pi / p), type * sin(2 * pi / p));//处理出 p 次单位根 for (int k = 0; k &lt; lim; k += p)//对每一个进行合并 { complex w = complex(1, 0);//处理 \\omega_p^0 for (int l = k; l &lt; k + len; ++l, w = w * Wp)//开始合并 { //此时的 a[l] 就是之前的 a1[i]，a[len + l] 就是之前的 a2[i] complex tmp = w * a[len + l]; a[len + l] = a[l] - tmp;//相当于上面的 a[i + (lim &gt;&gt; 1)] = a1[i] - w * a2[i] a[l] = a[l] + tmp;//相当于上面的 a[i] = a1[i] + w * a2[i] } } }} 多项式乘法的实现 总的一个非递归版 FFT 的实现如下（洛谷 P3803）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)const int maxn = 3e6 + 5;const double pi = acos(-1.0);inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}template&lt;typename T&gt; inline void myswap(T &amp;a, T &amp;b){ T t = a; a = b; b = t; return;}struct complex{ double x, y; complex(double xx = 0, double yy = 0) { x = xx, y = yy; }} a[maxn], b[maxn];int rev[maxn];complex operator+(const complex &amp;a, const complex &amp;b) {return complex(a.x + b.x, a.y + b.y);}complex operator-(const complex &amp;a, const complex &amp;b) {return complex(a.x - b.x, a.y - b.y);}complex operator*(const complex &amp;a, const complex &amp;b) {return complex(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}void DFT(int lim, complex *a, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(a[i], a[rev[i]]);//先预处理翻转完了的结果 for (int p = 2; p &lt;= lim; p &lt;&lt;= 1)//模拟合并答案的过程，即为所谓的 n { int len = p &gt;&gt; 1;//即上面的 n / 2 complex Wp = complex(cos(2 * pi / p), type * sin(2 * pi / p));//处理出 p 次单位根 for (int k = 0; k &lt; lim; k += p)//对每一个进行合并 { complex w = complex(1, 0);//处理 \\omega_p^0 for (int l = k; l &lt; k + len; ++l, w = w * Wp)//开始合并 { //此时的 a[l] 就是之前的 a1[i]，a[len + l] 就是之前的 a2[i] complex tmp = w * a[len + l]; a[len + l] = a[l] - tmp;//相当于上面的 a[i + (lim &gt;&gt; 1)] = a1[i] - w * a2[i] a[l] = a[l] + tmp;//相当于上面的 a[i] = a1[i] + w * a2[i] } } }}int main(){ int n = read(), m = read(); FOR(i, 0, n) a[i].x = read(); FOR(i, 0, m) b[i].x = read(); int lim = 1; while (lim &lt;= n + m) lim &lt;&lt;= 1;//补齐高位 FOR(i, 0, lim - 1) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | (((i &amp; 1) ? (lim &gt;&gt; 1) : 0)));//先处理翻转完的结果 DFT(lim, a, 1);//DFT DFT(lim, b, 1);//DFT FOR(i, 0, lim) a[i] = a[i] * b[i];//对处理出来的点值进行乘法 DFT(lim, a, -1);//IDFT FOR(i, 0, n + m) printf(\"%d \", (int)(a[i].x / lim + 0.5)); return 0;} 使用 FFT 来求高精度整数乘法的实现（洛谷 P1919）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)template&lt;typename T&gt; inline void myswap(T &amp;a, T &amp;b) {T t = a; a = b; b = t; return;}typedef double db;const int maxn = 3000000 + 5;const db pi = acos(-1.0);struct cmplx{ db x, y; cmplx(db xx = 0, db yy = 0) {x = xx, y = yy;}} a[maxn], b[maxn];cmplx operator+(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x + b.x, a.y + b.y);}cmplx operator-(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x - b.x, a.y - b.y);}cmplx operator*(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}char s1[maxn], s2[maxn];int rev[maxn], ans[maxn];void DFT(cmplx *f, int lim, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(f[i], f[rev[i]]); for (int p = 2; p &lt;= lim; p &lt;&lt;= 1) { int len = p &gt;&gt; 1; cmplx Wp(cos(2.0 * pi / p), type * sin(2.0 * pi / p)); for (int k = 0; k &lt; lim; k += p) { cmplx w(1, 0); for (int l = k; l &lt; k + len; ++l, w = w * Wp) { cmplx tmp = w * f[l + len]; f[l + len] = f[l] - tmp; f[l] = f[l] + tmp; } } } return;}int main(){ scanf(\"%s\\n%s\", s1, s2); int n1 = -1, n2 = -1; DEC(i, strlen(s1) - 1, 0) a[++n1].x = s1[i] - '0'; DEC(i, strlen(s2) - 1, 0) b[++n2].x = s2[i] - '0'; int lim = 1; while (lim &lt;= n1 + n2) lim &lt;&lt;= 1; FOR(i, 0, lim - 1) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | (((i &amp; 1) ? (lim &gt;&gt; 1) : 0))); DFT(a, lim, 1); DFT(b, lim, 1); FOR(i, 0, lim) a[i] = a[i] * b[i]; DFT(a, lim, -1); FOR(i, 0, lim) ans[i] = (int)(a[i].x / lim + 0.5); FOR(i, 0, lim) if (ans[i] &gt;= 10) ans[i + 1] += ans[i] / 10, ans[i] %= 10, lim += (i == lim); while (!ans[lim] &amp;&amp; lim &gt; -1) --lim; if (lim == -1) puts(\"0\"); else DEC(i, lim, 0) printf(\"%d\", ans[i]); return 0;} 当然，千万要记得 IDFT 还回去的时候要除以 lim，实在怕记不住就在 DFT 函数里面加几句话直接处理好 1234if (type == -1) FOR(i, 0, lim - 1) f[i].x /= lim; 针对多项式乘法：三次变两次优化 我们发现我们在做多项式乘法的时候，需要先 DFT A(x) ， B(x) ，乘在一起之后再 IDFT 还回来 C(x) ，一共进行了三次这样的操作。考虑如何减少我们调用 DFT 的次数。 可以把 B(x) 的系数放到 A(x) 系数的虚部上面，即 a + b\\mathrm i ，然后 DFT 一下 A(x) 再求个平方，得到 A^2(x) ，再 IDFT 回去。我们可以发现得到的系数都是 (a + b\\mathrm i)^2 = a^2 - b^2 + 2ab\\mathrm i 的形式的，所以只需要取出虚部再除以二就得到答案了。 这样的写法可以减小常数，跑的比 NTT 还快。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)typedef double db;const int maxn = 3e6 + 5;const db pi = acos(-1.0);inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}template&lt;typename T&gt; inline void myswap(T &amp;a, T &amp;b){ T t = a; a = b; b = t; return;}struct cmplx{ db x, y; cmplx(db xx = 0, db yy = 0) { x = xx, y = yy; }} a[maxn];int rev[maxn];cmplx operator+(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x + b.x, a.y + b.y);}cmplx operator-(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x - b.x, a.y - b.y);}cmplx operator*(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}void DFT(cmplx *f, int lim, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(f[i], f[rev[i]]); for (int p = 2; p &lt;= lim; p &lt;&lt;= 1) { int len = p &gt;&gt; 1; cmplx Wp(cos(2 * pi / p), type * sin(2 * pi / p)); for (int k = 0; k &lt; lim; k += p) { cmplx w(1, 0); for (int l = k; l &lt; k + len; ++l, w = w * Wp) { cmplx tmp = w * f[len + l]; f[len + l] = f[l] - tmp; f[l] = f[l] + tmp; } } }}int main(){ int n = read(), m = read(); FOR(i, 0, n) a[i].x = read(); FOR(i, 0, m) a[i].y = read(); int lim = 1; while (lim &lt;= n + m) lim &lt;&lt;= 1; FOR(i, 0, lim - 1) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (lim &gt;&gt; 1) : 0)); DFT(a, lim, 1); FOR(i, 0, lim - 1) a[i] = a[i] * a[i]; DFT(a, lim, -1); FOR(i, 0, n + m) printf(\"%d \", (int)(a[i].y / lim / 2.0 + 0.5)); return 0;} 快速数论变换（NTT） 有了 FFT，我们已经有能力在 O(n\\log n) 的时间内求出两个多项式的卷积了。但是 FFT 也有它的缺点：复数采用的浮点运算不仅造成精度的问题，还会增大常数。遗憾的是数学家们已经证明了 \\mathbb C 中只有单位复数根满足 FFT 的要求。 考虑到利用多项式的计数题很多都是模意义下的，所以自然希望为单位复数根找一个模意义下的替代品。此时就进入下面的前置知识：原根。 原根 设整数 r,n 满足 r\\perp n\\land r \\not= 0 \\land n &gt; 0 ，使得 r^x \\equiv 1\\pmod n 的最小正整数 x 称为 r 模 n 的阶，记为 \\mathrm{ord}_nr 或 \\delta_n(r) 。 若 r,n\\in\\mathbb N^+\\land r\\perp n ，当 \\operatorname{ord}_nr = \\phi(n) 时，称 r 是模 n 的原根或者 n 的原根。 NTT 对于质数 p = qn + 1\\:(n = 2^m) ，原根 g 满足 g^{qn}\\equiv 1\\pmod p ，将 g_n = g^q\\pmod p 看作 \\omega_n 的等价，其满足相似的性质，比如 g_n^n\\equiv 1\\pmod p,g_n^{n/2} \\equiv -1\\pmod p 。 常见的质数 \\begin{aligned} p &amp;= 998244353 = 7\\times17\\times2^{23} + 1,&amp;g = 3\\\\ p &amp;= 1004535809 = 479\\times 2^{21} + 1,&amp;g = 3 \\end{aligned} 迭代到长度为 l 时， g_l = g^{\\frac{p - 1}{l}} 直接看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)typedef long long ll;const ll G = 3;const ll mod = 998244353;const int maxn = 3e6 + 5;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}template&lt;typename T&gt; inline void myswap(T &amp;a, T &amp;b){ T t = a; a = b; b = t; return;}ll pow(ll base, ll p = mod - 2){ ll ret = 1; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ret = ret * base % mod; base = base * base % mod; } return ret;}int rev[maxn];ll f[maxn], g[maxn];const ll invG = pow(G);void NTT(ll *f, int lim, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(f[i], f[rev[i]]); for (int p = 2; p &lt;= lim; p &lt;&lt;= 1) { int len = p &gt;&gt; 1; ll tG = pow(type ? G : invG, (mod - 1) / p); for (int k = 0; k &lt; lim; k += p) { ll buf = 1; for (int l = k; l &lt; k + len; ++l, buf = buf * tG % mod) { ll tmp = buf * f[len + l] % mod; f[len + l] = f[l] - tmp; if (f[len + l] &lt; 0) f[len + l] += mod;//及时取模 f[l] = f[l] + tmp; if (f[l] &gt; mod) f[l] -= mod;//及时取模 } } } ll invlim = pow(lim);//最后还回去，除以lim相当于乘上lim的逆元 if (!type) FOR(i, 0, lim - 1) f[i] = (f[i] * invlim % mod); return;}int main(){ int n = read(), m = read(); FOR(i, 0, n) f[i] = read(); FOR(i, 0, m) g[i] = read(); int lim = 1; while (lim &lt;= n + m) lim &lt;&lt;= 1; FOR(i, 0, lim - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (lim &gt;&gt; 1) : 0); NTT(f, lim, 1), NTT(g, lim, 1); FOR(i, 0, lim - 1) f[i] = f[i] * g[i] % mod; NTT(f, lim, 0); FOR(i, 0, n + m) printf(\"%d \", (int)f[i]); return 0;} 任意模数多项式乘法 问题描述 有些毒瘤题目里面，模数不一定是满足 p = a\\times2^k + 1 的形式，这就意味着 NTT 是不能用的，而普通的 FFT 精度又不够，怎么办呢？ 一般的问题形式：给定 f(x) 和 g(x) ，求 h(x) = f(x)\\times g(x) ，系数对 10^9 + 7 取模。 法 1：三模 NTT 分析可得最大的数应该是 p^2\\times\\max\\{\\deg f, \\deg g\\} ，是 10^{23} 级别的。所以选三个模数分别做 NTT 然后用 CRT 合并即可。需要做 9 次 DFT，常数较大，暂不考虑。 法 2：拆系数 FFT（MTT） 考虑把多项式的系数拆成形如 a\\times 2^{15} + b 的形式，那么 a, b\\le 2^{15} 。这样子相乘的值域大概是 10^{14} 级别的。 于是有 c_1c_2 = (a_1\\times 2^{15} + b_1)(a_2\\times 2^{15}+b_2) = a_1a_2\\times 2^{30} + (a_1b_2 + a_2b_1)2^{15} + b_1b_2 。然而这样看似要求四次多项式乘法， 12 次 DFT，似乎更加屑了。 冷静分析一下：现在的问题是有四个多项式 A_1 ， A_2 ， B_1 和 B_2 ，要求这些多项式的两两乘积。 利用复数的性质：考虑 (a + bi)(c + di) = ac - bd + (ad + bc)i 。那么令复多项式 P = A_1 + iA_2 ， Q = B_1 + iB_2 。 有 T_1 = P\\times Q = A_1B_1 - A_2B_2 + (A_1B_2 + A_2B_1)i 。 再设 P' = A_1 - iA_2 ，那么有 T_2 = P'\\times Q = A_1B_1 + A_2B_2 + (A_1B_2 - A_2B_1)i 。 两式相加可以得到 2A_1B_1 + 2A_1B_2i ，两式相减可以得到 2A_2B_2 - 2A_2B_1i 。把这两个多项式的实部虚部拆出来就得到我们想要的结果了。 这样子需要做 5 次 DFT，常数不小但比 9 次 NTT 优。 实现 可以直接配合后面的 vector 版多项式板子食用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869namespace complex { struct cmplx { db x, y; cmplx(db xx = 0, db yy = 0) : x(xx), y(yy) {} }; il cmplx operator+(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x + b.x, a.y + b.y);} il cmplx operator-(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x - b.x, a.y - b.y);} il cmplx operator*(const cmplx &amp;a, const cmplx &amp;b) {return cmplx(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);}} using namespace complex;namespace MTT { using std::sin; using std::cos; using std::acos; using std::floor; const db PI = acos(-1.0); const int DIV = 32768; int mod; #define clr2(f, n) memset(f, 0, (sizeof(cmplx)) * n) void DFT(cmplx *g, int type, int lim) { static cmplx f[maxn &lt;&lt; 1]; getTr(lim); FOR(i, 0, lim - 1) f[i] = g[tr[i]]; for (int p = 2; p &lt;= lim; p &lt;&lt;= 1) { int len = p &gt;&gt; 1; cmplx Wp(std::cos(PI / len), type * std::sin(PI / len)); for (int k = 0; k &lt; lim; k += p) { cmplx w(1, 0); for (int l = k; l &lt; k + len; ++l, w = w * Wp) { cmplx tmp = w * f[len + l]; f[len + l] = f[l] - tmp; f[l] = f[l] + tmp; } } } FOR(i, 0, lim - 1) if (type == -1) g[i] = cmplx(f[i].x / lim, f[i].y / lim); else g[i] = f[i]; return; } Poly operator*(const Poly &amp;A, const Poly &amp;B) { static cmplx p1[maxn &lt;&lt; 1], p2[maxn &lt;&lt; 1], q[maxn &lt;&lt; 1], t1[maxn &lt;&lt; 1], t2[maxn &lt;&lt; 1]; VEC(i, A) p1[i] = cmplx(A[i] / DIV, A[i] % DIV), p2[i] = cmplx(A[i] / DIV, -p1[i].y); VEC(i, B) q[i] = cmplx(B[i] / DIV, B[i] % DIV); Poly C; C.resize(min(lim, (int)A.size() + (int)B.size() - 1)); int n; for (n = 1; n &lt; (int)(A.size() + B.size() - 1); n &lt;&lt;= 1); DFT(p1, 1, n), DFT(p2, 1, n), DFT(q, 1, n); FOR(i, 0, n - 1) t1[i] = p1[i] * q[i], t2[i] = p2[i] * q[i]; DFT(t1, -1, n), DFT(t2, -1, n); VEC(i, C) { ll a1b1, a1b2, a2b1, a2b2; a1b1 = (ll)floor((t1[i].x + t2[i].x) / 2.0 + 0.49) % mod; a1b2 = (ll)floor((t1[i].y + t2[i].y) / 2.0 + 0.49) % mod; a2b1 = ((ll)floor(t1[i].y + 0.49) - a1b2) % mod; a2b2 = ((ll)floor(t2[i].x + 0.49) - a1b1) % mod; C[i] = ((((a1b1 &lt;&lt; 15) + (a1b2 + a2b1)) &lt;&lt; 15) + a2b2) % mod; C[i] = (C[i] + mod) % mod; } clr2(p1, n), clr2(p2, n), clr2(q, n), clr2(t1, n), clr2(t2, n); return C; }} using namespace MTT; FFT/NTT 优化卷积的一些例子 在继续之前，我们先来看看 FFT/NTT 的一些应用。（高精度乘法就不说了，记得最后进位就可以了） 优化一般的卷积 和生成函数一起食用 字符串匹配（你没看错） 洛谷 P3338 [ZJOI2014]力 题意：给定 \\{q\\} ，定义 F_i = \\sum_{j = 1}^{i - 1}\\frac{q_iq_j}{(i - j)^2} - \\sum_{j = i + 1}^n\\frac{q_iq_j}{(i - j)^2} 求 E_i=\\frac{F_i}{q_i} 考虑暴力的话，这道题是 O(n^2) 的，过不去，考虑转化式子： \\begin{aligned} E_i &amp;= \\frac{F_i}{q_i}\\\\ &amp;=\\sum_{j = 1}^{i - 1}\\frac{q_j}{(i - j)^2} - \\sum_{j = i + 1}^n\\frac{q_j}{(i - j)^2}\\\\ \\end{aligned} 我们尝试将其化为卷积的形式，令 f_i = q_i ，且 f_0 = 0 ； g_i =\\dfrac{1}{i^2} ，且 g_0 = 0 ，回代： \\begin{aligned} E_i &amp;= \\sum_{j = 0}^{i}f_jg_{i - j} - \\sum_{j = i}^nf_jg_{j - i} \\end{aligned} 左边的部分已经是一个卷积的形式了，考虑继续化简右边。此时我们可以使用一个翻转的技巧，令 f'_i = f_{n - i} ， t = n - i ，则右半边的式子可以化为 \\displaystyle\\sum_{j = 0}^{t}f'_{t - j}g_j 。现在两边都化为卷积的形式了，可以愉快的使用 FFT 加速了。 即我们设多项式 A(x) =\\displaystyle\\sum_{i = 0}^nf_ix^n ， B(x) = \\displaystyle\\sum_{i = 0}^ng_ix^n ， C(x) = \\displaystyle\\sum_{i = 0}^nf'_i 。再令 L(x) = A(x)B(x) ， R(x) = B(x)C(x) ，不难发现答案 E_i = l_i - r_{n - i} ，其中 l_i 和 r_i 分别为 L(x) 和 R(x) 中 x^i 的系数。 12345678910111213141516171819202122int main(){ int n; scanf(\"%d\", &amp;n); FOR(i, 1, n) { scanf(\"%lf\", &amp;a[i].x); b[i].x = (1.0 / i / i); c[n - i].x = a[i].x; } int lim = 1; while (lim &lt;= (n &lt;&lt; 1)) lim &lt;&lt;= 1; FOR(i, 0, lim) rev[i] = ((rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (lim &gt;&gt; 1) : 0)); DFT(a, lim, 1), DFT(b, lim, 1), DFT(c, lim, 1); FOR(i, 0, lim) a[i] = a[i] * b[i], c[i] = b[i] * c[i]; DFT(a, lim, -1), DFT(c, lim, -1); FOR(i, 1, n) printf(\"%.3lf\\n\", a[i].x - c[n - i].x); return 0;} 洛谷 P3723 [AH2017/HNOI2017]礼物 题意：给定两个序列 \\{x\\} 和 \\{y\\} ，可以整体平移序列或者整体加/减某个数，求最终序列 \\sum_{i = 1}^n(x_i - y_i)^2 的最小值。 分析：设整体加减的数为 c （ c 可正可负），我们需要最小化的就是下面这个式子： \\sum_{i = 1}^n(x_i - y_i + c)^2 展开上面的式子，由 (x_i - y_i +c)^2 = x_i^2 + y_i^2 + c^2 + 2x_ic - 2y_ic - 2x_iy_i 可以得到原式可化简为 \\sum x_i^2 + \\sum y_i^2 + nc^2 + 2c\\sum x_i - 2c\\sum y_i - 2\\sum x_iy_i （下标省略） 不难发现我们只需要最大化 \\sum x_iy_i 就可以啦。 设 f_k 为旋转了 k 个单位后 \\sum x_iy_i 的取值，先把 \\{x\\} 倍长一波，则 f_k = \\sum_{i = 1}^nx_{i + k}y_k 翻转 y ： f_k = \\sum_{i = 1}^nx_{i + k}y_{n - i + 1}' 考虑多项式 f(t) = \\sum_{i = 1}^n x_it^i ， g(t) = \\sum_{i = 1}^n y_it^i ，令 h(t) = f(t) * g(t) ，不难发现其 t^{n + k + 1} 的系数即为 f_k 。因此可以使用 FFT/NTT 将倍长过的 \\{x\\} 与翻转过的 \\{y\\} 卷起来，然后把结果从第 n + 1 到第 2n 处找最值就可以了 NTT 的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556ll a[maxn], b[maxn];ll suma, sumb, suma2, sumb2, n, m;int rev[maxn];void NTT(ll *f, int lim, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) swap(f[i], f[rev[i]]); for (int p = 2; p &lt;= lim; p &lt;&lt;= 1) { int len = p &gt;&gt; 1; ll Gp = pow(type ? G : invG, (mod - 1) / p); for (int k = 0; k &lt; lim; k += p) { ll buf = 1; for (int l = k; l &lt; k + len; ++l, buf = buf * Gp % mod) { ll tmp = buf * f[l + len] % mod; f[l + len] = f[l] - tmp; if (f[l + len] &lt; 0) f[l + len] += mod; f[l] = f[l] + tmp; if (f[l] &gt; mod) f[l] -= mod; } } } ll invlim = pow(lim); if (!type) FOR(i, 0, lim - 1) f[i] = f[i] * invlim % mod; return;}int main(){ n = read(), m = read(); FOR(i, 1, n) a[i] = a[i + n] = read(), suma += a[i], suma2 += a[i] * a[i]; FOR(i, 1, n) b[n - i + 1] = read(), sumb += b[n - i + 1], sumb2 += b[n - i + 1] * b[n - i + 1]; int lim = 1; while (lim &lt;= 3 * n) lim &lt;&lt;= 1; FOR(i, 0, lim - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (lim &gt;&gt; 1) : 0); NTT(a, lim, 1), NTT(b, lim, 1); FOR(i, 0, lim) a[i] = a[i] * b[i] % mod;//千万不要忘记取模 NTT(a, lim, 0); ll ans = 1e18; FOR(i, 1, n) FOR(j, -m, m) ans = min(ans, suma2 + sumb2 + j * j * n + 2 * j * (suma - sumb) - 2 * a[i + n]); printf(\"%lld\\n\", ans); return 0;} BZOJ3771 Triple 题意：有 n 把价值分别为 a_i 的斧子，河神可能拿走 1 - 3 把，问每种可能的损失价值及其对应方案数。（不计顺序） 思路：这是一道生成函数的入门题。 考虑设出多项式 A(x) ，其系数有 A[a_i] = 1 ，代表选一把的。则你可能会觉得答案为 A(x) + A^2(x) + A^3(x) 。但是这样是显然不对的。为什么？ 因为这样的话同一个元素可能被选两次或三次，对于这种情况定义 B(x) 和 C(x) 满足 B[2a_i] = 1 和 C[3a_i] = 1 ，代表同时选两次/三次的，减掉这些方案数就可以了。然后需要注意顺序问题： 选一把的答案为 A(x) ，不难发现选两种的即为 \\dfrac{A^2(x) - B(x)}{2} ，选三种的比较麻烦：不能同时选两种一样的，即减去 3A(x)B(x) ，，但是选三种同样的又会被多减两次，最后除以 3! 去掉顺序问题，所以最终答案为： A(x) + \\frac{A^2(x) - B(x)}{2} + \\frac{A^3(x) - 3A(x)B(x) + 2C(x)}{6} 生成函数的卷积使用 NTT 或 FFT 优化即可。注意此时 NTT 模数要取一个更大的质数。不知道为什么生成函数能这样对应的可以意会一下多项式卷积的定义式以及这些系数的组合意义。 1234567891011121314151617181920212223242526272829303132333435363738ll f1[maxn], f2[maxn], f3[maxn], ans[maxn];ll g[maxn], t[maxn];int main(){ int n = read(); while (n--) { int tmp = read(); ++f1[tmp], ++g[tmp], ++ans[tmp]; ++f2[tmp &lt;&lt; 1], ++f3[tmp * 3]; } int lim = 1; while (lim &lt;= (40000 * 3 + 5)) lim &lt;&lt;= 1; FOR(i, 0, lim - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (lim &gt;&gt; 1) : 0); NTT(f1, lim, 1), NTT(g, lim, 1); FOR(i, 0, lim - 1) g[i] = f1[i] * g[i] % mod; NTT(g, lim, 0); FOR(i, 0, lim - 1) ans[i] += (g[i] - f2[i]) / 2; NTT(g, lim, 1); FOR(i, 0, lim - 1) g[i] = f1[i] * g[i] % mod; NTT(g, lim, 0); NTT(f2, lim, 1); FOR(i, 0, lim - 1) f2[i] = f2[i] * f1[i] % mod; NTT(f2, lim, 0); FOR(i, 0, lim - 1) { ans[i] += (g[i] - 3 * f2[i] + 2 * f3[i]) / 6; if (ans[i]) printf(\"%d %lld\\n\", i, ans[i]); } return 0;} FFT/NTT 与字符串匹配 字符串下标从 1 开始 最一般的情况 考虑文本串 S 和模式串 T ，串长 n = |S| ， m = |T| ，保证 n \\ge m ，现在需要找出 T 在 S 中出现的每个位置。直接跑 KMP 就可以了，但是这个不是要提的重点。考虑串 S 的第 i 个字符为 S[i] ，那么匹配就可以写成 S[i] - T[j] = 0 ，这个应该是比较好想的。 假设 T 在 S 的第 i 位开始成功匹配，则我们有 \\sum_{j = 1}^{m} (S[i + j - 1] - T[j])^2 = 0 为了防止正负号相互抵消，所以需要平方。由于 i + j - 1 + j 不是定值，不符合我们需要的卷积的形式，所以翻转一下 T 让其变为 T' ： \\sum_{j = 1}^{m} (S[i + j - 1] - T[m - j + 1])^2 = 0 打开来我们就会发现 \\sum_{j = 1}^{m} (S[i + j - 1]^2 + T[j]^2 - 2S[i + j - 1]T[m - j + 1]) = 0 i + j - 1 + m - j + 1 = i + m ，为定值。 所以上面的式子就可以化成 \\sum_{j = 1}^m S[i + j - 1]^2 + \\sum_{j = 1}^m T[j]^2 - 2\\sum_{x + y = i + m}S[x]T[y] 第一项直接前缀和就可以解决，第二项常数，第三项使用 FFT/NTT。 更加好理解地，设 f(x) = \\sum_{i + j = x + m}S[i]T[j] ，我们只需要求出这个 f(x) 就可以了。 问题来了，这样难写复杂度高常数大全方位被 KMP 吊打的算法有什么存在的意义吗？对不起还真的有： 带通配符的字符串匹配 请看例题 洛谷 P4173 残缺的字符串。仍然是字符串匹配，但是每个串都有通配符，这个时候 KMP 就显得无能为力了。怎么办呢？好好思考一下两个字符如何才能匹配： 两个字符完全一样 其中至少一个为通配符 两者是逻辑或的关系，我们魔改一下上面的式子，不难发现我们只需要把通配符的值设为 0 就可以解决了： 定义匹配函数 F(x) 表示 S 的第 x 位开始和 T 是否匹配，匹配的话 F(x) = 0 。 F(x) = \\sum_{j = 1}^m(S[x + j - 1] - T[j])^2S[x + j - 1]T[j] 化简： \\begin{aligned} F(x) &amp;= \\sum_{j = 1}^m(S[x + j - 1] - T[j])^2S[x + j - 1]T[j]\\\\ &amp;= \\sum_{j = 1}^m(S[x + j - 1] - T'[m - j + 1])^2S[x + j - 1]T'[m - j + 1]\\\\ &amp;= \\sum_{j = 1}^m(S[x + j - 1]^2 + T'[m - j + 1]^2 - 2S[x + j - 1]T'[m - j + 1])S[x + j - 1]T'[m - j + 1]\\\\ &amp;= \\sum_{j = 1}^m S[x + j - 1]^3T'[m - j + 1] + \\sum_{j = 1}^m S[x + j - 1]T'[m - j + 1]^3- 2\\sum_{j = 1}^m S[x + j - 1]^2T'[m - j + 1]^2\\\\ &amp;= \\sum_{i + j = x + m}S[i]^3T'[j] + \\sum_{i + j = x + m}S[i]T'[j]^3 - 2\\sum_{i + j = x + m}S[i]^2T[j]^2 \\end{aligned} 于是问题就解决了，只需要用 NTT/FFT 计算出上面三项恶心的东西出来就 OK 了。一共进行 7 次 NTT 即可。 需要注意的是最后枚举答案的时候只能枚举到 n - m + 1 处，否则只有 35 分。 12345678910111213141516171819202122232425262728293031323334353637int f[maxn &lt;&lt; 1], g[maxn &lt;&lt; 1], f2[maxn &lt;&lt; 1], g2[maxn &lt;&lt; 1], f3[maxn &lt;&lt; 1], g3[maxn &lt;&lt; 1];int ans[maxn &lt;&lt; 1], vec[maxn &lt;&lt; 1], tot;int n, m;char a[maxn], b[maxn];int main(){ m = readInt(), n = readInt(); scanf(\"%s\", a + 1); scanf(\"%s\", b + 1); FOR(i, 1, m) { g[i] = (a[m - i + 1] == '*') ? 0 : a[m - i + 1] - 'a' + 1; g2[i] = g[i] * g[i], g3[i] = g2[i] * g[i]; } FOR(i, 1, n) { f[i] = (b[i] == '*') ? 0 : b[i] - 'a' + 1; f2[i] = f[i] * f[i], f3[i] = f2[i] * f[i]; } int lim = 1; while (lim &lt;= n + m) lim &lt;&lt;= 1; NTT(f, lim, 1), NTT(f2, lim, 1), NTT(f3, lim, 1); NTT(g, lim, 1), NTT(g2, lim, 1), NTT(g3, lim, 1); FOR(i, 0, lim - 1) ans[i] = (1ll * f3[i] * g[i] % mod + 1ll * f[i] * g3[i] % mod - 2ll * f2[i] * g2[i] % mod) % mod; NTT(ans, lim, 0); int cnt = 0; FOR(i, 1, n - m + 1) if (ans[i + m] == 0) ++cnt, vec[++tot] = i; printf(\"%d\\n\", cnt); FOR(i, 1, tot) printf(\"%d \", vec[i]); return 0;} 另外一道例题 请看 CF528D Fuzzy Search。题意：字符串匹配， 1\\le |T| \\le |S| \\le 2\\times 10^5 ，字符集只有 \\texttt{ATCG} 。 T 在 S 中的第 i 个位置出现当且仅当 \\forall j\\in [1,T] ， \\exists p 使得 |i + j - 1 - p|\\le k \\land S[p] = T[j] 。即偏移量不能超过 k 。 注意到字符集很小，只有 4 个字符，所以我们可以把字符串 01 化，分开考虑每个字母。比如 S = \\texttt{ATCGAA} ， T = \\texttt{ACAA} ，现在只考虑字母 \\texttt A ，把 \\texttt A 化成 1 而其他的化为 0 ，则 S = \\texttt{100011} ， T= \\texttt{1011} 。然后假设 k = 1 ，把能扩展的都往两边扩展，则 S = \\texttt{110111} 。 这个时候，我们就可以设匹配 F(x, c) 表示 T 从 S 的第 x 位开始字符 c 能匹配的数量，最终答案为 A(x) = \\sum_{c\\in\\lbrace\\texttt{A,T,C,G}\\rbrace}F(x,c) ， T 匹配成功当且仅当 A(x) = m ，即所有字符都匹配到了，否则失败。 不难发现 F(x, c) = \\sum_{j = 1}^mS[x + j - 1]T[j] ，老套路翻转一下变为 F(x, c) = \\sum_{j = 1}^m S[x + j - 1]T[m - j + 1] = \\sum_{i + j = x + m}S[i]T[j] 。这就是喜闻乐见的卷积形式了。NTT 直接上就完了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int f[maxn &lt;&lt; 1], g[maxn &lt;&lt; 1];int ans[maxn &lt;&lt; 1];int n, m, k, lim = 1;char s[maxn &lt;&lt; 1], t[maxn &lt;&lt; 1];void proc(char c){ clr(f, lim), clr(g, lim); for (int i = 1, lst = -1e9; i &lt;= n; ++i) { if (s[i] == c) lst = i; if (i - lst &lt;= k) f[i] = 1; } for (int i = n, lst = 1e9; i; --i) { if (s[i] == c) lst = i; if (lst - i &lt;= k) f[i] = 1; } FOR(i, 1, m) g[i] = (t[m - i + 1] == c); NTT(f, lim, 1), NTT(g, lim, 1); FOR(i, 0, lim - 1) f[i] = 1ll * f[i] * g[i] % mod; NTT(f, lim, 0); FOR(i, 1, n) ans[i] += f[i + m];}int main(){ n = readInt(), m = readInt(), k = readInt(); scanf(\"%s\", s + 1); scanf(\"%s\", t + 1); while (lim &lt;= n + m) lim &lt;&lt;= 1; FOR(i, 0, 3) proc(\"ATCG\"[i]); int cnt = 0; FOR(i, 1, n) cnt += (ans[i] == m); printf(\"%d\\n\", cnt); return 0;} 关于封装 以后的全家桶会大量使用 NTT 等基础操作，考虑实现一个常数较小的且方便阅读的封装： 首先是各种 #define。由于我们在进行多项式运算的时候需要考虑界的问题，因此一定要把超过界了的给清零，不然可能出现各种奇奇怪怪的问题比如多卷了之类的： 1234567891011121314#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)#define VEC(i, v) for (int i = 0; i &lt; (int)v.size(); ++i)#define il inline#define ll long long#define ull unsigned long long#define clr(f, n) memset(f, 0, (sizeof(int)) * (n))#define cpy(f, g, n) memcpy(f, g, (sizeof(int)) * (n))#define MOD 998244353 memset 和 memcpy 的用法建议自己去查。 接下来是一些基本的东西，下面我们使用 vector 来实现多项式，这样子的好处是常数不大而且方便好写： 12345678910const int G = 3, mod = MOD, maxn = 1 &lt;&lt; 17 | 500;typedef std::vector&lt;int&gt; Poly;ll qPow(ll a, ll b = mod - 2) { ll ret = 1; for (; b; b &gt;&gt;= 1, a = a * a % mod) if (b &amp; 1) ret = a * ret % mod; return ret;}const int invG = qPow(G); NTT 时需要用到的位逆序置换： 123456789int tr[maxn &lt;&lt; 1], revLim;void getTr(int n) { if (revLim == n) return; revLim = n; FOR(i, 0, n - 1) tr[i] = (tr[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? (n &gt;&gt; 1) : 0);} 这样子可以在需要进行很多次 NTT 的时候智能的求出对应需要的 tr。 NTT：关于 static 关键字相关的建议自己查一下。 1234567891011121314151617181920212223void NTT(int *g, bool op, int n) { getTr(n); static ull f[maxn &lt;&lt; 1], w[maxn &lt;&lt; 1]; w[0] = 1; FOR(i, 0, n - 1) f[i] = (((ll)mod &lt;&lt; 5ll) + g[tr[i]]) % mod; for (int l = 1; l &lt; n; l &lt;&lt;= 1) { ull tG = qPow(op ? G : invG, (mod - 1) / (l &lt;&lt; 1)); FOR(i, 1, l - 1) w[i] = w[i - 1] * tG % mod; for (int k = 0; k &lt; n; k += (l &lt;&lt; 1)) for (int p = 0; p &lt; l; ++p) { int tt = w[p] * f[k | l | p] % mod; f[k | l | p] = f[k | p] + mod - tt; f[k | p] += tt; } if (l == (1 &lt;&lt; 10)) FOR(i, 0, n - 1) f[i] %= mod; } if (!op) { ull invn = qPow(n); FOR(i, 0, n - 1) g[i] = f[i] % mod * invn % mod; } else FOR(i, 0, n - 1) g[i] = f[i] % mod;} 其中有几个需要注意的点。使用 ull 是因为 ull 可以大幅减少需要的取模操作，我们可以在迭代 10 次再取模，减少常数。而第五行则为去掉传进来的 [x^i]g(x) 为负数时可能产生的影响。 然后是 poly 的常见运算，重载了之后会非常方便。 123456789101112131415161718192021222324252627282930313233343536void mul(int *f, int *g, int n) { FOR(i, 0, n - 1) f[i] = 1ll * f[i] * g[i] % mod; return;}Poly operator+(const Poly &amp;A, const Poly &amp;B) { Poly C = A; C.resize(max(A.size(), B.size())); VEC(i, B) C[i] = (C[i] + B[i]) % mod; return C;}Poly operator-(const Poly &amp;A, const Poly &amp;B) { Poly C = A; C.resize(max(A.size(), B.size())); VEC(i, B) C[i] = (C[i] + mod - B[i]) % mod; return C;}Poly operator*(const int c, const Poly &amp;A) { Poly C = A; VEC(i, A) C[i] = 1ll * c * C[i] % mod; return C;}int lim;//代表多项式运算时的界Poly operator*(const Poly &amp;A, const Poly &amp;B) { static int a[maxn &lt;&lt; 1], b[maxn &lt;&lt; 1]; cpy(a, &amp;A[0], A.size()); cpy(b, &amp;B[0], B.size()); Poly C; C.resize(min(lim, (int)(A.size() + B.size() - 1))); int n = 1; for (n = 1; n &lt; (int)(A.size() + B.size() - 1); n &lt;&lt;= 1); NTT(a, 1, n), NTT(b, 1, n); mul(a, b, n), NTT(a, 0, n); cpy(&amp;C[0], a, C.size()); clr(a, n), clr(b, n); return C;} 多项式乘法逆 定义 当两个多项式 F(x) 与 G(x) 在每一项系数模 p 时有 F(x)*G(x)\\equiv 1\\pmod{x^n} 时，称 F(x) 与 G(x) 互为乘法逆元。此处 \\pmod{x^n} 代表次数高于 n 的项都不考虑。 需要的前置知识：NTT。 求法 考虑倍增。假设我们要求满足 F(x)*G(x)\\equiv 1\\pmod{x^k} 的 G(x) ，并且已经求出了满足 F(x)*G'(x)\\equiv1\\pmod{x^{\\lceil\\frac x 2\\rceil}} 的 G‘(x) 。那么我们由 F(x)*G'(x)\\equiv1\\pmod{x^{\\lceil\\frac x 2\\rceil}} 必然可以推出 F(x)*G(x)\\equiv1\\pmod{x^{\\lceil\\frac x 2\\rceil}} 那么 G(x) \\equiv G'(x)\\pmod{x^{\\lceil\\frac x 2\\rceil}} 作差， G(x) - G'(x)\\equiv 0\\pmod{x^{\\lceil\\frac x2\\rceil}} 将两边同时平方，不难发现界会从 \\lceil\\frac n2\\rceil 变为 n 。 G^2(x) - 2G(x)G'(x) + G'^2(x)\\equiv 0\\pmod{x^n} 现在要求的是 G(x) ，而我们发现 G^2(x) 不好处理，怎么办？同时乘以 F(x) 就可以消掉一个 G(x) ： G(x) - 2G'(x) + G'^2(x)F(x)\\equiv 0\\pmod{x^n} 所以我们得到了 G(x)\\equiv 2G'(x) - G'^2(x)F(x)\\pmod{x^n} 根据这个，我们就可以从 G'(x) 推出 G(x) 的值出来了。从上往下递归求解，到常数项的时候直接费马小定理求逆元然后一步步回溯上去。不难发现复杂度为 T(n) = T(n/2) + O(n\\log n) ，由主定理知总复杂度为 O(n\\log n) 。 实现 递归版多项式求逆，套用上面的板子： 12345678910111213141516171819202122void polyInv(const Poly &amp;A, Poly &amp;B, int n) { if (!n) return; if (n == 1) B.push_back(qPow(A[0])); else if (n &amp; 1) { polyInv(A, B, --n); int sav = 0; FOR(i, 0, n - 1) sav = (sav + 1ll * B[i] * A[n - i]) % mod; B.push_back(1ll * sav * qPow(mod - A[0]) % mod); } else { polyInv(A, B, n &gt;&gt; 1); Poly sA; sA.resize(n); cpy(&amp;sA[0], &amp;A[0], n); B = 2 * B - B * B * sA; B.resize(n); } return;}Poly polyInv(const Poly &amp;A) { Poly C; polyInv(A, C, A.size()); return C;} 其中把 n 为奇数的情况进行了特判优化，调用就直接对下面的 polyInv 函数传入一个 vector 即可。 多项式的导数/积分/复合 回顾一下一些基础的导数公式： \\begin{aligned} f(x) = e^x&amp;\\implies f'(x) = e^x\\\\ f(x) = \\ln x&amp;\\implies f'(x) = \\frac1x\\\\ f(x) = ax^k&amp;\\implies f'(x) = akx^{k - 1}\\\\ (f(x)\\pm g(x))'&amp;= f'(x)\\pm g'(x)\\\\ (f(g(x)))' &amp;=f'(g(x))\\times g'(x) \\end{aligned} 我们在这里定义一下多项式的求导： f(x) = \\sum_{i = 0}^na_ix^i\\implies f'(x) = \\sum_{i = 0}^{n - 1}(i + 1)a_{i + 1}x^i 积分为求导的逆运算： f(x) = \\sum_{i = 0}^na_ix_i\\implies\\int f(x) \\mathrm dx= \\sum_{i = 1}^{n + 1}\\frac{a_{i - 1}x^i}{i} 所以多项式求导和求积分的代码就很容易写出来了，当然需要一开始线性预处理一下逆元。 12345678910111213141516171819202122int inv[maxn];void initInv() { inv[1] = 1; FOR(i, 2, lim) inv[i] = 1ll * inv[mod % i] * (mod - mod / i) % mod; return;}Poly deri(const Poly &amp;A) { Poly C = A; for (int i = 1; i &lt; (int)C.size(); ++i) C[i - 1] = 1ll * C[i] * i % mod; if (!C.empty()) C.pop_back(); return C;}Poly ints(const Poly &amp;A) { Poly C = A; for (int i = (int)C.size() - 1; i &gt; 0; --i) C[i] = 1ll * C[i - 1] * inv[i] % mod; if (!C.empty()) C[0] = 0; return C;} 需要非常注意传进来的多项式为空的情况，对空 vector 进行调用 pop_back() 和访问元素会直接 RE，需要注意。 定义多项式的复合： f(g(x)) = \\sum_{i = 0}f_i(g(x))^i 应该比较好理解，直接把 g(x) 代入即可。后面学习牛顿迭代的时候需要用到。 牛顿迭代法 这节内容相当重要，是后面学习开根和 \\exp 的基础，建议掌握好。 牛迭求函数零点 首先各位如果学过旧人教版选修 2-2 的话应该都有看到过牛顿迭代。 牛顿迭代是一种求函数零点的方法。设初始近似值为 x_0 ，则我们有这点的切线方程 y = f'(x_0)(x - x_0) + f(x_0) 令 y = 0 ，得 x = x_0 - \\dfrac{f(x_0)}{f'(x_0)} 。这样子我们就可以一直迭代下去，令 x_0\\leftarrow x ，就可以在很短的时间内很接近地得到 f(x) 的零点。 泰勒展开 简单扯一扯吧，实际上就是使用多项式函数来拟合 \\ln 啊 \\sin 啊这类的函数（因为多项式真的方便啊），其原理就是在要求的函数 f(x) 上找一个点 x_0 ，构造一个多项式 g(x) 使得这个多项式在 x_0 处的 n 阶导数都相等，随着 n 越来越大，拟合的效果就越来越好。 泰勒展开的公式是长这样的： f(x) = \\frac{f(x_0)}{0!}(x - x_0)^0 + \\frac{f'(x_0)}{1!}(x - x_0)^1 + \\frac{f''(x_0)}{2!}(x - x_0)^2 + \\cdots + \\frac{f^{(n)}(x_0)}{n!}(x - x_0)^n + R_n(x) 或者写成 f(x) \\approx \\sum_{i = 0}^n\\frac{f^{(i)}(x_0)}{i!}(x - x_0)^i 其中 f^{(i)}(x_0) 表示 f(x) 在 x_0 处的 i 阶导数。 x_0 = 0 时得到的级数就是麦克劳林级数，下面的东西需要牢记： \\begin{aligned} \\mathrm e^x &amp;= \\sum_{k = 0}^\\infty\\frac{x^k}{k!}\\\\ \\sin x &amp;= x - \\frac{x^3}{3!} + \\frac{x^5}{5!} - \\cdots + (-1)^n\\frac{x^{2n - 1}}{(2n - 1)!} + \\cdots\\\\ &amp;= \\sum_{i = 0}^\\infty(-1)^i\\frac{x^{2i - 1}}{(2i - 1)!}\\\\ \\cos x &amp;= 1 - \\frac{x^2}{2!} + \\frac{x^4}{4!} - \\cdots + (-1)^n\\frac{x^{2n}}{(2n)!}+\\cdots\\\\ &amp;= \\sum_{i = 0}^\\infty(-1)^i\\frac{x^{2i}}{(2i)!}\\\\ \\ln(1 + x) &amp;= \\sum_{i = 1}^\\infty(-1)^{i - 1}\\frac{x^i}{i}\\\\ \\ln(1 - x) &amp;= -\\sum_{i = 1}^\\infty\\frac{x^i}{i} \\end{aligned} 多项式的 \\ln 是如是定义的： \\ln(1 - f(x)) = -\\sum_{i = 1}^{+\\infty}\\frac{f^i(x)}{i}\\\\\\ln(1 + f(x)) = \\sum_{i = 1}^{+\\infty}\\frac{(-1)^{i - 1}f^i(x)}{i} 多项式的 \\exp 则是这样： \\exp f(x) = e^{f(x)}=\\sum_{i = 0}^{+\\infty}\\frac{f^i(x)}{i!} 多项式牛迭 现在要解决的是给定 g(x) ，求满足 g(f(x))\\equiv 0\\pmod{x^n} 的 f(x) （模 x^n 意义下）。 考虑倍增。 当 n = 1 的时候， [x^0]g(f(x)) = 0 的解要单独的算。 假设已经求出了模 x^{\\left\\lceil\\frac n 2\\right\\rceil} 意义下的解 f_0(x) ，要求模 x^n 意义下的 f(x) 。 将 g(f(x)) 在 f_0(x) 处泰勒展开，有： \\sum_{i = 0}^{+\\infty}\\frac{g^{(i)}(f_0(x))}{i!}(f(x) - f_0(x))^i\\equiv 0\\pmod{x^n} 因为 f(x) - f_0(x) 的最低非零项次数最低为 \\left\\lceil\\frac n 2\\right\\rceil ，所以当 i\\ge 2 时有 (f(x) - f_0(x))^i\\equiv 0\\pmod{x^n} 所以泰勒展开的结果为 g(f_0(x)) + g'(f_0(x))(f(x) - f_0(x))\\equiv 0\\pmod{x^n} 化简下来就是 f(x)\\equiv f_0(x) - \\frac{g(f_0(x))}{g'(f_0(x))}\\pmod{x^n} 应用 这个形式可能暂时看不出来有什么用，但是等一下涉及到 \\exp 和多项式开根等操作时其就会发挥大作用。 多项式对指开根 建议先了解清楚高中数学必修 1 中的对数函数/指数函数/幂函数以及一些最基础的微积分知识（基础导数公式，泰勒展开） 多项式 ln 问题描述 给定 A(x) ，求 B(x) 满足 B(x)\\equiv \\ln A(x) \\pmod{x^n} 。 由上文多项式对数的定义，多项式的对数仅在常数项为 1 时才有意义。 求法 不管那么多了，直接求导再积分积回去就可以了： \\begin{aligned} (\\ln A(x))' &amp;= \\frac{A'(x)}{A(x)}\\\\ \\ln A(x) &amp;= \\int \\frac{A'(x)}{A(x)}\\mathrm{d}x \\end{aligned} 均在 \\pmod{x^n} 意义下进行。所以我们只需求导，求逆，乘起来再积个分就可以了。 实现 就一行，超级短。 1234Poly polyLn(const Poly &amp;A) { return ints(deri(A) * polyInv(A));} 洛谷 4725 的实现： 12345678910111213int n;Poly f;int main() { read(n); lim = n; initInv(); f.resize(n); FOR(i, 0, n - 1) read(f[i]); f = polyLn(f); print(f); return output(), 0;} 多项式 exp 问题描述 给定多项式 A(x) ，求 B(x) 满足 B(x)\\equiv \\exp A(x)\\pmod{x^n} 。 **多项式的指数函数仅在常数项为 0 时才有意义，**否则常数项将不收敛。 求法 1 牛顿迭代 考虑使用牛顿迭代。 \\begin{aligned}B(x)&amp;\\equiv \\exp A(x)&amp;\\pmod{x^n}\\\\\\ln B(x) - A(x)&amp;\\equiv 0&amp;\\pmod{x^n}\\\\\\end{aligned} 现在我们把 A(x) 看成一个常数， B(x) 看成一个变量，则我们就是要求这个勾八东西的零点。令 G(B(x)) \\equiv \\ln B(x) - A(x)\\pmod{x^n} ，这个东西求导是 G'(B(x))\\equiv \\dfrac{1}{B(x)} 。 套用一下上面的牛迭式子，假设我们已经搞定了模 x^{\\left\\lceil\\frac n 2\\right\\rceil} 意义下的解 B_0(x) ，要求模 x^n 意义下的 B(x) 。然后就有了 \\begin{aligned}B(x) &amp;\\equiv B_0(x) - \\frac{G(B_0(x))}{G'(B_0(x))}\\\\&amp;\\equiv B_0(x) - (\\ln B_0(x) - A(x))B_0(x)\\\\&amp;\\equiv B_0(x)(1 - \\ln B_0(x) + A(x))\\pmod{x^n}\\end{aligned} 这样子我们就成功的把递推式写出来了。 实现 1 这种递归写起方便的就写递归好一点。 1234567891011121314151617181920212223242526void polyExp(const Poly &amp;A, Poly &amp;B, int n) { if (!n) return; if (n == 1) B.push_back(1); else if (n &amp; 1) { polyExp(A, B, n - 1); n -= 2; int sav = 0; FOR(i, 0, n) sav = (sav + 1ll * (i + 1) * A[i + 1] % mod * B[n - i]) % mod; B.push_back(1ll * sav * inv[n + 1] % mod); } else { polyExp(A, B, n / 2); Poly lnB = B; lnB.resize(n); lnB = polyLn(lnB); VEC(i, lnB) lnB[i] = (mod + A[i] - lnB[i]) % mod; ++lnB[0]; B = B * lnB; B.resize(n); } return;}Poly polyExp(const Poly &amp;f) { Poly ret; polyExp(f, ret, f.size()); return ret;} 但是需要注意的是，这个多项式 \\exp 的常数还是比较大的，需要尽量减少其调用。 求法 2 分治 FFT 分治 FFT 可以在 O(n\\log^2n) 的复杂度下以极优的常数（比一个 \\log 快）求出结果。暂时不想写，咕咕咕。 多项式开根 问题描述 给定一个多项式 A(x) ，求 B(x) 使得 B^2(x)\\equiv A(x)\\pmod{x^n} 求解 考虑使用牛顿迭代，令 f(B(x)) = B^2(x) - A(x)\\pmod{x^n} 。则 f'(B(x)) = 2B(x) ，套牛迭式子： \\begin{aligned}B(x) &amp;\\equiv B_0(x) - \\frac{f(B_0(x))}{f'(B_0(x))}\\\\&amp;\\equiv B_0(x) - \\frac{B_0^2(x) - A(x)}{2B_0(x)}\\\\&amp;\\equiv \\frac{B_0^2(x) + A(x)}{2B_0(x)}\\end{aligned} 时间复杂度 O(n\\log n) 。 注意一下如果常数项不为 0 的话是需要二次剩余来求出答案的常数项的。 实现 1234567891011121314151617void polySqrt(const Poly &amp;A, Poly &amp;B, int m) { if (m == 1) { B.push_back(QuadResidue::cipolla(A[0])); return; } polySqrt(A, B, (m + 1) &gt;&gt; 1); B.resize(m); Poly invB = polyInv(2 * B), sA(A.begin(), A.begin() + m); B = qPow(2) * B + invB * sA; return;}Poly polySqrt(const Poly &amp;A) { Poly C; polySqrt(A, C, A.size()); return C;} 应用 1 多项式快速幂 分两种情况。第一种 [x^0]f(x) = 1 ，此时我们不难发现 \\begin{aligned}g(x) &amp;\\equiv f^k(x)\\\\\\ln g(x) &amp;\\equiv k\\ln f(x)\\\\g(x) &amp;\\equiv \\exp(k\\ln f(x))\\pmod{x^n}\\end{aligned} 然后就一个 \\ln ，乘上 k ，再 \\exp 一下，这题就做完了。 1234567891011121314Poly f;int n, k;char s[maxn];int main() { read(n), read(s); f.resize(lim = n); for (int i = 0; s[i]; ++i) k = (10ll * k + s[i] - '0') % mod; FOR(i, 0, n - 1) read(f[i]); initInv(); f = polyExp(k * polyLn(f)); print(f); return output(), 0;} 第二种情况 [x^0]f(x) \\not= 1 ，此时我们应该做的，就是创造条件强上。 怎么上呢？当 [x^0]f(x)\\not= 0 时，我们就直接： f^k(x)\\equiv \\left(\\frac{f(x)}{[x^0]f(x)} \\right)^k\\times \\left([x^0]f(x)\\right)^k 当 [x^0]f(x) = 0 时，我们就把多项式平移一下，然后强行按上面上，最后平移回去就可以了。 1234567891011121314151617181920212223242526272829303132Poly f;int n, k, k2;char s[maxn];int main() { read(n), read(s); f.resize(n); FOR(i, 0, n - 1) read(f[i]); int p = 0; while (f[p] == 0 &amp;&amp; p &lt; n) ++p; for (int i = 0; s[i]; ++i) { k = (10ll * k + s[i] - '0') % mod; k2 = (10ll * k2 + s[i] - '0') % (mod - 1); if (1ll * k * p &gt; n) { FOR(i, 0, n - 1) putchar('0'), putchar(' '); return output(), 0; } } lim = n = n - p * k, initInv(); int u = qPow(f[p], MOD - 2), v = qPow(f[p], k2); FOR(i, 0, n - 1) f[i] = 1ll * f[i + p] * u % mod; clr(&amp;f[0] + n, p * k); f = v * polyExp(k * polyLn(f)); FOR(i, 0, p * k - 1) putchar('0'), putchar(' '); print(f); return output(), 0;} 应用 2 ln 的组合意义 看例题：洛谷 P4841 [集训队作业2013]城市规划 求 n 个点的有标号无向连通图的个数 \\bmod 1004535809 的值。 可以先不考虑标号，最后得到的答案乘以 n! 就可以了。 然后不考虑联通的话， g_n = 2^{\\binom n 2} ，即考虑每条边选还是不选，设联通的情况的方案数为 f_n 。 构造一下联通的 EGF： F(x) = \\displaystyle\\sum_{i = 0}^\\infty f_i\\frac{x_i}{i!} ，不连通的类似： G(x) = \\displaystyle\\sum_{i = 0}^\\infty g_i\\frac{x^i}{i!} 。根据 EGF 的性质发现 G(x) = \\mathrm e^{F(x)} 。 所以求个 \\ln 就可以了。 配合封装过的 \\ln 是这样的：（upd：下面的代码未更新新的封装，请看准了食用） 1234567891011121314151617181920212223242526272829303132333435void polyln(int *f, int m){ static int invf[maxn &lt;&lt; 1]; int lim = 1; while (lim &lt; m &lt;&lt; 1) lim &lt;&lt;= 1; initinv(lim); cpy(invf, f, m); invpoly(invf, m); derivate(f, m); NTT(f, lim, 1), NTT(invf, lim, 1); FOR(i, 0, lim - 1) f[i] = 1ll * f[i] * invf[i] % mod; NTT(f, lim, 0); intergrate(f, m); clr(invf, lim); clr(f + m, lim - m);}int f[maxn &lt;&lt; 1], invf[maxn &lt;&lt; 1];int fact[maxn &lt;&lt; 1];int n;int main(){ n = readInt(); fact[0] = 1, f[0] = 1; FOR(i, 1, n) fact[i] = 1ll * fact[i - 1] * i % mod, f[i] = 1ll * qpow(2, 1ll * i * (i - 1ll) &gt;&gt; 1) % mod * qpow(fact[i]) % mod; polyln(f, n + 1); printf(\"%d\\n\", 1ll * f[n] * fact[n] % mod); return 0;} 应用 3 配合生成函数推式子 请看 P4389 付公主的背包。 设容量为 i 的物品的个数为 k_i 个，则其生成函数为 A_i(x) = \\left(\\sum_{j = 0}^{+\\infty}x^{ji}\\right)^{k_i} =\\left(\\frac{1}{1 - x^i}\\right)^{k_i} 所以我们要求的就是 f(x) = \\prod_{i = 1}^n A_i(x) 的每项系数。暴力乘起来是 O(nm\\log n) 的，无法通过本题。 我们试一下求个 \\ln ，则我们有 \\begin{aligned} f(x) &amp;= \\prod_{i = 1}^nA_i(x)\\\\ \\ln f(x) &amp;= \\sum_{i = 1}^n\\ln A_i(x)\\\\ \\ln f(x) &amp;= \\sum_{i = 1}^nk_i(\\ln 1 - \\ln(1 - x^i))\\\\ \\ln f(x) &amp;= -\\sum_{i = 1}^nk_i\\ln(1 - x^i) \\end{aligned} 然后我们注意到这个 \\ln 的形式，回顾一下上面讲过的一个式子： \\ln(1 - x) = -\\sum_{m = 1}^{+\\infty}\\frac{x^{m}}{m} 所以 \\begin{aligned} \\ln f(x) &amp;= \\sum_{i = 1}^nk_i\\sum_{j = 1}^{+\\infty}\\frac{x^{ij}}{j} \\end{aligned} 然后问题就转化为了求 \\exp\\left(\\sum_{i = 1}^nk_i\\sum_{j = 1}^{+\\infty}\\frac{x^{ij}}{j} \\right) 里面的东西可以 O(m\\log m) 算，总时间复杂度 O(m\\log m) 。 123456789101112131415161718192021222324int n, m, cnt[maxn];Poly f;int main() { read(n), read(m); f.resize(lim = m + 1); initInv(); FOR(i, 1, n) { int tmp; read(tmp); ++cnt[tmp]; } FOR(i, 1, m) { if (cnt[i]) { for (int j = i; j &lt;= m; j += i) { f[j] += 1ll * cnt[i] * inv[j / i] % mod; if (f[j] &gt; mod) f[j] -= mod; } } } f = polyExp(f); FOR(i, 1, m) print(f[i]), putchar('\\n'); return output(), 0;} 多项式带余除法 问题描述 给定多项式 f(x) 和 g(x) 。求 f(x) 除以 g(x) 的商 Q(x) 和余数 R(x) 。 若令 n = \\deg f ， m = \\deg g ，则要求满足 \\deg Q = n - m ， \\deg R &lt; m 。 问题求解 最关键的问题就是 R(x) ，如果我们能把 R(x) 的影响消去，那么就可以直接求逆来求出 Q(x) 。 令 n = \\deg f ， m = \\deg g 。主要思想是构造 f^R(x) = x^nf\\left(\\frac1x\\right) 然后不难发现这个东西的实质就是反转 f(x) 的系数。 将 f(x) = Q(x)g(x) + R(x) 中的 x 换成 \\dfrac 1x 进行化简： \\begin{aligned}f\\left(\\frac1x\\right) &amp;= Q\\left(\\frac1x\\right)g\\left(\\frac1x\\right) + R\\left(\\frac1x\\right)\\\\x^nf\\left(\\frac1x\\right) &amp;= x^{n - m}Q\\left(\\frac1x\\right)x^mg\\left(\\frac1x\\right) + x^{n - m + 1}x^{m - 1}R\\left(\\frac1x\\right)\\\\f^R(x)&amp;=Q^R(x)g^R(x) + x^{n - m + 1}R^R(x)\\\\f^R(x)&amp;\\equiv Q^R(x)g^R(x)\\pmod{x^{n - m + 1}}\\end{aligned} 所以我们可以用求逆求出 Q(x) ，然后回代就可以求出 R(x) 了。 时间复杂度 O(n\\log n) 。 实现 12345678910void polyDiv(const Poly &amp;A, const Poly &amp;B, Poly &amp;Q, Poly &amp;R) { Poly rA = A, rB = B; reverse(rA), reverse(rB); int n = A.size(), m = B.size(); rA.resize(n - m + 1), rB.resize(n - m + 1); Q = rA * polyInv(rB), Q.resize(n - m + 1), reverse(Q); R = A - B * Q, R.resize(m - 1); return;} 主函数调用： 123456789101112131415int n, m;Poly f, g, R, Q;int main() { read(n), read(m); f.resize(++n), g.resize(++m); lim = n; FOR(i, 0, n - 1) read(f[i]); FOR(i, 0, m - 1) read(g[i]); polyDiv(f, g, Q, R); print(Q); print(R); return output(), 0;} 多项式三角函数/反三角函数 感觉这东西没什么用。。。 多项式三角函数 问题描述 给定多项式 f(x) ，求模 998244353 意义下的 \\sin f(x) 和 \\cos f(x) 。 式子推导 欧拉公式： e^{i\\theta} = \\cos \\theta + i\\sin\\theta 用诱导公式日一通之后可以得到 e^{i(-\\theta)} = \\cos\\theta - i\\sin\\theta 由上面两个式子就可以得到 \\begin{aligned} \\sin\\theta &amp;= \\frac{e^{i\\theta} - e^{-i\\theta}}{2i}\\\\ \\cos\\theta &amp;= \\frac{e^{i\\theta} + e^{-i\\theta}}{2} \\end{aligned} 把 f(x) 带进去： \\begin{aligned} \\sin f(x) &amp;= \\frac{\\exp(if(x)) - \\exp(-if(x))}{2i}\\\\ \\cos f(x) &amp;= \\frac{\\exp(if(x)) + \\exp(-if(x))}{2} \\end{aligned} 现在看来似乎直接 \\exp 就可以做完了，然而 i 是什么东西呢？ 回顾一下在复数域下，我们有 i^2 = -1 。放在 \\mathbb Z_{998244353} 下不就是 i^2\\equiv 998244352\\pmod{998244353} 。取 998244352 的一个二次剩余 86583718 即可。 实现 注意一下我们能尽量少求 \\exp 就少求 \\exp （有 \\exp(-if(x)) = (\\exp(if(x)))^{-1} ），可以很大程度地优化常数 12345678910Poly polySin(const Poly &amp;A) { Poly tmp = polyExp(imgunit * A); return qPow(1ll * 2 * imgunit % mod) * (tmp - polyInv(tmp));}Poly polyCos(const Poly &amp;A) { Poly tmp = polyExp(imgunit * A); return qPow(2) * (tmp + polyInv(tmp));} 超级短。。。 1234567891011int n, type;Poly f;int main() { read(n), read(type); f.resize(lim = n), initInv(); FOR(i, 0, n - 1) read(f[i]); print(type ? polyCos(f) : polySin(f)); return output(), 0;} 多项式反三角函数 问题描述 给定 f(x) ，求模 998244353 意义下的 \\arcsin f(x) ， \\arccos f(x) 和 \\arctan f(x) 。 式子推导 首先需要知道 \\begin{aligned} \\arcsin'x &amp;= \\frac{1}{\\sqrt{1 - x^2}}\\\\ \\arccos'x &amp;= -\\frac{1}{\\sqrt{1 - x^2}}\\\\ \\arctan'x &amp;= \\frac{1}{1 + x^2} \\end{aligned} 然后类似 \\ln ，先求求导后积分我们就可以得到： \\begin{aligned} \\arcsin f(x) &amp;= \\int\\frac{f'(x)}{\\sqrt{1 - f^2(x)}}\\\\ \\arccos f(x) &amp;= -\\int\\frac{f'(x)}{\\sqrt{1 - f^2(x)}}\\\\ \\arctan f(x) &amp;= \\int\\frac{f'(x)}{1 + f^2(x)} \\end{aligned} 实现 12345678910Poly polyAsin(const Poly &amp;A) { Poly one; one.push_back(1); return ints(deri(A) * polyInv(polySqrt(one - A * A)));}Poly polyAtan(const Poly &amp;A) { Poly one; one.push_back(1); return ints(deri(A) * polyInv(one + A * A));} vector 封装的优势得到体现。 拉格朗日插值 问题背景 给出 n 个点 (x_i,y_i) ，令这 n 个点确定的多项式为 L(x) ，求 L(x) 的系数表示。 结论 L(x) = \\sum_{i=1}^n y_il_i(x) 其中每个 l_i(x) 为拉格朗日基本多项式，表达式为 l_i(x) = \\prod_{j=1,j\\ne i}^n\\frac{x-x_j}{x_i-x_j} 其特点是 l_i(x_i)=1 ， \\forall j\\ne i 有 l_i(x_j)=0 。 推导 抛开拉插，这道题明显可以列方程组然后使用高斯消元求解，但是复杂度为 O(n^3) 且精度问题明显，所以拉格朗日是这样考虑的： 对于每个点 P_i(x_i,y_i) ，构造一个 n-1 次多项式 l_i(x) 使其在 x_i 上取值为 1 ，在其余 x_j 上为 0 。构造的结果就是上面的结论： l_i(x) = \\prod_{j=1,j\\ne i}^n\\frac{x-x_j}{x_i-x_j} 不加证明地，上面这个多项式是正确且唯一的。 然后考虑构造答案：很显然对于点 P_i(x_i,y_i) ，只有 l_i(x_i) 的取值为 1 ，其他的都为 0 。所以答案的正确性也是比较显然的：对于 x_i ，只有 y_il_i(x_i) 产生了贡献，其余的都是 0 。故这个多项式是正确的。 所以回到一开始，若我们需要求 f(k) 的值，则我们需要的就是 f(k) = \\sum_{i=1}^n y_i\\prod_{j=1,j\\ne i}^n\\frac{k-x_j}{x_i-x_j} 由于模数是质数，所以使用费马小定理求逆元，跑得飞快。 复杂度 O(n^2) ，求逆元就是个很小的常数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inlinetypedef long long ll;inline ll read(){ char c = getchar(); ll s = 0; bool x = 0; while (!isdigit(c)) x = x | (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}const ll maxn = 2e3 + 5, mod = 998244353;ll x[maxn], y[maxn];ll pow(ll base, ll p){ ll ans = 1; base = (base + mod) % mod; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ans = ans * base % mod; base = base * base % mod; } return ans;}il ll inv(ll n){ return pow(n, mod - 2);}int main(){ ll n = read(), k = read(); for (int i = 1 ; i &lt;= n; ++i) x[i] = read(), y[i] = read(); ll ans = 0; for (int i = 1; i &lt;= n; ++i) { ll prod1 = 1, prod2 = 1; for (int j = 1; j &lt;= n; ++j) { if (i == j) continue; prod1 = prod1 * (k - x[j]) % mod; prod2 = prod2 * (x[i] - x[j]) % mod; } ans = (ans + prod1 * y[i] % mod * inv(prod2) % mod + mod) % mod; } printf(\"%lld\\n\", ans); return 0;} 重心型拉格朗日插值法 上面的做法在需要动态加点/删点的情况下是有弊端的，因为一次加点就需要 O(n^2) 重新计算，这样肯定是不优秀的。 继续推导式子。 \\begin{aligned}f(k) &amp;= \\sum_{i = 1}^nf(x_i)\\prod_{j\\not=i}\\frac{k - x_j}{x_i - x_j}\\\\&amp;=\\sum_{i = 1}^nf(x_i)\\frac{\\prod_{j = 1}^n(k - x_j)}{(k - x_i)\\prod_{j \\not= i}(x_i - x_j)}\\\\&amp;=\\prod_{i = 1}^n(k - x_i)\\sum_{i = 1}^nf(x_i)\\frac{1}{(k - x_i)\\prod_{j \\not= i}(x_i - x_j)}\\end{aligned} 设 w_i = \\dfrac{f(x_i)}{\\prod_{j\\not=i}(x_i - x_j)} ， g = \\displaystyle\\prod_{i = 1}^n(k - x_i) ，则 f(k) = g\\sum_{i = 1}^n\\frac{w_i}{k - x_i} 这个 w_i 称为重心权。每次加点更新的话其复杂度为 O(n\\log n) （更新 O(n) 个 w_i ，求逆 O\\log n ）。这样做就可以快速加点删点。 模板题：LOJ#165. 拉格朗日插值 本题需要特判 k = x_i 的情况。 123456789101112131415161718192021222324252627282930313233343536const int maxn = 3005;modint g = 1, w[maxn], x[maxn], y[maxn];int cnt;void ins(int cnt) { w[cnt] = y[cnt]; FOR(i, 1, cnt - 1) w[i] *= qPow(x[i] - x[cnt], mod - 2), w[cnt] *= qPow(x[cnt] - x[i], mod - 2); return;}modint calc(modint k) { FOR(i, 1, cnt) if (k == x[i]) return y[i]; modint g = 1; FOR(i, 1, cnt) g *= (k - x[i]); modint ret = 0; FOR(i, 1, cnt) ret += w[i] * qPow(k - x[i], mod - 2); return ret * g;}int main() { int n; read(n); while (n--) { int op; read(op); if (op == 1) { read(x[++cnt]), read(y[cnt]); ins(cnt); } else { int x; read(x); print(calc(x)); putchar('\\n'); } } return output(), 0;} 正整数的 k 次方之和 问题描述 CF622F 题意：给定 n,k （ 1\\le n\\le 10^9,0\\le k\\le 10^6 ），求 \\sum_{i = 1}^ni^k = 1^k + 2^k + 3^k +\\cdots + n^k 模 10^9 + 7 的值。 题解 下面的证明会讲到，这个东西可以看作以 n 为变量的 k + 1 次多项式。 而我们很容易就可以在 O(k\\log k) 的时间内求出求出 f(1),f(2),\\cdots,f(k+ 1) ，我们需要求的是 f(n) ，故考虑拉格朗日插值，得出如下公式 f(n) = \\sum_{i = 1}^{k + 2}f(i)\\prod_{j\\neq i}\\frac{n - j}{i - j} 如果朴素地做的话，复杂度显然是 O(k^2) 的，但是注意到我们用于取点值的数都是连续的，所以 \\prod 这一堆是可以 O(n) 预处理然后 O(1) 求的。怎么预处理呢？我们考虑把他打开看看规律 \\begin{aligned} \\prod_{j = 1,j\\neq i}^{k + 2}\\frac{n - j}{i - j} &amp;= \\frac{(n - 1)(n - 2)\\cdots(n - j + 1)(n - j - 1)\\cdots(n - k - 1)(n - k - 2)}{(i - 1)(i - 2)\\cdots(i - j + 1)(i - j - 1)\\cdots(i - k - 2)}\\\\ &amp;=\\frac{\\prod_{j = 1}^{i - 1}(n - j)\\times\\prod_{j = i + 1}^{k + 2}(n - j)}{(-1)^{k -i}\\times i!\\times (k + 2 - i)!} \\end{aligned} 所以维护一下 (n - j) 的前/后缀积和 [1, k + 1] 的阶乘逆元，这道题就可以在 O(k\\log k) 的时间内做出来了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef long long ll;const ll mod = 1e9 + 7;const int maxn = 1e6 + 5;ll n, k;ll fac[maxn], pre[maxn], suf[maxn];ll qpow(ll base, ll p = mod - 2){ ll ret = 1; for (; p; p &gt;&gt;= 1, base = base * base % mod) if (p &amp; 1) ret = ret * base % mod; return ret;}int main(){ scanf(\"%lld %lld\", &amp;n, &amp;k); if (!k) { printf(\"%lld\\n\", n); return 0; } ll ans = 0, y = 0; pre[0] = 1, fac[0] = 1; FOR(i, 1, k + 2) pre[i] = pre[i - 1] * (n - i) % mod, fac[i] = fac[i - 1] * i % mod; suf[k + 3] = 1; DEC(i, k + 2, 0) suf[i] = suf[i + 1] * (n - i) % mod; FOR(i, 1, k + 2) { y = (y + qpow(i, k)) % mod; ll tmp = y * pre[i - 1] % mod * suf[i + 1] % mod * (((k - i) &amp; 1) ? -1 : 1) * qpow(fac[i - 1] * fac[k + 2 - i] % mod) % mod; ans = (ans + tmp + mod) % mod; } printf(\"%lld\\n\", ans); return 0;} 证明 这里的证明使用差分（参考数竞小蓝本数列那一册）。 定义多项式 f(x) 的一阶差分为 \\Delta f(x) = f(x + 1) - f(x) ，把得到的多项式再作次差分得到 f(x) 的二阶差分 \\begin{aligned} \\Delta^2f(x) &amp;= \\Delta (\\Delta f(x))\\\\ &amp;= \\Delta (f(x + 1) - f(x))\\\\ &amp;= (f(x + 2) - f(x + 1)) - (f(x + 1) - f(x))\\\\ &amp;= f(x + 2) - 2f(x + 1) + f(x) \\end{aligned} 类似的可以定义 p 阶差分，即 \\Delta^p f(x) = \\Delta(\\Delta^{p - 1}f(x)) 。类似的我们对数列也是可以进行差分操作的。如果一个数列的 p 阶差分为一个非零常数列，则称其为 p 阶等差数列。 定理： 数列 \\lbrace a_n\\rbrace 为 p 阶等差数列的充要条件是其通项公式为 n 的一个 p 次多项式。 证明： 已知数列 \\lbrace a_n\\rbrace 为 p 阶等差数列，设数列 \\lbrace a_n\\rbrace 的通项为一个关于 n 的 v 次多项式，即 f(n) = \\sum_{i = 0}^vu_ix^i 。 令 \\lbrace a_n\\rbrace 的差分为 \\lbrace b_n\\rbrace ，则 \\lbrace b_n\\rbrace 的通项公式为 \\begin{aligned} \\Delta f(x) &amp;= f(x + 1) - f(x)\\\\ &amp;= \\sum_{i = 0}^v u_i(x + 1)^i - \\sum_{i = 0}^vu_ix_i \\end{aligned} 打开后我们发现 x^v 的系数变为了 0 ，说明差分之后通项公式的次数减了 1 ，从其 p 阶差分为一个非零常数列可反推知其通项公式的次数为 p 。 回到本题，定义出数列 \\lbrace a_n\\rbrace = \\sum_{i = 1}^1i^k, \\sum_{i = 1}^2i^k,\\cdots,\\sum_{i = 1}^ni^k 对这个数列作差分可以得到 1^k,2^k,3^k,\\cdots, n^k ，发现其通项公式为 f(n) = n^k ，所以原数列的通项就是关于 n 的一个 k + 1 次多项式。 多项式多点求值 前置知识：多项式带余除法、简单的分治思想。 问题描述 给定一个多项式和 m 个点 \\{a_1,\\cdots, a_m\\} ，要求分别求出 f(a_1),f(a_2),\\cdots, f(a_m) 。 问题求解 核心思想是构造 + 分治。 考虑现在正在处理子问题 \\{a_1, a_2, \\cdots, a_m\\} 将其分为两个部分 \\{a_1, a_2,\\cdots, a_{\\left\\lfloor\\frac m2\\right\\rfloor}\\}\\quad \\{a_{\\left\\lfloor\\frac m2\\right\\rfloor + 1}, \\cdots, a_m\\} 然后构造两个多项式 g_0(x) = \\prod_{i = 1}^{\\lfloor\\frac m2\\rfloor}(x - a_i)\\\\g_1(x) = \\prod_{i = \\lfloor\\frac m2\\rfloor + 1}^m(x - a_i) 然后我们令 f(x) = g_0(x)Q(x) + f_0(x) ，则显然有 \\forall i\\in[1, \\lfloor\\frac m2\\rfloor] ，一定有 g_0(a_i) = 0 。所以有 f(x)\\equiv f_0(x)\\pmod {g_0(x)} 。这就是一个多项式取模的事情。对于右边则同理。 这样子我们就成功将问题的规模减半。时间复杂度 O(n\\log^2n) 。 实现 一开始就需要求出所有的 g(x) ，这个过程类似于线段树，是 O(n\\log^2n) 的。然后每一层也要给他个多项式取模。 然后鉴于多项式取模的巨大常数，当区间比较小的时候可以考虑直接暴算，优化常数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((l + r) &gt;&gt; 1)Poly g[maxn &lt;&lt; 2], Q;void initG(int k, int l, int r, int *a) { if (l == r) { g[k].push_back(a[l] ? mod - a[l] : 0); g[k].push_back(1); return; } initG(L, l, M, a); initG(R, M + 1, r, a); g[k] = g[L] * g[R]; return;}void work(int k, int l, int r, Poly A, int *a, int *ans) { if (r - l + 1 &lt; 100) { FOR(i, l, r) { int s = 0; DEC(j, A.size() - 1, 0) s = (1ll * s * a[i] % mod + A[j]) % mod; ans[i] = s; } return; } Poly B; polyDiv(A, g[L], Q, B); work(L, l, M, B, a, ans); polyDiv(A, g[R], Q, B); work(R, M + 1, r, B, a, ans); return;}void evaluate(Poly f, int m, int *a, int *ans) { initG(1, 1, m, a); work(1, 1, m, f, a, ans); return;}#undef L#undef R#undef M 多项式快速插值 前置知识：多点求值，洛必达法则 问题描述 给定 n 个点 (x_i, y_i) ，求出经过这 n 个点的 n - 1 次多项式。 问题求解 回顾一下拉格朗日插值公式： F(x) = \\sum_{i = 1}^n y_i\\prod_{j \\not=i}\\frac{x - x_j}{x_i - x_j} 先把后面的分母提到前面来： F(x) = \\sum_{i = 1}^n\\frac{y_i}{\\prod_{j\\not=i}(x_i - x_j)}\\prod_{j \\not= i}(x - x_j) 首先发现 \\dfrac{y_i}{\\prod_{j\\not=i}(x_i - x_j)} ，考虑先计算这个常数。令 \\delta(x) = \\displaystyle\\prod_{j = 1}^n(x - x_j) ，这个东西可以分治 O(n\\log^2 n) 求。然后看 y_i 的分母： \\prod_{j\\not= i}(x_i - x_j) = \\lim_{x\\to x_i}\\frac{\\delta(x)}{x - x_i} 这个东西就是导数的定义式，不难发现 \\lim_{x\\to x_i}\\frac{\\delta(x)}{x - x_i} = \\delta'(x_i) 求出 \\delta(x) 之后求个导再写个多点求值就可以搞定了。 然后问题就化简到了 F(x) = \\sum_{i = 1}^n\\frac{y_i}{\\delta'(x_i)}\\prod_{j\\not=i}(x - x_j) 还是用分治大法。设 \\displaystyle F_{l, r}(x) = \\sum_{i = l}^r\\frac{y_i}{\\delta'(x_i)}\\prod_{j\\not=i}(x - x_j) ， \\delta_{l,r}(x) = \\displaystyle\\prod_{j = l}^r(x - x_j) ， m = \\left\\lfloor\\dfrac {i+ j}2\\right\\rfloor ，开始化简： \\begin{aligned}F_{l, r}(x) &amp;= \\sum_{i = l}^r\\frac{y_i}{\\delta'(x_i)}\\prod_{j\\not=i}(x - x_j)\\\\&amp;=\\sum_{i = l}^m\\frac{y_i}{\\delta'(x_i)}\\prod_{j = l, j\\not=i}^m(x - x_j)\\prod_{j = m + 1, j\\not= i}^r(x - x_j) + \\sum_{i = m + 1}^r\\frac{y_i}{\\delta'(x_i)}\\prod_{j = l, j\\not=i}^m(x - x_j)\\prod_{j = m + 1, j\\not= i}^r(x - x_j)\\\\&amp;=F_{l,m}(x)\\delta_{m + 1, r}(x) + F_{m + 1, r}(x)\\delta_{l, m}(x)\\end{aligned} 边界肯定就是 l = r 的时候 F_{l,l}(x) = \\dfrac{y_l}{\\delta'(x_l)} 。总复杂度 O(n\\log^2n) 。 实现 配合上面的封装，其实不难写。 12345678910111213141516171819202122232425262728Poly delta[maxn &lt;&lt; 2], ddelta;int dval[maxn];void initDelta(int k, int l, int r, int *x) { if (l == r) { delta[k].push_back(x[l] ? mod - x[l] : 0); delta[k].push_back(1); return; } initDelta(L, l, M, x); initDelta(R, M + 1, r, x); delta[k] = delta[L] * delta[R]; return;}Poly interpolation(int k, int l, int r, int *x, int *y) { if (l == r) return Poly(1, 1ll * y[l] * qPow(dval[l]) % mod); return interpolation(L, l, M, x, y) * delta[R] + interpolation(R, M + 1, r, x, y) * delta[L];}Poly interpolation(int n, int *x, int *y) { initDelta(1, 1, n, x); ddelta = deri(delta[1]); evaluate(ddelta, n, x, dval); return interpolation(1, 1, n, x, y);}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"FFT","slug":"FFT","permalink":"https://old.blog.imyangty.com/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"容斥原理","slug":"inclusion-exclusion-principle","permalink":"https://old.blog.imyangty.com/tags/inclusion-exclusion-principle/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"拉格朗日插值","slug":"lagrange-interpolation","permalink":"https://old.blog.imyangty.com/tags/lagrange-interpolation/"}]},{"title":"NOIP2020 题解","slug":"sol-noip2020","date":"2021-03-09T11:25:17.000Z","updated":"2022-03-23T04:18:31.065Z","comments":true,"path":"sol-noip2020/","link":"","permalink":"https://old.blog.imyangty.com/sol-noip2020/","excerpt":"","text":"T1 排水系统 不想说什么，拓扑排序即可。 Implementation 实现的时候注意一下，可以直接将所有的分数以 60^{11} 为分母进行运算，然后需要用两个 long long 来实现一个 Bigint 类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cctype&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)#define DEC(i, a, b) for (int i = (a); i &gt;= (b); --i)namespace fastIO {const int maxc = 1 &lt;&lt; 23;char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;il char getchar() {return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}template&lt;typename T&gt; void read(T &amp;n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n;}} // namespace fastIOusing namespace fastIO;typedef long long ll;struct Bigint { static const ll base = 1e15; ll upper, lower; Bigint(ll u, ll l) : upper(u), lower(l) {} il friend Bigint operator+(const Bigint &amp;lhs, const Bigint &amp;rhs) { return Bigint(lhs.upper + rhs.upper + (lhs.lower + rhs.lower) / base, (lhs.lower + rhs.lower) % base); } il friend Bigint operator*(const Bigint &amp;lhs, const ll &amp;rhs) { return Bigint(lhs.upper * rhs + lhs.lower * rhs / base, lhs.lower * rhs % base); } il friend Bigint operator/(const Bigint &amp;lhs, const ll &amp;rhs) { return Bigint(lhs.upper / rhs, (lhs.lower + lhs.upper % rhs * base) / rhs); } il friend ll operator%(const Bigint &amp;lhs, const ll &amp;rhs) { return (lhs.upper % rhs * base + lhs.lower) % rhs; } il void print() { if (upper) printf(\"%lld%015lld\", upper, lower); else printf(\"%lld\", lower); }};const int maxn = 1e5 + 5, maxm = 5 * maxn;const int prime[] = {2, 3, 5};int head[maxn], to[maxm], nxt[maxm], n, m, cnte;int oud[maxn], ind[maxn];il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}struct Frac { Bigint upper, lower; Frac(Bigint x = Bigint(0, 0), Bigint y = Bigint(0, 1)) : upper(x), lower(y) {} il friend Frac operator+(const Frac &amp;lhs, const Frac &amp;rhs) { return Frac(lhs.upper + rhs.upper, lhs.lower); } il friend Frac operator/(const Frac &amp;lhs, const ll &amp;rhs) { return Frac(lhs.upper / rhs, lhs.lower); }} f[maxn];int q[maxn], qhead = 1, qtail = 0;int main() { Bigint base(0, 1); FOR(i, 1, 11) base = base * 60; read(n), read(m); FOR(i, 1, n) { read(oud[i]); FOR(j, 1, oud[i]) { int to; read(to); add(i, to), ++ind[to]; } f[i] = Frac(Bigint(0, 0), base); } FOR(i, 1, m) q[++qtail] = i, f[i].upper = base; while (qhead &lt;= qtail) { int u = q[qhead++]; Frac add; if (oud[u]) add = f[u] / oud[u]; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; f[v] = f[v] + add; if (!--ind[v]) q[++qtail] = v; } } FOR(i, 1, n) { if (!oud[i]) { FOR(j, 0, 2) while (f[i].upper % prime[j] == 0 &amp;&amp; f[i].lower % prime[j] == 0) f[i].upper = f[i].upper / prime[j], f[i].lower = f[i].lower / prime[j]; f[i].upper.print(), putchar(' '), f[i].lower.print(), putchar('\\n'); } } return 0;} T2 字符串匹配 Description 令 A^i 为 i 个 A 拼接而成的字符串。令 A ， B ， C 为非空字符串，求 S = (AB)^kC 的方案数。其中 F(A)\\le F(C) ， F(A) 意为 A 中出现次数为奇数的字符数量。 Solution 直接说 O(n) 做法。字符串下标从 1 开始。 考虑枚举 AB 的长度 i ，则这个循环前缀的长度为 ik 。现在的第一个问题是不知道有多少个合法的 k 。 注意到一个长度为 n 的字符串 S 有长度为 m 的循环节的充要条件是 S_{[1, n - m]} = S_{[m + 1, n]} （这是 KMP 相关题目的经典套路）。体现在本题中就是 S_{[1, (k - 1)i]} = S_{i + 1, ki} 。即从 i + 1 开始长度为 (k - 1)i 的子串与长度为 (k - 1)i 的前缀相同。 S_{[i +1, ki]} 其实即为后缀 i + 1 的前缀。考虑 Z 算法。则如果有 (k - 1)i\\le Z_{i + 1} ，即这个前缀的长度不大于 Z_{i+ 1} ，则根据 Z 的定义，有 S_{[1, (k - 1)i]} = S_{i + 1, ki} 。 于是对于一个长度为 i 的 AB ，有 \\dfrac{Z_{i + 1}}{i} + 1 个合法的 k 的取值。当然由于 C 要非空，所以 Z_{i + 1} 要与 n - i - 1 取 \\min 。至此，合法的 k 的个数得到了解决。下面的问题就是 F(A)\\le F(C) 的限定。 现在我们考虑 F(C) 。很明显，其为整串除掉了长度为 ik 的前缀之后得到的后缀。现在分 k 的奇偶性讨论。 k 为奇数时，不难发现 F(C) = F(\\mathrm{suf}(i + 1)) ，因为从第二个重复的 AB 一直到第 k 个 AB 是不产生贡献的。这样的 C 一共有 \\left\\lceil\\dfrac{\\frac{Z_{i + 1}}{i} + 1}{2}\\right\\rceil 个。 k 为偶数时，不难发现 F(C) = F(S) ，因为 F((AB)^k) 必然为 0 。这样的 C 有 \\left\\lfloor\\dfrac{\\frac{Z_{i + 1}}{i} + 1}{2}\\right\\rfloor 个。 接下来考虑合法的 A 。其实 A 也就是一个长度小于 i 的前缀。所以大力分类一波： k 为奇数时合法的 A 的数量即为 1\\le j&lt; i 使得 F(\\mathrm{pre}(j))\\le F(\\mathrm{suf}(i + 1)) 的 j 的个数。 k 为偶数时合法的 A 的数量即为 1\\le j &lt; i 使得 F(\\mathrm{pre}(j))\\le F(S) 的 j 的个数。 分别用乘法原理合并即可。然后至于上面提到的 j ，可以预先处理出所有的 F(\\mathrm{suf}(j)) ，然后边枚举 i 就边计算 F(\\mathrm{pre}(j)) 了。 Implementation 对于查询 k 为奇数时合法的 A 的数量，这里使用树状数组以减少编写难度。树状数组带来的常数很小，可以忽略不计。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstring&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)#define clr(a) memset(a, 0, sizeof a)const int maxn = (1 &lt;&lt; 20) + 5;typedef long long ll;char s[maxn];int z[maxn], n, fsuf[maxn], buc[26];inline int min(int a, int b) {return a &lt; b ? a : b;}#define lowbit(x) (x &amp; -x)int t[27];void add(int x){ for (; x &lt;= 26; x += lowbit(x)) ++t[x]; return;}int query(int x){ int ret = 0; for (; x; x -= lowbit(x)) ret += t[x]; return ret;}int main(){ int T; scanf(\"%d\", &amp;T); while (T--) { scanf(\"%s\", s + 1); n = strlen(s + 1); clr(z), clr(fsuf), clr(buc); z[1] = n; for (int i = 2, l = 0, r = 0; i &lt;= n; ++i) { if (i &lt;= r) z[i] = min(z[i - l + 1], r - i + 1); while (i + z[i] &lt;= n &amp;&amp; s[i + z[i]] == s[z[i] + 1]) ++z[i]; if (i + z[i] - 1 &gt; r) l = i, r = i + z[i] - 1; } //计算 z 数组 DEC(i, n, 1) { ++buc[s[i] - 'a']; if (buc[s[i] - 'a'] &amp; 1) fsuf[i] = fsuf[i + 1] + 1; else fsuf[i] = fsuf[i + 1] - 1; } //处理出所有后缀的 F 值 clr(buc), clr(t); int f = 0;//当前前缀的 f 值 ll ans = 0; FOR(i, 1, n - 1) { ++buc[s[i] - 'a']; f += ((buc[s[i] - 'a'] &amp; 1) ? 1 : -1); int totk = min(z[i + 1], n - i - 1) / i + 1; int tot0 = totk &gt;&gt; 1, tot1 = (totk + 1) &gt;&gt; 1;//k 为偶数/奇数的数量 ans += 1ll * tot0 * query(fsuf[1] + 1) + 1ll * tot1 * query(fsuf[i + 1] + 1); add(f + 1); //树状数组传进去的要全部加 1 是因为会有 0 的贡献 } printf(\"%lld\\n\", ans); } return 0;} T3 移球游戏 NOIP 考了构造/jk。今天补题。第一次做这种难度的构造题？ Description n + 1 个柱子上 n 个柱子有打乱排的 n 种颜色的球，每个柱子上面有 m 个，构造出一种步数在 820000 内的方案使得每个柱子上颜色相同。 每次操作只能为拿某柱子最顶端的一个球放到另一个柱子的最顶端，并且始终保持一个柱子上球个数不超过 m 法一 T4 微信步数 我都不敢相信这是 NOIP 题。。。 Description k 维空间的场地，第 i 维坐标限制在 [1, w_i] 中。某人跑步，在接下来的 \\prod w_i 天中每天从一个不同坐标出发，按照如下规则跑步： 一共 n 步，每步用 (c_i, d_i) 描述，表示在第 c_i 维移动 d_i （ d_i\\in\\{-1, 1\\} ），重复如上路线直到走出场地。 问这些天内走了多少步，答案对 10^9 + 7 取模，若存在某一天会在场内循环，输出 -1 。 1\\le n\\le 5\\times 10^5 ， 1\\le k\\le 10 ， 1\\le w_i\\le 10^9 ， d_i\\in\\{-1, 1\\} 。 Solution","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"拓扑排序","slug":"toposort","permalink":"https://old.blog.imyangty.com/tags/toposort/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"高精度","slug":"bigint","permalink":"https://old.blog.imyangty.com/tags/bigint/"},{"name":"Z算法","slug":"z-algo","permalink":"https://old.blog.imyangty.com/tags/z-algo/"}]},{"title":"CF1493D GCD of an Array","slug":"sol-cf1493d","date":"2021-03-06T17:16:04.000Z","updated":"2022-03-23T06:40:10.521Z","comments":true,"path":"sol-cf1493d/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1493d/","excerpt":"","text":"题意 给定 n 个数 a_{1\\cdots n} ，进行 q 次单点乘法操作，满足 1\\le n,q,a_i\\le 2\\times 10^5 ，求每次操作完后 \\displaystyle\\gcd_{i = 1}^na_i\\bmod (10^9 + 7) 。 题解 讲讲我的考场思路。 我们知道 gcd 实际上就是所有的质因子取最小次数再乘起来，想到这里就很自然的去维护所有的质因子的次数。 对每种出现的质因子用一个数据结构来维护其次数，支持单点修改和最值查询，我这里使用的是动态开点线段树（避免普通线段树的空间浪费）（当然其他支持删除并求最值的数据结构也是可以的比如可删堆，std::map 等等），因为 2\\times 10^5 中素数的个数约为 \\dfrac{n}{\\ln n}\\approx 20113 个，而一个 a_i 中最多有 7 个互异质因子，所以大概估计一下发现不会炸。 然后就很简单了。一开始输入数列的时候直接把质因子 p_j 对应的线段树在位置 i 上加上对应的次数 k 即可，注意这个线段树维护的是最小值（因为这样就可以方便的求 gcd），不难发现 gcd 中这个质因子贡献的值为 p_j^{\\min\\lbrace k\\rbrace} ，即树根的值。 维护 gcd 的时候乘上 p_j^{k_0} 的逆元以先消掉质因子 p_j 产生的贡献，修改完了再把 p_j^{k_0'} 乘回去就可以了。 根据上述过程知复杂度为 O(n\\log^2n) ，可以通过本题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;set&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x = (c == '-'), c = getchar(); while (isdigit(c)) s = s * 10 + c - '0', c = getchar(); return x ? -s : s;}typedef long long ll;inline int min(int a, int b) {return a &lt; b ? a : b;}const int maxn = 2e5 + 5, mod = 1e9 + 7;int a[maxn], n, q;int p[maxn], isp[maxn], tot, minfact[maxn];ll qpow(ll base, ll p = mod - 2){ ll ret = 1; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ret = ret * base % mod; base = base * base % mod; } return ret;}void make_prime(){ FOR(i, 2, maxn - 2) { if (!isp[i]) p[++tot] = i, minfact[i] = tot; for (int j = 1; i * p[j] &lt; maxn; ++j) { isp[i * p[j]] = 1; minfact[i * p[j]] = j;//维护一个数的最小质因子以再在分解时避免遍历无用的质数 if (i % p[j] == 0) break; } } return;}const int maxp = 2e7 + 5;//空间往不会炸的卡是绝对没错的int cnt, lson[maxp], rson[maxp], val[maxp];//动态开点线段树int root[maxn];void modify(int &amp;now, int l, int r, int x, int add){ if (!now) now = ++cnt; if (l == r) { val[now] += add; return; } int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) modify(lson[now], l, mid, x, add); else modify(rson[now], mid + 1, r, x, add); val[now] = min(val[lson[now]], val[rson[now]]); return;}int main(){ make_prime(); n = read(), q = read(); ll gcd = 1; FOR(i, 1, n) { int tmp = read(); for (int j = minfact[tmp]; tmp &gt; 1;)//j 的初始值要是最小质因子，避免无谓的循环 { int k = 0; while (tmp &gt; 1 &amp;&amp; tmp % p[j] == 0) ++k, tmp /= p[j]; gcd = gcd * qpow(qpow(p[j], val[root[j]])) % mod;//首先 gcd 删除 p[j] 的贡献 modify(root[j], 1, n, i, k); gcd = gcd * qpow(p[j], val[root[j]]) % mod;//然后把贡献乘回去 if (tmp &gt; 1) j = minfact[tmp];//如果不这么写是会 FST 的 } } while (q--) { int x = read(), v = read(); for (int j = minfact[v]; v &gt; 1;) { while (v &gt; 1 &amp;&amp; v % p[j]) ++j; int k = 0; while (v &gt; 1 &amp;&amp; v % p[j] == 0) ++k, v /= p[j]; gcd = gcd * qpow(qpow(p[j], val[root[j]])) % mod; modify(root[j], 1, n, x, k); gcd = gcd * qpow(p[j], val[root[j]]) % mod; if (v &gt; 1) j = minfact[v]; } printf(\"%lld\\n\", gcd); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"}]},{"title":"BZOJ1009/洛谷P3193 [HNOI2008]GT考试","slug":"sol-luogu-p3193","date":"2021-03-06T13:59:58.000Z","updated":"2022-03-23T04:18:30.933Z","comments":true,"path":"sol-luogu-p3193/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3193/","excerpt":"","text":"题意 求构造出长度为 n 的满足不出现 A 的字符串的方案数。字符集为数字， A\\le 20 ， n\\le 10^9 思路 考虑 dp。 定义状态 f_{i,j} 表示构造到第 i 位，匹配到 A 的第 j 位的方案数。不难发现答案即为 \\displaystyle\\sum_{j = 1}^{m - 1} f_{n, j} 。我们可以列出如下的转移方程： f_{i,j} = \\sum_{0\\le k\\le 9 }f_{i - 1, p} 其中这个 p 比较离谱，我们需要不断跳 fail 来找到这个 p 。 乍一看这个式子貌似不太好优化的样子，我们换一种思路：考虑 [1, j - 1] 匹配之后怎么匹配到 j ： f_{i, j} = \\sum_{k = 1}^{m - 1}f_{i - 1, k} \\times g_{k, j} 这个式子的意思就是：假设前 i - 1 位的后缀为 A_{1\\cdots k} ，考虑有多少种加数字的方法可以使匹配了的 A_{1\\cdots k} 变成 A_{1\\cdots j} ，方法数即为 g_{k,j} 。注意到一定有 k &gt; j ，即 A_{1\\cdots j} 为 A_{1\\cdots k} + n 的后缀，其中 n 为加上的数。 那么这个 g 怎么求呢？我们可以在每一位 i 枚举添加的数 j ，然后跳 fail 直到找到合法的位置 p ，让 g_{i,p} 加一即可。 123456789101112for (int i = 0; i &lt; m; ++i){ for (int j = '0'; j &lt;= '9'; ++j) { int p = i; while (p &amp;&amp; s[p + 1] != j) p = fail[p]; if (s[p + 1] == j) ++p; ++g.a[i][p]; }} 接下来我们把所有的 f_{i,j} 看成一个列向量 F_i ，我们只需要每次 F_{i} = F_{i - 1}\\times G 就可以了。 F_{0,0} = 0 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxm = 25;int n, m, mod, fail[maxm];char s[maxm];struct matrix{ int a[maxm][maxm]; matrix() { memset(a, 0, sizeof a); } matrix operator*(matrix &amp;b) { matrix ret; for (int i = 0; i &lt; m; ++i) for (int j = 0; j &lt; m; ++j) for (int k = 0; k &lt; m; ++k) ret.a[i][j] = (ret.a[i][j] + this-&gt;a[i][k] * b.a[k][j]) % mod; return ret; }};matrix pow(matrix a, int p){ matrix ret; for (int i = 0; i &lt;= m; ++i) ret.a[i][i] = 1; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ret = ret * a; a = a * a; } return ret;}int main(){ scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;mod); scanf(\"%s\", s + 1); matrix f, g; f.a[0][0] = 1; for (int i = 2, j = 0; i &lt;= m; ++i) { while (j &amp;&amp; s[j + 1] != s[i]) j = fail[j]; if (s[j + 1] == s[i]) ++j; fail[i] = j; } for (int i = 0; i &lt; m; ++i) { for (int j = '0'; j &lt;= '9'; ++j) { int p = i; while (p &amp;&amp; s[p + 1] != j) p = fail[p]; if (s[p + 1] == j) ++p; ++g.a[i][p]; } } f = f * (g = pow(g, n)); int ans = 0; for (int i = 0; i &lt; m; ++i) (ans += f.a[0][i]) %= mod; printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"字符串","slug":"string","permalink":"https://old.blog.imyangty.com/tags/string/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"KMP","slug":"KMP","permalink":"https://old.blog.imyangty.com/tags/KMP/"}]},{"title":"2021年3月 OI学习记录","slug":"summary-2021-03","date":"2021-03-01T14:33:25.000Z","updated":"2022-03-23T04:19:24.322Z","comments":true,"path":"summary-2021-03/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-03/","excerpt":"","text":"前言 联合省选 rp++ 不想开学/kk 学习内容 分数规划 整体二分 cdq 分治 Matrix-Tree 定理 Borůvka 算法 长链剖分 dsu on tree 点分治 做题记录 21/03/01 CF126B Password KMP 算法的理解问题，找到 \\max_{1\\le i\\lt n}fail_i ，然后判定哪个最长的 Border 能作为答案即可。 21/03/02 P3435 [POI2006]OKR-Periods of Words 涉及到 KMP 的理解。需要求出每个前缀的最小 Border——直接跳 fail 跳到 fail = 0 即可，但是不能暴跳，需要记忆化递推。 P3538 [POI2012]OKR-A Horrible Poem 字符串哈希判循环串模板。考虑枚举循环节的长度（分解质因数），然后通过哈希实现判定 P4503 [CTSC2014]企鹅QQ 哈希，枚举每一位判定即可，通过 sort 加速判断。 P1659 [国家集训队]拉拉队排练 manacher 求奇数长度回文串，需要前缀和一下而且还要快速幂 21/03/03 LOJ#149. 01 分数规划 01 分数规划裸题，二分答案 P1404 平均数 01 分数规划 P4377 [USACO18OPEN]Talent Show G 01 分数规划套了个背包而已 UVA11475 Extend to Palindrome 求一个最长回文后缀即可 21/03/04 P4824 [USACO15FEB]Censoring S KMP + 栈 21/03/05 P3121 [USACO15FEB]Censoring G 上题的 AC 自动机版本 21/03/06 CF526D Om Nom and Necklace KMP 循环节 P3193 [HNOI2008]GT考试 KMP + 矩阵快速幂加速 dp Codeforces Round #705 (Div. 2) A + B + D rk1057 21/03/07 U155026 给给 紫书题变种 P4986 逃离 牛顿迭代法 21/03/09 P7115 [NOIP2020] 移球游戏 构造 CF622F The Sum of the k-th Powers 拉格朗日插值 21/03/10 P2055 [ZJOI2009]假期的宿舍 最大流 Codeforces Round #706 (Div. 2) A + B+ C 21/03/11 CF1495B Let's Go Hiking 博弈论，补题 21/03/12 CF1495C Garden of the Sun 构造，赛后补题 P5431 【模板】乘法逆元2 氵 21/03/13 Codeforces Round #707 (Div. 2, based on Moscow Open Olympiad in Informatics) A + B P5104 红包发红包 先分析第一个人能得到多少： \\int_0^w \\frac 1w x\\mathrm dx = \\frac w 2 ，所以这样推下去知答案为 \\frac{w}{2^k} CF1500A Going Home 毒瘤暴力题分析复杂度 21/03/15 ARC069D Flags 二分答案 + 线段树优化建图 + 2-SAT 21/03/16 POJ 3352 Road Construction 求最小添加的边数使得去掉所有桥，答案为边双连通分量缩点后叶子的数量加一除以二。 21/03/17 BZOJ#4398. 福慧双修 将 1 号点拆点之后二进制分组连边跑最短路保证每对出点都被枚举到。 21/03/18 P5958 [POI2017]Sabotaż f_u = \\max\\lbrace\\min\\lbrace \\frac{size_v}{size_u - 1}, f_v \\rbrace\\rbrace P3177 [HAOI2015]树上染色 毒瘤树形dp，细节繁多，只需考虑每条边产生的贡献。需要注意状态转移的合法性，可以使用 tmp 数组进行暂存 21/03/19 CF708C Centroids 换根 dp，考虑找到一个大小大于 n/2 的子树然后将其接走即可 P2515 [HAOI2010]软件安装 tarjan 缩点 + 树上背包，注意图不连通的情况，需要特判 P5304 [GXOI/GZOI2019]旅行者 二进制分组跑最短路 21/03/23 P4298 [CTSC2008]祭祀 构造一个 DAG 的最长反链。 UVA11419 SAM I AM 把横行和纵列作为二分图的左部和右部，中间的点连边，跑最小覆盖即可。 21/03/24 P6062 [USACO05JAN]Muddy Fields G 把所有极长木板看作点，左右部分别为横和纵 P7112 【模板】行列式求值 任意模数行列式求值，考虑两行之间辗转相减 21/03/25 P6178 【模板】Matrix-Tree 定理 Matrix-Tree 定理的带权版本 P4336 [SHOI2016]黑暗前的幻想乡 Matrix-Tree 加容斥 P4455 [CQOI2018]社交网络 Matrix-Tree 模板 21/03/27 NOI Online #1 提高组 [0, 10] + [80,100] + 20 21/03/28 P3810 【模板】三维偏序（陌上花开） cdq 分治 P1429 平面最近点对（加强版） 平面最近点对，分治法 21/03/29 HDU4343 Interval query 倍增优化贪心 HDU6031 Innumerable Ancestors 两点集 LCA 查询，树上倍增+二分答案 P3366 【模板】最小生成树 Borůvka 算法通过 21/03/30 CF888G Xor-MST 最小 xor 生成树 P5903 【模板】树上 k 级祖先 长链剖分 U41492 树上数颜色 dsu on tree 模板 21/03/31 CF600E Lomsat gelral dsu on tree CF570D Tree Requests dsu on tree LOJ#6669. Nauuo and Binary Tree 交互好题，树链剖分 CF1009F Dominant Indices 长链剖分优化 dp P3806 【模板】点分治1 点分治 NOIOL 1 0 + 80 + 20 = 100","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"P3518 [POI2011]SEJ-Strongbox","slug":"sol-luogu-p3518","date":"2021-02-25T14:46:22.000Z","updated":"2022-03-23T06:40:10.529Z","comments":true,"path":"sol-luogu-p3518/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3518/","excerpt":"","text":"数学一本通例题 题意 有一个密码箱， 0 到 n-1 中的某些整数是它的密码。且满足：若 a 和 b 是它的密码，则 (a+b)\\bmod n 也是它的密码（ a ， b 可以相等）。某人试了 k 次密码，前 k-1 次都失败了，最后一次成功了。 问，该密码箱最多有多少种不同的密码。 思路 可以证明，密码集合 A 里面的数一定是形如 x, 2x, 3x\\cdots 的形式（模意义下），且 x\\mid a_k\\land \\forall i &lt; k,x\\not\\mid a_i 。并且如果 x\\in A ， \\gcd(x, n)\\in A 。 做法： a_k:= \\gcd(a_k, n) ，然后考虑 a_k 的每个因子，如果能整除 \\gcd(a_i, a_k) 那就不行，遇到答案输出即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)typedef long long ll;const int maxn = 250000 + 5;ll a[maxn], k, n, tot, ans;inline ll gcd(ll a, ll b) {return b ? gcd(b, a % b) : a;}inline ll max(ll a, ll b) {return a &gt; b ? a : b;}bool check(ll x){ DEC(i, tot, 1) if (a[i] % x == 0) return false; return true;}int main(){ scanf(\"%lld %lld\", &amp;n, &amp;k); FOR(i, 1, k) scanf(\"%lld\", a + i), a[i] = gcd(a[i], n); std::sort(a + 1, a + k); tot = std::unique(a + 1, a + k) - a - 1; for (ll i = 1; i * i &lt;= a[k]; ++i) { if (a[k] % i == 0) { if (check(i)) { ans = n / i; break; } else if (check(a[k] / i)) ans = max(n / (a[k] / i), ans); } } printf(\"%lld\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"BZOJ3771. Triple","slug":"sol-bzoj3771","date":"2021-02-19T09:47:07.000Z","updated":"2022-03-23T04:18:30.657Z","comments":true,"path":"sol-bzoj3771/","link":"","permalink":"https://old.blog.imyangty.com/sol-bzoj3771/","excerpt":"","text":"题意 有 n 把价值分别为 a_i 的斧子，河神可能拿走 1 - 3 把，问每种可能的损失价值及其对应方案数。（不计顺序） 思路 生成函数入门题。 考虑设出多项式 A(x) ，其系数有 A[a_i] = 1 ，代表选一把的。则答案为 A(x) + A^2(x) + A^3(x) 。但是这样是显然不对的。为什么？ 因为这样的话同一个元素可能被选两次或三次，对于这种情况定义 B(x) 和 C(x) 满足 B[2a_i] = 1 和 C[3a_i] = 1 ，代表同时选两次/三次的，减掉这些方案数就可以了。然后需要注意顺序问题： 选一把的答案为 A(x) ，不难发现选两种的即为 \\dfrac{A^2(x) - B(x)}{2} ，选三种的比较麻烦：不能同时选两种一样的，即减去 3A(x)B(x) ，，但是选三种同样的又会被多减两次，最后除以 3! 去掉顺序问题，所以最终答案为： A(x) + \\frac{A^2(x) - B(x)}{2} + \\frac{A^3(x) - 3A(x)B(x) + 2C(x)}{6} 生成函数的卷积使用 NTT 或 FFT 优化即可。注意此时 NTT 模数要取一个更大的质数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}typedef long long ll;const int maxn = 5e5 + 5;const ll G = 3, mod = 2281701377;template&lt;typename T&gt; inline void myswap(T &amp;a, T &amp;b){ T t = a; a = b; b = t; return;}ll pow(ll base, ll p = mod - 2){ ll ret = 1; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ret = ret * base % mod; base = base * base % mod; } return ret;}int rev[maxn];const ll invG = pow(G);void NTT(ll *f, int lim, int type){ FOR(i, 0, lim - 1) if (i &lt; rev[i]) myswap(f[i], f[rev[i]]); for (int p = 2; p &lt;= lim; p &lt;&lt;= 1) { int len = p &gt;&gt; 1; ll tG = pow(type ? G : invG, (mod - 1) / p); for (int k = 0; k &lt; lim; k += p) { ll buf = 1; for (int l = k; l &lt; k + len; ++l, buf = buf * tG % mod) { ll tmp = buf * f[len + l] % mod; f[len + l] = f[l] - tmp; if (f[len + l] &lt; 0) f[len + l] += mod; f[l] = f[l] + tmp; if (f[l] &gt; mod) f[l] -= mod; } } } ll invlim = pow(lim); if (!type) FOR(i, 0, lim - 1) f[i] = f[i] * invlim % mod; return;}ll f1[maxn], f2[maxn], f3[maxn], ans[maxn];ll g[maxn], t[maxn];int main(){ int n = read(); while (n--) { int tmp = read(); ++f1[tmp], ++g[tmp], ++ans[tmp]; ++f2[tmp &lt;&lt; 1], ++f3[tmp * 3]; } int lim = 1; while (lim &lt;= (40000 * 3 + 5)) lim &lt;&lt;= 1; FOR(i, 0, lim - 1) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) ((i &amp; 1) ? (lim &gt;&gt; 1) : 0); NTT(f1, lim, 1), NTT(g, lim, 1); FOR(i, 0, lim - 1) g[i] = f1[i] * g[i] % mod; NTT(g, lim, 0); FOR(i, 0, lim - 1) ans[i] += (g[i] - f2[i]) / 2; NTT(g, lim, 1); FOR(i, 0, lim - 1) g[i] = f1[i] * g[i] % mod; NTT(g, lim, 0); NTT(f2, lim, 1); FOR(i, 0, lim - 1) f2[i] = f2[i] * f1[i] % mod; NTT(f2, lim, 0); FOR(i, 0, lim - 1) { ans[i] += (g[i] - 3 * f2[i] + 2 * f3[i]) / 6; if (ans[i]) printf(\"%d %lld\\n\", i, ans[i]); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://old.blog.imyangty.com/tags/BZOJ/"},{"name":"FFT","slug":"FFT","permalink":"https://old.blog.imyangty.com/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"容斥原理","slug":"inclusion-exclusion-principle","permalink":"https://old.blog.imyangty.com/tags/inclusion-exclusion-principle/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"}]},{"title":"Codeforces 比赛日记","slug":"summary-codeforces","date":"2021-02-17T10:11:15.000Z","updated":"2022-04-09T11:25:13.902Z","comments":true,"path":"summary-codeforces/","link":"","permalink":"https://old.blog.imyangty.com/summary-codeforces/","excerpt":"","text":"Round div id sol rk perf A B C D E F G H I R670 2 1406 0 9207 🉑 🉑 🉑 🉑 🉑 R695 2 1467 1 6299 🉑 👀 👀 👀 👀 R697 3 1475 4 N/A 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R698 2 1478 2 4882 🉑 🉑 R698 1 1477 N/A N/A 👀 👀 👀 😅 😅 😅 EDU103 edu 1476 2 4551 🉑 🉑 🉑 🉑 🉑 😅 😅 R699 2 1481 3 2113 🉑 🉑 🉑 🉑 🉑 👀 R700 2 1480 2 6974 🉑 🉑 🉑 R700 1 1479 N/A N/A 🉑 👀 👀 👀 😅 R701 2 1485 1 vp 👀 🉑 👀 👀 👀 👀 EDU104 edu 1487 2 4964 🉑 🉑 🉑 🉑 👀 👀 👀 R702 3 1490 5 1352 🉑 🉑 🉑 🉑 🉑 🉑 🉑 R705 2 1493 3 869 🉑 🉑 👀 🉑 👀 👀 R706 2 1496 3 1792 🉑 🉑 R706 1 1495 N/A N/A 🉑 🉑 🉑 👀 😅 😅 R707 2 1501 2 1320 🉑 🉑 R707 1 1500 N/A N/A 🉑 👀 👀 😅 😅 😅 R712 2 1504 1 8171 🉑 👀 R712 1 1503 N/A N/A 👀 👀 👀 😅 😅 😅 HSSC21 1+2 1553 5 vp 🉑 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 R733 1+2 1530 4 vp 🉑 🉑 🉑 🉑 R736 2 1549 4 373 🉑 🉑 R736 1 1548 N/A N/A 🉑 🉑 🉑 👀 😅 R737 2 1557 3 463 🉑 🉑 🉑 👀 👀 R738 2 1559 4 1780 🉑 🉑 🉑 🉑 🉑 R740 2 1561 4 1738 🉑 🉑 R740 1 1558 N/A N/A 🉑 🉑 👀 👀 😅 😅 R741 2 1562 2 3894 🉑 👀 🉑 👀 👀 👀 DR 2021 1+2 1556 4 vp 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R742 2 1567 3 2622 🉑 🉑 🉑 🉑 🉑 🉑 R743 2 1573 4 vp 🉑 🉑 R743 1 1572 N/A N/A 🉑 🉑 🉑 🉑 🉑 😅 EDU113 edu 1569 2 8249 🉑 🉑 🉑 👀 👀 😅 GR17 gr 1566 4 4019 1330 🉑 🉑 🉑 🉑 🉑 EDU114 edu 1574 3 1807 1585 🉑 🉑 🉑 🉑 👀 😅 R745 2 1581 3 279 1886 🉑 🉑 R745 1 1580 N/A N/A N/A 🉑 👀 👀 👀 😅 😅 R746 2 1592 3 550 1928 🉑 🉑 🉑 🉑 👀 👀 R747 2 1594 5 605 1825 🉑 🉑 🉑 🉑 🉑 🉑 EDU115 edu 1598 4 581 1825 🉑 🉑 🉑 🉑 🉑 🉑 😅 R749 1+2 1586 5 349 2284 🉑 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 R750 2 1582 4 1738 1514 🉑 🉑 🉑 🉑 🉑 👀 👀 R754 2 1605 3 869 1787 🉑 🉑 🉑 🉑 🉑 👀 R755 1 1588 2 451 1933 🉑 🉑 👀 🉑 😅 😅 R758 1+2 1608 3 522 2059 🉑 🉑 🉑 🉑 👀 😅 😅 GR18 gr 1615 3 816 2031 🉑 🉑 🉑 🉑 🉑 👀 😅 😅 Hello2022 1621 N/A skip N/A 🉑 🉑 🉑 🉑 🉑 😅 😅 😅 😅 R765 2 1625 4 140 2191 🉑 🉑 🉑 🉑 👀 R766 2 1627 3 1275 1678 🉑 🉑 🉑 🉑 🉑 🉑 R767 2 1629 4 305 1988 🉑 🉑 R767 1 1628 N/A N/A N/A 🉑 🉑 🉑 🉑 😅 😅 R768 2 1631 3 2765 1435 🉑 🉑 R768 1 1630 N/A N/A N/A 🉑 🉑 👀 👀 😅 😅 R769 2 1632 3 1620 1661 🉑 🉑 🉑 🉑 🉑 GR19 gr 1637 4 1047 1975 🉑 🉑 🉑 🉑 🉑 🉑 😅 😅 R771 2 1638 4 521 1936 🉑 🉑 🉑 🉑 🉑 😅 R772 2 1635 5 121 2204 🉑 🉑 🉑 🉑 🉑 🉑 EDU123 edu 1644 5 365 1968 🉑 🉑 🉑 🉑 🉑 😅 R773 1 1641 2 689 1884 🉑 🉑 👀 😅 😅 😅 R777 2 1647 4 549 1908 🉑 🉑 🉑 🉑 👀 👀 R781 2 1665 🉑 🉑 🉑 🉑 🉑 Codeforces Round #670 (Div. 2) 打的第一场 CF 然而一题都没做出来。 1406D - Three Sequences 题意：给定 a_i ，要求构造一个不减序列 b_i 和一个不增序列 c_i 使得 a_i = b_i + c_i 。请最小化 \\max\\{b_i, c_i\\} 。 q 次操作，每次可以对 a_l, a_{l + 1},\\cdots , a_r 加上 x 。问每次修改后的最小的 \\max\\{b_i, c_i\\} 。 一个比较奇妙的贪心。我们注意到答案为 \\max(b_n, c_1) 。而我们发现，对于 a_{i + 1} &gt; a_i ，我们若是调整在 c 上，则不优；但如若调整 b ，则因为 b 递增，所以令 b_{i + 1} = b_i + a_{i + 1} - a_i 是最优的。而 a_{i + 1} &lt; a_i 时，我们若是调整 c ，则 c_{i + 1} = c_i + a_{i +1} - a_i 是最优的。 好，那么我们可以知道， a_1 = b_1 + c_1 = b_n - \\sum_{i = 2}^n(b_i - b_{i - 1}) + c_1 。故令 b_n 和 c_1 尽量接近最优。答案为 \\displaystyle\\lceil\\frac{a_1 + \\sum_{i = 2}^n(b_i - b_{i - 1})}{2}\\rceil 。 而 \\sum_{i = 2}^n(b_i - b_{i - 1}) = \\sum_{i = 2}^n(a_i - a_{i - 1})\\cdot[a_i &gt; a_{i - 1}] 。这个东西应该是可以 O(1) 维护的。 123456789101112131415161718192021222324const int maxn = 1e5 + 5;using ll = long long;int n, q;ll a[maxn], d[maxn];int main() { read(n); FOR(i, 1, n) read(a[i]), d[i] = a[i] - a[i - 1]; ll sum = 0; FOR(i, 2, n) if (d[i] &gt; 0) sum += d[i]; print((ll)ceil((sum + d[1]) * 0.5)); int q; read(q); while (q--) { int l, r; ll x; read(l, r, x), ++r; ll dl = d[l], dr = d[r]; d[l] += x, d[r] -= x; if (l != 1) sum += max(d[l], 0ll) - max(dl, 0ll); if (r != n + 1) sum += max(d[r], 0ll) - max(dr, 0ll); print((ll)ceil((sum + d[1]) * 0.5)); } return output(), 0;} 1406E - Deleting Numbers 交互题。交互库给定一个数字 n ，要你猜一个数字 x （ 1\\le x\\le n ）。一开始你有一个集合 \\{1, 2,\\cdots, n\\} ，你可以进行至多 10000 次操作： A a：询问当前集合中有多少数为 a 的倍数。 B a：询问当前集合中有多少数为 a 的倍数，并将他们全部删掉。 x 不会被删掉。 C a：告诉交互库答案为 a 。 1\\le x\\le n\\le 10^5 。 首先，有一种很朴素的想法是枚举每个质数，删除其倍数然后判断 x 是否有这一个质因子 p ，然后就依次枚举 p^k 并询问 A p^k 直到收到的答案为 0 ，那么 x 就有一部分 p^{k - 1} ，根据唯一分解定理，我们这样子就能确定 x 。 令 \\tau(n) 为 [1, n] 中质数的幂的数量， \\pi(n) 为 [1, n] 中质数个数。发现 \\pi(10^5) = 9592 ， \\tau(10^5) = 9700 。上面这个做法的询问次数为 \\pi(n) + \\tau(n) + 1 ，显然要寄。 考虑优化。一个很常见的结论是，考虑根号分治，将质因子分为 \\le \\sqrt n 和 &gt;\\sqrt n 两部分，则 &gt; \\sqrt n 的一定只有一个。 对于 \\le \\sqrt n 的部分，我们直接用上面的方法暴力，操作次数为 \\pi(\\sqrt n) + \\tau(\\sqrt n)\\le 238 。对于 &gt; \\sqrt n 的部分，我们考虑分块，每次删 100 个质数，删了之后询问被删掉的数是否为 100 个，如果不是，那么直接暴力找这个 &gt;\\sqrt n 的质因子就能得到答案了。 细节有点烦人，一定要小心。 12345678910111213141516171819202122232425262728293031323334353637383940414243const int maxn = 1e5 + 5;int vis[maxn], p[maxn], tot, n;int ask(int a, char c) { cout &lt;&lt; c &lt;&lt; ' ' &lt;&lt; a &lt;&lt; endl &lt;&lt; flush; int x; cin &gt;&gt; x; return x;}int main() { cin &gt;&gt; n; FOR(i, 2, n) { if (!vis[i]) p[++tot] = i; for (int j = 1; i * p[j] &lt;= n; ++j) { vis[i * p[j]] = 1; if (i % p[j] == 0) break; } } int B = (int)ceil(sqrt(1e5)), ans = 1, i; for (i = 1; i &lt;= tot &amp;&amp; p[i] &lt;= B; ++i) { ask(p[i], 'B'); int tmp = p[i], flag = ask(p[i], 'A'); while (flag &amp;&amp; (tmp *= p[i]) &lt;= n) flag = ask(tmp, 'A'); ans *= tmp / p[i]; } for (i; i &lt;= tot; i += 98) { int cnt0 = ask(1, 'A'), r = min(i + 97, tot); FOR(j, i, r) cnt0 -= ask(p[j], 'B'); int cnt1 = ask(1, 'A'); if (cnt0 != cnt1) { FOR(j, i, r) { if (ask(p[j], 'A')) { ans *= p[j]; break; } } break; } } cout &lt;&lt; \"C \" &lt;&lt; ans &lt;&lt; endl &lt;&lt; flush; return 0;} Codeforces Round 706 1495A - Diamond Miner 在 x 轴上有 n 个钻石矿， y 轴上有 n 个矿工，保证所有的矿工和钻石都不在原点。需要建立每个矿工与每个钻石矿的一一对应关系使得每对矿工和矿的距离之和最小。 要么是贪心要么是 O(n) 的 dp，先考虑两对矿工和钻石的情况：（由于正负其实不影响，所以我们把所有的钻石和矿的坐标都取绝对值，在正半轴上考虑问题。两对点的情况无非就是交叉着连（蓝线）和平行着连（红线）。所以考虑哪个要大一些，即比较 \\sqrt{a^2 + d^2} + \\sqrt{b^2 + c^2} 和 \\sqrt{a^2 + c^2} + \\sqrt{b^2 + d^2} 的大小。 两边同时平方： a^2 + b^2 + c^2 + d^2 + \\sqrt{(a^2 + d^2)(b^2 + c^2)} 和 a^2 + b^2 + c^2 + d^ 2+ \\sqrt{(a^2 + c^2)(b^2 + d^2)} 所以只需要考虑 (a + d)(b+ c) 与 (a + c)(b + d) 的大小即可，化简之后不难发现 (a + d)(b + c)\\ge(a + c)(b + d) 所以平行的连法一定是最优的。将所有的点取绝对值后排序然后依次累加答案就搞定了。 1495B - Let's Go Hiking 题意：给定一个 1-n 的排列 p ，Qingshan 和 Daniel 在草稿纸上按照如下规则进行远足游戏。 首先 Qingshan 选定一个数 x 并告诉 Daniel，接下来 Daniel 选定另一个数 y ， 1\\le x, y\\le n 且 x\\not=y 。然后他们轮流进行游戏，Qingshan 为先手： 如果轮到 Qingshan，则 Qingshan 只能把 x 移动到 x' ，其中 x' - x = 1 ，且 x' \\neq y ， p_x\\gt p_{x'} 。 如果轮到 Daniel，则 Daniel 只能把 y 移动到 y' ，其中 y' - y = 1 ，且 y'\\neq x ， p_y\\lt p_{y'} 。 如果轮到某一方时无路可走了，则另一方胜利。 假设双方都足够聪明，那么判断有多少个初始的 x 可以让 Qingshan 一定取胜。 题解：首先发掘这个游戏的性质：每个人只能往一个方向走，不能回头。注意到这个性质之后不难发现如果 Qingshan 要赢，那么 Daniel 必须被 Qingshan 卡死或者自己被卡死。 因为两方都足够聪明，所以我们把问题范围缩小到最长单调序列上面来，因为这样可以最大化双方的移动步数。 可以证明的是，Qingshan 一开始选的点在最长单调序列的顶端是他能赢的必要条件。至于为什么呢？如果 Qingshan 选的不是最长单调序列的顶端，那么 Daniel 就可以选最长单调序列的底端进行游戏，那么 Qingshan 肯定先被卡死。 并且如果有多条不相交的最长单调序列，Qingshan 必输。因为这样 Daniel 可以选择另外一条序列的底端，而 Qingshan 是先手，所以 Qingshan 肯定先被卡死。 如果只有一条最长单调序列，还是 Qingshan 必输，因为 Qingshan 是先手，Daniel 选择的位置但凡与 Qingshan 的初始位置成的链长为偶数，那么 Daniel 肯定可以卡死 Qingshan。 剩下的两种情况就是同时有两条最长单调序列，要么成“V”形要么成山峰形。对于“V”形的情况还是 Qingshan 必输，因为 Daniel 可以往与 Qingshan 相反的方向跑走，那么当 Qingshan 最后到达谷底的时候就 GG 了。对于山峰形的情况，Qingshan 肯定是选峰顶，接下来分最长单调序列长度的奇偶性讨论： 奇数：如果 Daniel 选了坡底，那么 Qingshan 只要往 Daniel 的方向走那么就必然可以卡死 Daniel；如果不选坡底，那么 Qingshan 只要往另一个方向走就可以让 Daniel 先无路可走，所以此时答案为 1 ，Qingshan 唯一的必胜策略就是选择山顶。 偶数：类似上面的分析方法，不难发现要么 Daniel 卡死 Qingshan，要么 Qingshan 先无路可走，所以 Qingshan 必败。 分析到这里我们就发现了答案为 1 当且仅当有两条最长单调序列并且他们共享一个最高点，否则答案为 0 。 O(n) 直接扫就可以过了。 1495C - Garden of the Sun 题意：给定一个 n\\times m 矩阵，里面含有字符 . 和 X。保证所有 X 之间无公共点（即不联通），请将一部分 . 替换成 X 使得这些 X 形成一棵树（要求四联通，即两个 X 之间有一公共边，不能有环）。 首先所有 X 之间无公共点是一个特别好的性质，这保证了下面填充列的方法的正确性。 具体地，考虑 3\\mid m 的情况，不妨直接将 2,5,8,\\cdots 列全部填成 X，不难发现这样隔两列填一列的方式是不会出现环的，然后再将 3, 6, 9, \\cdots 和 4,7,10,\\cdots 等列构造成联通的就可以了，最简单的方法就是只考虑第一行和第二行，如果合法就直接连。 如果 3\\not\\mid m ，那么只需要变一下，把 1, 4, 7,\\cdots 填成 X，剩余操作类似。至于为什么填的列改变了则可以考虑画一下图自己模拟一下，会发现如果选 2, 5, 8,\\cdots 的话在 m = 3k + 1 的时候会多出一个需要单独考虑的列，所以不如简化问题。 Codeforces Round 707 Div.2 based on moscow open olympiad in informatics 1500A - Going Home Description 给定 \\lbrace a_n\\rbrace ，满足 4\\le n\\le 2\\times10^5 并且 \\forall i\\in[1,n],1\\le a_i\\le 2.5\\times10^6 ，求四个不同的下标 x,y,z,w 使得 a_x + a_y = a_z + a_w 。 有解则打印解，无解输出 \\texttt{NO} Solution 注意到我们的和 a_i + a_j\\le 5\\times 10^6 ，这个是解决问题的关键。 所以我们直接大力枚举 S = a_i + a_j ，记录一下加出来的这个 S ，如果同样的 S 出现了第二次则直接输出答案就好。根据鸽巢原理，我们如果枚举的次数超过了值域，那么就肯定不存在解。 Harbour.Space Scholarship Contest 2021-2022 (open for everyone, rated, Div. 1 + Div. 2) VP on 21/10/18. A + B + C + D + F。 1553E - Permutation Shift 初始有排列 (1, 2, \\cdots, n) ，现给定排列 P 和正整数 m ，求出所有满足下列条件的整数 k\\in[0, n- 1] ： 将初始排列向右循环移位 k 个单位后，能经过不超过 m 次交换元素的操作后得到 P 。 1\\le n\\le 3\\times 10^5 ， 0\\le m\\le \\dfrac n3 。 可以考虑枚举 k 然后判断这个 k 是否可行。但是 O(n^2) 显然会爆炸。考虑由于我们一次交换最多改变两个数的位置，所以位置不用改变的数字至少有 n - 2m 个，令 x_k 表示循环移位 k 次后不用动的数字个数，一定有 \\displaystyle\\sum_{i = 0}^{n - 1}x_i = n ，而且由 m\\le \\dfrac n 3 得知 x_k\\ge \\dfrac n 3 恒成立。这样满足条件的 x_k 至多有 3 个。所以我们预处理一下所有的 x_k 然后每次找 \\ge n - 2m 的 x_k 然后 O(n) 找环即可，复杂度 O(n) 。 1553F - Pairwise Modulo 给定 n 和 \\{a_n\\} （ 1\\le a_i\\le 2\\times 10^5 ），对每个 k 求出 f_k = \\displaystyle\\sum_{1\\le i,j\\le k}a_i\\bmod a_j 。 考虑新加进来一个 a_i 时产生的贡献，将这部分贡献与 f_{i - 1} 相加即得到 f_i 。其分为 \\sum_j a_j\\bmod a_i 。这部分比较好办，树状数组直接扫便是，俩 \\log 。 \\sum_j a_i\\bmod a_j 。这部分不太好直接去算。考虑 a_i\\bmod a_j = a_i - a_j\\lfloor a_i/a_j\\rfloor ，故可以在计算之前的 a_j 的时候顺便更新一下它能更新到的区间。区间加，单点查，依然可以树状数组。还是俩 \\log 。 于是 O(n\\log^2n) 解决掉了。比 E 不知道简单到哪里去了。 1553G - Common Divisor Graph 给定一个包含 n 个节点的图。第 i 个节点都有权值 a_i ，没有两个节点权值相同。节点 i,j 之间有一条无向边仅当 \\gcd(a_i,a_j)&gt;1 。 给定 q 次询问，每次包含整数 s,t 表示你希望从节点 s 到达节点 t 。为了到达那个节点，你可以进行下列操作任意次： 选定一个节点 i 。创造一个新的节点，该节点的权值为 a_i\\times(a_i+1) ，并按照上述规则连边。 对于每次询问，你都需要求出，至少需要多少次操作才能使节点 s 能到达节点 t 。询问互相独立。 由于 a_s(a_s + 1) 和 a_t(a_t + 1) 必然有公约数 2 所以连通。所以答案至多为 2 。 考虑一开始先用并查集连好已经有了的边，查询的时候若已经连通，则答案为 0 。然后考虑什么时候答案为 1 ，显然，当 a_s + 1 和 a_t 所在集合连通或者 a_s 所在集合和 a_t + 1 连通时答案就为 1 。这个可以预处理一下。 时间复杂度大抵是 \\log 级别的，能过。 Codeforces Round #737 (Div. 2) 1557C. Moamen and XOR 拆开位来考虑。处理一下组合数。 Codeforces Round #738 (Div. 2) 1559D1. Mocha and Diana (Easy Version) 暴力给两个森林加边， O(n^2\\log n) 可过。 1559D2. Mocha and Diana (Hard Version) 考虑延续上题的性质。 贪心的把 1 能连的边连了，然后会出现两类点：只在 A 图中与 1 相连以及只在 B 图中与 1 相连。然后显然可以在两个集合中挑点出来连边。直接连就行了，复杂度 O(n\\log n) 。 1559E. Mocha and Stars 求满足如下条件的序列 (a_1, a_2, \\cdots , a_n) 的数量： \\forall i\\in[1, n], a_i\\in[l_i, r_i] ； \\sum a_i\\le m ； \\gcd(a_1, a_2, \\cdots, a_n) = 1 2\\le n\\le 50 ， 1\\le m\\le 10^5 ，答案对 998244353 取模。 不考虑 \\gcd 的限制，发现其为一个背包。令 f_{i, j} 为前 i 个物品，背包容量为 j 的方案数，则有转移方程： f_{i, j} = \\sum_{k = l_i}^{r_i}f_{i - 1, j - k} 这样直接去做是 O(nm^2) 的，发现转移可以使用前缀和优化，具体设 s_{i, j} 表示 s_{i, j} = \\sum_{k = 0}^jf_{i, k} 然后就有了转移方程 f_{i, j} = s_{i - 1, j - l_i} - s_{i - 1, j - r_i - 1} 背包部分的复杂度为 O(nm) 。 然后考虑 \\gcd 的限制，这类套路问题使用莫比乌斯反演即可。 \\begin{aligned} &amp;\\sum_{a_1=l_1}^{r_1}\\sum_{a_2=l_2}^{r_2}\\cdots\\sum_{a_n=l_n}^{r_n}[\\gcd(a_1,\\cdots,a_n)=1]\\left[\\sum_{i = 1}^na_i\\le m\\right]\\\\ =&amp;\\sum_{a_1=l_1}^{r_1}\\sum_{a_2=l_2}^{r_2}\\cdots\\sum_{a_n=l_n}^{r_n}\\left[\\sum_{i = 1}^na_i\\le m\\right]\\sum_{d \\mid \\gcd(a_1,\\cdots,a_n)}\\mu(d)\\\\ =&amp;\\sum_{a_1=l_1}^{r_1}\\sum_{a_2=l_2}^{r_2}\\cdots\\sum_{a_n=l_n}^{r_n}\\left[\\sum_{i = 1}^na_i\\le m\\right]\\sum_{d\\mid a_1,\\cdots,d \\mid a_n}\\mu(d)\\\\ =&amp;\\sum_{d=1}^M\\mu(d)\\sum_{a_1=\\lceil\\frac{l_1}{d}\\rceil}^{\\lfloor\\frac{r_1}{d}\\rfloor}\\sum_{a_2=\\lceil\\frac{l_2}{d}\\rceil}^{\\lfloor\\frac{r_2}{d}\\rfloor}\\cdots\\sum_{a_n=\\lceil\\frac{l_n}{d}\\rceil}^{\\lfloor\\frac{r_n}{d}\\rfloor}\\left[\\sum_{i = 1}^na_i\\le \\left\\lfloor\\frac m d\\right\\rfloor\\right] \\end{aligned} 总时间复杂度 O(nm\\log m) 。 123456789101112131415161718192021222324int main() { init(); read(n), read(m); FOR(i, 1, n) read(L[i]), read(R[i]); modint ans = 0; FOR(d, 1, m) { if (mu[d] == 0) continue; FOR(j, 0, m / d) sum[j] = 1; FOR(i, 1, n) { l[i] = (L[i] + d - 1) / d, r[i] = R[i] / d; FOR(j, 1, m / d) f[j] = 0; FOR(j, l[i], m / d) { f[j] = sum[j - l[i]]; if (j - r[i] - 1 &gt;= 0) f[j] -= sum[j - r[i] - 1]; } sum[0] = 0; FOR(j, 1, m / d) sum[j] = f[j] + sum[j - 1]; } ans += sum[m / d] * mu[d]; } print(ans); return output(), 0;} VK Cup 2021 — Final (Engine) and Codeforces Round #740 1561A. Simply Strange Sort 模拟 1558A. Charmed by the Game 直接枚举 A 先手 B 赢比赛的次数，分 a + b 的奇偶性讨论即可。 1561C. Deep Down Below 二分答案，水。 1558B. Up the Strip 一个点 x 可以通过以下两种方式到别的格子： 减法操作：到 y ， 1\\le y &lt; x 。 除法操作：到 y ， y = \\lfloor x / d\\rfloor ， d\\ge 2 。 dp，首先最朴素的做法可以通过前缀和和整除分块实现，总复杂度 O(n\\sqrt n) 。 考虑 f_i 对后面产生的贡献。 设 j = qi + r ， 0\\le r &lt; q ，则不难发现 \\lfloor j / q\\rfloor = i ，所以一个 i 对于每个 q\\ge 2 ，会对 [qi, q(i + 1)) 产生贡献。 差分维护一下即可，复杂度调和 O(n\\log n) 。 Codeforces Round 741 (Div. 2) A + C 1562C - Rings 题意：给定 10^5 的 01 串，要求选出两不同的长度大于 \\lfloor \\frac n2\\rfloor 的子段，要求一个为另一个的倍数，保证有解。 注意到一个二进制数后面添一个 0 相当于就是乘上 2 。而本题中前导零也不影响，所以直接找串中的 0 即可。特判全 1 串。 Deltix Round, Summer 2021 (open for everyone, rated, Div. 1 + Div. 2) 1556C - Compressed Bracket Sequence 考虑如果我们遇到了一串连续的右括号，统计他们的贡献。 如果左边的左括号比他多，则贡献为右括号的个数。 如果左边的左括号和他一样多，则贡献为右括号的数量加上左边相邻合法括号串的数量。 如果左边的左括号比他少，则贡献为右括号的数量加上左边相邻合法括号串的数量，但是还剩若干右括号没有匹配，往左枚举左括号重复上述三种情况即可。 需要维护一个点结尾处合法括号串的数量。 1234567891011121314151617181920212223242526272829303132333435using ll = long long;const int maxn = 1005;int n, a[maxn];ll sum[maxn];int main() { read(n); FOR(i, 1, n) read(a[i]); ll ans = 0; for (int i = 2; i &lt;= n; i += 2) { int tot = a[i]; for (int j = i - 1; j &gt;= 1; j -= 2) { if (!tot) break; if (!a[j]) continue; if (tot &lt; a[j]) { ans += tot; a[j] -= tot; ++sum[i]; break; } else if (tot == a[j]) { ans += tot + sum[j - 1]; sum[i] += 1 + sum[j - 1]; a[j] = 0; break; } else { tot -= a[j]; ans += a[j] + sum[j - 1]; a[j] = 0; } } } print(ans, '\\n'); return output(), 0;} 1556D - Take a Guess 有一个很关键的结论是 a + b = (a\\land b) + (a\\lor b) 。 所以直接询问 a_1 + a_i （ i\\le [2, n] ），然后再询问 a_2 + a_3 ，就可以刚好在 2n 次询问里面得到答案。 1556E - Equilibrium 首先，令 c_i = b_i - a_i ，则一次操作变为在 c 的某些位置上加一，某些位置上减一，目标变为使某一段 c 全部变为 0 。 可行性：会发现这个操作有点类似括号匹配，故 c 在 [l, r] 上的任意位置的前缀和不可小于零而且总和要为 0 。即 \\min\\{s_j\\}\\ge s_{l - 1} 。需要一个 RMQ。 构造答案：将加减法两两配对之后多组的一起完成。即为嵌套最深的括号，相当于爬山爬的最高峰，查一下爬山的最高峰即可。也需要一个 RMQ。直接上就行了。 1556F - Sports Betting 1556G - Gates to Another World Codeforces Round #742 (Div. 2) A + B + C 1567C - Carrying Conundrum 题意：定义 Alice 的加法为 a + b 竖式下进位进到前面两位去。问有多少种有序正整数对 (a, b) 使得 a + b = n 。 可以考虑 DP，注意到只有当前位和后面一位有后效性，所以可以令 f_{i, k_0, k_1} 表示从低到高第 i 位，当前位及上一位有没有产生进位，转移易得，答案为 f_{len, 0, 0} 。 注意需要去除 (n, 0) 和 (0, n) 。评测记录#127974617。 1567D - Expression Evaluation Error 题意：给定一个数 s ，要求划分成 n 个数 n_1,\\cdots n_s ，要求把这些数看成 11 进制的然后按照 11 进制加起来使得结果最大。构造方案。 首先考虑按位贪心：让最高位最大是显然的，让其等于 s 的最高位一定是最优的。然后我们会发现这个构造出的最大结果一定不会大于 s 看成 11 进制表示的结果。 最优的做法是尽量让 Alice 不要进位：将 s 表示成 10^k 之和，例如 25 就可以被表示为 10 + 10 + 1 + 1 + 1 + 1 + 1 。但是难免有划分数量多的时候，那么就从高位往低位贪，让高位尽量不要进位即可。 所以从最高位往最低位依次划分即可。 1567E - Non-Decreasing Dilemma 单点修改序列，区间查询不降子段个数。 线段树维护每个区间的答案，左端的不降子段长度，右端的不降子段长度。 注意 pushup 即可。评测记录 1567F - One-Four Overload 题意：给定 n\\times m 的方格，有 . 和 X 两种点，要求在 . 中填入 1 或 4 ，X 点中填入 5 的倍数满足其为与其四联通的 . 中数字之和。输出无解或构造方案。 注意到 \\begin{aligned} 1&amp;\\equiv 1&amp;\\pmod 5\\\\ 4&amp;\\equiv -1&amp;\\pmod 5 \\end{aligned} 所以，不难发现一个 X 点旁边必须具有数量相等的 1 和 4 。对于形如 .X. 的情况，只需要建边然后二分图染色一下就好了。关键是对于“十”字形的我们怎么处理。 在纸上手玩几个发现对面的填相同颜色的是最优的，这样子能方便其他的构造方案：如 12345.1..4X41.1XX.1X4 如果我们这样 12345.1..1X4..4XX..X. 发现构造不出来。按照上述方法构造二分图（为什么是二分图应该挺显然的）然后就可以通过了。评测记录。 Codeforces Global Round 16 A + B + C + D1。D2 已补，水。 1566E - Buds Re-hanging 定义一棵有根树的一个节点为 bud 当且仅当其有至少一个儿子且其所有儿子都为叶节点。 每次操作可以提出一个 bud 及其儿子然后接在任意一个节点下面。 问若干次操作之后叶子节点最少为多少个。 一个 bud 接在一个叶子下之后会使得叶子节点至多减 1 （如果 bud 上面是根则会减 1 ）。而且移动 bud 的过程可逆，不妨将所有的 bud 找出来接在根上，设树节点为 n ，bud 有 k 个，则叶子节点数肯定为 n - k - 1 （总结点减去根和每个 bud）。 然后考虑如果根上至少连有一个叶子节点，则把所有的 bud 依次接上去，一共会接 k 次，答案为 n - 2k - 1 。 如果根上没有直接连的叶子节点，则把每个 bud 依次合并，接 k - 1 次，答案为 n - k - 1 - (k -1) = n - 2k 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 2e5 + 5;int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnte, d[maxn], k;il void add(int u, int v) { to[++cnte] = v; nxt[cnte] = head[u]; head[u] = cnte; return;}void dfs(int u, int fa) { bool flag = 0; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v == fa) continue; dfs(v, u); if (d[v] == 2) flag = 1; } if (fa) { if (flag) ++k, d[u] = 3; else d[u] = 2; } return;}int main() { int T; read(T); while (T--) { read(n); FOR(i, 1, n) head[i] = d[i] = 0; k = 0; FOR(i, 1, n - 1) { int u, v; read(u), read(v); add(u, v), add(v, u); } dfs(1, 0); int s = 0; for (int i = head[1]; i; i = nxt[i]) if (d[to[i]] == 2) {s = 1; break;} print(n - 2 * k - s), putchar('\\n'); } return output(), 0;} Codeforces Round #743 (Div. 1/2) VP on 21/10/09。D2A + D2B + D1A + D1B。 1572B - Xor of 3 首先有解的必要条件是 1 的个数为偶数个，因为每次操作是不会改变 1 的个数的奇偶性的。 然后考虑构造，若 n 为奇数，那么执行 n - 2, \\cdots, 3, 1 ，这样子之后 a_1 = 0 ，然后再执行一遍 1, 3, \\cdots, n - 2 就可以了。 对于 n 为偶数的情况将其拆成两段长度为奇数的含偶数个 1 的然后分开做就行了。 1572C - Paint 题意：给定一个最多含 20 种颜色的序列，每次操作可以把一段颜色相同的区间染成一种颜色，问将所有颜色染成同一种的最小操作次数。 n\\le 3000 。 考虑区间 dp。 首先肯定将相邻的同色缩起来。 然后设 f_{i, j} 为将 [i, j] 染成 c_j 的最小代价。为什么这样定义状态是因为一定存在一种方案使得最后的颜色为 c_j ，容易发现将 [1, j - 1] 同色之后再和 c_j 统一是不会更劣的。 首先有 f_{i, j} = \\min\\{f_{i + 1, j}, f_{i, j - 1} \\} + 1 。 其次，如果存在 k 使得 i\\le k &lt; j 且 c_k = c_j ，那么我们也可以从 f_{i, k} + f_{k + 1, j} 转移过来。记录一下上一个与 k 颜色相同的点就可以了。答案为 f_{1, n} 。 1572D - Bridge Club 显然，图为二分图，按照二进制表示下 1 的个数即可分为左部和右部，中间连权为 a_i + a_j 的边。 但是直接费用流或者 KM 都会死掉，因为点数为 O(2^n) 级别，边数为 O(n2^n) 级别，必死无疑。但是注意到这个 k 是很小的，我们需要从 k 上下手。 不难发现，每个点会连出去 n 条边，如果我们选择了一个匹配，那么剩下能匹配的方案数就会减少 2(n - 1) ，所以我们选了 k 个匹配后最多只会减少 k(2n - 1) 个匹配方式，即我们选了 k(2n - 1) 个匹配就会至少存在 k 个匹配。 所以我们只需要选出最大的 k(2n - 1) 条边，然后跑费用流就行了，不难发现一定有最优的方案存在在这最大的 k(2n - 1) 条边里面，证明可用反证法。 具体实现中，选出最大的 k(2n - 1) 条边我们使用 STL 的 nth_element() 函数，其复杂度为 O(\\text{length of the seq}) ，本题中为 n2^n ，然后注意加边的时候不要给每个 [0, 2^n - 1] 的球员都加边，否则会 TLE。 1572E - Polygon 给定一个严格凸多边形，最大化划 k 刀后的最小面积， 3\\le n\\le 200, 0\\le k\\le n - 3 。 二分这个最小面积。现在我们就需要划出来的 k + 1 个区域的面积都大于等于 S 。 只考虑划分 [l, r] 这个区间的点，有个贪心就是我们尽可能多划分，而 l 和 r 相邻的这部分有可能面积不大于 S ，我们要让其尽可能大。 设 f_{l, r} = (K, M) 表示最多划分出了 K 块合法的区域， l 和 r 相邻部分这块三角形的最大面积为 M 。转移易得，枚举 k\\in(l, r) 然后考虑合并 M 和 K 即可。 只要 f_{1, n}\\ge k + 1 ，就说明二分出来这个面积是合法的。 1234567891011121314151617181920212223242526272829303132333435363738using ll = long long;using pii = std::pair&lt;ll, ll&gt;;const int maxn = 205;ll x[maxn], y[maxn];int n, k;pii f[maxn][maxn];ll S(int i, int j, int k) {return (x[j] - x[i]) * (y[k] - y[i]) - (y[j] - y[i]) * (x[k] - x[i]);}bool check(ll mid) { FOR(len, 3, n) { for (int i = 1, j = i + len - 1; j &lt;= n; ++i, ++j) { f[i][j] = pii(0, 0); FOR(k, i + 1, j - 1) { ll K = f[i][k].first + f[k][j].first; ll M = f[i][k].second + f[k][j].second + S(i, k, j); if (M &gt;= mid) f[i][j] = max(f[i][j], pii(K + 1, 0)); else f[i][j] = max(f[i][j], pii(K, M)); } } } return f[1][n].first &gt; k;}int main() { read(n), read(k); FOR(i, 1, n) read(x[i]), read(y[i]); ll l = 0, r = 4e18, ans; while (l &lt;= r) { ll mid = (l + r) &gt;&gt; 1; if (check(mid)) ans = mid, l = mid + 1; else r = mid - 1; } print(ans, '\\n'); return output(), 0;} Codeforces Round #745 (Div. 1/2) 真的很毒瘤的场。Terrible Round。 1580D - Subsequence 给定长度为 n 的序列 a ，所有元素两两不同。需要选择一个长度为 m 的子序列 a_{b_1}, a_{b_2},\\cdots, a_{b_m} ，要使得其代价最大。 子序列的价值被定义为 \\sum_{i=1}^m(m\\cdot a_{b_i}) - \\sum_{i=1}^m\\sum_{j=1}^mf(\\min(b_i, b_j), \\max(b_i, b_j)) 其中 f(x, y) 表示 \\min_{x\\le i\\le y}\\{a_i \\} 。 1\\le m\\le n\\le 4000 。 化出式子： \\sum_{i = 1}^m(m - 1)a_{b_i} - 2\\sum_{i=1}^{m-1}\\sum_{j=i+1}^mf(b_i, b_j) 然后像 f 这种一脸 RMQ 样的东西考虑放到笛卡尔树上，然后再化好看一点： \\sum_{i=1}^{m-1}\\sum_{j=i+1}^m a_{b_i} + a_{b_j} - 2f(b_i, b_j) 那就是 a_{b_i} + a_{b_j} 再减去两倍他们的 LCA 的值，很像两点间的树上距离。考虑树形 dp f_{i,j} 表示 i 子树里面选了 j 个元素的最大代价，容易知道时间复杂度为 O(n^2) 。 123456789101112131415161718192021222324252627282930313233343536373839using ll = long long;const int maxn = 4005;int n, m, ls[maxn], rs[maxn], stk[maxn], top;ll a[maxn], size[maxn], f[maxn][maxn], w[maxn];void dfs(int u) { size[u] = 1; if (ls[u]) { dfs(ls[u]), w[ls[u]] = a[ls[u]] - a[u]; DEC(i, size[u], 0) DEC(j, size[ls[u]], 0) chkmax(f[u][i + j], f[u][i] + f[ls[u]][j] + j * (m - j) * w[ls[u]]); size[u] += size[ls[u]]; } if (rs[u]) { dfs(rs[u]), w[rs[u]] = a[rs[u]] - a[u]; DEC(i, size[u], 0) DEC(j, size[rs[u]], 0) chkmax(f[u][i + j], f[u][i] + f[rs[u]][j] + j * (m - j) * w[rs[u]]); size[u] += size[rs[u]]; } return;}int main() { read(n, m); FOR(i, 1, n) read(a[i]); stk[top = 1] = 1; FOR(i, 2, n) { while (top &amp;&amp; a[stk[top]] &gt; a[i]) --top; if (!top) ls[i] = stk[top + 1]; else ls[i] = rs[stk[top]], rs[stk[top]] = i; stk[++top] = i; } dfs(stk[1]); print(f[stk[1]][m]); return output(), 0;} Codeforces Round #746 (Div. 2) 题目出得不错。 1592C - Bakry and Partitioning 问将一棵树划分为最多 k 个连通块，要求这些连通块内点权的异或和相等，问是否有解。 首先发现，如果所有的点权异或和为 0 ，则必然有解，而且断掉任意一条边都是可以的。 然而异或和可能不为 0 ，我们不妨设其为 m 。而根据异或的性质，我们知道划分出来的各个连通块的异或和只能为 m ，而且连通块的个数为奇数。 这是为什么？考虑划分为三个连通块的情况：既要异或起来为 m 又要两两相等，不难发现只能为三个 m 。然后我们又会发现，但凡有解，一定能划分为这样的三个连通块。 现在问题就转化为了找到三个连通块使得他们的异或和都为 m 。dfs 扫描一遍即可。如果遇到一个节点 u 有两个子树 v_1,v_2 内含异或和为 m 的子树，则一定有解。而且，如果当前子树 u 的异或和为 0 ，且存在一个包含在 u 内的异或和为 m 的子树，则也一定有解。 稍加分析可知上面两种涵盖了所有的情况。 1592D - Hemose in ICPC ? 点数为 n （ n \\le 1000 ）的树，最多 12 次查询，每次查询给定一个点集，返回最大的 Dist(u, v) ，代表 u 到 v 的简单路径上的边权的 \\gcd 。要求找到 \\gcd 最大的 u 和 v 。 注意到 \\gcd 只会减小，不会增大，因此 \\gcd(u, v) 最大时一定是 u 和 v 相连，相当于我们要找这棵树的最大边权。 如何去找？这个查询次数和数据范围很明显的暗示了我们要二分一个点集，可是我们如何保证二分出来的两个点集是联通的呢？ 不妨考虑这棵树的欧拉序，将欧拉序建出来后会发现两两之间一定是有边的，所以在欧拉序上二分找最大值就可以了，可以保证查询次数最多为 1 + \\log(2n - 1) 。 实现起来很简单。 Codeforces Round #747 (Div. 2) A + B + C + D + E1。rk 606。补完了，好耶。 1594E2 - Rubik's Cube Coloring (hard version) 题意： k 层的满二叉树， n 个节点已经被染色，颜色来自魔方的六种颜色。要求树上相邻的节点染的颜色不能为魔方上不 相邻的颜色，问将整棵树涂满的方案数。 继承一下 E1 的做法，没有预先钦定的颜色那么答案为 6\\times 4^{2^k - 2} 。我们发现，已经钦定好的 n 个点会影响其到根的一条路径，把这条路径抽出来 dp 即可。然后令没有被影响的点有 m 个，答案乘上 4^m 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using namespace std;using ll = long long;map&lt;string, int&gt; st;map&lt;ll, modint&gt; f[3];map&lt;ll, int&gt; mp;map&lt;ll, set&lt;ll&gt; &gt; G;ll k, n;void dfs(ll u) { for (auto v : G[u]) dfs(v); FOR(c, 0, 2) { if (~mp[u] &amp;&amp; c ^ mp[u]) continue; f[c][u] = ~mp[u] ? 1 : 2; for (auto v : G[u]) f[c][u] *= (f[(c + 1) % 3][v] + f[(c + 2) % 3][v]); } return;}int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; k &gt;&gt; n; st[\"white\"] = st[\"yellow\"] = 0; st[\"green\"] = st[\"blue\"] = 1; st[\"red\"] = st[\"orange\"] = 2; FOR(i, 1, n) { ll u; string s; cin &gt;&gt; u &gt;&gt; s; mp[u] = st[s]; } if (!mp.count(1)) mp[1] = -1; auto mp0 = mp; for (auto p : mp0) { ll u = p.first; while (u ^ 1) { G[u &gt;&gt; 1ll].insert(u); if (!mp.count(u)) mp[u] = -1; u &gt;&gt;= 1; } } dfs(1); modint ans = (f[0][1] + f[1][1] + f[2][1]) * qPow(4, ((1ll &lt;&lt; k) - 1 - mp.size()) % (mod - 1)); cout &lt;&lt; ans.val &lt;&lt; endl; return 0;} 还是挺好的一道题，提出有用的点来进行树形 dp。 1594F - Ideal Farm 给出 n, s, k ，问是否所有的长度为 n 的和为 s 的正整数序列都有一段长度为 k 的区间。 考虑构造一个无解的情况。即要求没有两个前缀和的差为 k ，构造的时候即 1, 1,1,\\cdots, k + 1, 1, 1, \\cdots 如是构造。 n &lt; k 的时候特判一下。蠢得要死。。。 123456789101112131415161718using ll = long long;int main() { int T; read(T); while (T--) { ll s, n, k; read(s), read(n), read(k); if (n &lt; k) { if (s == k) puts(\"YES\"); else puts(\"NO\"); } else { ll w = n / k * 2ll * k + n % k; s &lt; w ? puts(\"YES\") : puts(\"NO\"); } } return output(), 0;} Educational Codeforces Round 115 A + B + C + D。 1598E - Staircases 注意到其实就这两种楼梯，要么结束位置是两个横着的，要么是两个竖着的。所以可以 dp，设 f_{i, j, 0/1} 表示 (i, j) 结束，最后位置为横/竖的方案数，则有转移 \\begin{cases} f_{i, j, 0} :=f_{i, j, 0} + f_{i - 1, j, 1}\\\\ f_{i, j, 1} := f_{i ,j , 1} + f_{i, j - 1. 0} \\end{cases} 初始条件为 f_{i, j, 0/1} = 1 ，因为一个格子也算楼梯。但是会算重，所以需要特判一下。 然后是修改操作。我们需要知道，一次修改操作能影响的 dp 值是有限的。手玩一下发现最多影响 3n 个格子。故总时间复杂度 O(n^2 + nq) 。 代码就不放了。 1598F - RBS 括号匹配 + 状压 dp 好题。 定义合法的括号串，给出 n\\le 20 个总长不超过 4\\times 10^5 的括号串 s_i ，问将所有 s_i 按照一定顺序拼接起来后最多有多少个前缀为合法括号串。 n\\le 20 这个限制就很灵性，考虑状压 dp。设 f_{S} 为集合 S 内字符串拼起来的答案。 思考转移。假设 S 在加上一个 x 后变成 T ，并假定 x 被接在末尾。 考虑括号串的性质，我们令 \\texttt{'('} = 1 ， \\texttt{')'} = -1 ，然后一个括号串将为合法当且仅当其每个前缀和都为非负且整个的前缀和为 0 。那么不妨处理出每个串的前缀和以及每个状态的串的前缀和之和。 而遍历一个字符串 x 将会形成一个“爬山”的过程，若这个过程中前缀和接触到了 0 ，那么合法的答案将会增加 1 ，若这个过程中前缀和变为了负数，那么这个状态就废掉了——答案不可能再增加。 所以对于每个串，我们需要记录一下其向下“穿过”了每个平面几次。然后在 dp 转移的时候就可以判定了。如果从 S 的高度走向 T 会走到若干次 0 ，那么答案对应累计，若会穿到 0 下面去，说明这个状态就废掉了，判掉即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define il inline#define FOR(i, a, b) for (int i = (a); i &lt;= (b); ++i)using namespace std;const int maxn = 22, maxs = 1 &lt;&lt; 21 | 50;struct String { int minp, sum; map&lt;int, int&gt; H; vector&lt;int&gt; L; int delta; void init(string s) { int p = 0; minp = 1e9; map&lt;int, bool&gt; no; FOR(i, 0, (int)s.size() - 1) { if (s[i] == '(') ++p; else --p; if (s[i] == ')') { if (!no[p]) ++H[p]; } else no[p] = 1; minp = min(minp, p); } sum = p; if (H.empty()) return; delta = H.begin()-&gt;first; int R = H.rbegin()-&gt;first; L.resize(R - delta + 1); for (auto p : H) L[p.first - delta] = p.second; return; } il int query(int x) { x -= delta; if (x &lt; 0 || x &gt;= (int)L.size()) return 0; return L[x]; }} s[22];int dp[maxs], sum[maxs], n;int main() { ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; FOR(i, 1, n) { string str; cin &gt;&gt; str; s[i].init(str); } FOR(S, 0, (1 &lt;&lt; n) - 1) FOR(i, 1, n) if ((1 &lt;&lt; (i - 1)) &amp; S) sum[S] += s[i].sum; memset(dp, -1, sizeof dp); dp[0] = 0; int ans = 0; FOR(S, 1, (1 &lt;&lt; n) - 1) { FOR(i, 1, n) if (S &amp; (1 &lt;&lt; (i - 1))) { int F = S ^ (1 &lt;&lt; (i - 1)); if (dp[F] == -1) continue; int nows = sum[F], cur = dp[F] + s[i].query(-nows); ans = max(ans, cur); if (nows + s[i].minp &lt; 0) continue; dp[S] = max(dp[S], cur); } } cout &lt;&lt; ans &lt;&lt; '\\n'; return 0;} Technocup 2022 — Elimination Round 1 and Codeforces Round #749 (Div. 1+Div. 2) A + B + C + D + F，rk 352，上 CM 了。 1583D - Omkar and the Meaning of Life 考虑寻找每个元素在排列中的下一个数。 对于每个 i ，询问 a_i = 2 ， a_j=1 ，其中 j\\neq i ，如果找到了一个 k ，则不难发现 \\operatorname{nxt}(k) = i 。 询问 a_i = 1 ， a_j = 2 的情况同理。 最后一个拓扑排序就可以求出整个排列。询问次数正好为 2n 。 1583E - Момент цветения 在一张无向图上构造 q 条始末点给定的路径，使得每条边都被覆盖偶数次，输出构造方案或者输出还需要多少条路径才有解。 考虑一张新图：将所有的点保留，为 q 次询问的 a ， b 点连边，若这张图中的各个连通分量都能形成欧拉回路，则一定有解。为什么？考虑原图的 dfs 生成树，每次在新图上走一条边相当于在原图上通过某种方式从 a 走到 b ，而欧拉回路代表着我最终又走回了一开始的起点，其每条边的经过次数必然是偶数。 构造就直接在 dfs 生成树上找路径就行了，倍增即可。 1586F - Defender of Childhood Dreams 给定一张竞赛图，其中边永远从编号小的点连向编号大的，用最少的颜色染这些边使得任何长度 \\ge k 的路径至少有两种颜色的边。 据说是 ZR CSP 七连的原题，亏。 考虑分块。将所有点每 k 个分为一小块，每 k^2 个分为一大块……依此类推，大小为 k 的块内部连一种颜色的边，大小为 k^2 的块内部连一种颜色的边……依此类推。所以一共有 \\lceil\\log_k n \\rceil 种颜色，代码很短。 123456789101112131415int n, k;int getans(int x, int y) { int now = k, ret = 1; while ((x - 1) / now != (y - 1) / now) now *= k, ++ret; return ret;}int main() { read(n), read(k); print((int)ceil(log(n) / log(k)), '\\n'); FOR(i, 1, n) FOR(j, i + 1, n) print(getans(i, j), ' '); return output(), 0;} 绝绝子了属于是。 Codeforces Round #750 (Div.2) 1582D - Vupsen, Pupsen and 0 给定向量 a ，求一个向量 b 使得 a\\cdot b = 0 ，其中向量维数 n\\le 10^5 ， |a_i|\\le 10^4 ，要求 \\sum|b_i|\\le 10^9 。 考虑两两配对，最后三个特判一下。 1582E - Pchelyonok and Segments 重点：找到 k 的范围然后直接 O(n\\sqrt n) 暴力。 由于 \\dfrac{k(k + 1)}{2}\\le n ，所以 k\\le \\sqrt{2n}\\le 447 。然后就可以设计一个 dp：令 f_{i, j} 为当前考虑了 [i, n] ，最前面的选的一段长度为 j ，最大的和。（类似 LIS 的贪心设计）然后转移就随便转移一下。 1234567891011121314151617181920212223242526272829using ll = long long;const int maxn = 1e5 + 5, sqrtn = 500, INF = 2e9;int n, a[maxn];ll sum[maxn], f[maxn][sqrtn];int main() { int T; read(T); while (T--) { read(n); FOR(i, 1, n) read(a[i]), sum[i] = sum[i - 1] + a[i]; int k = 0; while (k * (k + 1) / 2 &lt;= n) ++k; --k; FOR(j, 0, k) f[n + 1][j] = -INF; f[n + 1][0] = INF; DEC(i, n, 1) { FOR(j, 0, k) { f[i][j] = f[i + 1][j]; if (j &amp;&amp; i + j - 1 &lt;= n &amp;&amp; sum[i + j - 1] - sum[i - 1] &lt; f[i + j][j - 1]) chkmax(f[i][j], sum[i + j - 1] - sum[i - 1]); } } int ans = 0; FOR(j, 0, k) if (f[1][j] &gt; 0) ans = j; print(ans, '\\n'); } return output(), 0;} Codeforces Round #754 (Div. 2) 打的有点差劲，A + B + C。 1605D - Treelabeling 给定一棵未标号的树，求一个标号方式使得相邻的 (u,v) 满足 u 的最高位与 v 的最高位不同。 原题意易被翻译成如上，现在考虑如何构造。令 f(x) 为 x 在二进制表示下的最高位（从 0 开始编号）。 先给树二分图染色，然后令黑点个数为 b ，白点个数为 w ，不妨假设 w \\le b ，则显然 w\\le \\lfloor n / 2\\rfloor 。所以可以得到 f(w) \\le f(n) - 1 。 然后还有一个很好的性质，就是满足 f(x) = i 的 x 一共有 2^i 个，因此直接考虑 w 的每一位，若第 i 位为 1 ，则直接将满足 f(x) = i 的 x 分配给白点，剩余的分配给黑点。 于是这样就构造完了，正确性应该是十分显然的。 1605E - Array Equalizer 给定两个序列 \\{a_i\\} 和 \\{b_i\\} ，其中 a_i 是给定的， b_i 除了 b_1 其余都给出。一次操作可以选定一个 i 然后对于所有的 i\\mid j 的 j ， b_j 加上或减去 1 。对于 q 个 b_1 ，问将 \\{a_i\\} 变为 \\{b_i\\} 的最小操作次数。 首先令 b_i = b_i - a_i ，然后问题就变为将 \\{0\\} 变成 \\{b_i\\} 的最小操作次数。然后首先考虑只有一个 b_1 的时候，如何解决这个问题。 然后不难发现，只需要从小到大考虑即可。模拟一下操作： A B_1 B_2 B_3 B_4 B_5 \\cdots B B_1 B_2 B_3 B_4 B_5 \\cdots Add B_1 B_2 - B_1 B_3 - B_1 B_4 - B_2 B_5 - B_1 \\cdots 令 B_1 = x 的话，每次操作加上的数都形如 cx + d ，对操作次数的贡献即为 |cx + d| 。这个 c 和 d 是可以提前预处理出来的。然后的话，现在的目标就是求出一坨 |cx + d| 的和，发现这个可能不太好做，我们拆开绝对值，分类讨论一下： 当 cx + d &gt; 0 ，即 x &gt; -\\dfrac dc ，贡献就为 cx + d 。 当 cx + d&lt; 0 ，即 x&lt;-\\dfrac dc ，贡献为 -cx - d 。 当然，上述条件当且仅当 c &gt; 0 时成立，对于 c &lt; 0 的情况，直接乘个 -1 转换成 c &gt; 0 即可。而 c = 0 的时候，直接统计 d 的贡献即可。所以我们按照 -\\dfrac dc 排序，存储这些一次函数，然后就可以预处理一下前缀和和后缀和，每次二分一下就可以的解了。 事实上， c 就是 \\mu 。所以问题可以得到简化很多。 Technocup 2022 — Elimination Round 2 and Codeforces Round #755 (Div. 1, Div. 2) div 1. A + B。 1588B - Guess the Permutation 给定一个 [1, n] 的有序排列（ n 为 10^9 级别），翻转了 [i, j - 1] 和 [j, k] 。最多 40 次询问，一次询问一个区间的逆序对数，要求最后给出 i ， j 和 k 。 不难发现 i 可以通过二分得到，而 k 似乎也可以二分，但是 2\\log n 就会爆炸。所以只考虑二分出 i ，然后考虑 [i, k] 中逆序对的贡献，令两端的长度为 a 和 b ，则有 f(i, k) = (a - 1)a / 2 + (b - 1)b/2 ，所以我们询问一下 [i + 1, n] ，就可以得到 a 的值，具体地， a = f(i, k) - f(i - 1, k) + 1 ，证明考虑逆序对的性质。 然后不难二分出 b 的值，这题就做完了。 1588C - Game with Stones Codeforces Round #758 (Div.1 + Div. 2) terrible round。A + B + C，rk522。 1608D - Dominoes 首先我们知道，一个染色方案合法当且仅当 W 和 B 的数量相同，以及 WW 和 BB 的数量相同。计算 W 和 B 的数量，若其大于 n ，则显然无解。 否则，无解的情况就是 WB 和 BW 同时存在却没有 WW 或 BB。其他都为合法情况，方案大家可以在草稿纸上尝试进行构造。设问号有 c_0 个，W 有 c_B 个，则显然总染色方案数为 \\dbinom{c_0}{n - c_B} 。然后处理一下无解的情况。 同时存在 WB 和 BW 却没有 WW 或 BB 的方案数其实就是用 不存在 WW 和 BB 的方案数 减去 全是 WB 和 全是 BW 的情况。设 ?? 有 c_P 个，则对于第一个“不存在 WW 和 BB 的”的方案数就是 2^{c_P} ，且不存在 BB 或 WW；对于全是 WB 的至多一种，且不能存在 Bx 或 Wx，全是 BW 同理。 Codeforces Global Round 18 tiring and difficult round. A + B + C。 1615C - Menorah 比较巧妙的题。注意到一次对 i 的操作可以视为改变 i ，然后打上全局标记。 之后我们注意到，第一次操作要操作一开始为 1 的，第二次操作就必须操作一开始为 0 的。之后肯定是 1010\\cdots 交替操作。 预处理一下 same_{i, j} 数组表示 a_k = i ， [a_k = b_k] = j 的 k 的数量（即 a = 1/0 ，与 b 相同/不同的数量），则我们可以发现，一次对 1 同的操作会使得 1 同减一，同时 0 不同加一。 若果我们进行奇数次操作，那么全局翻转标记是有的，要求的就是 same_{1/0, 1} = 0 。所以一共要进行 same_{1, 1} + same_{0, 1} 次操作将所有的相同变为不同，然后因为有翻转，所以我们就能得到答案。这样做的前提条件是 same_{1,1} - same_{0, 1} = 1 。 那么若进行偶数次操作，同理，没有全局翻转标记，要求的就是 same_{1/0, 0} = 0 。所以一共要进行 same_{1, 0} + same_{0,0} 次操作将所有的不同变为相同，答案就能得到了。这样做的前提条件是 same_{1, 0} = same_{0, 0} 。 12345678910111213141516171819const int maxn = 1e5 + 5;char s1[maxn], s2[maxn];int n;int main() { int T; read(T); while (T--) { read(n), read(s1 + 1), read(s2 + 1); int same[2][2] = {0}; FOR(i, 1, n) ++same[s1[i] - '0'][s1[i] == s2[i]]; int ans = 1e9; if (same[1][1] - same[0][1] == 1) ans = same[1][1] + same[0][1]; if (same[1][0] == same[0][0]) chkmin(ans, same[1][0] + same[0][0]); print(ans &gt; n ? -1 : ans); } return output(), 0;} 1615D - X(or)-mas Tree 题意：给定一棵边带权树，有些边权未确定。给定形如 (a, b, c) 的限制表示 a 到 b 路径上的边权异或和的 popcount 的奇偶性为 c 。构造一个给未定权边定权的方案。 定义 \\operatorname{parity}(x) 表示 \\operatorname{popcount}(x)\\bmod 2 ，则我们可以知道 \\operatorname{parity}(x\\oplus y) = \\operatorname{parity}(x)\\oplus \\operatorname{parity}(y) 。所以干脆直接先将树上的所有边权 d 先变成 \\operatorname{parity}(d) 。 令树上前缀异或和为 r_u ，则我们注意到， (a,b) 路径的异或和为 r_a\\oplus r_b 。所以我们现在就有了若干条形如 r_a\\oplus r_b = c 的限制（对于树上已有的边 (u,v, x) 可以看作是 r_u\\oplus r_v = x ）。 对于每个限制 r_a\\oplus r_b = c ，在新图上建一条边 (a, b, c) ，然后考虑二分图染色（一开始钦定一个 r_1 ），这样子就可以求出所有的 r_u 并且判断矛盾。 1615E - Purple Crayon 题意：红蓝双方在一棵 1 为根的树上涂色。红先涂，每次可以选择一个子树内的点涂成红色，但涂的个数不能超过 k 。然后蓝涂，每次可以选择一个子树内的点涂成蓝色，但该子树内不能有红色节点。设最后白、红、蓝三种颜色的点各有 w 、 a 和 b 个，则分数定义为 w(r - b) 。红方想最大化分数，蓝方想最小化分数。双方都绝顶聪明，问最后的分数。 拆开式子： w(r- b) = (n - r - b)(r - b) = r(n - r) - b(n - b) 。所以对于红方，他想要做的就是最大化 r(n - r) 和最小化 b(n - b) 。到了蓝方这里，他一定是想最大化 b(n - b) ，其在 b = \\lfloor n / 2\\rfloor 处有最大值。 另外我们可以发现，红方选择了 u 子树意味着 1 到 u 上的点都不能被蓝方涂色，相当于控制了一条链。为了使得蓝方能达到的最大的 b(n - b) 最小，红方的最优策略一定是尽可能最小化 b 的最大值。所以说，红方尽可能多控制点，一定是最优的。 而且，为了尽可能多控制点，红方选的一定是叶子节点，若选的不是叶子，则选一个儿子节点能控制的节点肯定更多。 所以，我们从大到小取 k 根长链，取的时候算一下蓝方还能涂多少个 b ，若 b &gt; \\lfloor n / 2\\rfloor 则取 b = \\lfloor n / 2\\rfloor 。依此计算答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 2e5 + 5;vector&lt;int&gt; G[maxn];int n, k, son[maxn], h[maxn], fa[maxn], len[maxn], cnt;void dfs1(int u, int pre) { fa[u] = pre; for (auto v : G[u]) { if (v == pre) continue; dfs1(v, u); if (h[v] &gt; h[son[u]]) son[u] = v; } h[u] = h[son[u]] + 1; return;}void dfs2(int u, int topf) { if (!son[u]) { len[++cnt] = h[topf]; return; } dfs2(son[u], topf); for (auto v : G[u]) { if (v == son[u] || v == fa[u]) continue; dfs2(v, v); } return;}int main() { read(n, k); FOR(i, 1, n - 1) { int u, v; read(u, v); G[u].push_back(v), G[v].push_back(u); } dfs1(1, 0), dfs2(1, 1); sort(len + 1, len + cnt + 1, greater&lt;int&gt;()); long long ans = -1e18; int b = n; FOR(a, 1, k) { int x = min(n / 2, b -= len[a]); chkmax(ans, 1ll * (n - a - x) * (a - x)); } print(ans); return output(), 0;} Hello 2022 1621C - Hidden Permutations 交互题，猜一个排列 p （ n\\le 10000 ）。初始有一个排列 q_i = i ，每次可以询问一个 q_i 的值，交互库回答你的询问之后会将 q 替换成 q_i' = q_{p_i} 。最多 2n 次询问，求出 p 。 我们注意到，对 q 施加 q_i = q_{p_i} 的变换这一过程的本质是一个置换。不妨盯着一个 q_i 不放，我们发现其变换下去之后会为 p_i, p_{p_i}, p_{p_{p_i}},\\cdots 会形成一个环，环上 u\\to v 表示 p_u = v 。那么我们就可以每次盯着一个没有求出答案的下标询问，把这部分环找到，这题就解决了。 询问次数的上界刚好为 2n ，卡的很准。 1621D - The Winter Hike 给定 2n\\times 2n 的棋盘，初始有 n^2 个人在左上角的 n\\times n 正方形内（每个格子里面 1 人）。现要将这 n^2 个人通过如下方式移动到右下角的 n\\times n 正方形内（每个格子 1 人）： 选定一行，将其里面所有的人循环往左/右移一格。即对于有人的 (x_0, y) ，我们施变换 (x_0, y)\\to (x_0, y + 1) 或 (x_0, y)\\to(x_0, y - 1) 。在 (x_0, 2n) 和 (x_0, 1) 的特判。 选定一列，将其里面所有的人循环往上/下移一格。即对于有人的 (x, y_0) ，我们施变换 (x, y_0)\\to (x + 1, y_0) 或 (x, y_0)\\to(x - 1, y_0) 。在 (2n, y_0) 和 (1, y_0) 的特判。 操作可以进行任意次。同时有些格子里面有障碍，人不能经过，除掉 (x, y) 的障碍需要花费 c_{x, y} ，可除掉的障碍数不限。问最小花费。 是一道非常巧妙的构造。 首先我们观察一下，发现右下角的 n\\times n 区域是必须除掉的。然后观察一下样例 3 ，发现右下角的权值和为 12 ，说明我们只扣掉了一个多余的 2 。然后注意到挖掉 (2, 3) ， (3, 2) 或者 (1, 4) 和 (4, 1) 都是可以的。方案可以自行尝试构造。 然后我们就发现，我们除了右下角的 n\\times n 要抠掉，只需要在两块 n\\times n 区域四角的交界格点处抠掉一个点就可以了。至于方案构造，就考虑一行行/一列列的移入右下角的区域，可以自行想象一下。这些点一共有 8 个，分别是： (1, 2n) ， (2n, 1) ， (1, n + 1) ， (n + 1, 1) ， (n, n + 1) ， (n + 1, n) ， (n, 2n) ， (2n, n) 。于是这题就做完了。非常妙。 1621E - New School 要开办学校。 n 个老师， m 组学生。第 i 组学生有 k_i 人。老师的年龄分别为 a_1, \\cdots, a_n ，学生的年龄分别为 b_{i, 1},\\cdots, b_{i, k_i} 。要求安排老师到每组学生，满足 每组学生都恰好有一个老师。 一个老师最多带一个组。 一组内，学生的平均年龄不超过老师的年龄。 对于每个学生，求出若其不来上课，课程能否被安排。 1\\le m\\le n\\le 10^5 ， 1\\le a_i,b_{i,j}\\le 10^5 ， 2\\le k_i\\le 10^5 ， \\sum k_i\\le 2\\times 10^5 。 考虑将所有学生组和所有老师降序排序。则有解当且仅当 \\forall 1\\le i\\le m 有 avr_i\\le a_i ，该情况下我们将其一一对应即可。 而当一个学生不来时，其只会影响一个组 i 的平均年龄 avr_i 。对于每一个学生 b_{i, x} ，都可以二分找出没有他之后，整组人的新的位置 j 。这样一来， [j, i) 内的组都会往 i 的方向平移一格。我们需要知道的，就是改变后的局面是否合法。 至于改变之后是否合法，可以记三个前缀和数组（分别维护当前位置，当前位置往左/右平移一格后是否合法）来实现，详见代码。实现较为复杂恶心。同时，需要避开浮点误差。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int maxn = 2e5 + 5;using ll = long long;using pli = pair&lt;ll, int&gt;;int ok[maxn], ok_suf[maxn], ok_pre[maxn], pos0[maxn];pair&lt;pli, int&gt; B[maxn];pli a[maxn];vector&lt;int&gt; c[maxn];bool operator&gt;(const pli &amp;a, const pli &amp;b) {return a.first * b.second &gt; b.first * a.second;}void solve() { int n, m; read(n, m); FOR(i, 1, n) read(a[i].first), a[i].second = 1; FOR(i, 1, m) { int k; read(k); ll sum = 0; c[i].resize(k); FOR(j, 0, k - 1) read(c[i][j]), sum += c[i][j]; B[i] = make_pair(pli(sum, k), i); } sort(a + 1, a + n + 1, operator&gt;); auto cmp = [](const auto &amp;a, const auto &amp;b) {return a.first &gt; b.first;}; sort(B + 1, B + m + 1, cmp); FOR(i, 1, m) { ok[i] = ok[i - 1] + (B[i].first &gt; a[i]);//记录不合法的情况 ok_pre[i] = ok_pre[i - 1] + (B[i].first &gt; a[i - 1]);//记录不合法的情况 ok_suf[i] = ok_suf[i - 1] + (B[i].first &gt; a[i + 1]);//记录不合法的情况 pos0[B[i].second] = i; } FOR(i, 1, m) { for (auto x : c[i]) { pli now(B[pos0[i]].first.first - x, B[pos0[i]].first.second - 1); int to = lower_bound(B + 1, B + m + 1, make_pair(now, i), cmp) - B; if (to &gt; pos0[i]) putchar((now &gt; a[to - 1] || ok[pos0[i] - 1] + ok_pre[to - 1] - ok_pre[pos0[i]] + ok[m] - ok[to - 1]) ? '0' : '1'); else putchar((now &gt; a[to] || ok[to - 1] + ok_suf[pos0[i] - 1] - ok_suf[to - 1] + ok[m] - ok[pos0[i]]) ? '0' : '1'); } } putchar('\\n'); return;}int main() { int T; read(T); while (T--) solve(); return output(), 0;} Codeforces Round #764 (Div. 3) 随缘来做做。 1624F - Interacdive Problem 交互题，猜数字。给定一个正整数 n （ 2 &lt; n\\le 1000 ），要猜一个整数 x 满足 1\\le x &lt; n 。可以进行如下操作： + c，使得 x:=x + c ，然后交互器返回 \\displaystyle\\left\\lfloor\\frac{x}{n}\\right\\rfloor 的值。 ! x，输出答案，当前的 x 的值。 最多 10 次询问。 直觉告诉我们， 2^{10} = 1024 ，所以我们考虑二分出这个 x ，我们只需要每次对二分左右端点同时加上我们给交互库加上的 c 就可以了。我们的思路是尽可能把当前的 x 往其上面的第一个 n 的倍数去凑，所以每次二分的时候加上的都是 n - mid\\bmod n 。然后就可以根据交互库返回的值来一步步框死范围。 123456789101112131415161718192021int add(int x) { cout &lt;&lt; \"+ \" &lt;&lt; x &lt;&lt; endl; int res; cin &gt;&gt; res; return res;}int main() { int n; cin &gt;&gt; n; int l = 1, r = n; while (l &lt; r - 1) { int mid = (l + r) &gt;&gt; 1; int a = n - mid % n; int res = add(a); l += a, r += a, mid += a; if (res == l / n) r = mid; else l = mid; } cout &lt;&lt; \"! \" &lt;&lt; l &lt;&lt; endl; return 0;} 1624G - MinOr Tree 给定一张无向图，定义其生成树的边权为 OR 和，问最小生成树的边权 OR 和。 考虑从高到低按位贪心，用并查集判断该位是不是必须取，不是的话就不取。具体地，令 ans = 2^{30} - 1 ，然后每次先将 ans 的第 j 位去掉，看能否满足存在生成树，若能存在则第 j 位不取。 时间复杂度 O(m\\log a\\log n) 。 123456789101112131415161718192021222324252627282930313233343536373839const int maxn = 2e5 + 5;struct edge { int u, v, w;} e[maxn];int n, m, fa[maxn];int find(int u) {return fa[u] == u ? u : fa[u] = find(fa[u]);}int merge(int u, int v) { u = find(u), v = find(v); if (u == v) return false; return fa[u] = v, true;}int check(int mask) { FOR(i, 1, n) fa[i] = i; int size = n; FOR(i, 1, m) { if ((e[i].w | mask) != mask) continue; if (merge(e[i].u, e[i].v)) --size; } return size == 1;}int main() { int T; read(T); while (T--) { read(n, m); FOR(i, 1, m) read(e[i].u, e[i].v, e[i].w); int ans = (1 &lt;&lt; 30) - 1; DEC(i, 29, 0) { ans ^= (1 &lt;&lt; i); if (!check(ans)) ans ^= (1 &lt;&lt; i); } print(ans); } return output(), 0;} Codeforces Round #765 (Div. 2) 补完了！ 1625D - Binary Spiders 题意：给定一个数集 A ，大小 n\\le 3\\times 10^5 ，要求选出一个大小最大的子集 S ，使得其中元素两两异或的值都大于等于 K 。构造方案。 我们发现两个数字异或起来大于等于 K 的一个必要条件是其二进制表示下，最高的不相同的位大于等于 K 的最高位。即他们在 Trie 上的 LCA 大于等于 K 的最高位。下面令这个第 K 位为 up 。 在 Trie 上递归求解问题。点对分为在左右子树内部和跨越该节点两种情况。 当前 Trie 表示的位数大于 up ，此时左右子树内部的点对都有希望异或大于等于 K ，而跨越该节点的铁定大于 K ，所以递归下去做然后把两边答案合并。 当前 Trie 表示的位数等于 up ，此时我们要么在该子树中选出一个大于等于 K 的元素，要么找一对跨越左右子树的异或大于等于 K 的数对，然后就不用递归下去了。 这个过程应该是自证明的。找大于等于 K 的元素很简单，一直往右子树找最大的即可。找异或大于等于 K 的也很简单，将一个子树内的所有数字提出来，挨个在右边查最大异或对，就可以找到了。 K = 0 的情况需要特判。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980const int maxn = 3e5 + 5;int n, K, a[maxn], up;int ch[maxn * 30][2], val[maxn * 30], tot, root;void insert(int &amp;u, int id, int x, int k) { if (!u) u = ++tot; if (k &lt; 0) return val[u] = id, void(); int c = (x &gt;&gt; k) &amp; 1; insert(ch[u][c], id, x, k - 1); return;}vector&lt;int&gt; getval(int u, int k) { if (!u) return vector&lt;int&gt;(); if (k &lt; 0) return vector&lt;int&gt;{val[u]}; auto r1 = getval(ch[u][0], k - 1), r2 = getval(ch[u][1], k - 1); for (auto xx : r2) r1.push_back(xx); return r1;}int query(int u, int k, int x) { if (k &lt; 0) return val[u]; int c = ((x &gt;&gt; k) &amp; 1) ^ 1; if (!ch[u][c]) return query(ch[u][c ^ 1], k - 1, x); else return query(ch[u][c], k - 1, x);}vector&lt;int&gt; solve(int u, int k) { if (k &lt; up || !u) return vector&lt;int&gt;(); if (k &gt; up) { auto r1 = solve(ch[u][0], k - 1), r2 = solve(ch[u][1], k - 1); for (auto xx : r2) r1.push_back(xx); return r1; } else if (k == up) { vector&lt;int&gt; vec1 = getval(ch[u][1], k - 1), vec2 = getval(ch[u][0], k - 1), ans; if (!vec1.size()) { if (a[vec2.back()] &gt;= K) ans.push_back(vec2.back()); return ans; } if (!vec2.size()) { if (a[vec1.back()] &gt;= K) ans.push_back(vec1.back()); return ans; } bool flag = 0; for (auto x1 : vec1) { int x2 = query(ch[u][0], k - 1, a[x1]); if ((a[x1] ^ a[x2]) &gt;= K) { flag = 1; ans.push_back(x1), ans.push_back(x2); break; } } if (!flag) { if (a[vec1.back()] &gt;= K) ans.push_back(vec1.back()); } return ans; }}int main() { read(n, K); DEC(i, 30, 0) if ((K &gt;&gt; i) &amp; 1) { up = i; break; } if (K == 0) { print(n); FOR(i, 1, n) print(i, ' '); return output(), 0; } FOR(i, 1, n) read(a[i]), insert(root, i, a[i], 30); auto ans = solve(root, 30); if (!ans.size()) print(-1); else { print(ans.size()); for (auto x : ans) print(x, ' '); } return output(), 0;} 1625E1 - Cats on the Upgrade (easy version) 给出如下定义： 定义一个字符串是合法的括号序列（RBS）当且仅当其能通过每次去掉一个 . 或者一个连续的 () 变成空串。 一个 RBS 被称为“简单的”当且仅当其开头和结尾均不为.。 然后给定一个长为 n 的只包含字符 ( 和 ) 的字符串 S 。要求完成如下操作： 给定 l, r ，保证 S_l 为 (， S_r 为 )，其中间的字符均为 .，然后将 S_l 和 S_r 设为 .。 给定 l, r ，询问 S_{[l\\cdots r]} 有多少连续子段为简单的 RBS，保证 S_{[l\\cdots r]} 为简单 RBS。 2\\le n\\le 3\\times 10^5 ， 1\\le q\\le 3\\times10^5 。 easy version 无修改操作。 静态问题的话我们不妨记 p_i 为以 i 结尾的 RBS 的数量，这个东西很好 DP 出来，然后做个前缀和 S_i ，然后会发现 S_r - S_{l} 算重了某些信息。 具体地，多算 RBS 的左端点应该在 [1, l - 1] ，右端点应该在 [l, r] ，这些东西需要减掉。而，我们知道，设这样的 RBS 为 [i,j] ，则 [i, l - 1] ， [l, j] 和 [j + 1, r] 都应该是 RBS。所以这些形如 [i,j] 的 RBS 的数量应该是形如 [i, l -1] 的 RBS 的数量乘上形如 [l, j] 的 RBS 的数量，即为 p_{l - 1}\\times (p_r - p_{l - 1}) 。 1625E2 - Cats on the Upgrade (hard version) hard version 带上修改操作。 上面这种做法的扩展性应该是不太好的。考虑建出括号树（或者说，森林，那些不合法的字符就直接扔掉），一对左右括号是一个节点，类似下面这张图： 然后我们注意到，每次询问肯定都是询问树上一个节点或者若干个同层相邻节点的信息，并且每次操作都是删除叶子节点。我们考虑如何对于一个节点计算只选其儿子能构成 RBS 的数量 g_u ，发现其就是选择 1 个儿子、两个相邻儿子、三个相邻儿子……，设 x 个儿子的话， g_u = x(x+1)/2 。 而我们考虑一个节点 u 代表的 [l, r] 内的 RBS 数量的话，其明显为 \\sum_{u是v祖先} g_v + g_u 是 祖 先 。所以，对于一次询问的 [l, r] ，其肯定包含了一个同层的点集 A ，其答案就再加上 |A|\\times (|A| + 1) / 2 即可。 那么对于一次修改操作，我们思考其改变了什么：无非就是父亲节点的儿子数量减小，我们需要维护每个节点的 g_u ，支持单修区查；然后维护每个点的儿子，同样是单修区查，用树状数组就可以了。 这应该是最简洁的做法了。具体看代码，目前为 CF 最优解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using ll = long long;const int maxn = 3e5 + 5;char s[maxn];int n, q;struct bit { vector&lt;ll&gt; s; int sz; void build(int SZ) {sz = SZ + 5, s.resize(sz); return;} void add(int x, ll v) {for (; x &lt; sz; x += (x &amp; -x)) s[x] += v; return;} ll query(int x) {ll ret = 0; for (; x; x -= (x &amp; -x)) ret += s[x]; return ret;}} T, t[maxn];int son[maxn], fa[maxn], bel[maxn], ord[maxn], size[maxn];int main() { read(n, q); read(s + 1); int cnt = 1, now = 1; FOR(i, 1, n) { if (s[i] == '(') { ord[++cnt] = ++son[now]; fa[cnt] = now, bel[i] = cnt, now = cnt; } else if (now != 1) { bel[i] = now; now = fa[now]; } } T.build(cnt); FOR(i, 1, cnt) { T.add(i, 1ll * son[i] * (son[i] + 1) / 2); t[i].build(son[i]); } DEC(i, cnt, 1) size[fa[i]] += (++size[i]); while (q--) { int op, l, r; read(op, l, r); if (op == 1) { int now = bel[l]; t[fa[now]].add(ord[now], 1); T.add(fa[now], -son[fa[now]]--); } else { l = bel[l], r = bel[r]; ll ans = T.query(r + size[r] - 1) - T.query(l - 1); ll cnt = ord[r] - ord[l] + 1 - t[fa[l]].query(ord[r]) + t[fa[l]].query(ord[l] - 1); ans += cnt * (cnt + 1) / 2; print(ans); } } return output(), 0;} Codeforces Round #766 (Div. 2) 补完了，好！ 1627D - Not Adding 注意到所谓的加入数字的顺序其实无关紧要，为了尽可能多的加数，我们从大到小枚举加的这个数字。 假设其为 i ，然后枚举倍数 j 。我们只需要保证数组内有满足 \\gcd 为 i 的 j 即可。 12345678910111213141516171819202122232425262728const int maxn = 1e6 + 5, N = 1e6;int vis[maxn], n, maxx, ans;int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}int main() { read(n); FOR(i, 1, n) { int x; read(x); vis[x] = 1; chkmax(maxx, x); } DEC(i, maxx, 1) { if (vis[i]) continue; int cnt = 0, f = 0; for (int j = 2 * i; j &lt;= N; j += i) { if (vis[j]) { ++cnt; if (cnt == 1) f = j / i; else f = gcd(f, j / i); } } if (cnt &gt; 1 &amp;&amp; f == 1) vis[i] = 1, ++ans; } print(ans); return output(), 0;} 1627E - Not Escaping n 层楼，每层楼有 m 个房间，要求从 (1,1)\\to(n,m) 。走法有两种： 在同一楼层平移，如 (i, j_1)\\to(i, j_2) ，代价为 x_i\\cdot|j_2 - j_1| 。 通过梯子从 (a_i,b_i)\\to(c_i,d_i) ，代价为 -h_i 。保证有 a_i&lt;c_i 。 问最小代价或者输出无解。 2\\le n,m\\le 10^5 ，梯子总数 1\\le k\\le 10^5 ， 1\\le x_i,h_i\\le 10^6 。 实际上会发现，有用的点不超过 2k + 2 个（起点，终点和梯子的端点），并且梯子都是自下而上的。 因此我们从下往上一层一层的 dp，用当前层的 dp 值更新当前层，然后有梯子的就往上更新。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using ll = long long;using pil = pair&lt;int, ll&gt;;const int maxn = 1e5 + 5;const ll INF = 0x3f3f3f3f3f3f3f3f;ll x[maxn], dp[maxn];struct ladder { int a, b, c, d, h; ladder() {} ladder(int _a, int _b, int _c, int _d, int _h) : a(_a), b(_b), c(_c), d(_d), h(_h) {}};vector&lt;ladder&gt; lad[maxn];map&lt;int, ll&gt; row[maxn];void solve() { int n, m, k; read(n, m, k); FOR(i, 1, n) read(x[i]), vector&lt;ladder&gt;().swap(lad[i]), map&lt;int, ll&gt;().swap(row[i]); FOR(i, 1, k) { int a, b, c, d, h; read(a, b, c, d, h); lad[a].push_back(ladder(a, b, c, d, h)); row[a][b] = INF, row[c][d] = INF; } row[1][1] = 0, row[n][m] = INF; FOR(i, 1, n) { if (row[i].size() &gt;= 2) { pil last = *row[i].begin(); for (auto it = ++(row[i].begin()); it != row[i].end(); last = *it++) chkmin(it-&gt;second, last.second + x[i] * myabs(last.first - it-&gt;first)); last = *row[i].rbegin(); for (auto it = ++(row[i].rbegin()); it != row[i].rend(); last = *it++) chkmin(it-&gt;second, last.second + x[i] * myabs(last.first - it-&gt;first)); } for (auto ld : lad[i]) if (row[ld.a][ld.b] &lt; INF) chkmin(row[ld.c][ld.d], row[ld.a][ld.b] - ld.h); } if (row[n][m] &lt; INF) print(row[n][m]); else print(\"NO ESCAPE\");}int main() { int T; read(T); while (T--) solve(); return output(), 0;} 1627F - Not Splitting 给定一个 k\\times k 的方格（ k 为不超过 500 的偶数），并给定 n （ 1\\le n\\le 10^5 ）对相邻点对 (r_{i,1}, c_{i,1})\\leftrightarrow (r_{i,2}, c_{i,2}) 。然后将这个 k\\times k 方格切分为全等的两块，使得最多的约束条件能被满足（即点对中的两个点在一块上）。 然后我们会发现，这个切分的痕迹应该是关于方格中心对称的。 不妨将其看成一个最短路模型。将其视作一个网格图，若其有限制条件，则边权为 1 ，否则为 0 。 之后就从 (k/2, k/2) 出发，以四周为终点，跑最短路即可。需要注意的的是我们认为经过了 (x,y) 就等同于经过了 (k - x, k - y) ，因为要关于方格中心对称。 是一道非常有意思的题！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#define mktp make_tuplestruct node { int x, y, w; node() {} node(int xx, int yy, int ww) : x(xx), y(yy), w(ww) {} il bool operator&lt;(node rhs) const { return w &gt; rhs.w; }};map&lt;tuple&lt;int, int, int, int&gt;, int&gt; mp;const int fx[] = {1, -1, 0, 0};const int fy[] = {0, 0, 1, -1};bool vis[510][510];int main() { int T; read(T); while (T--) { int n, k; read(n, k); map&lt;tuple&lt;int, int, int, int&gt;, int&gt;().swap(mp); FOR(i, 0, k) FOR(j, 0, k) vis[i][j] = 0; FOR(i, 1, n) { int r1, c1, r2, c2; read(r1, c1, r2, c2); if (r1 &gt; r2) myswap(r1, r2); if (c1 &gt; c2) myswap(c1, c2); if (r1 == r2) mp[mktp(r1 - 1, c1, r1, c1)]++, mp[mktp(r1, c1, r1 - 1, c1)]++; if (c1 == c2) mp[mktp(r1, c1 - 1, r1, c1)]++, mp[mktp(r1, c1, r1, c1 - 1)]++; } priority_queue&lt;node&gt; q; q.push(node(k &gt;&gt; 1, k &gt;&gt; 1, 0)); while (!q.empty()) { auto now = q.top(); q.pop(); if (vis[now.x][now.y]) continue; vis[now.x][now.y] = vis[k - now.x][k - now.y] = 1; if (!now.x || now.x == k || !now.y || now.y == k) { print(n - now.w); break; } FOR(d, 0, 3) { int tx = now.x + fx[d], ty = now.y + fy[d]; if (tx &lt; 0 || tx &gt; k || ty &lt; 0 || ty &gt; k) continue; if (vis[tx][ty]) continue; q.push(node(tx, ty, now.w + mp[mktp(now.x, now.y, tx, ty)] + mp[mktp(k - now.x, k - now.y, k - tx, k - ty)])); } } } return output(), 0;} Codeforces Round #767 (Div. 1 and Div. 2) 能补的补完了。 1628C - XOR-сетка 一个很明显的转化就是每个格子内的数都要贡献奇数次，然后考虑构造。 123456789101112131415161718192021222324252627const int maxn = 1005;int n, vis[maxn][maxn], a[maxn][maxn];const int fx[] = {1, -1, 0 ,0};const int fy[] = {0 ,0, -1, 1};int main() { int T; read(T); while (T--) { read(n); int ans = 0; FOR(i, 1, n) FOR(j, 1, n) read(a[i][j]), vis[i][j] = 0; FOR(i, 2, n) FOR(j, 1, n) { if (!vis[i - 1][j]) { ans ^= a[i][j]; for (int k = 0; k &lt; 4; ++k) { int tx = i + fx[k], ty = j + fy[k]; if (tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; n) continue; vis[tx][ty] ^= 1; } } } print(ans); } return output(), 0;} 上面这个构造的方法就是从第二行开始遍历每个点 (i, j) ，如果遇到 (i - 1, j) 只被覆盖了偶数次，则我们贪心的直接选上 (i, j) 让其被覆盖奇数次。可以发现后面的过程中 (i - 1, j) 不会再被访问。于是这个构造方法的正确性被成功说明。 1628D1 - Game on Sum (Easy Version) Alice 和 Bob 在玩一个游戏， n 轮，他们轮流对 x 操作，已知 x 初始为 0 。每个回合： Alice 先选择一个实数 t\\in[0, k] 。 Bob 选择让 x 变为 x+t 或 x-t ，但是至少要有 m 个回合选择 x + t 。 Alice 想最大化 x ，Bob 想最小化 x 。双方绝顶聪明，问最终的 x 对 10^9 + 7 取模的结果。 1\\le m\\le n\\le 2000 ， 1\\le k\\le 10^9 + 7 。 显然 Bob 会选恰好 m 次增加操作。设 f_{n, m} 表示 n 轮游戏中 Bob 选了 m 次增加操作后最终的 x 。 假设 Alice 当前选了 t ，则 Bob 要选使得分数最小的一种方案，即 f_{n, m}= \\min\\{f_{n - 1, m} - t, f_{n - 1, m - 1} + t\\} 。而 Alice 为了使得 f_{n, m} 最大化，故其会选择一个最优的 t 。这里发现 f_{n - 1, m} - t = f_{n - 1, m - 1} + t 时会最优，故 t = \\dfrac{f_{n - 1, m} - f_{n - 1, m - 1}}{2} 。所以转移方程如下： f_{n, m} = \\frac{f_{n - 1, m} + f_{n - 1, m - 1}}{2} 边界条件是 f_{n, n} = nk ， f_{n, 0} = 0 。直接 DP 即可，复杂度 O(nm) 。 1628D2 - Game on Sum (Hard Version) 将上面的条件改为 1\\le m\\le n\\le 10^6 ，剩余不变。 上面那个东西给了我们什么启示呢？可以单独考虑每个 f_{i, i} 产生的贡献！这个 ik 一看就是一层层往下面像杨辉三角一样扩散。随便推一下式子就可以得到 f_{n,m} = \\sum_{i = 1}^m\\frac{ki}{2^{n - i}}\\binom{n - i - 1}{m - i} O(n) 解决了。需要特判一下 n = m 的情况，需要直接输出 nk ，代码就不放了。 Codeforces Round #768 (Div. 1 and Div. 2) 打得好像有点差的离谱。 1630B - Range and Partition 给定长度为 n 的序列 \\{a_i\\} 和正整数 k ，要求找到一个长度最短的区间 [x, y] 使得能将 \\{a_i\\} 恰好分为 k 段，使得每一段中 \\in[x,y] 的元素数量严格大于 \\notin [x,y] 的元素数量。 1&lt;k\\le n\\le 2\\times 10^5 ， 1\\le a_i\\le n 。 我们先考虑如何判断一个区间 [x, y] 是否合法。不妨设 b_i = \\begin{cases}1&amp;a_i\\in[x,y]\\\\-1&amp;a_i\\notin[x,y\\end{cases} ，然后求出 S = \\sum_{i = 1}^n b_i ，当 S \\ge k 时合法。为什么呢？因为划分出的每一段内， b_i 的和都至少为 1 ，所以总体的 S\\ge k 时就是合法的。 这个区间我们就可以通过二分或者双指针求出来，然后随便构造一下分段方式就有了。 1630C - Paint the Middle 给定长度为 n 的序列 a_i ，一开始 c_i = 0 。可以进行如下操作： 选择 1\\le i &lt; j &lt; k\\le n ，满足 c_i = c_j = c_k = 0\\land a_i = a_k ，然后 c_j:=1 。 问若干次操作之后最大的 \\sum_{i = 1}^nc_i 。 3\\le n\\le 2\\times 10^5 。 该做法来自评论区。DP，设 f_i 为区间 [1, i] 的答案，显然 f_1 = 0 。有如下 3 种转移到 f_i 的办法： a_i 在 a_j 出现过（ j &lt; i ），考虑将 (j, i) 全部涂色，则 f_i = f_j + (i - j - 1) 。 a_i 在 a_k 出现过（ k &lt; j &lt; i ），考虑取 f_j 的最优解但是留下 c_k 不涂，然后再涂上 [j, i) ，同样有 f_i = f_j + i - j - 1 。 直接继承 f_{i - 1} ，写规范一点就是 f_i = f_{i - 1} + (i - (i - 1) - 1) 。 于是若我们令 \\mathrm {first}(a_i) 表示 a_i 第一次出现时的下标，则转移方程就有了： f_i = \\max_{\\mathrm{first}(a_i)\\le j &lt; i}\\{f_{j} - j \\} + i - 1 此时这个做法是 O(n^2) 的，需要优化。改写转移方程： f_i - i = \\max_{\\mathrm{first}(a_i)\\le j &lt; i\\lor j = i - 1}\\{f_{j} - j \\} - 1 不难发现这可以拿一个维护 f_i - i 的最大值的线段树来优化，于是 O(n\\log n) 。代码太弱智不放了。 Codeforces Round #769 (Div. 2) 打的很差。 1632D - New Year Concert 给定一个长度为 n 的正整数组 a 。对于一个长度为 k 的正整数组 b ，定义 f(b_1,b_2,\\cdots,b_k) 为使得对于所有的 1\\leq l\\le r\\le k ，都有 \\gcd\\{b_l,b_{l+1},\\dots,b_r\\}\\neq r-l+1 的最少操作次数，其中一次操作可以将数组中的一个数改为任意正整数。现在，请求出 f(a_1),f(a_1,a_2),\\cdots,f(a_1,a_2,\\cdots,a_n) 的值。 1\\le n\\le 2\\times 10^5 ， 1\\le a_i\\le 10^9 。 我们一个个来处理。设 f_i 为 [1, i] 的答案，若不存在 l 使得 \\gcd\\{a_l, \\cdots, a_i\\} = i - l + 1 ，则 f_i = f_{i - 1} ，否则 f_i = f_{i - 1} + 1 ，并且需要修改 a_l 为一大质数。 考虑查找 l ，根据后缀 \\gcd 的单调不增性，且不同后缀 \\gcd 只有 O(\\log) 种，所以可以二分。这里使用 ST 表来查询区间 \\gcd 。 12345678910111213141516171819202122232425262728293031const int maxn = 2e5 + 5;int n, a[maxn], f[maxn], st[21][maxn], lg[maxn];int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}il int query(int l, int r) { int len = lg[r - l + 1]; return gcd(st[len][l], st[len][r - (1 &lt;&lt; len) + 1]);}int main() { read(n); FOR(i, 1, n) read(a[i]), lg[i] = i &gt; 1 ? lg[i &gt;&gt; 1] + 1 : 0, st[0][i] = a[i]; FOR(j, 1, lg[n]) FOR(i, 1, n + 1 - (1 &lt;&lt; j)) st[j][i] = gcd(st[j - 1][i], st[j - 1][i + (1 &lt;&lt; (j - 1))]); FOR(i, 1, n) { f[i] = f[i - 1]; for (int j = i; j &gt; 0; ) { int g = query(j, i), now = j; DEC(k, lg[n], 0) if (j &gt; (1 &lt;&lt; k) &amp;&amp; query(j - (1 &lt;&lt; k), i) == g) j -= (1 &lt;&lt; k); if (g &lt;= i - j + 1 &amp;&amp; g &gt;= i - now + 1) { f[i] = f[i - g] + 1; break; } --j; } print(f[i], ' '); } return output(), 0;} 1632E - Distance Tree n 个节点的树，每条边权为 1 ，定义： d(v) 为节点 1 到 v 的距离。 f(x) 为在任意两点 a, b 间添加一条权为 x 的边后， \\max_{1\\le v\\le n}\\{d(v)\\} 的最小值。 对于 \\forall x\\in[1, n] ，求出 f(x) 。Easy ver. 2\\le n,\\sum n\\le 3000 ​。Hard ver. 2\\le n,\\sum n\\le 3\\times 10^5 。 通过简单观察可以发现加的这条边的一个端点一定是 1 号点，可以反证。接下来钦定 1 为根。 之后会发现正着做似乎有点难搞。不妨思考一下如果给定了一个距离 y 然后反推边权 x 的范围，首先发现连边一定连深度大于 y 的边。 然后，设这些点构成的点集为 K(y) ，则考虑从 1 连哪个 v 能够使得最大的距离尽量小。发现连 K(y) 的直径中点是最优的，因为需要满足 x + \\operatorname{dis}(v, u)\\le y 。而 \\operatorname{dis}(v, u) 的最大值在当 v 为直径中点时取到最小，为 \\lceil \\mathrm{diameter} / 2 \\rceil ，不妨设其为 f(y) ，然后我们可以通过一个 O(n) 的树形 dp 来求出所有的 f(y) ，然后由于 f(y) 随 y 的增大而单调不增，所以可以双指针 O(n) 求出答案。 DP 的流程如下：对于每个节点，找到两个深度最大的儿子（即长链），设两个链底的深度分别为 a 和 b ，其中 a\\ge b ，则 f(b - 1) 就可以用 a + b - 2d_u 来更新了，代码中写的不太一样。然后再对所有的 f 来一个后缀最大值就可以了。 123456789101112131415161718192021222324252627282930313233343536const int maxn = 3e5 + 5;vector&lt;int&gt; G[maxn];int n, f[maxn];int dfs(int u, int fa, int d) { int a = 0, b = 0; for (auto v : G[u]) { if (v == fa) continue; int c = dfs(v, u, d + 1) + 1; if (c &gt; a) b = a, a = c; else chkmax(b, c); } if (b + d) chkmax(f[b + d - 1], (a + b + 1) &gt;&gt; 1); return a;}int main() { int T; read(T); while (T--) { read(n); FOR(i, 1, n) vector&lt;int&gt;().swap(G[i]), f[i] = 0; FOR(i, 1, n - 1) { int u, v; read(u, v); G[u].push_back(v), G[v].push_back(u); } int lim = dfs(1, 0, 0); DEC(i, n - 2, 0) chkmax(f[i], f[i + 1]); int ans = 1; FOR(i, 1, n) { while (i + f[ans] &gt; ans) ++ans; print(min(ans, lim), \" \\n\"[i == n]); } } return output(), 0;} Codeforces Global Round 19 1637D - Yet Another Minimization Problem 值域很小，拆分贡献之后发现可以定义 f_{i, s_1} ，然后就可以 O(n^3) dp 了。 1637E - Best Pair 首先这题有一个非常关键的性质就是，不同的 cnt_i 只有 O(\\sqrt n) 种。 因此我们枚举 cnt_x 和 cnt_y\\le cnt_x ，这样子复杂度就是 O(n) 的，从大到小找到第一个不和 a_i 形成 bad pair 的 j （可以用 set 维护， O(\\log n) ），这样的复杂度是 O(n\\log n) 的。 1637F - Towers 给定 n 个节点的树，第 i 个点的高度为 h_i 。可以在 n 个点上建任意多个塔，对于每个塔可以指定其能量 e 和其所在点的编号。建立能量为 e 的塔消耗 e 枚金币。 一个点 x 接收到信号当且仅当存在信号塔在点 u 和点 v （允许 x = u 或 x = v ，但是 u\\ne v ），满足 \\min(e_u, e_v)\\ge h_x 且 x 在链 (u, v) 上。 求一个让所有点接收到信号的最小代价。 2\\le n\\le 10^5 ， 1\\le h_i\\le 10^9 。 比较牛逼的贪心。经过观察可知只有叶子节点放信号塔是最优的，否则一定可以调整到只放叶子节点。 然后，不妨令 h 值最大的为根，那么我们就可以选择两个叶子 x, y 放上 h_\\max 的塔，然后 x, y 链上所有的点都会被覆盖掉。于是，剩下的所有点都只需要有某个子树的信号塔大于等于 h_u 即可。 考虑贪心，令 f_u 为 u 子树内 h 的最大值，然后对于叶子节点，答案加上 h_u ，对于非叶子节点，若其不是根，答案加上 \\max(0, h_u - \\max_{v\\in son(u)} f_v) ，若其是根，答案加上 2h_u 减去子树内最大的两个 h 值。 O(n) ，很优秀。 Codeforces Round #771 (Div. 2) 1638D - Big Brush 给定一个染了色的网格，要求构造方案从空白染成这样。 一次可以涂一个 2\\times 2 ，可以覆盖， n,m\\le 1000 。 考虑时光倒流，别人涂色我们刮刮乐。我们可以从若干个 2\\times 2 为起点来进行操作，没有 2\\times 2 就说明无解。然后就 bfs 即可。 1638E - Colorful Operations 给定一个长度为 n 的序列，初始时所有元素的值为 0 ，颜色为 1 。你需要实现以下三种操作： Color l r c ：把 [l,r] 这段的元素颜色改为 c ； Add c x：把所有颜色为 c 的元素值都加上 x ； Query i：输出元素 i 的值。 n,q\\le 10^6 。 颜色段均摊傻逼题，技不如人甘拜下风。 考虑对于修改同种颜色的操作，对其维护一个全局加标记。并用一个线段树维护一下所有的元素的值，输出的时候就输出单点修改 + tag 值。 然后，修改颜色的操作就硬递归，找到一段相同颜色的段之后加上原来的 tag 再减去新的 tag。由于一次染色操作最多添加一次连续段，所以一次操作均摊复杂度为 O(\\log n) 。 总 O((n + q)\\log n) ，随便维护一下就行了。 Codeforces Round #772 (Div. 2) 打出了有史以来最高的 perf，A + B + C + D + E。 1635F - Closest Pair n 个二元组 (x_i, w_i) ， |x_i|,w_i\\le 10^9 ， n\\le 3\\times 10^5 ， x_i 升序。 q\\le 3\\times 10^5 次询问，给出 [l,r] ，求 \\min_{l\\le i&lt;j\\le r}|x_i - x_j|(w_i + w_j) 一眼数据结构题，静态询问考虑离线。 考虑哪些 (i,j) 是不优的。 若存在 p 和 q ，使得 x_p &lt; x_q\\land w_p &gt; w_q ，则 q 作为 i 一定比 p 优。 若存在 p 和 q ，使得 x_p &lt; x_q\\land w_p&lt;w_q ，则 p 作为 j 一定比 q 优。 于是，令 L_i = \\max\\{j:j&lt;i\\land w_j\\le w_i\\} ， R_i = \\min\\{j:j&gt;i\\land w_j\\le w_i\\} ，答案就只能取形如 [i, R_i] 或 [L_i, i] 的区间。这样的区间一共有 2n 个。 先用单调栈求出所有的 L_i 和 R_i ，再计算出这 2n 个区间 [l_i, r_i] 的价值 c_i ，在每个 r_i 上挂上标记 (l_i, c_i) ，在每个询问 (i, ql, qr) 的 qr 上挂上标记 (ql, i) 。然后扫描线扫右端点，线段树或者树状数组维护一下 RMQ 和单点修改，这题就做完了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using ll = long long;using pll = pair&lt;ll, ll&gt;;const int maxn = 3e5 + 5;int n, m, L[maxn], R[maxn], stk[maxn], top;ll t[maxn &lt;&lt; 2], ans[maxn];pll a[maxn];vector&lt;pll&gt; op[maxn], q[maxn];il ll calc(int i, int j) {return myabs(a[i].first - a[j].first) * (a[i].second + a[j].second);}#define L (k &lt;&lt; 1)#define R (L | 1)#define M ((i + j) &gt;&gt; 1)void modify(int i, int j, int k, int x, ll v) { if (i == j) { chkmin(t[k], v); return; } if (x &lt;= M) modify(i, M, L, x, v); else modify(M + 1, j, R, x, v); t[k] = min(t[L], t[R]); return;}ll query(int i, int j, int k, int x, int y) { if (x &lt;= i &amp;&amp; y &gt;= j) return t[k]; ll ret = 2e18; if (x &lt;= M) chkmin(ret, query(i, M, L, x, y)); if (y &gt; M) chkmin(ret, query(M + 1, j, R, x, y)); return ret;}#undef L#undef R#undef Mint main() { read(n, m); FOR(i, 1, n) read(a[i].first, a[i].second); FOR(i, 1, m) { int l, r; read(l, r); q[r].push_back({l, i}); } FOR(i, 1, n) { while (top &gt; 0 &amp;&amp; a[stk[top]].second &gt; a[i].second) --top; L[i] = stk[top], stk[++top] = i; } top = 0; DEC(i, n, 1) { while (top &gt; 0 &amp;&amp; a[stk[top]].second &gt; a[i].second) --top; R[i] = stk[top], stk[++top] = i; } FOR(i, 1, n) { if (L[i]) op[i].push_back({L[i], calc(L[i], i)}); if (R[i]) op[R[i]].push_back({i, calc(i, R[i])}); } memset(t, 0x3f, sizeof t); FOR(i, 1, n) { for (auto &amp;p : op[i]) modify(1, n, 1, p.first, p.second); for (auto &amp;p : q[i]) ans[p.second] = query(1, n, 1, p.first, i); } FOR(i, 1, m) print(ans[i]); return output(), 0;} Educational Codeforces Round 123 (Rated for Div. 2) 下小分场。 Codeforces Round #773 (Div. 1) 1641B - Repetitions Decoding 其实这题出的很不错来着，但是毒瘤是真的毒瘤。 给定长度为 n （ 1\\le n\\le 500 ）的正整数序列 a ，可以进行形如 (x, c) 的操作：在 a_x 后面插入两个连续的正整数 c （ x\\in[0, \\text{the length of }a] ）。构造操作方案使得 a 最后可以拆分为若干个连续的子段，这些子段满足：长度为 2k ， k 为任意正整数，且 \\forall i\\in [1, k] 有 a_i = a_{i + k} 。 保证 \\sum n^2\\le 2.5\\times 10^5 ，操作次数需 \\le 2n^2 ，若无解则报告之。 首先，注意到每种数字的出现次数必须为偶数次，因为添加数字一定是给某种数字添加两个，若存在出现了奇数次的数字则无论如何都没办法找到与之配对的数，所以无解。 然后可以注意到，我们可以对一个前缀做翻转操作，具体地，看下面的例子： 12341 2 3 1 3 21 2 3 - 1 2 3 3 2 1 - 1 3 2 // 这一步可以通过 3 次操作实现(1 2 3 | 1 2 3) - 3 2 1 1 3 2 // 即我们构造一个回文串，然后将前面的合并到一段，前缀就成功被翻转了。 而通过这样，我们就可以将两个 1 放在一起，再反转一下： 12(1 2 3 | 1 2 3) - (3 2 1 1 | 3 2 1 1) - 1 1 2 3 - 3 2 然后两个 1 就顺理成章的在一起了，可以放在一段消掉了。 12(1 2 3 | 1 2 3) - (3 2 1 1 | 3 2 1 1) - (1 | 1) 2 3 3 2 接下来就解决 2 3 3 2 就行了，思路是一样的。 通过这样的操作，我们就能在 O(n^2) 的操作次数下，将两个数“两两合并”，解决这道题目。 输出方案比较毒瘤，大家写的时候需要注意细节。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using pii = pair&lt;int, int&gt;;const int maxn = 505;int n, a[maxn], alreadyLen, now;vector&lt;pii&gt; op;vector&lt;int&gt; ans;map&lt;int, int&gt; vis;void rev(int pos) { FOR(i, now + 1, pos - 1) op.push_back({i - now + alreadyLen + pos - 2, a[i]}); ans.push_back(2 * (pos - now - 1)); alreadyLen += 2 * (pos - now - 1); reverse(a + now + 1, a + pos); return;}int main() { int T; read(T); while (T--) { read(n); decltype(vis)().swap(vis); FOR(i, 1, n) read(a[i]), ++vis[a[i]]; bool flg = 1; for (auto &amp;p : vis) if (p.second &amp; 1) flg = 0; if (!flg) { print(-1); continue; } decltype(op)().swap(op); decltype(ans)().swap(ans); alreadyLen = 0, now = 0; while (now &lt; n) { if (now == n - 2) { ans.push_back(2); break; } int pos = 0; FOR(i, now + 2, n) if (a[i] == a[now + 1]) { pos = i; break; } rev(pos), rev(pos + 1); ans.push_back(2); now += 2; } print(op.size()); for (auto &amp;p : op) print(p.first, p.second); print(ans.size()); for (auto x : ans) print(x, ' '); putchar('\\n'); } return output(), 0;} Codeforces Round #781 (Div. 2) rnm退钱。 1665C - Tree Infection 读错题就一直想呗，想呗，哈哈。 直接转化成一个节点的儿子个数的问题。显然从儿子最多的挨个点传染。所以模拟一下这个过程即可。 1665D - GCD Guess 猜 1\\le x\\le 10^9 ，最多 30 次询问，每次可以查询 \\gcd(x + a, x + b) 。要求 a\\ne b,1\\le a,b\\le 2\\times 10^9 。 注意到 30 次询问非常灵性，相当于明示我们要按位考虑。具体地我们可以思考 x\\bmod 2^k 的值。 首先我们知道 x\\bmod 2^0 = 0 ，考虑如何从 x\\bmod 2^k 推得 x\\bmod 2^{k+1} 。其中间的差值要么是 0 要么是 2^k ，那么不妨令 x \\bmod 2^k = r ，则我们询问 \\gcd(x + 2^k - r, 2^{k + 1}) ，若结果为 2^{k + 1} 则 x\\bmod 2^{k + 1} = r + 2^k 。 具体地询问就是问 \\gcd(x + 2^k - r, x + 2^k + 2^{k+1}-r) ，可以发现刚好问 30 次。 1665E - MinimizOR 静态查询区间 [l, r] 内 \\min_{i\\ne j,l\\le i,j\\le r}\\{a_i\\lor a_j\\} 。 n\\le 10^5 ， 0\\le a_i&lt; 2^{30} 牛逼结论题。。结论是 &lt; 2^k 的数字中的答案只可能从最小的 k + 1 个数字中产生。于是线段树维护一下区间内最小的 31 个数即可，时间复杂度 O(n\\log^2n) 。 下面用归纳法证明： 当 k = 1 时，所有数都为 0 ，显然成立。 下面说明 k\\to k + 1 ： 若第 k 位的 0 的个数 \\le 1 ，则这一位最后或起来肯定是 1 ，问题变为 &lt; 2^k 的情况， k + 1 个数字即可， k + 2 个肯定也可以。 否则第 k 位我们贪心地强制其为 0 ，故答案只与第 k 位为 0 的数字有关。显然 k + 2 个也能满足需求。 证毕。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"博弈论","slug":"game-theory","permalink":"https://old.blog.imyangty.com/tags/game-theory/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"拓扑排序","slug":"toposort","permalink":"https://old.blog.imyangty.com/tags/toposort/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"},{"name":"根号分治","slug":"sqrt-division","permalink":"https://old.blog.imyangty.com/tags/sqrt-division/"},{"name":"二分图","slug":"bi-graph","permalink":"https://old.blog.imyangty.com/tags/bi-graph/"},{"name":"长链剖分","slug":"lld","permalink":"https://old.blog.imyangty.com/tags/lld/"},{"name":"强连通分量","slug":"scc","permalink":"https://old.blog.imyangty.com/tags/scc/"}]},{"title":"CF1000E We Need More Bosses","slug":"sol-cf1000e","date":"2021-02-04T12:12:31.000Z","updated":"2022-03-23T04:18:30.670Z","comments":true,"path":"sol-cf1000e/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf1000e/","excerpt":"","text":"题意 给定一个 n 点 m 边的无向图，找到 s 和 t 使得从 s 到 t 的路径上必须经过的边数最多。求这个最多边数。 思路 必须经过的边即指割边。因此可以考虑把每个边双连通分量缩成一个点，不难发现其生成的必然是一棵树（不能有环，有环了就还有边双）。树上的各个边都是割边，而我们要寻找的是最大的割边边数，因此考虑找这棵树的直径。 写这种实现较为复杂的题的代码的时候一定要保持思路清晰： Tarjan 找出每个点属于的边双 建立新树 在新树上挑一个点找到直径的一个端点 找到直径的另一个端点 这里使用了 namespace 以保持随时思路清晰（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline int min(int a, int b) {return a &lt; b ? a : b;}const int maxn = 3e5 + 5;namespace before{ int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt = 1; int bel[maxn], dfn[maxn], low[maxn], idx; int stk[maxn], top = 0, newtot; void add(int u, int v) { to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return; } void tarjan(int u, int from) { dfn[u] = low[u] = ++idx; stk[++top] = u; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (i == (from ^ 1)) continue; if (!dfn[v]) { tarjan(v, i); low[u] = min(low[u], low[v]); } else low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { ++newtot; int _u; do { _u = stk[top--]; bel[_u] = newtot; } while (u != _u); } return; }}namespace after{ int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt; void add(int u, int v) { to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return; } int d, maxdist; void dfs(int u, int fa, int dist) { if (dist &gt; maxdist) d = u, maxdist = dist; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs(v, u, dist + 1); } return; }}namespace before{ bool vis[maxn]; void dfs(int u, int fa) { vis[u] = 1; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (vis[v]) continue; if (bel[u] != bel[v]) { after::add(bel[u], bel[v]); after::add(bel[v], bel[u]); } dfs(v, u); } return; }}int main(){ int n = read(), m = read(); FOR(i, 1, m) { int u = read(), v = read(); before::add(u, v); before::add(v, u); } before::tarjan(1, -1); before::dfs(1, 0); after::dfs(1, 0, 0); after::maxdist = 0; after::dfs(after::d, 0, 0); printf(\"%d\\n\", after::maxdist); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"缩点","slug":"shrink","permalink":"https://old.blog.imyangty.com/tags/shrink/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"树的直径","slug":"diameter-of-tree","permalink":"https://old.blog.imyangty.com/tags/diameter-of-tree/"}]},{"title":"CF911F Tree Destruction","slug":"sol-cf911f","date":"2021-02-03T14:28:41.000Z","updated":"2022-03-23T04:18:30.737Z","comments":true,"path":"sol-cf911f/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf911f/","excerpt":"","text":"题意 给定一棵无根树，每次操作选两个叶子，把两者的距离加入贡献然后删掉其中一个，求最大贡献及对应方案 思路 不难发现离一个叶子节点最远的点必然是直径的一个端点，不妨删除这个叶子节点，这样既可以使破坏该节点产生的贡献最大又可以不用破坏直径。 先找出直径，然后删叶子，最后挨个删直径即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}const int maxn = 2e5 + 5;int n, head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt;void add(int u, int v){ to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; return;}int maxdist = 0, d1, d2;int dis[2][maxn];void dfs1(int u, int fa, int dist, int &amp;d, int tag){ if (dist &gt; maxdist) d = u, maxdist = dist; if (tag &gt; -1) dis[tag][u] = dist; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v == fa) continue; dfs1(v, u, dist + 1, d, tag); } return;}int diameter[maxn], tot = 0;long long ret = 0;struct node{ int a, b, c; node(){} node(int u, int v, int w) {a = u, b = v, c = w;}} ans[maxn];bool dfs2(int u, int fa){ bool flag = 0; if (u == d2) return diameter[++cnt] = u, 1; for (int i = head[u]; i; i = nxt[i]) { int v = to[i]; if (v == fa) continue; if (dfs2(v, u)) diameter[++cnt] = u, flag = 1; } if (!flag) if (dis[0][u] &gt; dis[1][u]) ans[++tot] = node(u, d1, u), ret += dis[0][u]; else ans[++tot] = node(u, d2, u), ret += dis[1][u]; return flag;}int main(){ n = read(); FOR(i, 1, n - 1) { int u = read(), v = read(); add(u, v); add(v, u); } dfs1(1, 0, 0, d1, -1); maxdist = 0; dfs1(d1, 0, 0, d2, 0); dfs1(d2, 0, 0, d1, 1); cnt = 0; dfs2(d1, 0); FOR(i, 1, cnt - 1) ans[++tot] = node(diameter[i], d1, diameter[i]), ret += dis[0][diameter[i]]; printf(\"%lld\\n\", ret); FOR(i, 1, tot) printf(\"%d %d %d\\n\", ans[i].a, ans[i].b, ans[i].c); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"树的直径","slug":"diameter-of-tree","permalink":"https://old.blog.imyangty.com/tags/diameter-of-tree/"}]},{"title":"CF734E Anton and Tree","slug":"sol-cf734e","date":"2021-02-03T14:25:29.000Z","updated":"2022-03-23T04:18:30.731Z","comments":true,"path":"sol-cf734e/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf734e/","excerpt":"","text":"题意 给定一棵 n 个节点的树，每个节点黑或白，每次可以使同种颜色的连通块变色，求使树变为同种颜色的最少操作次数。 思路 首先考虑将相邻连通块缩为一点（简单，一遍 dfs 解决），然后设新树直径为 d ，答案为 \\displaystyle\\left\\lfloor\\frac{d + 1}2\\right\\rfloor 。 为什么？考虑从直径中央开始反复横跳颜色，不难发现新树的颜色必须是相邻不同的，而直径明显为最长链，只考虑直径即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline int max(int a, int b) {return a &gt; b ? a : b;}const int maxn = 200000 * 2 + 5;namespace old{ int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt; int n, val[maxn]; void add(int u, int v) { to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; }}namespace after{ int tot; int head[maxn], to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], cnt; void add(int u, int v) { to[++cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; } int maxdist = 0, d = 0; void dfs(int u, int fa, int dist) { if (dist &gt; maxdist) maxdist = dist, d = u; for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; dfs(v, u, dist + 1); } }}namespace old{ void dfs(int u, int fa, int bel) { for (int i = head[u]; i; i = nxt[i]) { int &amp;v = to[i]; if (v == fa) continue; if (val[u] == val[v]) dfs(v, u, bel); else { int _bel = ++after::tot; after::add(bel, _bel); after::add(_bel, bel); dfs(v, u, _bel); } } }}int main(){ old::n = read(); FOR(i, 1, old::n) old::val[i] = read(); FOR(i, 1, old::n - 1) { int u = read(), v = read(); old::add(u, v); old::add(v, u); } old::dfs(1, 0, ++after::tot); after::dfs(1, 0, 0); after::maxdist = 0; after::dfs(after::d, 0, 0); printf(\"%d\\n\", (after::maxdist + 1) &gt;&gt; 1); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"缩点","slug":"shrink","permalink":"https://old.blog.imyangty.com/tags/shrink/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"树的直径","slug":"diameter-of-tree","permalink":"https://old.blog.imyangty.com/tags/diameter-of-tree/"}]},{"title":"WC2021 游记","slug":"travels-wc2021","date":"2021-02-02T09:18:00.000Z","updated":"2022-03-23T04:20:07.501Z","comments":true,"path":"travels-wc2021/","link":"","permalink":"https://old.blog.imyangty.com/travels-wc2021/","excerpt":"","text":"Day -inf NOIP 只有 97pts 的屑。。。也是花了 2.9k 报了 WC。 线 上 冬 眠 营 第一课堂第二课堂限额严重差评 Day 0 躺在床上睡不着被子好热/kk 还没有试过传说中的 zoom Day 1 七点半就醒来了（不符合我的风格），马上配置好 zoom 挂着。 广告完了是，开幕式，没听什么，去洗漱了，隐隐约约听到一句“好在今年的冬令营没有在夏天办”，我？？？？？ 然后就是无休无止的 ccf 广告。。。半个小时过去了就开始了 上午 dp，下午期望。dp 没听什么东西，晚上算是把所谓轮廓线搞懂了。期望就是全程开飞机跟不上（（（还顺带被往届学长嘲讽/kk 中午被迫自己煮饭，补了会题，晚上补了会题。 当天晚上我在 QQ 空间如是写道 WC Day 1 ccf逮人效率好评 老师讲课语速和口音都奇奇怪怪的 上午讲区间dp的时候觉得简单眯了会 醒来就到四边形不等式开始开飞机了 然后讲状压我又差点睡昏 醒来发现在讲插头dp了 草了每次都刚好在不会的东西中途醒来 下午概率期望全程又nm听不懂 “这不TM显然吗”------某gyyzoi往届选手 抢个红包抽个卡搞出n多花样 结果课讲错好多又没讲完 期望dp都好难啊草 知道你方法是对的但为什么我方法错了啊md 我爬爬爬爬爬 简直晕死了 员交没来（自我评价准确） Day 2 早上我眯了一会，然后起来的时候发现 第 二 课 堂 登 不 进 去 了 啊这，同学跟我说会议室里面没有满人，但是第二课堂就是进不去？？？？大家纷纷在微信群里面反映问题，CCF 置之不理第二课堂满了可以去第一课堂。第一课堂《IOI题目选讲》里面只有三百来人？？好像大家都想来听网络流（bushi）。 突然我玄学的就挤进了等待室然后被放进去了（，进去之后发现老师还在讲 EK，还手 把 手 教 写 代 码。（那没事了）于是继续听 Dinic 和一些最大流例题。前面几道勉勉强强跟得上，老师差点就把第一题的代码也写了，（如果真那样怕是连费用流都讲不到）。 一开始听得可认真了，一到 LIS 问题和魔术球问题就掉线了（草），到星际转移问题突然又跟上了（？？？）好吧于是在上下界网络流又懵逼了，低保网络和增量网络是什么啊啊啊啊为什么又可以增超级源超级汇啊啊啊啊...... 离下课还有半个小时的时候，老师看到讲不完了，突然问 linhe “是不是我只要在下午开始之前讲完就可以了”，可惜被拒绝了（（（（。此时课件才到一半，开始费用流了，然后我就彻底掉线了。之前只打过费用流板子，讲例题的时候全程懵，但出乎意料的是 12:12 的时候居然成功 rush 完了？？？ 下午开始字符串，第二课堂仍旧好多人（ “暴力怎么做？啊？”“加边加边加边，并查集查询” lj yyds 好吧。 挣扎地听完了 Manacher，最小表示法，KMP，exKMP，AC 自动机之后到了 SA 就开始开飞机了（（（（（（好吧我承认我太菜了。 讲道理为什么字符串这么难啊我淦。 不愧是冬眠营。 员交移到明天了，我还是不打算去 Day 3 彻底颓废惹。 上午树论看到那 170+ 页的 ppt 的时候我心脏骤停了事实证明人家十一点就把 ppt 读完了 smjb 树的直径那里勉强能冲，越到后面就越蒙（好吧我菜是真的菜），好多 CF 的题，课件的风格像是学长做的。老师越到后面越读课件 后面打开了个莫名其妙的 pdf，草了最后又不发/kk 没关系反正上面的题号我都抄起了 下午第二课堂的课件一看都是普及组，草了，去第一课堂。 第一课堂就是真正的冬眠了，IOI 题还没讲完就撑不住了（。到后面开始线性代数之后就遭不住了，跑去医院粘掉了的牙套钉了。 （贵阳话）天，你咋会掉三颗钉钉哦 被医生嫌弃了（ 和某人的关系出了点问题，心情低落。 Day 4 第二课堂没了，废了。 上午的逻辑挣扎到 11:00 就去水知乎了（反面示范），但那些奇奇怪怪的理论真的好高级（xmsl） 下午没听（看了课件梗概是并行计算。好有意思的样子 心情十分糟糕（不是因为 WC） 晚上睡得很早，明天 rp++ 所以最后也没给个准信说怎么测试，好在确实弄清楚了是线上测试。 Day 5 开题，T1 括号序列，看完了不会。T2 表达式求值，看完了不会。T3 斐波那契，看完了发现数据太大只能冲 n^3 规模的，错误的认为循环节是 m^2 级别的（神 tm 下午讲题说 6n ） 继续发呆 T2 发现暴力不会打。 T1 暴力爆炸了。 妈问吃不吃 KFC，我说好。 奇迹发生了，T1 重构的乱搞暴力过前三个样例了。T2 没有问号的 35pts 貌似可以冲。 好吧最后就结束了。。。。。 下午去修了一会陈年老图，然后听讲题。二十多分钟过去，讲题结束了，我？？？？？该不会还是不会（草） 但是其实一看，也没有难到特别难的地方，主要是思考问题的方式太，，， 自己菜也没办法是吧。 还好我省 WC 不计省选，那就联合省选 2020 rp++ 吧/cy Day 6 起来听答辩。 dmy 是个什么神仙/se又强又可爱还双国家队 dzd 为什么会问“如果你和他只能去一个”这种 nt 问题 下午去打球了，点开颁奖典礼开始听 Cu。听了半天没听到，很慌。 然后发现我是 80 分（菜死了），后面听到同校大佬是 110 我省今年就两个牌子，哎 跟你说再见 回家在你谷上面交了一下。T1 玄学搜索只骗了 20，T2 居然 50，我？》？？一看数据范围，不对啊？？？？难道是我？？？？？？？？？ 我靠简直离谱 T3 只混了 10pts，惨 就这样吧，NOI2021 rp++","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"游记","slug":"OI/travels","permalink":"https://old.blog.imyangty.com/categories/OI/travels/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"}]},{"title":"莫反/杜教筛做题记录","slug":"summary-mobius","date":"2021-02-01T12:40:23.000Z","updated":"2022-03-29T03:52:38.452Z","comments":true,"path":"summary-mobius/","link":"","permalink":"https://old.blog.imyangty.com/summary-mobius/","excerpt":"","text":"[TOC] 洛谷 P3455 [POI2007]ZAP-Queries Description 求： \\sum_{i = 1}^a\\sum_{j = 1}^b[\\gcd(i,j) = d] Solution 莫比乌斯反演时，一般要将含 \\gcd 的式子化为 \\gcd(i,j) = 1 的形式才好反演。因此考虑设 a' = a/d ， b' = b/d ，原式化为 \\sum_{i = 1}^{a'}\\sum_{j = 1}^{b'}[\\gcd(i,j) = 1] 然后就可以愉快的反演了。我们知道 \\mu * 1 = \\varepsilon 所以 \\varepsilon(n) = \\sum_{d\\mid n}\\mu(d) 稍微变一下： \\varepsilon(\\gcd(i,j)) = \\sum_{d\\mid \\gcd(i,j)}\\mu(d) 所以原式化为 \\sum_{i = 1}^{a'}\\sum_{j = 1}^{b'}\\sum_{d\\mid \\gcd(i,j)}\\mu(d) 考虑写成枚举 d 的形式： \\begin{aligned} &amp;\\sum_{i = 1}^{a'}\\sum_{j = 1}^{b'}\\sum_{d\\mid \\gcd(i,j)}\\mu(d)\\\\ =&amp;\\sum_{i = 1}^{a'}\\sum_{j = 1}^{b'}\\sum_{d = 1}^{\\min(a',b')}[d\\mid\\gcd(i,j)]\\mu(d)\\\\ =&amp;\\sum_{d=1}^{\\min(a',b')}\\mu(d)\\sum_{i = 1}^{a'}\\sum_{j = 1}^{b'}[d\\mid\\gcd(i,j)] \\end{aligned} 考虑到若要使 d\\mid \\gcd(i,j) ， i 和 j 必须同为 d 的倍数，根据乘法原理，原式可以化为 \\sum_{d=1}^{\\min(a',b')}\\mu(d)\\left\\lfloor\\frac{a'}{d}\\right\\rfloor\\left\\lfloor\\frac{b'}{d}\\right\\rfloor 预处理出 \\mu 的前缀和，再套一个整除分块即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)const int maxn = 5e4 + 7;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}int mu[maxn], prime[maxn], tot, vis[maxn];void getmu(){ mu[1] = 1; for (int i = 2; i &lt;= maxn - 5; ++i) { if (!vis[i]) { mu[i] = -1; prime[++tot] = i; } for (int j = 1; j &lt;= tot &amp;&amp; i * prime[j] &lt;= maxn - 5; ++j) { vis[i * prime[j]] = 1; if (i % prime[j] == 0) { mu[i * prime[j]] = 0; break; } else mu[i * prime[j]] = -mu[i]; } } FOR(i, 1, maxn - 5) mu[i] += mu[i - 1]; return;}inline int min(int a, int b) {return a &lt; b ? a : b;}int main(){ getmu(); int T = read(); while (T--) { int a = read(), b = read(), d = read(); a /= d, b /= d; int top = min(a, b), ans = 0; for (int l = 1, r = 0; l &lt;= top &amp;&amp; r &lt;= top; l = r + 1) { r = min(top, min(a / (a / l), b / (b / l))); ans += (a / l) * (b / l) * (mu[r] - mu[l - 1]); } printf(\"%d\\n\", ans); } return 0;} 洛谷 P2522 [HAOI2011]Problem b 与此题类似，只不过需要套一个容斥。 Summary 将含有 gcd 的式子化为 [\\gcd(i,j) = 1] ，然后就可以使用 \\varepsilon = 1 * \\mu 进行反演。 推式子的时候随时记得可以改变枚举的顺序。 洛谷 P2257 YY的GCD Description \\sum_{i = 1}^n\\sum_{j = 1}^m[\\gcd(i,j) \\in P] 其中 P 为质数集。 Solution 不妨枚举这个质数，如下： \\sum_{k\\in P}\\sum_{i = 1}^n\\sum_{j = 1}^m[\\gcd(i,j) = k] 然后就是像上题一样化简： \\begin{aligned} &amp;\\sum_{k\\in P}\\sum_{i = 1}^n\\sum_{j = 1}^m[\\gcd(i,j) = k]\\\\ =&amp;\\sum_{k\\in P}\\sum_{i = 1}^{n'}\\sum_{j = 1}^{m'}[\\gcd(i,j) = 1],\\quad n' = \\left\\lfloor\\frac nk \\right\\rfloor,m' = \\left\\lfloor\\frac mk \\right\\rfloor\\\\ =&amp;\\sum_{k\\in P}\\sum_{i = 1}^{n'}\\sum_{j = 1}^{m'}\\sum_{d\\mid \\gcd(i,j)}\\mu(d)\\\\ =&amp;\\sum_{k\\in P}\\sum_{d = 1}^{\\min(n',m')}\\mu(d)\\left\\lfloor\\frac{n}{kd}\\right\\rfloor\\left\\lfloor\\frac{m}{kd}\\right\\rfloor \\end{aligned} 此时这个式子看上去已经差不多了，但是实际运行的时候还是会 T 掉，考虑设 T = kd ，有 \\begin{aligned} &amp;\\sum_{k\\in P}\\sum_{d = 1}^{\\min(n',m')}\\mu(d)\\left\\lfloor\\frac{n}{kd}\\right\\rfloor\\left\\lfloor\\frac{m}{kd}\\right\\rfloor\\\\ =&amp;\\sum_{k\\in P}\\sum_{d= 1}^{\\min(n',m')}\\mu\\left(\\frac Tk\\right)\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\\\ \\end{aligned} 换成枚举 T ，提前： \\begin{aligned} &amp;\\sum_{k\\in P}\\sum_{d= 1}^{\\min(n',m')}\\mu\\left(\\frac Tk\\right)\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\\\ =&amp;\\sum_{T = 1}^n\\left\\lfloor\\frac{n}{T}\\right\\rfloor\\left\\lfloor\\frac{m}{T}\\right\\rfloor\\sum_{k\\mid T\\land k\\in P}\\mu\\left(\\frac Tk\\right) \\end{aligned} \\displaystyle\\sum_{k\\mid T\\land k\\in P}\\mu\\left(\\frac Tk\\right) 是可以预处理的，预处理然后整除分块就可以了。实际实现的时候记得开 long long 并卡卡常（不要处处 long long） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (register int i = a; i &lt;= b; ++i)const int maxn = 1e7 + 7;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline int min(int a, int b) {return a &lt; b ? a : b;}typedef long long ll;int mu[maxn], p[maxn], vis[maxn], tot;ll sum[maxn];void getmu(){ mu[1] = 1; FOR(i, 2, maxn - 5) { if (!vis[i]) { p[++tot] = i; mu[i] = -1; } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= maxn - 5; ++j) { vis[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } FOR(j, 1, tot) for (int i = 1; i * p[j] &lt;= maxn - 5; ++i) sum[i * p[j]] += mu[i]; FOR(i, 1, maxn - 5) sum[i] += sum[i - 1]; return;}signed main(){ getmu(); int kase = read(); while (kase--) { int n = read(), m = read(); int top = min(n, m); ll ans = 0; for (int l = 1, r = 0; l &lt;= top; l = r + 1) { r = min(top, min(n / (n / l), m / (m / l))); ans += (ll)(n / l) * (ll)(m / l) * (sum[r] - sum[l - 1]); } printf(\"%lld\\n\", ans); } return 0;} Summary 适当的时候设 T=kd 是可以化简式子减小运算的时间复杂度的。 洛谷 P3312 [SDOI2014]数表 Description 给定 n,m\\le 10^5,a ，求 \\sum_{i = 1}^n\\sum_{j = 1}^m\\sigma(\\gcd(i,j))\\times[\\sigma(\\gcd(i,j)) \\le a]\\bmod 2^{31} 其中 \\sigma(x) 表示 x 的正约数之和。 Solution 先忽略 \\sigma(\\gcd(i,j))\\le a 的条件，并假定 n\\le m ，化简上面的式子： \\begin{aligned} &amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\sigma(\\gcd(i,j))\\\\ =&amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\sum_{d = 1}^n\\sigma(d)[\\gcd(i,j) = d]\\\\ =&amp;\\sum_{d = 1}^n\\sigma(d)\\sum_{i = 1}^{\\lfloor n/d\\rfloor}\\sum_{j = 1}^{\\lfloor m / d\\rfloor}[\\gcd(i,j) = 1]\\\\ =&amp;\\sum_{d = 1}^n\\sigma(d)\\sum_{i = 1}^{\\lfloor n/d\\rfloor}\\sum_{j = 1}^{\\lfloor m / d\\rfloor}\\sum_{x\\mid i\\land x \\mid j}\\mu(x)\\\\ =&amp;\\sum_{d = 1}^n\\sigma(d)\\sum_{x = 1}^{\\lfloor n / d\\rfloor}\\lfloor n / dx\\rfloor\\lfloor m/ dx\\rfloor\\mu(x)\\\\ \\end{aligned} 令 T = dx ，则 \\begin{aligned} &amp;\\sum_{d = 1}^n\\sigma(d)\\sum_{x = 1}^{\\lfloor n / d\\rfloor}\\lfloor n / dx\\rfloor\\lfloor m/ dx\\rfloor\\mu(x)\\\\ =&amp;\\sum_{T = 1}^n\\lfloor n / T\\rfloor\\lfloor m / T\\rfloor\\sum_{d\\mid T}\\sigma(d)\\mu(T/d) \\end{aligned} 再令 f(T) = \\displaystyle\\sum_{d\\mid T}\\sigma(d)\\mu(T/d) ，则要求的东西就是： \\sum_{T = 1}^n\\lfloor n / T\\rfloor\\lfloor m / T\\rfloor f(T) 然后我们可以发现的是：只有当 \\sigma(d)\\le a 时，其才会对 f(T) 产生贡献，所以考虑离线处理每个询问，按照 a 从小到大排序，再将预处理好的 \\sigma(d) 从小到大排序，然后动态更新 f(T) 的前缀和。可以发现的是我们每次加入一个 \\sigma(d)\\mu(T/d) 都会让 d 的每个倍数的 T 对应增加。所以使用树状数组维护。对于每个询问整除分块即可。总复杂度 O(q\\sqrt n\\log n + n \\log^2 n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#define int long long#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define lowbit(x) ((x) &amp; (-x))#define Fi first#define Se second#define mk(a, b) std::make_pair(a, b)const int maxn = 1e5 + 13;struct queries{ int n, m, a, id;} q[20000 + 5];bool cmp(queries a, queries b) {return a.a &lt; b.a;}inline int read(){ int s = 0, x = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c =getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}inline int min(int a, int b) {return a &lt; b ? a : b;}int g[maxn], mu[maxn], vis[maxn], p[maxn], tot;std::pair&lt;int, int&gt; f[maxn];int tree[maxn], ans[maxn];void modify(int x, int val){ for (; x &lt;= maxn - 5; x += lowbit(x)) tree[x] += val; return;}int query(int x){ int ret = 0; for (; x; x -= lowbit(x)) ret += tree[x]; return ret;}void pre(){ g[1] = mu[1] = 1; f[1] = mk(1, 1); FOR(i, 2, maxn - 5) { if (!vis[i]) { vis[i] = 1; p[++tot] = i; mu[i] = -1; f[i] = mk(g[i] = i + 1, i); } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= maxn - 5; ++j) { vis[i * p[j]] = 1; if (i % p[j] == 0) { g[i * p[j]] = g[i] * p[j] + 1; f[i * p[j]] = mk(f[i].Fi / g[i] * g[i * p[j]], i * p[j]); mu[i * p[j]] = 0; break; } else { mu[i * p[j]] = -mu[i]; f[i * p[j]] = mk(f[i].Fi * f[p[j]].Fi, i * p[j]); g[i * p[j]] = p[j] + 1; } } }}int solve(int n, int m){ if (n &gt; m) {int t = n; n = m; m = t;} int ret = 0; for (int l = 1, r; l &lt;= n; l = r + 1) { r = min(n / (n / l), m / (m / l)); ret += (query(r) - query(l - 1)) * (n / l) * (m / l); } return ret;}signed main(){ pre(); std::sort(f + 1, f + maxn - 5); int Q = read(); FOR(i, 1, Q) q[i].id = i, q[i].n = read(), q[i].m = read(), q[i].a = read(); std::sort(q + 1, q + 1 + Q, cmp); for (int i = 1, j = 1; i &lt;= Q; ++i) { for (; f[j].Fi &lt;= q[i].a &amp;&amp; j &lt;= maxn - 5; ++j) for (int k = f[j].Se; k &lt;= maxn - 5; k += f[j].Se) modify(k, f[j].Fi * mu[k / f[j].Se]); ans[q[i].id] = solve(q[i].n, q[i].m); } FOR(i, 1, Q) printf(\"%lld\\n\", ans[i] % (1LL &lt;&lt; 31)); return 0;} Summary 适当使用 T = kd 进行换元。考虑贡献是如何产生的然后就可以使用恰当的数据结构进行维护。 洛谷 P3327 [SDOI2015]约数个数和 Description 设 \\tau(n) 表示 n 的约数个数，求 \\sum_{i = 1}^n\\sum_{j = 1}^m\\tau(ij) Solution 引理： \\tau(ij) = \\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x, y) = 1] 证明考虑 i 和 j 的质因子即可。 原式： \\begin{aligned} &amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\tau(ij)\\\\ =&amp;\\sum_{i = 1}^n\\sum_{j = 1}^m\\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x, y) = 1]\\\\ =&amp;\\sum_{x = 1}^n\\sum_{y = 1}^m\\left\\lfloor\\frac nx\\right\\rfloor\\left\\lfloor\\frac my\\right\\rfloor[\\gcd(x,y) = 1]\\\\ =&amp;\\sum_{x = 1}^n\\sum_{y = 1}^m\\left\\lfloor\\frac nx\\right\\rfloor\\left\\lfloor\\frac my\\right\\rfloor\\sum_{d\\mid \\gcd(x,y)}\\mu(d)\\\\ =&amp;\\sum_{d = 1}^{\\min\\{n,m\\}}\\mu(d)\\sum_{x = 1}^{\\left\\lfloor\\frac nd\\right\\rfloor}\\left\\lfloor\\frac n{dx}\\right\\rfloor\\sum_{y = 1}^{\\left\\lfloor\\frac md\\right\\rfloor}\\left\\lfloor\\frac m{dy}\\right\\rfloor \\end{aligned} 设 f(n) = \\sum_{1\\le i\\le n}\\left\\lfloor\\dfrac ni\\right\\rfloor ，则原式进一步化简为 \\sum_{d = 1}^{\\min\\{n,m\\}}\\mu(d)f\\left(\\left\\lfloor\\frac nd\\right\\rfloor\\right)f\\left(\\left\\lfloor\\frac md\\right\\rfloor\\right) f 的值可以一开始 O(n\\sqrt n) 求出来，然后总的复杂度明显为 O(n\\sqrt n + T\\sqrt n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;cctype&gt;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}typedef long long ll;inline int min(int a, int b) {return a &lt; b ? a : b;}const int maxn = 50005;int mu[maxn], p[maxn], vis[maxn], tot;ll f[maxn];void get_mu(){ mu[1] = 1; for (int i = 2; i &lt;= maxn - 5; ++i) { if (!vis[i]) { mu[i] = -1; p[++tot] = i; } for (int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= maxn - 5; ++j) { vis[i * p[j]] = 1; if (i % p[j] == 0) { mu[i * p[j]] = 0; break; } mu[i * p[j]] = -mu[i]; } } for (int i = 2; i &lt;= maxn - 5; ++i) mu[i] += mu[i - 1]; return;}void get_f(){ for (int n = 1; n &lt;= maxn - 5; ++n) for (int l = 1, r; l &lt;= n; l = r + 1) { r = n / (n / l); f[n] += (r - l + 1ll) * (n / l); } return;}ll solve(int n, int m){ ll ret = 0; int up = min(n, m); for (int l = 1, r; l &lt;= up; l = r + 1) { r = min(n / (n / l), m / (m / l)); ret += (ll)(mu[r] - mu[l - 1]) * f[n / l] * f[m / l]; } return ret;}signed main(){ get_mu(); get_f(); int T = read(); while (T--) { int n = read(), m = read(); printf(\"%lld\\n\", solve(n, m)); } return 0;} Summary \\tau(ij) = \\sum_{x\\mid i}\\sum_{y\\mid j}[\\gcd(x, y) = 1] 重要结论。 SPOJ5971 LCMSUM - LCM Sum Description T 组数据，求 \\sum_{i = 1}^n\\operatorname{lcm}(i,n)\\quad\\text{s.t. }1\\le T\\le 3\\times 10^5,1\\le n\\le 10^6 Solution 先推式子： \\sum_{i = 1}^n\\operatorname{lcm}(i, n) = \\sum_{i = 1}^n\\frac{in}{\\gcd(i,n)} 这一步相当显然。接下来由于这个式子不是很好处理，而我们知道 \\gcd(i, n) = \\gcd(n - i, n) ，所以考虑把 n 这一项提出来，然后复制一遍倒序求和： =\\frac12\\left(\\sum_{i = 1}^{n - 1}\\frac{in}{\\gcd(i, n)} + \\sum_{i = n - 1}^1\\frac{in}{\\gcd(n - i, n)} \\right) 合并分母相同的项， =\\frac12\\sum_{i = 1}^{n - 1}\\frac{n^2}{\\gcd(i, n)} + n 最后让这个式子好看一点： =\\frac12\\sum_{i = 1}^n\\frac{n^2}{\\gcd(i, n)} + \\frac n 2 由于很多的 \\gcd(i, n) 是相同的，所以考虑把它们并在一起计算。枚举 \\gcd(i, n) = d ，那会有多少个 i 满足 \\gcd(i, n) = d 呢？我们知道 \\displaystyle\\gcd(i, n) = d\\iff \\gcd(\\frac id, \\frac nd) = 1 ，所以有 \\phi(\\frac nd) 个这样的 i 是满足的。 =\\frac12\\sum_{d|n}\\frac{n^2\\phi(\\frac nd)}{d} + \\frac n2 提出一个 n/2 ，然后换一下元 d' = n / d ，得到 =\\frac 12 n\\left(\\sum_{d'|n}d'\\phi(d') + 1\\right) 令 g(n) = \\displaystyle\\sum_{d|n}d\\phi(d) ，则我们最终要求的就是 \\displaystyle\\frac12(g(n) + 1) 。 g(n) 为积性函数，所以可以线性筛做到 O(n)-O(1) 的复杂度。下面考虑如何线性筛出 g(n) 。 首先对于 n 为质数，显然 g(n) = 1 + n\\phi(n) = 1 + n(n - 1) 。 然后考虑正在用 i 来筛 g(i\\cdot p_j) 的过程。若 \\gcd(i, p_j) = 1 ，直接使用积性函数的性质即可。 若 p_j|i ，令 i = i'\\cdot p_j^w ，其中 \\gcd(i', p_j) = 1 ，然后可以得到 \\begin{aligned} g(i\\cdot p_j) &amp;= g(i')\\cdot g(p_j^{w + 1})\\\\ g(i)&amp;=g(i’)\\cdot g(p_j^w) \\end{aligned} 然后我们考虑计算 g(p_j^k) ，显然地， g(p_j^k) = \\sum_{w = 0}^kp_j^w\\cdot\\phi(p_j^w) 而 \\phi(p_j^w) = p_j^{w - 1}\\cdot(p_j - 1) ，所以 g(p_j^k) = \\sum_{w = 0}^kp_j^{2w-1}(p_j - 1) 于是 g(p_j^{w + 1}) = p_j^{2w + 1}(p_j - 1) + g(p_j^k) 。 回到之前的两个式子，将两式相减，可以得到 g(i\\cdot p_j) - g(i) = g(i')\\cdot p_j^{2w + 1}\\cdot(p_j - 1) 同理，由于 p_j|i ，所以 g(i) - g(\\frac{i}{p_j}) = g(i')\\cdot p_j^{2w - 1}\\cdot(p_j - 1) 所以两式相除消去 g(i') ，有 g(i\\cdot p_j) = g(i) + \\left(g(i) - g(\\frac{i}{p_j})\\right)\\cdot p_j^2 所以我们就在 O(n + T) 的时间内解决了这题。 12345678910111213141516171819202122232425262728293031323334353637#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)const int maxn = 1e6 + 5;typedef long long ll;int p[maxn], flg[maxn], cntp;ll g[maxn];int main(){ g[1] = 1; FOR(i, 2, maxn - 3) { if (!flg[i]) p[++cntp] = i, g[i] = 1ll * (i - 1) * i + 1; for (int j = 1; j &lt;= cntp &amp;&amp; i * p[j] &lt;= maxn - 3; ++j) { flg[i * p[j]] = 1; if (i % p[j] == 0) { g[i * p[j]] = g[i] + (g[i] - g[i / p[j]]) * p[j] * p[j]; break; } g[i * p[j]] = g[i] * g[p[j]]; } } int T = read(); while (T--) { int n = read(); printf(\"%lld\\n\", (g[n] + 1) * n / 2); } return 0;} Summary \\gcd(i, n) = \\gcd(n - i, n) （更相减损术） 对于很多项取值相等的项可以考虑提出来（类似整除分块的思想） 对于积性函数是可以线性筛的 hdu 4944 FSF’s game 见 题解 hdu 4944 FSF’s game 主要就是把奇奇怪怪的东西化简了。把问题化归到求 LCMSUM 那道题去。 BZOJ #3601. 一个人的数论 见 题解 BZOJ #3601. 一个人的数论 主要是化简之后将自然数幂之和化开用高斯消元，之后 O(1) 计算那个积性函数的值。 P1829 [国家集训队]Crash的数字表格 / JZPTAB Description \\sum_{i = 1}^n\\sum_{j = 1}^m\\operatorname{lcm}(i, j)\\bmod 20101009 Solution 先把 lcm 变成 gcd： \\sum_{i = 1}^n\\sum_{j = 1}^m\\frac{ij}{\\gcd(i, j)} 枚举 gcd： \\sum_{d = 1}^n\\sum_{i = 1}^n\\sum_{j = 1}^m\\frac{ij}{d}[\\gcd(i,j) = d] 然后是经典套路： \\sum_{d = 1}^nd\\sum_{i = 1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac md\\rfloor}ij\\sum_{k\\mid \\gcd(i,j)}\\mu(k) 再然后，枚举 k ： \\sum_{d = 1}^nd\\sum_{k = 1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)\\sum_{i = 1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac md\\rfloor}ij[k\\mid i][k\\mid j] 之后应该就能化简了： \\sum_{d = 1}^nd\\sum_{k = 1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)k^2\\sum_{i = 1}^{\\lfloor\\frac{n}{kd}\\rfloor}\\sum_{j = 1}^{\\lfloor\\frac{m}{kd}\\rfloor}ij 后面这个 f(x,y)=\\sum_{i= 1}^x\\sum_{j= 1}^yij 可以化简成 \\dfrac{n(n+ 1)m(m+1)}{4} ，然后我们最终得到的式子就是 \\sum_{d=1}^nd\\sum_{k=1}^{\\lfloor\\frac nd\\rfloor}\\mu(k)k^2f(\\lfloor n/kd\\rfloor, \\lfloor m/kd\\rfloor) 我们令 S(n,m) = \\displaystyle\\sum_{k=1}^{\\min(n,m)}\\mu(k)k^2f(\\lfloor n/k\\rfloor, \\lfloor m/k\\rfloor) 。这个东西可以先筛出 \\mu(n)n^2 之后用整除分块来做。然后，我们的答案明显为 \\displaystyle\\sum_{d= 1}^{\\min(n,m)}dS(\\lfloor n/d\\rfloor,\\lfloor m/d\\rfloor) 。可以再套一层分块来做。 Implementation 取模和 ll 的细节是有点烦的。 123456789101112131415161718192021222324252627282930313233343536373839404142const int maxn = 1e7 + 5, N = 1e7;int isp[maxn], p[maxn], mu[maxn], cnt;modint sum[maxn];void sieve() { mu[1] = 1; FOR(i, 2, N) { if (!isp[i]) p[++cnt] = i, mu[i] = -1; for (int j = 1; j &lt;= cnt &amp;&amp; i * p[j] &lt;= N; ++j) { isp[i * p[j]] = 1; if (i % p[j] == 0) break; mu[i * p[j]] = -mu[i]; } } FOR(i, 1, N) sum[i] = sum[i - 1] + (modint)i * i * mu[i];}modint f(int x, int y) {return modint(1ll * x * (x + 1) / 2 % mod) * modint(1ll * y * (y + 1) / 2 % mod);}modint S(int n, int m) { int top = min(n, m); modint ans = 0; for (int l = 1, r; l &lt;= top; l = r + 1) { r = min(n / (n / l), m / (m / l), top); ans += (sum[r] - sum[l - 1]) * f(n / l, m / l); } return ans;}int main() { sieve(); int n, m; read(n, m); int top = min(n, m); modint ans = 0; for (int l = 1, r; l &lt;= top; l = r + 1) { r = min(n / (n / l), m / (m / l), top); ans += (r - l + 1ll) * (l + r) / 2 % mod * S(n / l, m / l); } print(ans); return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"莫比乌斯反演","slug":"mobius-inversion","permalink":"https://old.blog.imyangty.com/tags/mobius-inversion/"},{"name":"杜教筛","slug":"du-sieve","permalink":"https://old.blog.imyangty.com/tags/du-sieve/"}]},{"title":"2021年2月 OI 学习记录","slug":"summary-2021-02","date":"2021-02-01T05:55:30.000Z","updated":"2022-03-23T04:19:24.319Z","comments":true,"path":"summary-2021-02/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-02/","excerpt":"","text":"前言 仍旧菜的抠脚。 WC 2021 rp ++ 学习内容 轮廓线 dp 上下界网络流 Manacher 最小表示法 exKMP SA 多项式乘法逆 做题记录 21/02/01 CF1198D Rectangle Painting 1 二维区间 dp，以 x 和 y 方向分别划分即可 HDU4283 You Are The One 比较清奇的区间 dp，考虑第 i 个人放到第 k 个出场造成的影响 UVA11270 Tiling Dominoes 插头 dp，参见大佬题解 HDU3507 Print Article 斜率优化 dp 21/02/02 P3254 圆桌问题 网络流。源向单位连大小为单位人数的边，餐桌向汇连大小为餐桌人数的边，每个单位连每个餐桌，跑最大流，满流有解，找流有东西的边输出即可 P2763 试题库问题 网络流。试题向属于的类型连 1，类型向汇连需要的题数，跑最大流，满流有解，输出方案。 P2891 [USACO07OPEN]Dining G 拆点，源-&gt;食物-&gt;牛in-&gt;牛out-&gt;饮料-&gt;汇，保证流过牛的流量为 1，跑最大流即可 P3805 【模板】manacher算法 manacher P1368 【模板】最小表示法 最小表示法 21/02/03 CF734E Anton and Tree ————————AC500 祭 缩点 + 树的直径 CF911F Tree Destruction 树的直径 + 贪心 21/02/04 CF1000E We Need More Bosses 边双 + 缩点 + 树的直径 P2766 最长不下降子序列问题 拆点 + 最大流 21/02/05 WC 2021 Codeforces Round #699 (Div. 2) A + B + C rk2134 该死终于能做三道题出来了/kk 21/02/06 WC2021 10 + 50 + 20 = 80，Cu LOJ#115. 无源汇有上下界可行流 上下界网络流 LOJ#116. 有源汇有上下界最大流 上下界网络流 P5192 Zoj3229 Shoot the Bullet东方文花帖【模板】有源汇上下界最大流 建模 + 上下界网络流 21/02/07 P2764 最小路径覆盖问题 最小路径覆盖数 = 点数 - 最大匹配数 P2765 魔术球问题 上题的加强版，从小往大枚举答案，每次在残量网络上继续跑 Dinic P2754 [CTSC1999]家园 / 星际转移问题 最大流 P4015 运输问题 费用流。套路：费用取负可以得到最大费用最大流 P4016 负载平衡问题 费用流 21/02/08 CF1475D Cleaning the Phone 补题，贪心 + 二分 CF1475F Unusual Matrix 异或运算的性质：考虑先异或两个矩阵，然后判断这个矩阵是否能变为 0 CF1475G Strange Beauty 比较神奇的数论dp CF1476C Longest Simple Cycle dp，注意 long long P2770 航空路线问题 最大费用最大流 P4014 分配问题 二分图最大权匹配，费用流 P4013 数字梯形问题 拆点 + 费用流，注意细节 21/02/09 CF1476D Journey 记忆化搜索/dp。注意到其实就是最多往左走的加上最多往右走的。 CF1476E Pattern Matching 字符串哈希/Trie + 拓扑排序。找到 s 能匹配的所有 p，然后加边，拓扑。 P2580 于是他错误的点名开始了 Trie 模板，注意数组开够 SP4033 PHONELST - Phone List Trie，如果在插入过程中遇到结束标记或者没有建立新的节点，则说明有前缀包含 HDU4825 Xor Sum 01-Trie 模板，考虑将每个数字化成 01 二进制串插入 Trie 树。为了找到异或的最大值需往反方向下跳（相同为 0，不同为 1） HDU5536 Chip Factory 01-Trie。要开够空间，多测清空。注意 i,j,k 两两不同，需要删点/加点。 P4551 最长异或路径 01-Trie。考虑处理每个点到根异或和 d_i ，则答案为 \\max\\lbrace d_x, d_y\\rbrace 。因为到根重复的一段会被消去（异或运算的性质） P3358 最长k可重区间集问题 比较精巧的网络流建模，费用流。 21/02/10 P3808 【模板】AC自动机（简单版） AC 自动机 P3796 【模板】AC自动机（加强版） AC 自动机 P2375 [NOI2014] 动物园 KMP，首先求出所有的 fail 然后建好 fail 树，在 fail 树上面进行动态统计即可。 21/02/11 P5357 【模板】AC自动机（二次加强版） 避免每次跳 fail，直接建 fail 树最后树上差分即可。 21/02/13 CF1485B Replace and Keep Sorted dp 21/02/15 P4782 【模板】2-SAT 问题 2-SAT P4171 [JSOI2010]满汉全席 2-SAT，读清楚题意是每种食材要么满要么汉 P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G tarjan 求 scc，只需要找出出度为 0 的 scc 即可 P2002 消息扩散 tarjan scc，找入度为 0 的点，即没有别的城市传信的城市 Educational Codeforces Round 104 (Rated for Div. 2) A + D，赛后补 B，C 21/02/16 P3357 最长k可重线段集问题 费用流 P4012 深海机器人问题 费用流 P1251 餐巾计划问题 费用流 Codeforces Round #702 (Div. 3) 赛中 A + B + C + D + F，赛后补 E 不开 long long 见祖宗 21/02/17 CF1490G Old Floppy Drive 赛后补题 CF1481D AB Graph 图论 + 构造。比较巧妙的构造题 21/02/18 UVA1660 电视网络 Cable TV Network 最小割 21/02/19 CF1481E Sorting Books 比较诡诈的 dp P3809 【模板】后缀排序 学习 SA P4051 [JSOI2007]字符加密 断环为链，即倍长串之后跑 SA BZOJ#3771. Triple NTT + 容斥 P2408 不同子串个数 SA P4391 [BOI2009]Radio Transmission 无线传输 KMP 求循环节： N - fail(N) UVA10298 Power Strings 同上 CF1200E Compress Words 找后缀和前缀的最长公共部分，那就 KMP P5410 【模板】扩展 KMP（Z 函数） Z 算法 21/02/20 P4238 【模板】多项式乘法逆 多项式乘法逆，倍增 21/02/21 P4173 残缺的字符串 NTT 做带通配符的字符串匹配 CF528D Fuzzy Search myy 论文题，单独考虑每个字符跑 NTT 21/02/25 P3518 [POI2011]SEJ-Strongbox gcd","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"解题报告 P2224 [HNOI2001]产品加工","slug":"sol-luogu-p2224","date":"2021-01-31T12:41:02.000Z","updated":"2022-03-23T04:18:30.894Z","comments":true,"path":"sol-luogu-p2224/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2224/","excerpt":"","text":"Description 某加工厂有A、B两台机器，来加工的产品可以由其中任何一台机器完成，或者两台机器共同完成。由于受到机器性能和产品特性的限制，不同的机器加工同一产品所需的时间会不同，若同时由两台机器共同进行加工，所完成任务又会不同。某一天，加工厂接到n个产品加工的任务，每个任务的工作量不尽一样。 你的任务就是：已知每个任务在A机器上加工所需的时间t1, B机器上加工所需的时间t2及由两台机器共同加工所需的时间t3，请你合理安排任务的调度顺序，使完成所有n个任务的总时间最少。 n \\le 6000, t_1,t_2,t_3\\in[0,5] ，0表示不行 Solution 这种奇葩的 dp 是第一次见。如果状态以时间为维度定义的话会炸掉，所以考虑这样定义状态： f_{i,j} 表示完成了前 i 项任务，A 机子花了 j 时间，B 机子花的最小时间。 为什么这样定义状态是对的呢？直接考虑把两个机子一起做的放到最前面做就可以了，就无需考虑顺序问题了。详情见 wjyyy大佬的博客。 转移方程可以很轻松的写出来，但是需要优化。考虑枚举上下界，即计算出 f_{i,j} 有取值的 j 的上下界。最后答案跑 min 即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)int read(){ int ret = 0; int rev = 0; char c = getchar(); while (!isdigit(c)) rev = (c == '-'), c = getchar(); while (isdigit(c)) ret = 10 * ret + c - '0', c = getchar(); return rev ? -ret : ret;}inline int min(int a, int b) {return a &lt; b ? a : b;}inline int max(int a, int b) {return a &gt; b ? a : b;}const int maxn = 6000 + 5;int f[maxn * 5];int main(){ int n = read(), up, down, tmp, ans = 0x7fffffff; FOR(i, 1, n) { int a = read(), b = read(), c = read(); up += max(max(a, b), c), tmp = down; down = 0x7fffffff; DEC(j, up, tmp) { int t = 0x3fffffff; if (a &amp;&amp; j - a &gt;= tmp) t = min(t, f[j - a]); if (b) t = min(t, f[j] + b); if (c &amp;&amp; j - c &gt;= tmp) t = min(t, f[j - c] + c); if (t &lt; 0x3fffffff) down = min(down, j); f[j] = t; } } FOR(i, down, up) ans = min(ans, max(i, f[i])); printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"背包","slug":"backpack-dp","permalink":"https://old.blog.imyangty.com/tags/backpack-dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"解题报告 BZOJ2973 石子游戏","slug":"sol-bzoj2973","date":"2021-01-13T14:42:25.000Z","updated":"2022-03-23T04:19:01.537Z","comments":true,"path":"sol-bzoj2973/","link":"","permalink":"https://old.blog.imyangty.com/sol-bzoj2973/","excerpt":"","text":"题意 石头游戏的规则是这样的。 石头游戏在一个n行m列的方格阵上进行。每个格子对应了一个编号在0~9之间的操作序列。 操作序列是一个长度不超过6且循环执行、每秒执行一个字符的字符串。它包括： 数字 0 ~ 9：拿0 ~ 9个石头到该格子。 NWSE：把这个格子内所有的石头推到相邻的格子。 D：拿走这个格子的石头。 石头游戏的问题是：当这个石头游戏进行了t秒之后，所有方格中最多的格子有多少个石头。 注意：所有格子的操作同时执行。 思路 考虑构造只有 1 行 n\\times m + 1 列的状态矩阵 F ，然后给原方阵中 i 行 j 列的元素标号 f(i, j) = (i - 1)m + j 。然后由于所有操作序列长度不超过 6 ，所以最多 \\operatorname{lcm}(1, 2, 3, 4, 5 ,6) = 60 次之后就会出现循环，所以考虑 t = 60q + r,r\\in[0, 60) 。然后构造 t\\in[1, 60] 中每个时间的转移矩阵 A_k ，令 A_0 = \\prod A_k ，则答案为 F_0 \\times A_0^q +\\times \\prod_{k = 1}^rA_k 转移矩阵的构造想通了就很简单了： A_k 的左上角赋为 0 ，如果操作为数字那就 A_k[0, f(i,j)] = opt, A_k[f(i,j),f(i,j)] = 1 ，如果是移动的话那就 A_k[f(i, j),f(i',j')] = 1 。 但是要注意细节： 矩阵初始化问题 乘千万不要写成 A_0\\times F 了，是错的。 long long 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#define R register#define il inline#define FOR(i, a, b) for (R signed i = a; i &lt;= b; ++i)#define int long long#define dbg printf(\"debug\\n\")char act[11][7], org[11][11];int actlen[11];int n, m, acts, t;int a[81];il int num(int i, int j){ return (i - 1) * m + j;}il int max(int a, int b) {return a &gt; b ? a : b;}struct Matrix{ int r, c, a[81][81]; void init(int _r, int _c) { r = _r, c = _c; } int max_element() { int ret = -1e9; FOR(i, 0, r) FOR(j, 0, c) ret = max(ret, a[i][j]); return ret; } Matrix() { memset(a, 0, sizeof a); }} ans, A[61];Matrix operator*(const Matrix &amp;a, const Matrix &amp;b){ Matrix ret; ret.init(a.r, b.c); int r = ret.r, c = ret.c, p = a.c; FOR(i, 0, r) FOR(j, 0, c) FOR(k, 0, p) ret.a[i][j] += a.a[i][k] * b.a[k][j]; return ret;}signed main(){ scanf(\"%lld %lld %lld %lld\", &amp;n, &amp;m, &amp;t, &amp;acts); FOR(i, 1, n) scanf(\"%s\", &amp;org[i][1]); FOR(i, 1, n) FOR(j, 1, m) a[num(i, j)] = org[i][j] - '0'; FOR(i, 0, acts - 1) scanf(\"%s\", &amp;act[i][1]), actlen[i] = strlen(&amp;act[i][1]), act[i][0] = act[i][actlen[i]]; int N = n * m; ans.init(0, N); ans.a[0][0] = 1; FOR(k, 0, 60) A[k].init(N, N); FOR(k, 1, 60) { A[k].a[0][0] = 1; FOR(i, 1, n) FOR(j, 1, m) { int idx = k % actlen[a[num(i, j)]]; char opt = act[a[num(i, j)]][idx]; if (isdigit(opt)) A[k].a[0][num(i, j)] = opt - '0', A[k].a[num(i, j)][num(i, j)] = 1; else { if (opt == 'N' &amp;&amp; i - 1 &gt; 0) A[k].a[num(i, j)][num(i - 1, j)] = 1; else if (opt == 'E' &amp;&amp; j + 1 &lt;= m) A[k].a[num(i, j)][num(i, j + 1)] = 1; else if (opt == 'S' &amp;&amp; i + 1 &lt;= n) A[k].a[num(i, j)][num(i + 1, j)] = 1; else if (opt == 'W' &amp;&amp; j - 1 &gt; 0) A[k].a[num(i, j)][num(i, j - 1)] = 1; } } if (k == 1) A[0] = A[k]; else A[0] = A[0] * A[k]; } int q = t / 60, r = t % 60; for (; q; q &gt;&gt;= 1) { if (q &amp; 1) ans = ans * A[0]; A[0] = A[0] * A[0]; } FOR(i, 1, r) ans = ans * A[i]; printf(\"%lld\\n\", ans.max_element()); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://old.blog.imyangty.com/tags/BZOJ/"}]},{"title":"解题报告 POJ3696 The Luckiest number","slug":"sol-poj3696","date":"2021-01-06T13:06:15.000Z","updated":"2022-03-23T04:18:31.076Z","comments":true,"path":"sol-poj3696/","link":"","permalink":"https://old.blog.imyangty.com/sol-poj3696/","excerpt":"","text":"题意 给定正整数 L 满足 L\\in[2, 10^9] ，问至少多少个 8 连起来组成的正整数是 L 的倍数 思路 首先设 x 个 8 连起来，这个数记为 \\displaystyle \\frac{8(10^x-1)}{9} ，题意就是求最小正整数 x 使得 L\\mid \\displaystyle \\frac{8(10^x-1)}{9} 。 首先将式子化为 9L\\mid 8(10^x - 1) ，两边同时约去 d=\\gcd(L, 8) 得到 \\displaystyle \\frac{9L}{d} \\mid 10^x - 1 所以原式化为 10^x\\equiv 1\\pmod{\\frac{9L}{d}} 引理 若正整数 a\\perp n ，则满足 a^x\\equiv 1\\pmod n 的最小正整数 x_0 为 \\varphi(n) 的约数。 使用欧拉定理 a^{\\varphi(n)}\\equiv 1\\pmod n 可以证明 所以设 p = \\varphi\\left(\\displaystyle \\frac{9L}{d}\\right) ，枚举其所有约数 x ，符合条件即为答案。 模数可能为 long long，要开快速乘。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define int long longint gcd(int a, int b){ if (!b) return a; return gcd(b, a % b);}int phi(int n){ int ans = n, sq = sqrt(n); for (int i = 2; i &lt;= sq; ++i) { if (n % i == 0) { ans = ans / i * (i - 1); while (n % i == 0) n /= i; } } if (n &gt; 1) ans = ans / n * (n - 1); return ans;}int mul(int a, int b, int mod){ int ans = 0, x = a; b = (b + mod) % mod, a = (a + mod) % mod; for (; b; b &gt;&gt;= 1ll) { if (b &amp; 1ll) ans = (ans + x) % mod; x = (x &lt;&lt; 1) % mod; } return ans;}int ksm(int base, int p, int mod){ int ans = 1; base %= mod; for (; p; p &gt;&gt;= 1) { if (p &amp; 1) ans = mul(ans, base, mod); base = mul(base, base, mod); } return ans;}std::vector&lt;int&gt; fact;signed main(){ int n; for (signed kase = 1; ; ++kase) { scanf(\"%lld\", &amp;n); if (!n) return 0; int d = gcd(n, 8); int phip = phi(9 * n / d), sqrtp = sqrt(phip); fact.clear(); for (int i = 2; i &lt;= sqrtp; ++i) if (phip % i == 0) { fact.push_back(i); if (phip / i != i) fact.push_back(phip / i); } std::sort(fact.begin(), fact.end()); int ans = 0; for (int i = 0; i &lt; fact.size(); ++i) { if (ksm(10, fact[i], 9 * n / d) == 1) { ans = fact[i]; break; } } printf(\"Case %d: %lld\\n\", kase, ans); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"POJ","slug":"POJ","permalink":"https://old.blog.imyangty.com/tags/POJ/"},{"name":"欧拉函数","slug":"euler-totient-func","permalink":"https://old.blog.imyangty.com/tags/euler-totient-func/"}]},{"title":"2021年1月 OI学习记录","slug":"summary-2021-01","date":"2021-01-01T15:33:40.000Z","updated":"2022-03-23T04:19:24.316Z","comments":true,"path":"summary-2021-01/","link":"","permalink":"https://old.blog.imyangty.com/summary-2021-01/","excerpt":"","text":"前言 新年快乐！终于活过 2020 年了。 WC2021 GZOI2021 NOI2021（如果有可能的话）rp++ 学习内容 欧拉函数 (ex)BSGS 矩阵乘法的应用 高斯消元 基础分块 基础线性代数 数位 dp 复杂度分析 狄利克雷卷积 莫比乌斯反演 杜教筛 FFT 做题记录 21/01/01 EOJ monthly 2020.01 A+C+E rk80 P1072 [NOIP2009 提高组] Hankson 的趣味题 需要特别注意处理 a_0,a_1,b_0,b_1&gt;\\sqrt n 的情况 P2158 [SDOI2008]仪仗队 设左下角 (0, 0) ，右上角 (n-1, n - 1) 。抛开 (1,0)(0,1)(1,1) 三个点，发现能看到的关于对角线对称，考虑一半即可。这一半就是求 1\\le x\\lt y 且 x \\perp y 的 (x,y) 对数，发现对于每个 y 来说这样的 x 对数即为 \\varphi(y) 。 答案为 \\displaystyle3 + 2\\sum_{i=2}^{n-1}\\varphi(i) ，特判 n = 1 的情况 21/01/06 POJ3696 The Luckiest number 欧拉定理的推论 https://imyangty.com/oi/1280 P3846 [TJOI2007] 可爱的质数/【模板】BSGS BSGS 21/01/07 P4861 按钮 求满足 k^x\\equiv 1\\pmod m 的最小正整数 x 。由裴蜀定理可得有解的充要条件是 \\gcd(k, m) = 1 ，所以直接 BSGS P2485 [SDOI2011]计算器 快速幂取模 + exgcd + BSGS 综合题 21/01/09 P4195 【模板】扩展BSGS/SP3105 MOD - Power Modulo Inverted exBSGS CF1063B Labyrinth 双端队列优化 01bfs CF786B Legacy 线段树优化建图模板 21/01/13 BZOJ2973 石子游戏 构造转移矩阵，矩阵乘法 21/01/14 P3389 【模板】高斯消元法 高斯消元 LOJ6208 树上询问 线段树维护矩阵和 P4035 [JSOI2008]球形空间产生器 推式子，二次项消去后高斯消元 21/01/15 LOJ#6277. 数列分块入门 1 区间修改单点求值 LOJ#6278. 数列分块入门 2 区间修改区间询问某数排名 P3372 【模板】线段树 1 分块重写 21/01/16 CF149D Coloring Brackets 区间 dp（记忆化搜索）， f(i, j, k_1, k_2) 为合法序列 [i,j] ，两端状态 k_1, k_2 ，需注意合法序列两端未必就是匹配的，所以之前定义 f(i, j, k) 是错误的 CF242E XOR on Segment 区间 xor 区间求和，按位拆分方便处理区间 xor，对于每一位都建一棵线段树，xor 就是集体取反。 21/01/17 CF607A Chain Reaction 线性 dp， f_i 为从位置 i 开始激活最多保留的激光塔个数 P1005 [NOIP2007 提高组] 矩阵取数游戏 很水的区间dp，难点高精，int128 过之 LOJ#6279. 数列分块入门 3 区间修改区间询问某数前驱 21/01/21 LOJ#6280. 数列分块入门 4 区间修改区间查询 LOJ#6281. 数列分块入门 5 区间开根区间查询 21/01/23 POJ1830 开关问题 高斯消元求解 xor 方程组 P1102 A-B 数对 std::map 或二分 LOJ#6282. 数列分块入门 6 单点插入单点查询（块状链表） LOJ#6283. 数列分块入门 7 区间乘区间加单点查询 LOJ#6284. 数列分块入门 8 区间查询某数出现个数并赋值 P4168 [Violet]蒲公英 强制在线区间众数 LOJ#6285. 数列分块入门 9 区间众数 21/01/24 P4127 [AHOI2009]同类分布 P2657 [SCOI2009] windy 数 数位 dp 21/01/25 Codeforces Round #697 (Div. 3) A+B+C+E，是否 fst 未知 21/01/26 Codeforces Round #697 (Div. 3) 没有 fst，A+B+C+E P3455 [POI2007]ZAP-Queries P2522 [HAOI2011]Problem b P2257 YY的GCD 莫比乌斯反演 21/01/27 P4213 【模板】杜教筛（Sum） 杜教筛 21/01/28 Codeforces Round #698 (Div. 2) A + B，菜的我直接爬 21/01/29 P3803 【模板】多项式乘法（FFT） FFT 板子 P1919 【模板】A*B Problem升级版（FFT快速傅里叶） FFT 实现高精度乘法 Educational Codeforces Round 103 菜的抠脚依旧 A + B，C 没调出来 21/01/30 P3338 [ZJOI2014]力 转化式子之后使用 FFT P3312 [SDOI2014]数表 莫反 + 树状数组，比较巧妙 P3377 【模板】左偏树（可并堆） 左偏树模板 21/01/31 P3723 [AH2017/HNOI2017]礼物 FFT/NTT 加速卷积 P2224 [HNOI2001]产品加工 奇葩的状态定义：https://imyangty.com/oi/1298","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"P1463 [POI2002][HAOI2007]反素数","slug":"sol-luogu-p1463","date":"2020-12-22T14:08:11.000Z","updated":"2022-04-13T12:27:28.346Z","comments":true,"path":"sol-luogu-p1463/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1463/","excerpt":"","text":"题意 对于任何正整数 x ，其约数的个数记作 g(x) 。例如 g(1)=1 ， g(6)=4 。 如果某个正整数 x 满足： \\forall 0 \\lt i \\lt x ，都有 g(x) \\gt g(i) ，则称 x 为反质数。例如，整数 1,2,4,6 等都是反质数。 求不超过 N 的最大的反质数 思路 考虑唯一分解定理分解一个数 x ： x = \\prod p_i^{c_i} 其中 p_i 为质数，且单调递增。 其约数和即为 \\prod(c_i+1) 。 注意到 c_i 一定单调递减，因为如果不满足单调减的话可以通过调整法找到更优解。所以一个数是反素数的必要条件是 c_i 单调递减。 而且，注意到最小的十一个素数乘积大于 2\\times 10^9 ，所以只需要最前面的几个素数。同时如果只包含最小的素数， 2^{31}\\gt2\\times 10^9 ，所以指数只用枚举到 30 。 所以直接 dfs，找到约数个数最多的数中最小的一个（因为要 \\forall 0 \\lt i \\lt x ）。 123456789101112131415161718192021222324252627#include &lt;cstdio&gt;typedef long long ll;const ll prime[] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};ll n, ans, maxcnt;void dfs(int now, ll nowprod, ll nowcnt, int nowlim){ if (nowcnt &gt; maxcnt (nowcnt == maxcnt &amp;&amp; nowprod &lt; ans)) { ans = nowprod; maxcnt = nowcnt; } for (ll i = 1, t = prime[now]; i &lt;= nowlim &amp;&amp; t * nowprod &lt;= n; ++i, t *= prime[now]) dfs(now + 1, nowprod * t, nowcnt * (i + 1), i);}int main(){ scanf(\"%lld\", &amp;n); ans = 1, maxcnt = 1; dfs(1, 1, 1, 30); printf(\"%d\\n\", ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"素数与筛法","slug":"prime","permalink":"https://old.blog.imyangty.com/tags/prime/"}]},{"title":"解题报告 POJ2689 Prime Distance","slug":"sol-poj2689","date":"2020-12-21T14:46:27.000Z","updated":"2022-04-13T12:27:28.342Z","comments":true,"path":"sol-poj2689/","link":"","permalink":"https://old.blog.imyangty.com/sol-poj2689/","excerpt":"","text":"题意 给定 [L,R] ，求 [L,R] 中相邻两素数的最大/最小距离。其中 L&lt;R\\le 2^{31}-1 ， R-L\\le10^6 。 思路 值域过大，不能直接筛，但是注意到 [L,R] 中的数的最大质因子都不会超过 \\sqrt R ，所以可以先筛出来 [1,\\sqrt{2^{31}-1}] 的素数表，然后用这张表去筛 [L,R] 内的素数，最后扫一遍即可。 总的复杂度为 O(n + (R-L)\\log\\log R) 一定要特判 1 不是素数，不然狂 WA 不止。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define int long longint l, r;const int maxr = 1ll &lt;&lt; 31;const int maxn = 1e6 +5;int prime[50005], cntprime;bool is_prime[maxn];inline int max(int a, int b){return a &gt; b ? a : b;}signed main(){ is_prime[1] = 1; for (int i = 2; i &lt;= 55000; ++i) { if (!is_prime[i]) prime[++cntprime] = i; for (int j = 1; j &lt;= cntprime &amp;&amp; i * prime[j] &lt;= 55000; ++j) { is_prime[i * prime[j]] = 1; if (!(i % prime[j])) break; } } while (scanf(\"%lld %lld\", &amp;l, &amp;r) != EOF) { memset(is_prime, 0, sizeof is_prime); for (int i = 1; i &lt;= cntprime &amp;&amp; prime[i] * prime[i] &lt;= r; ++i) for (int j = max(2, l / prime[i]); prime[i] * j &lt;= r; ++j) if (prime[i] * j &gt;= l) is_prime[prime[i] * j - l] = 1; if (l == 1) is_prime[0] = 1; int mindist = maxr, maxdist = -maxr, last = -1, cnt = 0, c1, c2, d1, d2; for (int i = l; i &lt;= r; ++i) { if (!is_prime[i - l]) { ++cnt; if (last &gt; 0) { if (i - last &gt; maxdist) d1 = last, d2 = i, maxdist = i - last; if (i - last &lt; mindist) c1 = last, c2 = i, mindist = i - last; } last = i; } } if (cnt &lt; 2) printf(\"There are no adjacent primes.\\n\"); else printf(\"%lld,%lld are closest, %lld,%lld are most distant.\\n\", c1, c2, d1, d2); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"素数与筛法","slug":"prime","permalink":"https://old.blog.imyangty.com/tags/prime/"},{"name":"POJ","slug":"POJ","permalink":"https://old.blog.imyangty.com/tags/POJ/"}]},{"title":"平衡树笔记","slug":"note-bst","date":"2020-12-12T06:20:29.000Z","updated":"2022-03-23T04:17:42.159Z","comments":true,"path":"note-bst/","link":"","permalink":"https://old.blog.imyangty.com/note-bst/","excerpt":"","text":"二叉搜索树(BST) BST 是一种常用的数据结构，每个节点储存着一个可以比较大小的权值，并且其满足如下性质：对于任意节点 u ，其左子树（如果存在）内所有节点的权值均小于 u 的权值，其右子树（如果存在）内所有节点的权值均大于 u 的权值。 不难发现这棵树可以做很多事情：这棵树的中序遍历就是排好序的序列，并且可以很方便的进行插入删除和查找操作（只需层层递归即可），同时可以统计一个元素的排名（只需看左边有多少节点）。 然而，如果插入的序列是一个递增的序列，则 BST 的复杂度可以退化到 O(n) ，这样的话查找一个元素的复杂度和在线性表内查找就没有什么区别了，需要进行优化。 不难发现，对于一个集合，如果我们将他建构成一棵 BST，可以有很多情况，而很明显地：左右平衡的结构是相对比较优的，这样子的话操作的期望复杂度为 O(\\log n) ，达到了我们的目的。 下面学习一些比较常用的可以使 BST 平衡的手法 Treap 简介 Treap=Tree+Heap，是一种相对好写的平衡 BST（简称平衡树），从其命名可以看出来它是一个堆（Heap) 与 BST（Tree）的结合体。 Treap 有如下性质： 是一棵关于元素值 val 的 BST 是关于权值 priority（一般是随机的）的堆（小根大根没什么区别） val 和 priority 确定时，Treap 唯一 这样随机给元素分配权值可以使得 Treap 不容易退化成链，使查找/插入/删除/第 k 大/排名的操作都是 O(\\log n) 的。 Initialization 首先是 Treap 的数组形式定义（指针太难写了而且容易出奇奇怪怪的 bug） 1234567struct treap{ int ch[2];//存储左/右儿子的编号 int cnt,size;//存储当前元素的数量和子树大小 int val,p;//val为元素值，p为随机权值}t[maxn]; 下面操作类似于线段树的 pushup，主要是下面信息改变后维护子树大小用 12345678#define L t[u].ch[0]#define R t[u].ch[1]inline void maintain(int u){ t[u].size=t[u].cnt+t[L].size+t[R].size; return;} 旋转 接下来了解一下 Treap 的核心操作：旋转。 Treap 的旋转操作只需要实行一次，说人话就是为了保持堆的性质，将某节点的儿子旋转上来，同时要使树仍满足 BST 的性质，怎么实现呢？看下图： 画图理解后，代码就比较容易写了： d 是旋转方式，0 为旋转左儿子上来（右旋），1 则反之亦然。 123456789void rotate(int &amp;x,int d)// x 引用是为了方便修改，一般传进来的参就是 t[u].ch[x]{ int k=t[x].ch[d];//要旋转上来的节点 t[x].ch[d]=t[k].ch[d^1]; t[k].ch[d^1]=x; maintain(x);//这里一定要先维护 x maintain(x=k);//然后将 x 的值改变，并维护之} 注意 x 和 k 的维护顺序，因为 k 的 size 是要从 x 那里更新来的，所以要先处理好儿子的结果。 插入/删除 插入操作。直接从根开始，二分查找到对应位置，如果已经存在则 ++cnt，如果不存在就新建节点。 1234567891011121314151617181920212223void insert(int &amp;u,int val){ if(!u)//如果 val 不存在 { u=++cnt;//开一个新节点 t[u].size=t[u].cnt=1; t[u].val=val; t[u].p=rand();//随机一个权值 return; } t[u].size++;//因为加到子树里面了，所以 ++size if(t[u].val==val)//找到了就直接增加cnt { t[u].cnt++; return; } int d=t[u].val&lt;val;//比较巧妙的写法，待插入值大的话就是1，对应右儿子，反之亦然 insert(t[u].ch[d],val); if(t[u].p&gt;t[t[u].ch[d]].p)//维护小根堆，如果插入后破坏了堆的性质 rotate(u,d);//就把对应儿子旋上来 return;} 删除操作。比较难搞，遇到一个节点的时候分为如下情况： 当前节点不是待删除节点，递归儿子查找删除 当前节点是待删除节点但是个数大于 1，个数-- 然后返回 当前节点是待删除节点且个数为 1 至少有一个儿子为空：把另外一个儿子翻上来，然后直接丢掉自己 两个儿子都不为空：把随机权值较低的儿子翻上来，然后化为 1 情况继续递归 12345678910111213141516171819void delnode(int &amp;u,int val){ if(!u)return;//访问到空了 if(t[u].val==val)//找到待删除节点 { if(t[u].cnt&gt;1)//多于一个就只删除一个 { t[u].cnt--; t[u].size--; return; } int d=t[L].p&gt;t[R].p; if((!L)||(!R))//如果左或右有至少一边为空 u=L+R;//直接把非空的赋给 u else rotate(u,d),delnode(u,val);//否则就把随机权值更小的儿子翻上来，然后递归处理 } else t[u].size--,delnode(t[u].ch[t[u].val&lt;val],val);//size--，然后递归到儿子里面删除} 查询排名/第 k 大/小 查询排名操作。这个就比较简单了，同时也是我们为什么要维护每个节点的 size。看代码即能理解： 12345678910int rank(int u,int val){ if(!u)return 1;//如果到了空节点，返回 1，因为排名可以排到 1 if(t[u].val==val)//如果找到了对应的数 return t[L].size+1;//返回左儿子的大小加 1 if(t[u].val&gt;val)//如果当前节点大于待查找 return rank(L,val);//递归查找左儿子 else return rank(R,val)+t[L].size+t[u].cnt;//这里比较容易错，因为需要加上左儿子和节点本身产生的贡献} 查询第 k 小/大。这里实现查询第 k 小，理解了排名操作基本就能写出来了。值得注意的是这里既可以递归操作，也可以直接迭代写出来。 递归： 123456789101112int kth(int u, int k){ if (!u) return 0; int lsize = L ? t[L].size : 0; if (k &lt;= lsize) return kth(L, k); else if(k &lt;= lsize + t[u].cnt) return t[u].val; else return kth(R, k - t[u].cnt - lsize);//k要减去贡献} 非递归： 12345678910111213int kth(int k){ int u=root;//从根节点开始向下查找 while (true) { if(k&lt;=t[L].size)//如果待查询的 k 小于左子树大小 u=L;//往左走 else if(k&gt;t[L].size+t[u].cnt)//如果大于了左边和本身产生的贡献 k-=t[L].size+t[u].cnt,u=R;//首先 k 要减去贡献，然后再往右走 else return t[u].val;//否则就是找到了，直接返回即可 }} 前驱后继/完整代码 前驱和后继。前驱的定义为“小于 x 的最大的数”。为了满足“小于 x ”，如果当前节点大于等于 x ，则在左儿子里面查找。但如果发现了小于 x 的数，为了满足“最大的数”，要在其右子树里面继续查找，结合代码会更好理解。 123456789101112131415161718int pre(int u,int val){ if(!u)//查到了空节点 return -inf;//就返回一个不会对答案产生贡献的 -inf if(t[u].val&gt;=val)//如果不满足“小于 val“ 的性质 return pre(L,val);//就在左儿子里面找 return max(pre(R,val),t[u].val);//取max是为了处理万一右儿子不存在}int nxt(int u,int val)//与前驱同理{ if(!u) return inf; if(t[u].val&lt;=val) return nxt(R,val); return min(nxt(L,val),t[u].val);} 所以 洛谷 P6136 的代码如下（省略了一些不关键的定义）：（建议不要提交 P3369，有很多问题没有考虑到的 Treap 是可以通过那道题的，建议交加强版） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;climits&gt;#include &lt;cstdlib&gt;#define L t[u].ch[0]#define R t[u].ch[1]inline int read(){ char c = getchar(); int s = 0; bool x = 0; while (!isdigit(c)) x = x | (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x?-s:s;}inline int max(int a,int b){return a &gt; b? a : b;}inline int min(int a,int b){return a &lt; b? a : b;}const int maxn = 2e6+5, inf = INT_MAX-20;int cnt, root, lastans = 0, ans = 0;struct treap{ int ch[2]; int val, p; int size, cnt;} t[maxn];inline void maintain(int u){ t[u].size = t[u].cnt + t[L].size + t[R].size; return;}inline void rotate(int &amp;u, int d){ int k = t[u].ch[d]; t[u].ch[d] = t[k].ch[d ^ 1]; t[k].ch[d^1] = u; maintain(u); maintain(u = k); return;}void insert(int &amp;u, int val){ if (!u) { u = ++cnt; t[u].size = t[u].cnt = 1; t[u].val = val; t[u].p = rand(); return; } t[u].size++; if (t[u].val == val) { t[u].cnt++; return; } int d = val &gt; t[u].val; insert(t[u].ch[d], val); if (t[t[u].ch[d]].p &lt; t[u].p) rotate(u, d); return;}void delnode(int &amp;u,int val){ if (!u) return; if (t[u].val == val) { if (t[u].cnt &gt; 1) { t[u].cnt--; t[u].size--; return; } if ((!L) || (!R)) u = L + R; else { int d = t[L].p &gt; t[R].p; rotate(u, d); delnode(u, val); } } else t[u].size--, delnode(t[u].ch[val &gt; t[u].val], val); return;}int rank(int u,int val){ if (!u) return 1; if (val == t[u].val) return t[L].size + 1; if (val &lt; t[u].val) return rank(L, val); else return rank(R, val) + t[L].size + t[u].cnt;}int kth(int u, int k){ if (!u) return 0; int lsize = L ? t[L].size : 0; if (k &lt;= lsize) return kth(L, k); else if(k &lt;= lsize + t[u].cnt) return t[u].val; else return kth(R, k - t[u].cnt - lsize);}int pre(int u, int val){ if (!u) return -inf; if (t[u].val &gt;= val) return pre(L, val); else return max(t[u].val, pre(R, val));}int suc(int u, int val){ if (!u) return inf; if (t[u].val &lt;= val) return suc(R, val); else return min(t[u].val, suc(L, val));}int main(){ int n = read(), m = read(); srand(20041031); while (n--) insert(root, read()); while (m--) { int opt = read(), x = read() ^ lastans; switch (opt) { case 1: insert(root, x); break; case 2: delnode(root, x); break; case 3: ans ^= (lastans = rank(root, x)); break; case 4: ans ^= (lastans = kth(root, x)); break; case 5: ans ^= (lastans = pre(root, x)); break; case 6: ans ^= (lastans = suc(root, x)); break; } } printf(\"%d\\n\", ans); return 0;} FHQ-Treap（无旋 Treap） 由范浩强大佬发明的神级数据结构，相比于 Treap 不用旋转，且增添了两个核心操作：分裂（split）与合并（merge），这两个操作是无旋 Treap 的核心操作，其余的所有操作都是基于 split 和 merge 的。 两个值相同的元素是分别储存在两个不同的节点里面的，不像 Treap 的 cnt 域 分裂 该操作把一棵 Treap 分裂成两棵，有两种分裂方法：按值分裂以及按大小分裂。这里先考虑按值分裂。 该种分裂方式按照一个阈值 k 把一棵 Treap 分裂成两棵，满足左树的所有元素值均小于等于 k ，右树的所有元素值均大于 k 。由于 Treap 满足堆的性质，所以直接分裂即可，不需要特殊维护。 一般来说 split() 函数使用递归实现：void split(int u, int k, int &amp;x, int &amp;y)，其中 u 表示当前节点， k 不再赘述，两个引用 x 和 y 是放返回值（即分裂出来的左树的根和右树的根）的。 1234567891011121314151617void split(int u, int k, int&amp; x, int&amp; y) { if (!u) x = y = 0; else { if (t[u].val &lt;= k) { x = u; split(R, k, R, y); } else { y = u; split(L, k, x, L); } maintain(u); } return;} 接下来解释一下上面的代码： 首先如果这个节点不存在，就不能再继续了，直接 x = y = 0; 即可。 然后如果这个节点的值小于等于 k ，则这个节点肯定是划到左树里面去了，所以有 x = u;，然后对于这个节点的左子树，肯定是被划到左子树里面去的，所以继续分裂右子树，即 split(R, k, R, y);。如果无法理解，下面来看看具体步骤： 这是一棵分裂前的 FHQ-Treap（省略了节点编号和随机权值，只保留了值），让我们以阈值 7 将其分裂。一开始 split(root, 7, x, y) 首先我们找到树根 6 ， 6 \\le 7 ，所以划到左树里面，同时它的左子树也都属于左树。（属于左树的节点标红） 接下来 split(R, k, R, y) 即 split(10的编号, 7, t[6].ch[1], y) 现在来到节点 10 ，注意到 10 &gt; 6 ，所以 10 划给右树， 10 的所有右节点也都划给右树：此时 y 就被赋为 10 的编号。 然后 split(L, k，x, L) 即 split(8的编号, 7, t[6].ch[1], t[10].ch[0])， 8 &gt; 7 接下来 split(L, k, x, L) 即 split(7的编号, 7, t[6].ch[1], t[8].ch[0])，发现 7 \\le 7 ，所以划到左子树，并且 x=u ，即把 t[6].ch[1] 赋为 7， 然后 split(R, k, R, y) 即 split(0, 7, t[7].ch[1], t[8].ch[0])，发现节点不存在，将 x 和 y 都赋为 0 ，返回即可。这样就完成了分裂。 总结一下： 遇到比小于等于阈值的节点，由于其左子树一定划为左树，所以要继续分裂右子树，传下去左树的根是当前节点的右儿子，在更深的递归层会更新。 遇到大于阈值的节点，同理，分裂左子树，传下去右树的根是当前节点的左儿子，在更深的递归层会更新 这个递归可能一开始不太好理解，但是理解了会发现其实挺简单的。 合并 合并的时候是把两棵 FHQ-Treap x 和 y 合并成一棵，必须满足： x 中所有节点的值小于等于 y 中所有节点的值，然后合并的结果也要满足 Treap 的性质（即堆的性质）。 合并函数 int merge(int x, int y) 返回合并后的树根， x,y 分别为两棵待合并树的根。由于要维护堆的性质，实现如下： 123456789101112131415int merge(int x, int y) { if (!x || !y) return x + y; if (t[x].key &lt; t[y].key) { t[x].ch[1] = merge(t[x].ch[1], y); maintain(x); return x; } else { t[y].ch[0] = merge(x, t[y].ch[0]); maintain(y); return y; }} 首先如果两棵树的其中一棵为空，则直接返回另一棵的根即可。 然后维护一个小根堆（小根大根其实无所谓），如果发现左边子树根（ x ）的权小一些，说明是 x 做父亲，将其右子树与 y 合并的结果作为其右子树即可，合并完记得 pushup 一下就行了。 反之亦然，将 y 的左子树与 x 合并的结果作为 y 的左子树即可，注意传参的顺序：先传左树后传右树 还是比较好理解的。学习完了两个基本操作，就可以很轻松的实现插入删除排名 k\\text{th} 前驱后继等操作了。 插入 值得注意的是，FHQ-Treap 在处理相同值的时候是单独开新节点的，不像一般的 Treap 维护 cnt 域。 核心思想就是以待插入值为阈值分裂成树 x ， y ，然后将 x ，新节点和 y 合并即可。 12345678910void insert(int val) { t[++cnt].val = val;//开新节点 t[cnt].key = rnd();//随机分配权 t[cnt].size = 1; int x, y;//临时变量 split(root, val, x, y);//按照 val 分裂 root = merge(merge(x, cnt), y);//先合并 x 和新节点，再将结果与 y 合并 return;} 删除 这个操作比较精妙：考虑删除 val ，先将整棵树分裂成 x ， y ， z 三棵树，满足： x 中所有节点值均小于 val ， y 中均等于 val ， z 中均大于 val 。这时候我们发现要删除一个 val 就只需要拿掉 y 的根节点就可以了，其等价于直接合并 y 的左右子树。 123456789void delnode(int val) { int x, y, z; split(root, val - 1, x, y);//按照 val-1 分裂出 x 树 split(y, val, y, z);//再按照 val 分裂出 y 和 z y = merge(t[y].ch[0], t[y].ch[1]);//直接拿掉 y 的根 root = merge(merge(x, y), z);//再复原就可以了 return;} 排名/第 k 大/小 查询排名很类似于删除操作，但只需要分裂出小于 val 的树然后返回其大小加一的值即可。 12345678int rank(int val) { int x, y; split(root, val - 1, x, y); int ans = t[x].size + 1; root = merge(x, y); return ans;} 然而查询 k\\text{th} 时就不能分裂/合并了，老老实实按照大多数平衡树的写法就可以了，建议非递归，常数小一些。 1234567891011121314int kth(int k) { int u = root; while (true) { int lsize = 0; if (L) lsize = t[L].size; if (k &lt;= lsize) u = L; else if (k &gt; lsize + 1) k -= lsize + 1, u = R; else return t[u].val; }} 前驱/后继 前驱：小于 x 且最大的数，所以利用排名和 k\\text{th} 即可。查找 x 的排名然后输出对应该排名减一的数即可。 后继：查找 x+1 的排名然后输出该排名对应的数即可 12345678int pre(int val) { return kth(rank(val) - 1);}int suc(int val) { return kth(rank(val + 1));} 普通平衡树的实现 可以发现代码明显短于一般 Treap 和 Splay，但常数大于 Treap 小于 Splay。关键是特别好写好背 洛谷 P6136 的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;const int maxn = 1e6 + 2e5;inline int read() { char c = getchar(); int s = 0; bool x = 0; while (!isdigit(c)) x = x | (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}struct node { int size; int ch[2]; int val, key;#define L (t[u].ch[0])#define R (t[u].ch[1])} t[maxn];int cnt, root;inline void pushup(int u) { t[u].size = t[L].size + t[R].size + 1; return;}void split(int u, int k, int&amp; x, int&amp; y) { if (!u) { x = y = 0; return; } if (t[u].val &lt;= k) { x = u; split(R, k, R, y); } else { y = u; split(L, k, x, L); } pushup(u); return;}int merge(int x, int y) { if (!x || !y) return x + y; if (t[x].key &lt; t[y].key) { t[x].ch[1] = merge(t[x].ch[1], y); pushup(x); return x; } else { t[y].ch[0] = merge(x, t[y].ch[0]); pushup(y); return y; }}void insert(int val) { t[++cnt].val = val; t[cnt].key = rand(); t[cnt].size = 1; int x, y; split(root, val, x, y); root = merge(merge(x, cnt), y); return;}void delnode(int val) { int x, y, z; split(root, val - 1, x, y); split(y, val, y, z); y = merge(t[y].ch[0], t[y].ch[1]); root = merge(merge(x, y), z); return;}int rank(int val) { int x, y; split(root, val - 1, x, y); int ans = t[x].size + 1; root = merge(x, y); return ans;}int kth(int k) { int u = root; while (true) { int lsize = 0; if (L) lsize = t[L].size; if (k &lt;= lsize) u = L; else if (k &gt; lsize + 1) k -= lsize + 1, u = R; else return t[u].val; }}int pre(int val) { return kth(rank(val) - 1);}int suc(int val) { return kth(rank(val + 1));}int main() { int n = read(), m = read(), ans = 0, lastans = 0; srand(20041031); while (n--) insert(read()); while (m--) { int opt = read(), x = read() ^ lastans; switch (opt) { case 1: insert(x); break; case 2: delnode(x); break; case 3: ans ^= (lastans = rank(x)); break; case 4: ans ^= (lastans = kth(x)); break; case 5: ans ^= (lastans = pre(x)); break; case 6: ans ^= (lastans = suc(x)); break; } } printf(\"%d\\n\", ans); return 0;} 按大小分裂/文艺平衡树的实现 FHQ-Treap 还有另外一种分裂方式：按大小分裂，将一棵 FHQ-Treap 分裂成 x ， y ，满足 x 的大小为给定值。这样子分裂能够让我们更好更方便地处理区间问题，下面以文艺平衡树为例： 首先是分裂函数： 1234567891011121314void split(int u, int size, int &amp;x, int &amp;y) { if (!u) { x = y = 0; return; } pushdown(u); if (t[L].size &lt; size) x = u, split(R, size - t[L].size - 1, R, y); else y = u, split(L, size, x, L); pushup(u); return;} 基本和一般的按值分裂是差不多的，只不过要注意的就是如果要继续分裂右子树，传下去的 size 值是需要改变的。 剩下的也没什么了，对于要翻转区间 [l,r] ，直接分裂成三棵树。具体地，按照 l-1 分裂成 x 和 y ，再将 y 按照 r-l+1 分裂成 y 和 z ，此时 y 树就是提取出来的区间 [l,r] ，打上标记即可。 实现文艺平衡树的时候需要特别注意标记的下传，实现如下，比 Splay 简洁且不容易写错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;const int maxn = 100000 + 5;inline int read() { char c = getchar(); int s = 0; bool x = 0; while (!isdigit(c)) x = x | (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}struct node { int ch[2]; int size; int val, key; bool tag;#define L (t[u].ch[0])#define R (t[u].ch[1])} t[maxn];int cnt, root;inline void pushup(int u) { t[u].size = t[L].size + t[R].size + 1; return;}inline void pushdown(int u) { if (t[u].tag) { int tmp = L; L = R; R = tmp; t[L].tag ^= 1, t[R].tag ^= 1; t[u].tag = 0; } return;}void split(int u, int size, int&amp; x, int&amp; y) { if (!u) { x = y = 0; return; } pushdown(u); if (t[L].size &lt; size) x = u, split(R, size - t[L].size - 1, R, y); else y = u, split(L, size, x, L); pushup(u); return;}int merge(int x, int y) { if (!x || !y) return x + y; if (t[x].key &lt; t[y].key) return pushdown(x), t[x].ch[1] = merge(t[x].ch[1], y), pushup(x), x; else return pushdown(y), t[y].ch[0] = merge(x, t[y].ch[0]), pushup(y), y;}int newnode(int val) { t[++cnt].val = val; t[cnt].key = rand(); t[cnt].size = 1; return cnt;}void reverse(int l, int r) { int x, y, z; split(root, l - 1, x, y); split(y, r - l + 1, y, z); t[y].tag ^= 1; root = merge(merge(x, y), z); return;}void dfs(int u) { if (!u) return; pushdown(u); dfs(L); printf(\"%d \", t[u].val); dfs(R); return;}int main() { int n = read(), m = read(); for (int i = 1; i &lt;= n; ++i) root = merge(root, newnode(i)); while (m--) { int l = read(), r = read(); reverse(l, r); } dfs(root); return 0;} 可见 100 行出头就写完了，比 Splay 好写太多了。 维护区间时的一个 trick 当我们在使用 FHQ-Treap 维护一段序列时，有时需要快速找出某元素在序列中的位置，怎么办呢？ 此时可以在建树时记录下这个元素在树中的节点编号，然后在找寻其排名时自底而上记录在它左边的节点个数。具体可以这样： 123456789101112int getrank(int u){ int ret = t[L].size + 1; while (t[u].fa) { if (t[t[u].fa].ch[1] == u) ret += t[t[t[u].fa].ch[0]].size + 1; u = t[u].fa; } return ret;} 对于一个节点 u ，首先它的排名就是其左子树大小加一，然后往上跳，在跳的过程中判断一下它是父亲节点的左儿子还是右儿子，如果是右儿子的话，父亲本身和其兄弟节点都会产生贡献，一路搜到根即可。 同时 pushup 的时候要更新父亲，pushup 一个节点的时候顺带更新其两个儿子的父亲（需要判断是否存在） 12345678910inline void pushup(int u){ t[u].size = 1; if (L) t[u].size += t[L].size, t[L].fa = u; if (R) t[u].size += t[R].size, t[R].fa = u; return;} 相关题目 [ZJOI2006]书架、[CQOI2014]排序机械臂，当然这些题都可以用 Splay 解决。 启发式合并 此处的合并与之前的 merge 操作不同，此处合并的两棵树就是两棵一般的树，不能简单地直接 O(\\log n) 合并。此时我们能做的就是将小树暴力递归加入到大树中，复杂度 O(\\log^2 n) 。具体实现如下： 12345678910111213141516171819202122232425void insert(int&amp; root, int u) { //表示将 u 节点加入 root 为根的新树中 int x, y; int val = t[u].val; split(root, val, x, y); root = merge(merge(x, u), y); return;}void dfs(int u, int&amp; root) { //这个 root 的引用是新树的树根 if (!u) return; dfs(L, root);//先把左子树加入 dfs(R, root);//加入右子树 L = R = 0;//清空儿子，这一步不写会出问题 insert(root, u);//再加入自己 return;}int join(int x, int y) { if (t[x].size &gt; t[y].size) swap(x, y); dfs(x, y);//使 x 成为小树然后递归加入 y 中 return y;//返回新的根 y} 相关试题 [HNOI2012]永无乡 易错点 分裂代码不背错就行 涉及到分裂完合并的时候**一定记得更新根！！**即 root = merge(...) 类似第二点，删除节点过程中合并 y 的左右子树的时候千万记得更新 y 的值 涉及到子树的操作千万提前 pushdown Splay 简介/Initialization 相较于两种 Treap，Splay（伸展树）则稍微难写一点，Splay 的核心操作就是 splay：即把一个节点旋转到根的位置，以此维护树的平衡。它相较于 Treap 的优点就是可以处理区间信息以及快速合并/分裂（虽然 fhqTreap 也能做到）。 Splay 具有一切 BST 具有的性质，其相较于 Treap 的区别就是它是双旋的，这样可以保证均摊复杂度 O(\\log n) （证明要用势能分析，我太菜暂时不会）。首先看下结构体如何定义： 1234567struct Splay{ int ch[2], fa;//与 treap 不同之处在于 splay 需要记录父亲节点的编号 int cnt, size; int val;} t[maxn]; 处理旋转的时候是需要知道这个节点是父亲的左儿子还是右儿子的，如下： 12345inline bool get(int u){ return t[t[u].fa].ch[1] == u;} 旋转后与 Treap 一样需要维护 size 123456inline void maintain(int u){ t[u].size = t[u].cnt + t[L].size + t[R].size; return;} 旋转/伸展（Splay） 接下来就是该死的旋转操作了：考虑将 x 节点旋转到 fa 的位置，（令 fa 的父节点为 gfa ）图示如下： 这是一开始的情况，首先判断 x 是其父亲的哪个儿子，定义 d_1 为 0 表示是左儿子， 1 为右儿子，然后把其父亲的 d_1 儿子变成 t[x].ch[d1^1]，如下，此时由于 d_1=0 ，所以 d1^1 为右儿子： 接下来用 x 连接 gfa ，代替 fa 的位置 最后把 x 与 fa 接起来就可以了（即 t[x].ch[d1^1]=fa） 这样，一次旋转操作就完成了，它完成的就是将一个节点往上旋转到其父亲的位置。代码如下： 12345678910111213void rotate(int u){ int fa = t[u].fa, gfa = t[fa].fa; int d1 = get(u), d2 = get(fa); t[fa].ch[d1] = t[u].ch[d1 ^ 1], t[t[u].ch[d1 ^ 1]].fa = fa; if (gfa) t[gfa].ch[d2] = u; t[u].fa = gfa; t[fa].fa = u, t[u].ch[d1 ^ 1] = fa; maintain(fa);//最后不忘维护，注意先维护 fa，理由同 treap maintain(u);} 接下来就是 splay 过程了，splay 操作的目的就是将指定节点旋转到根节点，一次操作分为六种情况： 如果 x 的父亲为根，则旋转一次 如果 x 的父亲不为根，且 x 和 fa 的儿子类型相同（即“三点共线”，代码中就是 get() 函数返回值相同），那么首先左/右旋 fa ，再左/右旋 x （两次单旋的方向相同） 如果在第二种情况种， x 和 fa 的儿子类型不同，则将 x 旋转两次，先左/右再右/左旋（两次单旋的方向不同） ”三点共线“的情况见下图： 6 为 x ， 3 为 fa ， 2 为 gfa 。 可见我们先右旋 fa ，得到如下结果： 接下来再右旋 x ，得到： 三点不共线的情况如下图： 此时 x=6 ， fa=4 ， gfa=2 ，现在对 x 先进行一次右旋： 再对 x 进行一次左旋： 反复执行如上操作，直到 x 成为根后，整个 splay 过程就结束了。 下面的 splay(u,goal) 意为把 u 节点伸展到 goal 节点的儿子处（ goal=0 就是使 u 变成根节点） 12345678910111213141516void splay(int u, int goal) { while (t[u].fa != goal) {//一直伸展 int fa = t[u].fa, gfa = t[fa].fa;//找到父亲和爷爷 int d1 = get(u), d2 = get(fa);//找到 u 是什么儿子，fa 是什么儿子。左0右1 if (gfa != goal) {//如果爷爷不是根，则需要旋转两次，下面是旋转第一次 if (d1 == d2)//如果三点共线 rotate(fa);//先旋转 fa else rotate(u);//否则先旋转 u } rotate(u);//第二次旋转 } if (goal == 0)//如果 u 成为根了 root = u;//更新根的值} 插入 插入操作就比较简单了，由于 Splay 的形态是可以改变的，所以不需要递归。每插入一个元素都进行一次 Splay 操作让其变为根 1234567891011121314151617void insert(int val) { int u = root, fa = 0; while (u &amp;&amp; t[u].val != val) fa = u, u = t[u].ch[t[u].val &lt; val];//往下走 if (u)//如果节点已经存在 t[u].cnt++; else { u = ++cnt;//否则新开节点 if (fa)//如果自己不是根 t[fa].ch[t[fa].val &lt; val] = u; t[u].fa = fa; t[u].size = t[u].cnt = 1; t[u].val = val; } splay(u, 0);//为了降低均摊复杂度，需要将新插入的节点 splay 到根} 排名/第 k 小/大 由于 Splay 的形态可以改变，因此在查询排名的时候可以直接将其 splay 到树根，然后统计左子树大小再 +1 就可以了。当然首先需要找到对应的数在哪里，下面先实现 find(int val) 函数，它返回刚好等于 val 的节点的编号（如果存在的话），不存在则返回一个叶子节点（手玩一下便知它返回的要么是前驱要么是后继，但不一定是与 val 的值最接近的节点，但是一定可以保证返回的排名是正确的）。然后 rank() 函数的实现就相当简单了： 1234567891011int find(int val) { int u = root; while (t[u].val != val &amp;&amp; t[u].ch[t[u].val &lt; val]) u = t[u].ch[t[u].val &lt; val]; return u;}int rank(int val) { splay(find(val), 0);//先把对应节点旋转到根 return t[t[root].ch[0]].size + 1;//直接根的左子树大小加 1} 需要注意的是如果查询排名的数不存在的话会出一些奇奇怪怪的问题，所以在写加强版模板的时候推荐使用下面的写法： 1234567int rank(int val) { insert(val); int ans = t[t[root].ch[0]].size + 1; delnode(val); return ans;} 第 k 小。类似递归的查找即可，注意查询右子树的时候要减去本身和左子树的贡献： 123456789101112int kth(int k) { int u = root; while (true) { if (k &lt;= t[L].size)//如果第 k 小在左子树中 u = L; else if (k &gt; t[L].size + t[u].cnt) { //如果第 k 小在右子树中 k -= t[L].size + t[u].cnt;//减去 L 和 u 产生的贡献 u = R; } else return t[u].val;//否则就是自己了，返回即可 }} 前驱后继/删除 同排名操作，考虑直接把 val 节点翻到根。此时前驱要么就是根节点，要么就是左子树中最靠右的节点。由 find() 函数的性质，如果 val 存在，则前驱一定在左子树里面的最右边，如果 val 不存在，则翻上来的点要么是前驱要么是后继，如果小于 val 就直接返回，大于 val 则和第一种情况一样，在左子树里面的最右边。 而后继几乎同理。不难写出如下代码： 12345678910111213int getnxt(int val, int opt) {//opt=0 是前驱，1 是后继 splay(find(val), 0);//先把对应节点翻到根 int u = root; if (t[u].val &lt; val &amp;&amp; (!opt))//如果要找前驱并且根就是前驱，直接返回即可 return u; if (t[u].val &gt; val &amp;&amp; opt)//同理，要查找后继并且根就是后继 return u; u = t[u].ch[opt];//否则到左/右子树查找 while (t[u].ch[opt ^ 1])//查找最右/左边的节点 u = t[u].ch[opt ^ 1]; return u;} 注意这个函数返回的是前驱/后继在树中的编号，为什么要这样呢，为了下面的删除操作。 删除一个数时，注意我们如果将其 splay 到根的话，会发现左右子树不好处理。怎么办呢，把前驱旋转到根，然后把后继翻到前驱的下面，此时 splay() 函数的 goal 参数就体现出它的作用了。 不难发现，此时 val 一定是后继节点的左儿子，如图（回想一下前驱和后继的定义，你会发现确实是这样的）： 问题现在就很简单了，只需要删除掉 suc 的左儿子就可以了，如果有多个那就 cnt-- 并把对应节点 splay 到根，只有一个就把 suc 的左儿子设为空即可。现在知道为什么上面前驱和后继的函数返回的是节点编号了吧 123456789101112void delnode(int val) { int pre = getnxt(val, 0); int suc = getnxt(val, 1); splay(pre, 0); splay(suc, pre);//把后继旋转到前驱的儿子 if(t[t[suc].ch[0]].cnt &gt; 1) { t[t[suc].ch[0]].cnt--; splay(t[suc].ch[0], 0);//不忘再splay一次 } else t[suc].ch[0] = 0; return;} 普通平衡树的实现 唯一要注意的就是一开始需要先插入正负无穷，然后算出来的排名要减一，查询的 k 要加一 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;cstdio&gt;#include &lt;cctype&gt;#define L t[u].ch[0]#define R t[u].ch[1]inline int read() { char c = getchar(); int s = 0; bool x = 0; while (!isdigit(c)) x = x | (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}inline int max(int a, int b) { return a &gt; b ? a : b; }inline int min(int a, int b) { return a &lt; b ? a : b; }const int maxn = 1e5 + 5, inf = 0x3f3f3f3f;int cnt, root;struct Splay { int ch[2], fa; int cnt, size; int val;} t[maxn];inline bool get(int u) { return t[t[u].fa].ch[1] == u;}inline void maintain(int u) { t[u].size = t[u].cnt + t[L].size + t[R].size; return;}void rotate(int u) { int fa = t[u].fa, gfa = t[fa].fa; int d1 = get(u), d2 = get(fa); t[fa].ch[d1] = t[u].ch[d1 ^ 1], t[t[u].ch[d1 ^ 1]].fa = fa; t[gfa].ch[d2] = u, t[u].fa = gfa; t[fa].fa = u, t[u].ch[d1 ^ 1] = fa; maintain(fa); maintain(u);}void splay(int u, int goal) { while (t[u].fa != goal) { int fa = t[u].fa, gfa = t[fa].fa; int d1 = get(u), d2 = get(fa); if (gfa != goal) { if (d1 == d2) rotate(fa); else rotate(u); } rotate(u); } if (goal == 0) root = u;}void insert(int val) { int u = root, fa = 0; while (u &amp;&amp; t[u].val != val) fa = u, u = t[u].ch[t[u].val &lt; val]; if (u) t[u].cnt++; else { u = ++cnt; if (fa) t[fa].ch[t[fa].val &lt; val] = u; t[u].fa = fa; t[u].size = t[u].cnt = 1; t[u].val = val; } splay(u, 0);}int find(int val) { int u = root; while (t[u].val != val &amp;&amp; t[u].ch[t[u].val &lt; val]) u = t[u].ch[t[u].val &lt; val]; return u;}int rank(int val) { splay(find(val), 0); return t[t[root].ch[0]].size + 1;}int kth(int k) { int u = root; while (true) { if (k &lt;= t[L].size) u = L; else if (k &gt; t[L].size + t[u].cnt) { k -= t[L].size + t[u].cnt; u = R; } else return t[u].val; }}int getnxt(int val, int opt) { splay(find(val), 0); int u = root; if (t[u].val &lt; val &amp;&amp; (!opt)) return u; if (t[u].val &gt; val &amp;&amp; opt) return u; u = t[u].ch[opt]; while (t[u].ch[opt ^ 1]) u = t[u].ch[opt ^ 1]; return u;}void delnode(int val) { int pre = getnxt(val, 0); int suc = getnxt(val, 1); splay(pre, 0); splay(suc, pre); if (t[t[suc].ch[0]].cnt &gt; 1) { t[t[suc].ch[0]].cnt--; splay(t[suc].ch[0], 0); } else t[suc].ch[0] = 0; return;}int main() { insert(inf), insert(-inf); int n = read(); while (n--) { int opt = read(), x = read(); switch (opt) { case 1: insert(x); break; case 2: delnode(x); break; case 3: printf(\"%d\\n\", rank(x) - 1); break; case 4: printf(\"%d\\n\", kth(x+1)); break; case 5: printf(\"%d\\n\", t[getnxt(x, 0)].val); break; case 6: printf(\"%d\\n\", t[getnxt(x, 1)].val); break; } } return 0;} 前驱后继/删除操作的另一种实现 其实对于查询前驱/后继，我们也可以先插入 val （插入后它就会被 splay 成根），然后在其左/右子树中查询前驱/后继，最后完事了删除 val 就行了（ val 工具人表示很淦）。 但问题是，删除怎么办，此时要完成前驱后继操作就需要先学会删除。 此处不妨把 val splay 到根，然后分两种情况讨论： 如果左/右子树至少有一个是空的话，直接让不空的那个节点当根就可以了（如果删干净了就删干净了吧） 如果左右子树都不为空，则相当于要合并两棵 Splay，怎么办呢，考虑怎么维护 Splay 的性质： 我们可以将左子树最大的节点 Splay 到最上方，然后注意到此时根的左儿子肯定没有右儿子了。所以直接把根的右子树接到根的左儿子的右儿子上，然后让左儿子当根，根就直接滚蛋了。觉得抽象的可以看一下下面的图： 这是将待删除节点 splay 到根后，然后我们把左子树的最大值 splay 到左子树的根，这样左子树就不存在右子树了，将原来根的右子树接上去即可。 原来的根节点就可以丢掉不要了，同时不要忘记再更新根的值。 代码如下：（此时 getnxt() 返回的是答案了） 12345678910111213141516171819202122232425262728293031323334void delnode(int val) { splay(find(val), 0);//把待删除节点旋转到根 if (t[root].val != val) return; if (t[root].cnt &gt; 1) { t[root].cnt--; t[root].size--; return; } if ((!t[root].ch[0]) || (!t[root].ch[1])) root = t[root].ch[0] + t[root].ch[1]; else { int lmax = t[root].ch[0]; while (t[lmax].ch[1]) lmax = t[lmax].ch[1]; splay(lmax, root); t[t[root].ch[1]].fa = lmax; t[lmax].ch[1] = t[root].ch[1]; maintain(root = lmax); } t[root].fa = 0;//千万不要忘记把根的 fa 设为 0 return;}int getnxt(int val,int opt) { insert(val); int u = t[root].ch[opt], ans = t[u].val; while (t[u].ch[opt ^ 1]) u = t[u].ch[opt ^ 1], ans = t[u].val; delnode(val); return ans;} 普通平衡树的另外一种实现 洛谷P6136 的实现：这个版本可以较好的处理查询前驱/后继/排名时待查询数不存在的情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;cstdio&gt;#include &lt;cctype&gt;#define L t[u].ch[0]#define R t[u].ch[1]inline int read() { char c = getchar(); int s = 0; bool x = 0; while (!isdigit(c)) x = x | (c == '-'), c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}inline int max(int a, int b) { return a &gt; b ? a : b; }inline int min(int a, int b) { return a &lt; b ? a : b; }const int maxn = 2e6 + 5, inf = 2147483647 - 20;int cnt, root;struct Splay { int ch[2], fa; int cnt, size; int val;} t[maxn];inline bool get(int u) { return t[t[u].fa].ch[1] == u;}inline void maintain(int u) { t[u].size = t[u].cnt + t[L].size + t[R].size; return;}void rotate(int u) { int fa = t[u].fa, gfa = t[fa].fa; int d1 = get(u), d2 = get(fa); t[fa].ch[d1] = t[u].ch[d1 ^ 1], t[t[u].ch[d1 ^ 1]].fa = fa; if (gfa) t[gfa].ch[d2] = u; t[u].fa = gfa; t[fa].fa = u, t[u].ch[d1 ^ 1] = fa; maintain(fa); maintain(u);}void splay(int u, int goal) { while (t[u].fa != goal) { int fa = t[u].fa, gfa = t[fa].fa; int d1 = get(u), d2 = get(fa); if (gfa != goal) { if (d1 == d2) rotate(fa); else rotate(u); } rotate(u); } if (goal == 0) root = u;}void insert(int val) { int u = root, fa = 0; while (u &amp;&amp; t[u].val != val) fa = u, u = t[u].ch[t[u].val &lt; val]; if (u) t[u].cnt++; else { u = ++cnt; if (fa) t[fa].ch[t[fa].val &lt; val] = u; t[u].fa = fa; t[u].size = t[u].cnt = 1; t[u].val = val; } splay(u, 0);}int find(int val) { int u = root; while (t[u].val != val &amp;&amp; t[u].ch[t[u].val &lt; val]) u = t[u].ch[t[u].val &lt; val]; return u;}int kth(int k) { int u = root; while (true) { if (k &lt;= t[L].size) u = L; else if (k &gt; t[L].size + t[u].cnt) { k -= t[L].size + t[u].cnt; u = R; } else return t[u].val; }}void delnode(int val) { splay(find(val), 0); if (t[root].val != val) return; if (t[root].cnt &gt; 1) { t[root].cnt--; t[root].size--; return; } if ((!t[root].ch[0]) || (!t[root].ch[1])) root = t[root].ch[0] + t[root].ch[1]; else { int lmax = t[root].ch[0]; while (t[lmax].ch[1]) lmax = t[lmax].ch[1]; splay(lmax, root); t[t[root].ch[1]].fa = lmax; t[lmax].ch[1] = t[root].ch[1]; maintain(root = lmax); } t[root].fa = 0; return;}int rank(int val) { insert(val); int ans = t[t[root].ch[0]].size + 1; delnode(val); return ans;}int getnxt(int val, int opt) { insert(val); int u = t[root].ch[opt], ans = t[u].val; while (t[u].ch[opt ^ 1]) u = t[u].ch[opt ^ 1], ans = t[u].val; delnode(val); return ans;}int main() { insert(inf), insert(-inf); int n = read(), m = read(); while (n--) insert(read()); int ans = 0, last = 0; while (m--) { int opt = read(), x = read() ^ last; switch (opt) { case 1: insert(x); break; case 2: delnode(x); break; case 3: ans ^= (last = rank(x) - 1); break; case 4: ans ^= (last = kth(x + 1)); break; case 5: ans ^= (last = getnxt(x, 0)); break; case 6: ans ^= (last = getnxt(x, 1)); default: break; } } printf(\"%d\\n\", ans); return 0;} 文艺平衡树的实现 文艺平衡树，可实现快速区间翻转，主要得益于 Splay 的区间操作功能。具体地，我们对序列 1 - n 建一棵 Splay，这棵 Splay 的中序遍历即为我们的序列。然后如果要对 [l,r] 翻转，就需要先把 [l,r] 区间独立出来成单独一个子树然后打标记。我们可以考虑先把在 Splay 中排名为 l-1 的点 splay 到根，然后将排名为 r+1 的点 splay 到根下方，由 BST 的性质我们可以知道此时 r+1 的左子树就是我们的 [l,r] 。 找到之后打标记即可，注意旋转和 Splay 以及找节点的时候千万记得下放标记。 12345678910inline void pushdown(int u) { if (t[u].mark &amp;&amp; u) { swap(L, R); t[L].mark ^= 1; t[R].mark ^= 1; t[u].mark = 0; } return;} 然后是翻转函数的实现。注意由于 l-1 可能等于 0 ，所以需要提前插入正无穷和负无穷节点，同时读入的 [l,r] 要各自自增 1 。同时注意此处 find() 函数与之前的区别 123456789101112131415161718192021222324int find(int val) { int u = root; while (1) { pushdown(u); if (val &lt;= t[L].size) u = L; else { val -= t[L].size + 1; if (!val) return u; u = R; } }}void reverse(int l, int r) { splay(find(l - 1), 0); splay(find(r + 1), root); int u = t[root].ch[1]; u = t[u].ch[0]; t[u].mark ^= 1; return;} 全部具体实现如下：洛谷P3391 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#define L (t[u].ch[0])#define R (t[u].ch[1])...struct Splay { int ch[2], fa; int size, val; int mark;} t[maxn];int root, cnt, n, m;void maintain(int u) { t[u].size = t[L].size + t[R].size + 1; return;}int get(int u) { return t[t[u].fa].ch[1] == u;}inline void pushdown(int u) { if (t[u].mark &amp;&amp; u) { swap(L, R); t[L].mark ^= 1; t[R].mark ^= 1; t[u].mark = 0; } return;}void rotate(int u) { int fa = t[u].fa, gfa = t[fa].fa; pushdown(fa); pushdown(u); int d1 = get(u), d2 = get(fa); t[fa].ch[d1] = t[u].ch[d1 ^ 1]; t[t[u].ch[d1 ^ 1]].fa = fa; t[u].ch[d1 ^ 1] = fa; t[fa].fa = u; if (gfa) t[gfa].ch[d2] = u; t[u].fa = gfa; maintain(fa); maintain(u); return;}void splay(int u, int goal) { pushdown(u); while (t[u].fa != goal) { int fa = t[u].fa, gfa = t[fa].fa; int d1 = get(u), d2 = get(fa); if (gfa != goal) { if (d1 == d2) rotate(fa); else rotate(u); } rotate(u); } if (!goal) root = u; return;}void build(int i, int j, int&amp; u, int fa) { int cur = (i + j) &gt;&gt; 1; u = ++cnt; t[u].fa = fa; t[u].size = 1; if (cur == 1) t[u].val = -(maxn &lt;&lt; 1); else if (cur == n + 2) t[u].val = maxn &lt;&lt; 1; else t[u].val = cur - 1; if (cur &gt; i) build(i, cur - 1, t[u].ch[0], u); if (cur &lt; j) build(cur + 1, j, t[u].ch[1], u); maintain(u); return;}int find(int val) { int u = root; while (1) { pushdown(u); if (val &lt;= t[L].size) u = L; else { val -= t[L].size + 1; if (!val) return u; u = R; } }}void reverse(int l, int r) { splay(find(l - 1), 0); splay(find(r + 1), root); int u = t[root].ch[1]; u = t[u].ch[0]; t[u].mark ^= 1; return;}void dfs(int u) { if (!u) return; pushdown(u); dfs(L); if (t[u].val &lt;= 0 || t[u].val &gt; n + 1); else printf(\"%d \", t[u].val); dfs(R); return;}int main() { n = read(), m = read(); build(1, n + 2, root, 0); while (m--) { int l = read() + 1, r = read() + 1; reverse(l, r); } dfs(root); return 0;} 易错点 一开始记得插入正负无穷，然后在计算排名和第 k 大的时候要考虑其影响 旋转操作完成后务必 pushup 如果涉及到标记下传，需要在可能改变树形的时候或者向下遍历节点的时候先 pushdown 插入完成一个节点之后要将其 splay 到根，否则可能 TLE 或者导致其父亲的 size 计算错误（因为 splay 时会一路更新 size） splay 一个节点到根之后务必更新 root 变量 对于任何操作，如果该改变了节点的父子关系，一定记得既要更改儿子的，也要更改父亲的 这样，最基础的平衡树就学习完了，当然平衡树还有很多其他品种，如红黑树、AVL、替罪羊树、SBT 等等，但事实上 FHQ-Treap 和 Splay 已经基本能解决大多数问题了，所以就不再继续深入了。祝大家 debug 快乐。 可持久化平衡树 简介 与可持久化线段树类似，可持久化平衡树支持普通平衡树的基本操作，同时支持在某个历史版本的基础上进行查询和修改。 鉴于 splay 是均摊数据结构，形态多变，不好进行可持久化；而 fhq-treap 只涉及分裂/合并，且不旋转，容易实现，所以一般的“可持久化平衡树”均指“可持久化 fhq-treap” 前置知识：主席树，fhq-treap 做法 对于 merge 和 split 操作，我们可以通过对这些过程经过的节点进行复制以达到可持久化的效果。 其相比普通的平衡树，是没有什么改变的： 1234567891011121314151617void split(int u, int k, int&amp; x, int&amp; y) { if (!u) { x = y = 0; return; } if (t[u].val &lt;= k) { x = clone(u);//***************** split(t[x].ch[1], k, t[x].ch[1], y); pushup(x); } else { y = clone(u);//***************** split(t[y].ch[0], k, x, t[y].ch[0]); pushup(y); } return;} 对比一下普通版的： 12345678910111213void split(int u, int k, int &amp;x, int &amp;y) { if (!u) { x = y = 0; return; } if (t[u].val &lt;= k) x = u, split(R, k, R, y); else y = u, split(L, k, x, L); pushup(u); return;} 注意一下星号的几行。其本质也就是对进行了修改的节点进行增加并且复制。 由于我们进行修改的时候，split 和 merge 是成对存在的，所以在 merge 的时候就不需要再复制一遍节点了。 容易出错的地方： 如果存在 pushdown 操作，那么 pushdown 的时候也要复制一遍节点 注意哪里要 pushdown 以及哪里不要 pushdown 思考清楚各个数据间被调用的先后顺序及关系 普通平衡树的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstdlib&gt;#define il inline#define FOR(i, a, b) for (int i = a; i &lt;= b; ++i)#define DEC(i, a, b) for (int i = a; i &gt;= b; --i)namespace fastIO { const int maxc = 1 &lt;&lt; 21; char ibuf[maxc], * __p1 = ibuf, * __p2 = ibuf; il char getchar() { return __p1 == __p2 &amp;&amp; (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++; } template&lt;typename T&gt; void read(T&amp; n) { int x = 0; n = 0; char c = getchar(); while (!isdigit(c)) x |= (c == '-'), c = getchar(); while (isdigit(c)) n = n * 10 + c - '0', c = getchar(); n = x ? -n : n; } char obuf[maxc], * __pO = obuf; il void putchar(char c) { *__pO++ = c; } template&lt;typename T&gt; void print(T x) { if (x &lt; 0) putchar('-'), print(-x); else { if (x &gt; 9) print(x / 10); putchar(x % 10 + '0'); } return; } void output() { fwrite(obuf, __pO - obuf, 1, stdout); }}using namespace fastIO;const int maxn = 5e5 + 5;int root[maxn], cnt;struct node { int ch[2], size, val, key; void clear() {ch[0] = ch[1] = size = val = key = 0;}} t[maxn * 50];#define L t[u].ch[0]#define R t[u].ch[1]il void pushup(int u) { t[u].size = t[L].size + t[R].size + 1; }il int newnode() { return ++cnt; }il int newnode(int val) { int u = newnode(); t[u].ch[0] = t[u].ch[1] = 0, t[u].size = 1, t[u].val = val, t[u].key = rand(); return u;}int merge(int x, int y) { if (!x || !y) return x ^ y; if (t[x].key &lt; t[y].key) return t[x].ch[1] = merge(t[x].ch[1], y), pushup(x), x; else return t[y].ch[0] = merge(x, t[y].ch[0]), pushup(y), y;}void split(int u, int k, int&amp; x, int&amp; y) { if (!u) { x = y = 0; return; } if (t[u].val &lt;= k) { x = newnode(), t[x] = t[u]; split(t[x].ch[1], k, t[x].ch[1], y); pushup(x); } else { y = newnode(), t[y] = t[u]; split(t[y].ch[0], k, x, t[y].ch[0]); pushup(y); } return;}void insert(int&amp; u, int val) { int x, y, z; split(u, val, x, z); y = newnode(val); u = merge(merge(x, y), z); return;}void delNode(int&amp; u, int val) { int x, y, z; split(u, val, x, z); split(x, val - 1, x, y); y = merge(t[y].ch[0], t[y].ch[1]); u = merge(merge(x, y), z); return;}int getRank(int&amp; u, int val) { int x, y; split(u, val - 1, x, y); int ans = t[x].size + 1; u = merge(x, y); return ans;}int getKth(int u, int k) { if (k == t[L].size + 1) return t[u].val; else if (k &lt;= t[L].size) return getKth(L, k); else return getKth(R, k - t[L].size - 1);}int getPre(int&amp; root, int val) { int x, y, ans; split(root, val - 1, x, y); if (!x) return -2147483647; ans = getKth(x, t[x].size); root = merge(x, y); return ans;}int getSuc(int&amp; root, int val) { int x, y, ans; split(root, val, x, y); if (!y) return 2147483647; ans = getKth(y, 1); root = merge(x, y); return ans;}int main() { srand(20041031); int n; read(n); FOR(i, 1, n) { int v, op, val; read(v), read(op), read(val); root[i] = root[v]; if (op == 1) insert(root[i], val); else if (op == 2) delNode(root[i], val); else if (op == 3) print(getRank(root[i], val)), putchar('\\n'); else if (op == 4) print(getKth(root[i], val)), putchar('\\n'); else if (op == 5) print(getPre(root[i], val)), putchar('\\n'); else if (op == 6) print(getSuc(root[i], val)), putchar('\\n'); } return output(), 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"平衡树","slug":"balanced-bst","permalink":"https://old.blog.imyangty.com/tags/balanced-bst/"}]},{"title":"解题报告 UVA11732 \\\"strcmp()\\\" Anyone?","slug":"sol-uva11732","date":"2020-12-07T14:32:59.000Z","updated":"2022-03-23T04:18:31.100Z","comments":true,"path":"sol-uva11732/","link":"","permalink":"https://old.blog.imyangty.com/sol-uva11732/","excerpt":"","text":"题意 输入 n 个字符串，两两调用一次 strcmp()，求比较次数。 思路 考虑两个单词，不难发现其产生的贡献就是 2x+1 ，其中 x 为两者最长公共前缀的长度。最长公共前缀考虑 Trie。然后在 Trie 上维护单词节点和往下会产生贡献的单词数量。 dfs 一遍 Trie 树然后进行一些特判除去重复贡献即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxnode=4000*1000+555,sigma_size=26*2+10;typedef long long ll;inline int idx(char c){ if('0'&lt;= c &amp;&amp; c&lt;='9') return c-'0'; else if('A'&lt;=c &amp;&amp; c&lt;='Z') return c+10-'A'; else if('a'&lt;=c &amp;&amp; c&lt;='z') return c+36-'a';}int size;int ch[maxnode][sigma_size];ll end[maxnode],sum[maxnode],ans;void insert(char *s,int v){ int u=0; int n=strlen(s); for(int i=0;i&lt;n;++i) { int c=idx(s[i]); if(!ch[u][c]) { memset(ch[size],0,sizeof ch[size]); sum[size]=end[size]=0; ch[u][c]=size++; } ++sum[u]; u=ch[u][c]; } ++end[u]; ++sum[u]; return;}void dfs(int u,int dep){ ll cnt=0; for(int i=0;i&lt;62;++i) { int v=ch[u][i]; if(!v) continue; cnt+=sum[v]*(sum[u]-sum[v]-end[u]); cnt+=end[u]*sum[v]*2; dfs(v,dep+1); ch[u][i]=0; } cnt&gt;&gt;=1; ans+=cnt*((dep&lt;&lt;1)+1); ans+=(end[u]*(end[u]-1)&gt;&gt;1)*((dep+1)&lt;&lt;1); sum[u]=end[u]=0; return;}int main(){ int n; for(int kase=1;scanf(\"%d\",&amp;n) &amp;&amp; n;++kase) { size=1; char tmp[1005]; for(int i=1;i&lt;=n;++i) { scanf(\"%s\",tmp); insert(tmp,1); } ans=0; dfs(0,0); printf(\"Case %d: %lld\\n\",kase,ans); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Trie","slug":"Trie","permalink":"https://old.blog.imyangty.com/tags/Trie/"},{"name":"字符串","slug":"string","permalink":"https://old.blog.imyangty.com/tags/string/"},{"name":"UVa","slug":"UVa","permalink":"https://old.blog.imyangty.com/tags/UVa/"}]},{"title":"解题报告 P5017 摆渡车","slug":"sol-luogu-p5017","date":"2020-12-03T13:54:32.000Z","updated":"2022-03-23T04:18:30.998Z","comments":true,"path":"sol-luogu-p5017/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p5017/","excerpt":"","text":"题意 有 n 名同学要乘坐摆渡车从人大附中前往人民大学，第 i 位同学在第 t_i 分钟去等车。只有一辆摆渡车在工作，但摆渡车容量可以视为无限大。摆渡车从人大附中出发、 把车上的同学送到人民大学、再回到人大附中（去接其他同学），这样往返一趟总共花费 m 分钟（同学上下车时间忽略不计）。摆渡车要将所有同学都送到人民大学。 凯凯很好奇，如果他能任意安排摆渡车出发的时间，那么这些同学的等车时间之和最小为多少呢？ 注意：摆渡车回到人大附中后可以即刻出发。 思路 考虑以时间为维度进行 dp，即设 f_i 为第 i 秒摆渡车出发时所有同学的最小等车时间之和。答案即为 \\min_{i\\in [t_{\\max},t_{\\max}+m)}\\lbrace f_i\\rbrace 注意摆渡车不一定要在 t_{\\max} 分钟出发，因为可能最优方案中他还没回来 预处理一下人数的前缀和 s_i 和所有人等车时间的前缀和 t_i ，则不难得到转移方程： f_i=\\min_{j\\in[0,i-m]}\\lbrace f_j+t_i-t_j+(i-j)\\times s_j\\rbrace 时间复杂度为 O(t_{\\max}^2) ，无法通过本题。考虑优化： 展开方程发现很像斜率优化的形式： f_j-t_j+j\\times s_j=f_i-t_i+i\\times s_j 而且 i 和 s_j 都单增，所以可以使用单调队列的斜率优化，时间复杂度为 O(t_{\\max}) ，可以通过本题。 实现 斜率优化如果两点横坐标相同，则 \\Delta x 应该赋一个很小的数如 10^{-9} ，但是一定要注意先后顺序！！！！！！！！！包括 slope() 函数传参的顺序！！！！不然惨 WA，斜率会变成诸如负无穷之类的奇奇怪怪的东西 一开始 head=1,tail=0，即开始时队列应该为空，不然会从非法状态进行转移，只有 65pts 如果判定斜率涉及到两个点，则边界应为 head&lt;tail，不加解释 注意边界条件： f_i 的初始值应赋为 t_i 花了三个小时在各种 debug 上，心力憔悴 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;const int maxn=505,maxt=4e6+1005;int n,m;int s[maxt],t[maxt],f[maxt],maxtime;int q[maxt],head,tail;inline double X(int j){return (double)s[j];}inline double Y(int j){return (double)(f[j]-t[j]+j*s[j]);}inline double slope(int a,int b){return (Y(b)-Y(a))/(s[a]==s[b]?1e-9:X(b)-X(a));}//千万注意这里inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline int max(int a,int b){return a&gt;b?a:b;}inline int min(int a,int b){return a&lt;b?a:b;}int main(){ n=read(),m=read(); for(int i=1,tmp;i&lt;=n;++i) { tmp=read(); ++s[tmp]; maxtime=max(tmp,maxtime); } for(int i=1;i&lt;maxtime+m;++i) s[i]+=s[i-1],t[i]=t[i-1]+s[i-1]; q[head=1]=0; for(int i=0;i&lt;maxtime+m;++i) { f[i]=t[i]; double k=i; if(i-m&gt;=0) { while(head&lt;tail &amp;&amp; slope(q[tail-1],q[tail])&gt;=slope(q[tail],i-m)) --tail; q[++tail]=i-m; } while(head&lt;tail &amp;&amp; slope(q[head],q[head+1])&lt;=k)++head; int j=q[head]; if(head&lt;=tail) f[i]=min(f[i],f[j]+t[i]-t[j]-(i-j)*s[j]); } int ans=0x3f3f3f3f; for(int i=maxtime;i&lt;maxtime+m;++i) ans=min(ans,f[i]); printf(\"%d\\n\",ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"单调队列","slug":"mono-queue","permalink":"https://old.blog.imyangty.com/tags/mono-queue/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"解题报告 P1099 树网的核","slug":"sol-luogu-p1099","date":"2020-12-01T14:25:24.000Z","updated":"2022-03-23T04:18:30.819Z","comments":true,"path":"sol-luogu-p1099/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1099/","excerpt":"","text":"题意 给定一棵边带权的树，在直径上取一条长度小于等于 s 的路径（可以退化成点）最小化树上其他点到路径上的最大距离。 思路 观察直径的性质 首先一棵树可以有很多条直径，但是他们分别必定关于他们的交点对称。 所以我们可以只考虑一条直径，不妨设两个端点分别为 P_1 ， P_2 。下面指的路径全部为直径上的路径 然后，对于一个路径上的一个点来说，距离其最远的点一定在直径的某一个端点上（反证法：如果不是最远的话那直径就不是直径了），很明显，如果路径是这样的： P_1-A_1-A_2-P_2 ，则直径的端点对答案产生的贡献即为 \\max(dis(P_1,A_1),dis(A_2,P_2) 。 首先 dfs 两遍求出 P_1 和 P_2 ，然后预处理出直径上的点分别到两端点的距离并将所有直径上的点打入一个 vector，复杂度为 O(n) 其他的贡献 不妨考虑一个极端情况： s=dis(P_1,P_2) ，这样的话直径两个端点对答案产生的贡献就为 0，然而答案并不一定是这样的：其他不在直径上的点也会产生贡献。所以对于直径上的某个点，一定要处理出与其相连的非直径边能到达的最远距离，dfs 一遍也可做到。 dp 最后就是 dp 了，在直径上可以尺取法，一路考虑下第二种贡献和直径端点产生的贡献，答案取 min 即可。 时间复杂度 O(n) ，可以通过 NOIP 原题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using std::vector;const int maxn=500000+5;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}template&lt;typename T&gt; inline T max(T a,T b){return a&gt;b?a:b;}template&lt;typename T&gt; inline T min(T a,T b){return a&lt;b?a:b;}int n,s;struct edge{ int from,to,w,nxt;}e[maxn&lt;&lt;1];int head[maxn],cntedge;inline void add(int u,int v,int w){ e[++cntedge].to=v; e[cntedge].w=w; e[cntedge].from=u; e[cntedge].nxt=head[u]; head[u]=cntedge; return;}int dis[maxn];int disp1[maxn],disp2[maxn];int p1,p2;//直径的两个端点bool vis[maxn];vector&lt;int&gt; diam;void dfs1(int u,int fa){ for(int i=head[u];i;i=e[i].nxt) { int &amp;v=e[i].to; if(v==fa) continue; dis[v]=dis[u]+e[i].w; dfs1(v,u); } return;}bool find_diameter(int u,int fa){ if(u==p2) return true; for(int i=head[u];i;i=e[i].nxt) { int &amp;v=e[i].to; if(v==fa)continue; disp1[v]=disp1[u]+e[i].w; if(find_diameter(v,u)) { diam.push_back(v); return true; } } return false;}int dfs2(int u){ vis[u]=1; int tmp=0; for(int i=head[u];i;i=e[i].nxt) { int v=e[i].to; if(vis[v])continue; dis[v]=dis[u]+e[i].w; dfs2(v); tmp=max(tmp,dis[v]); } return tmp;}int main(){ n=read(),s=read(); for(int i=1;i&lt;n;++i) { int u=read(),v=read(),w=read(); add(u,v,w); add(v,u,w); } dfs1(1,0); for(int i=1,maxdist=0;i&lt;=n;dis[i++]=0) if(dis[i]&gt;maxdist) maxdist=dis[i],p1=i; dfs1(p1,0); for(int i=1,maxdist=0;i&lt;=n;dis[i++]=0) if(dis[i]&gt;maxdist) maxdist=dis[i],p2=i; find_diameter(p1,0); diam.push_back(p1); for(int i:diam) vis[i]=true; for(int i=1;i&lt;=n;++i) disp2[i]=disp1[p2]-disp1[i]; for(int i=1;i&lt;=n;++i) dis[i]=dfs2(i); int ans=0x3f3f3f3f; for(int i=0;i&lt;diam.size();++i) { int tmp=0; for(int j=i;j&lt;diam.size();++j) { if(disp1[diam[i]]-disp1[diam[j]]&gt;s)break; tmp=max(tmp,dis[diam[j]]); int tmp1=max(tmp,max(disp1[diam[j]],disp2[diam[i]])); ans=min(ans,tmp1); } } printf(\"%d\\n\",ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"2020年12月 OI学习记录","slug":"summary-2020-12","date":"2020-12-01T09:35:25.000Z","updated":"2022-03-23T04:19:24.313Z","comments":true,"path":"summary-2020-12/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-12/","excerpt":"","text":"前言 11 月是水过来的，12 月活过 NOIP 之后要努力了。 第一周复习 NOIP，之后到寒假前全力冲刺弱的板块，起码达到提高组水平： 贪心 二分 数论 组合计数 分治 dp 学习内容 Trie 平衡树（Treap、Splay、FHQ-Treap） exCRT 拉格朗日插值 整除分块 做题记录 20/12/01 P1052 过河 dp，需要对坐标轴上进行缩点，（特判 s=t ）考虑如果一个石头无论如何可以被前面的石头不跳过，就直接缩，之后就是 f_i=\\min_{j\\in[s,t]}\\lbrace f_{i-j}+[i为石子] \\rbrace 为 石 子 P3951 小凯的疑惑 打表找规律，答案为 ab-a-b ，证明一下写 SP666 VOCV - Con-Junctions 第一问直接照搬没有上司的舞会，第二问根据乘法原理和加法原理分类讨论即可 P1099 树网的核 题面十分毒瘤的树形 dp，综合考察了直径的性质。https://imyangty.com/oi/1234 20/12/02 P5664 Emiya 家今天的饭 计数 dp P5858 「SWTR-03」Golden Sword 线性 dp，设 f_{i,j} 为放入第 i 个元素后锅中有 j 个元素可达到的最大耐久值，显然有 f_{i,j}=\\min_{k=\\max(0,1-j)}^{\\min(s,w+i-j)}\\lbrace f_{i-1,j-1+k}+j\\times a_i\\rbrace 其中 k 为我们要拿掉的元素数量。这样做复杂度可视为 O(nws) ，单调队列稍加优化可达到 O(nw) 20/12/03 P5017 摆渡车 斜率优化，在奇奇怪怪的问题上调了很久 20/12/05 NOIP 爆炸 20/12/07 P3174 [HAOI2009]毛毛虫 树形 dp UVA1401 Remember the Word Trie 优化 dp UVA11732 \"strcmp()\" Anyone? Trie 上计数 https://imyangty.com/oi/1241 20/12/12 学习平衡树 P3369 【模板】普通平衡树 使用 Treap 和 Splay 通过 P6136 【模板】普通平衡树（数据加强版） 使用 Treap 通过 20/12/13 P6136 【模板】普通平衡树（数据加强版） 使用 Splay 通过 20/12/15 P2286 [HNOI2004]宠物收养场 平衡树，练习 Splay P3391 【模板】文艺平衡树 使用 Splay 通过 P1486 [NOI2004]郁闷的出纳员 平衡树裸题，运用了差量思想。考虑全局变量记录所有人工资的加减情况，然后插入时插入 k-\\Delta 以消除影响。删除时可将所有会被删除的集中起来然后直接删掉。注意 kth() 函数的实现是求第 k 大 20/12/18 P3165 [CQOI2014]排序机械臂 调了三天的题，Splay 维护区间信息 使用 FHQ-Treap 通过普通平衡树和文艺平衡树 20/12/19 P2596 [ZJOI2006]书架 FHQ 的一个 trick：可以记录每个节点的父亲，这样可以快速查找某值在序列中的位置，同时不要忘了 pushup P4146 序列终结者 平衡树维护区间信息，标记比较多，注意维护即可 20/12/20 P3224 [HNOI2012]永无乡 启发式合并 FHQ-Treap，使用并查集维护连通性 P5338 [TJOI2019]甲苯先生的滚榜 平衡树板子，卡常 20/12/21 POJ2689 Prime Distance 区间筛素数板子，注意特判 20/12/22 P1463 [POI2002][HAOI2007]反素数 dfs 20/12/24 UVA11526 H(n) 整除分块， O(\\sqrt n) P2261 [CQOI2007]余数求和 整除分块 + 等差数列 20/12/25 P2260 [清华集训2012]模积和 推式子 + 整除分块 P3935 Calculating 推式子 + 整除分块 P4781 【模板】拉格朗日插值 拉插 20/12/26 P4280 [AHOI2008]逆序对 线性 dp + 树状数组，注意讨论 -1 可能产生的贡献 P4777 【模板】扩展中国剩余定理（EXCRT） exCRT 20/12/27 P3868 [TJOI2009]猜数字 CRT，需要快速乘防溢出 20/12/31 P4774 [NOI2018] 屠龙勇士 细节相当繁琐的 exCRT，第一道黑题祭","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"CSP-S 2020 题解","slug":"sol-csps2020","date":"2020-11-30T12:51:32.000Z","updated":"2022-03-23T04:18:30.751Z","comments":true,"path":"sol-csps2020/","link":"","permalink":"https://old.blog.imyangty.com/sol-csps2020/","excerpt":"","text":"前言 今年考 CSP 状态奇差，本来期望得分 40+100+60+0=200，实际 40+0+70+0=110（T2 MLE 惨案）。考 NOIP 之前决定来颓一颓题解 T1 儒略历 T2 动物园 先读入所有的动物编号，记录下所有已经被占用的二进制位。然后考虑每条要求，如果发现了 p_i 没有被已有动物占用但却要购买没买过的 q_i 饲料，则这一位是铁定不能有的，记录一下。不难发现由乘法原理并去重，我们的答案就是 2^s-n ， s 表示可以使用的二进制位。 注意如果 n=0 ， k=64 的话答案为 2^{64} ，而 1ull&lt;&lt;64 是 UB，所以需要特判输出 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;cctype&gt;#define FOR(i,j,k) for(int i=j;i&lt;=k;++i)typedef unsigned long long ll;const int maxn=1e6+5,maxc=1e8+5;inline ll read(){...}ll n,m,c,k,a[maxn],p[maxn],q[maxn];bool vis[maxc],affected[65];ll tmp=0;int main(){ n=read(),m=read(),c=read(),k=read()-1; FOR(i,1,n) a[i]=read(),tmp=a[i]; FOR(i,1,m) { p[i]=read(),q[i]=read(); if(tmp&amp;(1ull&lt;&lt;p[i])) vis[q[i]]=1; } FOR(i,1,m) { if(!(tmp&amp;(1ull&lt;&lt;p[i]))) if(!vis[q[i]]) affected[p[i]]=1; } ll nafed=0; if(k==63 &amp;&amp; n==0) { printf(\"18446744073709551616\"); return 0; } FOR(i,0,k) if(!affected[i]) ++nafed; printf(\"%llu\\n\",(1ull&lt;&lt;nafed)-n); return 0;} T3 函数调用 不难发现所有的函数调用关系是一个 DAG，然后其实我们可以考虑一个加法操作被乘法影响了几次。 首先所有的数是肯定要乘上所有调用的 2 号函数的操作值之积的，所以可以开一个 mul[i] 数组表示调用函数 i 后数列会乘上多少。对于所有的 2 号函数，它的 mul[i] 就是 v_i ，1 号函数则为 1，对于所有的 3 号函数，可以 dfs 一遍之后找出答案。 12345678910111213void dfs(int id){ vis[id]=true; mul[id]=(type[id]==2?val[id]:1); VEC(it,c[id])//遍历3号函数的所有子函数 { int i=*it; if(!vis[i])dfs(i); mul[id]=mul[id]*mul[i]%mod; } return;} 之后定义一个变量 mu，记录一共要乘多少，在处理函数调用序列的时候可以一并处理，这里先考虑怎么处理加法。 定义一个数组 add[i] 表示 a[i] 最终在乘上 mu 之后还要加上多少，于是考虑如何处理 add[i]。 先这样想：如果一个 1 号函数被调用之后所有的数被乘上了 t ，则这个 1 号函数就会产生 t 倍的贡献，不妨定义 f_i 表示函数 i 对其调用的 1 号函数产生了 f_i 倍贡献。 倒序处理函数调用序列：首先 mu=1，然后： 对于 1 号函数， f_i\\leftarrow f_i+mu 对于 2 号函数， mu\\leftarrow mu\\times v_i 对于 3 号函数， f_i\\leftarrow f_i+mu ， mu\\leftarrow mu\\times mul_i 最后通过在调用关系的 DAG 上拓扑排序来把 3 号函数真正的 f_i 求出来： 对于 1 号函数： add_{p_i}\\leftarrow add_{p_i}+v_i\\times f_i 2 号函数不做处理 对于 3 号函数，倒序处理它调用的函数，对于每个被调用的函数 j ， f_j\\leftarrow f_j+f_i ，而 j 对之前被调用的函数 pre 放大了 mul_j 倍贡献，所以 f_i\\leftarrow f_i\\times mul_j ，然而 f_i 会被覆盖，所以需要单独开一个变量 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define FOR(i,j,k) for(int i=j;i&lt;=k;++i)#define DEC(i,j,k) for(int i=j;i&gt;=k;--i)#define VEC(it,c) for(std::vector&lt;int&gt;::iterator it=c.begin();it!=c.end();++it)typedef long long ll;const ll mod=998244353,maxn=1e5+5;inline ll read(){...}int n,m,Q,type[maxn],pos[maxn],cal[maxn],deg[maxn];bool vis[maxn];ll a[maxn],val[maxn],mu=1,mul[maxn],f[maxn],add[maxn];std::vector&lt;int&gt; c[maxn];std::queue&lt;int&gt; q;void dfs(int id){ vis[id]=true; mul[id]=(type[id]==2?val[id]:1); VEC(it,c[id]) { int i=*it; if(!vis[i])dfs(i); mul[id]=mul[id]*mul[i]%mod; } return;}int main(){ n=read(); FOR(i,1,n)a[i]=read(); m=read(); FOR(i,1,m) { type[i]=read(); if(type[i]==1)pos[i]=read(),val[i]=read(); else if(type[i]==2)val[i]=read(); else { int ci=read(); while(ci--) { int tmp=read(); c[i].push_back(tmp); ++deg[tmp]; } } } FOR(i,1,m) if(!vis[i] &amp;&amp; !deg[i]) dfs(i); Q=read(); FOR(i,1,Q)cal[i]=read(); DEC(i,Q,1) { if(type[cal[i]]==1) f[cal[i]]+=mu; else if(type[cal[i]]==2) mu=mu*val[cal[i]]%mod; else f[cal[i]]+=mu,mu=mu*mul[cal[i]]%mod; } FOR(i,1,m) if(!deg[i])q.push(i); while(!q.empty()) { int i=q.front();q.pop(); if(type[i]==1) add[pos[i]]=(add[pos[i]]+f[i]*val[i])%mod; ll tmp=f[i]; std::reverse(c[i].begin(),c[i].end()); VEC(it,c[i]) { int g=*it; if(!--deg[g]) q.push(g); f[g]=(f[g]+tmp)%mod,tmp=tmp*mul[g]%mod; } } FOR(i,1,n) printf(\"%lld \",(a[i]*mu+add[i])%mod); return 0;} T4 贪吃蛇 太难了先咕咕咕","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"拓扑排序","slug":"toposort","permalink":"https://old.blog.imyangty.com/tags/toposort/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"图论","slug":"graph","permalink":"https://old.blog.imyangty.com/tags/graph/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"}]},{"title":"NOIP 2020 退役记","slug":"travels-noip2020","date":"2020-11-29T14:34:28.000Z","updated":"2022-03-23T04:20:07.495Z","comments":true,"path":"travels-noip2020/","link":"","permalink":"https://old.blog.imyangty.com/travels-noip2020/","excerpt":"","text":"前言 CSP 炸成那样的分之后我深深体会到了自己有多菜，所以 NOIP2020 要是挂分了我基本也就退役了/kk。退役前的这个星期打算好好复习一下模板然后打一打往年的 NOIP 题和高质量模拟题。 说实话感觉省队无望了，/kk/kk/kk Day -3 又是颓废的一天 完了菜死了 Day -2 文化课作业写不完了然后熬夜熬到三点 感觉要凉 Day -1 整个晚自习都在调摆渡车（斜率优化好tm ex） 废了废了，文化课作业又没写完 Day 0 平淡无奇 Day 1 开题一看，T1 sb 题，只开了 long long 之后就是自闭，打完了 T2T3T4 的暴力然后走人 T2 写了个 O(n^3) 方的屑，T3 写了个过不了样例的 IDA*，T4 瞎写了暴力。 Day inf 出分了，T1 先乘后除溢出了只剩 60pts，60 + 32 + 0 + 5 = 97。直接去世，二等。 白努力了三个月 dp 了，今年一道没有 T3 构造，这方面我还是太弱，要加油。 T2 的字符串直接送我去世（字符串算法极度不熟练的我） T4 拉插，NOIP 居然考多项式，我直接爬 还是我太菜了，去掉前面 2 个高三的大佬我是 rk4，进队还有希望，要靠明年省选了/kk/kk 省选要加油呀","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"游记","slug":"OI/travels","permalink":"https://old.blog.imyangty.com/categories/OI/travels/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"}]},{"title":"解题报告 P1593 因子和","slug":"sol-luogu-p1593","date":"2020-11-27T13:28:13.000Z","updated":"2022-03-23T04:18:30.845Z","comments":true,"path":"sol-luogu-p1593/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1593/","excerpt":"","text":"题意 求 a^b 的正约数和模 9901 的值。 思路 考虑对 a 进行质因数分解，得到 a=\\prod p_i^{c_i} 易知 a^b=\\prod p_i^{bc_i} 其所有约数和即为 \\prod\\sum_{k=0}^{bc_i}p_i 注意到其为一个等比数列，所以我们可以将其化为 \\prod\\dfrac{p_i^{bc_i+1}-1}{p_i-1} 最终就是求出 (\\prod (p_i^{bc_i+1}-1))\\bmod 9901 ，然后求出所有 p_i-1 的逆元即可。 但问题是，如果 p_i-1\\equiv0\\pmod{9901} ，即 p_i\\bmod9901=1 ，则 p_i-1 不存在逆元，然而等比数列还是有意义的，所以需要进行特判： 具体地，这段数列即为 1+p_i\\bmod9901+p_i^2\\bmod 9901+\\cdots+p_i^{c_i}\\bmod9901\\equiv1+c_i\\pmod{9901} ，特判即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;vector&gt;const int mod=9901,maxn=5e7+10;int pow(int base,int p){ int ret=1; base%=mod; for(;p;p&gt;&gt;=1) { if(p&amp;1) ret=ret*base%mod; base=base*base%mod; } return ret;}int main(){ int a,b; scanf(\"%d %d\",&amp;a,&amp;b); if(b==0) { printf(\"1\\n\"); return 0; } int ans=1,cnt=0; for(int i=2;i*i&lt;=a;++i) { int t=0;//t记录i的次数 if((!(a%i))&amp;&amp;a!=1) { do { t++; a/=i; }while((!(a%i))&amp;&amp;a!=1); } t*=b; if(i%mod==1)//上文的特判 ans=ans*(t+1)%mod; else { ans=ans*(pow(i,t+1)+mod-1)%mod; ans=ans*(pow(i-1,mod-2)+mod)%mod; } if(a==1)break; } if(a!=1)//如果还有一个比较大的因子 { if(a%mod==1) ans=ans*(b+1)%mod; else { ans=ans*(pow(a,b+1)+mod-1)%mod; ans=ans*(pow(a-1,mod-2)+mod)%mod; } } printf(\"%d\\n\",ans%mod); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"解题报告 P1850 换教室","slug":"sol-luogu-p1850","date":"2020-11-24T14:32:55.000Z","updated":"2022-03-23T04:18:30.864Z","comments":true,"path":"sol-luogu-p1850/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1850/","excerpt":"","text":"题意 对于 n 个时间段中的每一个时间段 i ，都有两门内容相同的课程分别在 c_i 和 d_i 教室上课，一开始被默认分到 c_i 上课，对于每个时间段 i 可以提交一个申请将教室从 c_i 换到 d_i ，申请通过的概率为 k_i ，一共可以提交 m 个申请。整个学校是一张无向图，求上课需要在教室间穿梭的期望最短路。 思路 期望 dp，考虑设计状态。注意到我们可以考虑当前上到了第 i 门课，提交了 j 份申请。然而发现对于某个 i ，是否提交换教室的申请具有后效性，因此定义 f_{i,j,k} （ k\\in\\lbrace0,1\\rbrace ）来表示当前在第 i 个时间段提交了 j 份申请，第 i 个时间段的教室有没有提交申请的期望最短路值。 考虑转移：如果这节课不提交申请，那么问题就变得简单： f_{i,j,0}=\\min(f_{i-1,j,0}+dis_{c_{i-1},c_i},f_{i-1,j,1}+dis_{d_{i-1},c_i}\\cdot k_{i-1}+dis_{c_{i-1},c_i}\\cdot(1-k_{i-1})) 这个方程的意思就是考虑从前一个教室转移过来的情况，由于前一个换教室的申请有 k_{i-1} 的概率通过，但是也有 1-k_{i-1} 的概率不通过，所以为 f_{i-1,j,1}+dis_{d_{i-1},c_i}\\cdot k_{i-1}+dis_{c_{i-1},c_i}\\cdot(1-k_{i-1}) 对于提交申请，就需要分六种情况讨论，如果从 f_{i-1,j-1,1} 转移来，则： 这节课和上节课都通过了：期望加上 dis_{d_{i-1},d_i}\\cdot k_i\\cdot k_{i-1} （乘法原理） 这节课通过了，上节课没通过： dis_{c_{i-1},d_i}\\cdot k_i\\cdot (1-k_{i-1}) 这节课没通过，上节课通过了： dis_{d_{i-1},c_{i}}\\cdot (1-k_i)\\cdot k_i 这节课和上节课都没通过： dis_{c_{i-1},c_{i}}\\cdot(1-k_i)\\cdot(1-k_{i-1}) 如果从 f_{i-1,j-1,0} 转移来，则只需考虑这节课的申请通不通过，就是 f_{i-1,j-1,0}+dis_{c_{i-1},d_i}\\cdot k_i+dis_{c_{i-1},c_i}\\cdot (1-k_i) 所以总的方程式就为： 1234567891011121314151617for(int i=2;i&lt;=n;++i) { f[i][0][0]=f[i-1][0][0]+dis[c[i-1]][c[i]]; for(int j=1;j&lt;=m;++j) { f[i][j][0]=min(f[i-1][j][0]+dis[c[i-1]][c[i]], f[i-1][j][1]+dis[d[i-1]][c[i]]*k[i-1]+dis[c[i-1]][c[i]]*(1-k[i-1])); if(j) f[i][j][1]=min(f[i-1][j-1][0]+dis[c[i-1]][c[i]]*(1-k[i])+dis[c[i-1]][d[i]]*k[i], f[i-1][j-1][1]+ dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+ dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]+ dis[d[i-1]][c[i]]*k[i-1]*(1-k[i])+ dis[d[i-1]][d[i]]*k[i-1]*k[i]); } } 实现 坑点： 图里面有重边和自环，要特判 由于同一个教室里面不需要走路，所以 dis_{i,i} 的初值要设为 0 double 类型进行 memset 初始化时要用 127 统计答案时，由于申请可以一条都不提交，所以答案为 \\displaystyle\\min_{i\\in[0,m],k\\in\\lbrace 0,1\\rbrace}\\lbrace f_{n,i,k} \\rbrace 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxv=305,maxn=2005;int n,m,v,e;int c[maxn],d[maxn];double k[maxn],f[maxn][maxn][2];int dis[maxv][maxv];template&lt;typename T&gt;inline T min(T a,T b){return a&lt;b?a:b;}int main(){ scanf(\"%d %d %d %d\",&amp;n,&amp;m,&amp;v,&amp;e); for(int i=1;i&lt;=n;++i) scanf(\"%d\",c+i); for(int i=1;i&lt;=n;++i) scanf(\"%d\",d+i); for(int i=1;i&lt;=n;++i) scanf(\"%lf\",k+i); memset(dis,0x3f,sizeof dis); while(e--) { int a,b,w; scanf(\"%d %d %d\",&amp;a,&amp;b,&amp;w); dis[a][b]=dis[b][a]=min(dis[a][b],w); } for(int i=1;i&lt;=v;++i) dis[i][i]=0; for(int r=1;r&lt;=v;r++) for(int p=1;p&lt;=v;p++) for(int q=1;q&lt;=v;q++) dis[p][q]=min(dis[p][q],dis[p][r]+dis[r][q]); memset(f,127,sizeof f); f[1][0][0]=f[1][1][1]=0; for(int i=2;i&lt;=n;++i) { f[i][0][0]=f[i-1][0][0]+dis[c[i-1]][c[i]]; for(int j=1;j&lt;=m;++j) { f[i][j][0]=min(f[i-1][j][0]+dis[c[i-1]][c[i]], f[i-1][j][1]+dis[d[i-1]][c[i]]*k[i-1]+dis[c[i-1]][c[i]]*(1-k[i-1])); if(j) f[i][j][1]=min(f[i-1][j-1][0]+dis[c[i-1]][c[i]]*(1-k[i])+dis[c[i-1]][d[i]]*k[i], f[i-1][j-1][1]+ dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+ dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]+ dis[d[i-1]][c[i]]*k[i-1]*(1-k[i])+ dis[d[i-1]][d[i]]*k[i-1]*k[i]); } } double ans=1e18; for(int i=0;i&lt;=m;i++) ans=min(ans,min(f[n][i][0],f[n][i][1])); printf(\"%.2lf\\n\",ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"最短路","slug":"shortest-path","permalink":"https://old.blog.imyangty.com/tags/shortest-path/"}]},{"title":"解题报告 P3153 [CQOI2009]跳舞","slug":"sol-luogu-p3153","date":"2020-11-23T14:04:03.000Z","updated":"2022-03-23T04:18:30.924Z","comments":true,"path":"sol-luogu-p3153/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3153/","excerpt":"","text":"题意 一次舞会有 n 个男孩和 n 个女孩。 每首曲子开始时，所有男孩和女孩恰好配成 n 对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。 有一些男孩女孩相互喜欢，而其他相互不喜欢（不会“单向喜欢”）。每个男孩最多只愿意和 k 个不喜欢的女孩跳舞，而每个女孩也最多只愿意和 k 个不喜欢的男孩跳舞。 给出每对男孩女孩是否相互喜欢的信息，求舞会最多能有几首舞曲 思路 考虑将每个男女生拆成两个点，分别为男/女生喜欢/不喜欢。 答案不好求，但由于其满足单调性所以可以使用二分答案，问题变为问跳 a 支舞曲能不能实现，注意到 a 越大越难实现，故单调性得证。 对于每一对互相喜欢的男女，从对应的男生喜欢往女生喜欢连一条容量为 1 的边，对于互相不喜欢的，就从对应的男生不喜欢往女生不喜欢连一条容量为 1 的边。之后建立超级源点 s 和超级汇点 t ，从 s 往每个男生喜欢连一条容量为 a 的边（因为最多只能跳 a 支舞曲），从每个女生喜欢往 t 连一条容量为 a 的边，最后再从每个男生喜欢往对应的男生不喜欢连一条容量为 k 的边，从每个女生不喜欢往对应的女生喜欢连一条容量为 k 的边（因为不喜欢的最多只能跳 k 次） 对于每次枚举到的 a ，跑一次最大流，如果最大流刚好等于 a\\times n ，则说明能满足跳 a 支。 具体实现 边数组要开够 每次枚举到的 a 要重新初始化 剩下的没有什么了，数据范围很小，不加优化的 Dinic 跑得过去 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;int n,k;const int maxn=1000;int head[maxn],cur[maxn],to[maxn&lt;&lt;4],nxt[maxn&lt;&lt;4],c[maxn&lt;&lt;4],cnt;int dep[maxn];int s,t;char tmp[55][55];inline void add(int u,int v,int w){ to[++cnt]=v; nxt[cnt]=head[u]; c[cnt]=w; head[u]=cnt; return;}inline int min(int a,int b){return a&lt;b?a:b;}//男生喜欢 ：1-n 男生不喜欢 n+1-2n 女声喜欢 2n+1-3n 女生不喜欢：3n+1-4nvoid build(int a){ cnt=1; memset(head,0,sizeof head); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) { if(tmp[i][j]=='Y') add(i,2*n+j,1),add(2*n+j,i,0); else if(tmp[i][j]=='N') add(n+i,3*n+j,1),add(3*n+j,n+i,0); } for(int i=1;i&lt;=n;i++) add(s,i,a),add(i,s,0), add(i,n+i,k),add(n+i,i,0), add(3*n+i,2*n+i,k),add(2*n+i,3*n+i,0), add(2*n+i,t,a),add(t,2*n+i,0);}bool bfs(){ memset(dep,-1,sizeof dep); dep[s]=0; std::queue&lt;int&gt; q; q.push(s); while(!q.empty()) { int u=q.front();q.pop(); for(int i=head[u];i;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0 &amp;&amp; dep[v]==-1) { dep[v]=dep[u]+1; q.push(v); if(v==t) return 1; } } } return 0;}int dfs(int u,int sum){ if(u==t) return sum; int k,res=0; for(int i=head[u];i &amp;&amp; sum;i=nxt[i]) { int v=to[i]; if(c[i]&gt;0 &amp;&amp; dep[v]==dep[u]+1) { k=dfs(v,min(sum,c[i])); if(!k) dep[v]=-2; c[i]-=k; c[i^1]+=k; res+=k; sum-=k; } } return res;}int dinic(){ int ret=0; while(bfs()) ret+=dfs(s,1e9); return ret;}int main(){ scanf(\"%d %d\",&amp;n,&amp;k); s=4*n+1,t=4*n+2; for(int i=1;i&lt;=n;i++)scanf(\"%s\",tmp[i]+1); int ans,l=0,r=n; while(l&lt;=r) { int mid=l+r&gt;&gt;1; build(mid); if(dinic()==mid*n) l=mid+1,ans=mid; else r=mid-1; } printf(\"%d\\n\",ans); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最大流","slug":"maxflow","permalink":"https://old.blog.imyangty.com/tags/maxflow/"}]},{"title":"网络流记录合集","slug":"summary-networkflow","date":"2020-11-23T14:02:23.000Z","updated":"2022-03-23T04:19:24.402Z","comments":true,"path":"summary-networkflow/","link":"","permalink":"https://old.blog.imyangty.com/summary-networkflow/","excerpt":"","text":"网络流好毒瘤 qwq 最大流 20/11/21 P3376 【模板】网络最大流 学习最基础的网络流 20/11/22 P1343 地震逃生 最大流模板 20/11/23 P3153 舞会 最大流 + 二分答案 https://imyangty.com/oi/1218 21/02/02 P3254 圆桌问题 源向单位连大小为单位人数的边，餐桌向汇连大小为餐桌人数的边，每个单位连每个餐桌，跑最大流，满流有解，找流有东西的边输出即可 21/02/02 P2763 试题库问题 试题向属于的类型连 1，类型向汇连需要的题数，跑最大流，满流有解，输出方案。 20/02/02 P2891 [USACO07OPEN]Dining G 拆点，源-&gt;食物-&gt;牛in-&gt;牛out-&gt;饮料-&gt;汇，保证流过牛的流量为 1，跑最大流即可 21/02/04 P2766 最长不下降子序列问题 第一问使用 n^2 dp，然后拆点处理第二问和第三问。 21/02/07 P2764 最小路径覆盖问题 从每个路径长度为 0 开始想，此时有 n 条路径，然后考虑合并两个相邻的路径，发现每次合并都会造成路径个数减一。所以考虑使用网络流来做这件事情。 建源汇，拆点成入和出，源连向所有的入，所有的出连向汇，对于原图的每一条边将入连向出。所有的边容量都是 1 ，这样就可以跑出新图的最大匹配，使用原图的点数减去即可 21/02/07 P2765 魔术球问题 上题的加强版，考虑把每个柱子都看成一条路径，然后每个点像上题一样连边。从小到大枚举答案，在残量网络上跑 Dinic 跑出增加的流量，判断是否可行，然后像上题一样输出路径。 需要注意数组一定要开够，往大了开绝对不会出问题，然后注意点编号的映射 21/02/07 P2754 [CTSC1999]家园 / 星际转移问题 对于每天每个太空站都建点，枚举天数逐天加飞船边判断能流多少，流到了就成功了。一开始先用并查集判无解的情况。 21/09/01 P2423 [HEOI2012]朋友圈 求原图最大团等价于求补图最大独立集，建模成二分图。 21/09/02 P1231 教辅的组成 拆点最大流。 21/09/02 P2472 [SCOI2007]蜥蜴 蜥蜴建成流，柱子拆点容量为高度，跑最大流即可。 费用流 20/11/23 P3381 【模板】最小费用最大流 学习基础费用流 21/02/07 P4015 运输问题 基础费用流，第二问求最大费用时直接重新建图，把所有费用取反相反数然后求出的最小费用取相反数就是最大费用。 21/02/07 P4016 负载平衡问题 不用拆点，源向每个点连对应初始货量的边，费用为 0 ，每个点向汇连对应最后要达到的边，费用为 0 ，相邻两个点之间连双向边，容量无限，费用 1 ，跑费用流即可。 21/02/08 P2770 航空路线问题 先逆向看问题，把问题转化为找到两条从左到右不相交的路径，然后在航线连边，费用 1，容量 1。拆点。每个入点向出点连容量 1，费用 0，特别地，最左和最右连的容量为 2（因为要走两次），跑最大费用最大流。最大流为 2 说明有解，城市数即为费用；最大流为 1 时特判航线从最左直飞到最右的情况即可。 21/02/08 P4014 分配问题 二分图最大权完美匹配，KM 和费用流均可过。 21/02/08 P4013 数字梯形问题 拆点 + 费用流。第一个子任务对应的是所有边容量为 1，第二个把原点与拆点之间的容量改成 inf，同时把最后一排到 t 的容量改为 inf，第三个直接把剩余除了 s 到第一排的都改为 inf 即可。原点与拆点间的费用为点权，剩余费用为 0。跑最大费用最大流。 21/02/09 P3358 最长k可重区间集问题 所有重复了的区间最多被选择 k 次，所以考虑流量为 k 寻找费用流解法。离散化每个端点，然后从左到右连流量无限费用 0 的边，然后对于每个区间从左往右连流量为 1 费用为区间长度的边。跑最大费用最大流。 21/02/16 P3357 最长k可重线段集问题 和上题基本类似，我们会发现只需要投影到 x 轴上做并判断与 x 轴垂直的线段即可。考虑将每个端点横坐标乘以二，对于 (x_1, x_2) 类型的我们再将 x_1 + 1 ，对于 (x,x) 类型的变为 (x, x + 1) ，不难发现这样可以轻松处理垂直的线段。 21/02/16 P4012 深海机器人问题 比较简单的费用流。对于网格内每个能走的路径建两条边，一条表示取海洋生物，一条不取。源向每个起点连，每个终点连向汇。跑最大费用最大流即可。 21/02/16 P1251 餐巾计划问题 非常清奇的建模。显然把每天拆成早上和晚上，每天晚上都会获得 r_i 条脏餐巾，所以源向第 i 天晚上连边，同理，每天早上都会送出去 r_i 条干净餐巾，所以往汇连。购买操作从源买即可，算起费用，洗餐巾的操作同理。 21/09/03 P4452 [国家集训队]航班安排 对每个包机请求拆点来做。将飞机视作流。 对于一个需求，如果 0 能飞到起点，那么从假源点连 (s_0, i_0 +\\infty, w(0, a_i)) ，如果能从终点飞回 0 ，那么连 (i_1, t, +\\infty, w(b_i, 0) ，为了保证只有一架飞机飞连 (i_0, i_1, t, -c) （因为 c 是净利润）。之后能一个飞完到另一个的也都连边，最后连 (s, s_0, k, 0) 。跑最小费用最大流然后取相反数。 最小割 21/02/18 UVA1660 电视网络 Cable TV Network 考虑枚举不连通的两个点，作为源和汇。然后拆点，连容量为 1 的边，再把原来的无向图的边化为出点到入点容量为 inf 的边，跑最大流就可以求出最小割，最小割即为容量为 1 的边数——去掉的点数。如果最小割为 inf 说明没办法使图不连通。 21/09/01 P2057 [SHOI2007]善意的投票 / [JLOI2010]冠军调查 最小割之集合划分问题。 21/09/01 P4126 [AHOI2009]最小割 最小割的可行边和必须边问题。 21/09/11 P2805 [NOI2009] 植物大战僵尸 最大权闭合图，注意到存在环，所以需要拓扑排序把环先去掉。 上下界网络流 21/02/06 LOJ#115. 无源汇有上下界可行流 无源汇有上下界可行流，考虑低保网络和增量网络，为了使增量网络和低保网络会在一起之后流量守恒，需建虚拟源/汇使得多了的流量有归宿 21/02/06 LOJ#116. 有源汇有上下界最大流 转换模型，从原来的 t 向 s 连 [0,+\\infty) 的边，保证源汇点流量平衡，然后就可以找到一个可行流（这个可行流的流量即为 &lt;t,s&gt; 的流量。之后在残量网络上跑从 s 到 t 的最大流榨干剩余的流量即可。 21/02/06 P5192 Zoj3229 Shoot the Bullet东方文花帖【模板】有源汇上下界最大流 源向每天连 [0,D_i] 的边，每天向对应的每个少女连对应 [L,R] 的边，每个少女向汇连 [G_i,+\\infty) 的边，然后跑有源汇上下界最大流","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"}]},{"title":"解题报告 P2279 [HNOI2003]消防局的设立","slug":"sol-luogu-p2279","date":"2020-11-17T14:41:25.000Z","updated":"2022-03-23T04:18:30.904Z","comments":true,"path":"sol-luogu-p2279/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2279/","excerpt":"","text":"题意 给定一棵树，一个选定的点可以覆盖距离小于等于二的点，求最少选点个数使整棵树被覆盖 思路 定义状态 f_{u,s} （ s\\in\\lbrace0,1,2,3,4\\rbrace ）分别表示当前子树根为 u ，满足状态 s 的最小消防局个数： s=0 ，表示当前子树全被覆盖，子树的父亲及二级祖先也被覆盖的情况 s=1 ，表示当前子树全被覆盖，子树的父亲也被覆盖的情况 s=2 ，表示当前子树全被覆盖的情况 s=3 ，表示当前子树的所有孩子及孩子们的子树全部被覆盖的情况（ u 不一定被覆盖） s=4 ，表示当前子树的所有孙子及孙子们的子树全部被覆盖的情况（ u 及 u 的孩子们不一定被覆盖） 易知 f_{u,0}\\ge f_{u,1}\\ge f_{u,2} \\ge f_{u,3}\\ge f_{u,4} （显然） 考虑转移，下面方程中令 v 和 v' 为 u 的孩子 f_{u,0}=\\sum f_{v,4} 这是一个比较显然的贪心，因为二级祖先被覆盖说明必有一个消防局设立在 u 上，所以易知 u 的孙子们肯定被覆盖了，所以选择 f_{v,4} 来覆盖他儿子的孙子； f_{u,1}=\\min\\lbrace f_{v',0}+\\sum_{v\\not=v'}f_{v,3}\\rbrace 此时 u 的父亲要被覆盖，说明 u 的儿子至少要选一个，即 f_{v',0} 。选了的那个儿子同时又可以覆盖其他儿子，所以是 f_{v,3} f_{u,2}=\\min\\lbrace f_{v',1}+\\sum_{v\\not=v'}f_{v,2}\\rbrace 此时 u 及其子树要被覆盖，所以必须选一个 f_{v',1} 使 u 本身被覆盖，然后其他儿子自身也要被覆盖，所以其他的要选 f_{v,2} f_{u,3}=\\sum f_{v,2} f_{u,4}=\\sum f_{v,3} 这两个方程比较显然 实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;const int maxn=1005;int head[maxn],to[maxn&lt;&lt;1],nxt[maxn&lt;&lt;1],cnt;int n;inline void add(int u,int v){ to[++cnt]=v; nxt[cnt]=head[u]; head[u]=cnt; return;}inline int min(int a,int b){ return a&lt;b?a:b;}inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}int f[maxn][5];void dfs(int u,int fa){ f[u][0]=1; f[u][3]=f[u][4]=0; int sum2=0,sum3=0; for(int i=head[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; dfs(v,u); f[u][0]+=f[v][4]; f[u][3]+=f[v][2]; f[u][4]+=f[v][3]; sum2+=f[v][2]; sum3+=f[v][3]; } for(int i=head[u];i;i=nxt[i]) { int v=to[i]; if(v==fa) continue; f[u][2]=min(f[u][2],sum2-f[v][2]+f[v][1]); f[u][1]=min(f[u][1],sum3-f[v][3]+f[v][0]); } f[u][1]=min(f[u][1],f[u][0]); f[u][2]=min(f[u][2],f[u][1]); f[u][3]=min(f[u][3],f[u][2]); f[u][4]=min(f[u][4],f[u][3]); return;}int main(){ n=read(); for(int i=2;i&lt;=n;i++) { int j=read(); add(i,j); add(j,i); } memset(f,0x3f,sizeof f); dfs(1,0); printf(\"%d\\n\",f[1][2]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"2020年11月 OI学习记录","slug":"summary-2020-11","date":"2020-11-02T11:32:08.000Z","updated":"2022-03-23T04:19:24.310Z","comments":true,"path":"summary-2020-11/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-11/","excerpt":"","text":"目标 撑过 CSP 复赛（确信） dpdpdp dsdsds 数论数论数论 图论图论图论 学习内容 树上差分 换根 dp 扫描线 网络流基础 斜率优化 做题记录 20/11/02 P3128 [USACO15DEC]Max Flow P 树上差分模板 P4408 [NOI2003]逃学的小孩 求直径并枚举点即可，开 long long P2052 [NOI2011]道路修建 水 P1967 货车运输 Kruskal 求最大瓶颈生成森林，然后树剖处理路径上最小边的询问 20/11/03 P1983 车站分级 建图，拓扑排序找层数即可 P2597 [ZJOI2012]灾难 一道紫题，思路比较巧妙。 首先对图拓扑排序，建出的拓扑序列保证后面的不是前面的猎物。然后尝试建一棵树，保证根节点灭绝后整个子树会跟着灭绝。考虑按照拓扑序列给树加点，每次将一个点加到其所有食物的 LCA 上（拓扑序保证了这些食物已经被加进树里面），求 LCA 的过程使用倍增维护。然后 dfs 一遍求出所有节点的子树大小即可。总时间复杂度 O(m\\log n+n\\log n) 20/11/04 P3478 [POI2008]STA-Station 换根 dp 板子题，考虑当前节点的贡献以及父亲节点的贡献即可。 P2986 [USACO10MAR]Great Cow Gathering G 还是换根 dp，ans 初始值要赋超级大（1e18） P3047 [USACO12FEB]Nearby Cows G 换根 dp， f_{i,k} 为答案， g_{i,k} 表示点 i 的儿子中到 i 的距离不超过 k 的权值和，则 f_{v,k}=f_{u,k-1}+g_{v,k}-g_{v,k-2} CF1187E Tree Painting 题意：给定一棵n个点的树 初始全是白点 要求你做n步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。 第一次操作可以任意选点。 求可获得的最大权值 设 f_u 为先选 u 号点获得的最大答案， g_u 为先选 u 点在子树中的最大答案，则 g_u=size(u)+\\sum g_v ，然后通过换根求出 f_u 即可。 20/11/07 csp 爆炸 20/11/09 P4427 [BJOI2018]求和 复习树剖模板 P1944 最长括号匹配 线性 dp，使用 dp 解决括号串匹配问题，找准转移关键即可。 20/11/10 P2572 [SCOI2010]序列操作 sb 题，区间推平的时候要清空反转标记，维护区间和，前缀 0/1，后缀 0/1，最大连续 0/1 和两个懒标记即可。 20/11/11 P1772 [ZJOI2006]物流运输 比较巧的线性 dp，设 f_i 为到第 i 天为止的最少花费。转移时对于第 i 天，倒序枚举天数 j ，意思为从第 j 天开始改线路，同时记录 TeX parse error: Undefined control sequence \\[ 天不可用的点，跑最短路即可。 有 f_i=\\min\\lbrace f_{j-1}+k+\\operatorname{dis}(1,m)\\cdot (j-i+1)\\rbrace ，即改了线之后的最短路乘以改线后的天数，并寻找最佳改线的时间点。 1234567891011121314151617f[0]=-k;//边界条件 for(int i=1;i&lt;=n;i++) { for(int j=1;j&lt;=m;j++) now[j]=0;//now[u] 维护在 [j,i] 天区间内点 u 是否可用 for(int j=i;j&gt;=1;j--) { for(int u=1;u&lt;=m;u++) if(avl[u][j]) now[u]=1; ll dis=dij(); if(dis&gt;=0x3f3f3f3f)//如果已经无法继续到达就可以直接结束 break; f[i]=std::min(f[i],f[j-1]+(i-j+1)*dis+k);//状态转移 } } 20/11/12 P5490 【模板】扫描线 扫描线求面积并模板 P1856 [USACO5.5]矩形周长Picture 扫描线求周长并模板 20/11/13 P1502 窗口的星星 转化成扫描线问题 P2146 [NOI2015]软件包管理器 树剖，对于每个安装操作，统计从根到该节点上的和并全部赋 1，对于每个卸载操作，统计这个节点的子树大小并全部赋 0 即可。 20/11/14 P1608 路径统计 最短路计数问题，注意判断重边（当然如果从 i 到 j 存在 w_1&lt;w_2 的话显然选 w_1 ，所以不能直接简单的 bool 数组判重）。跑 dij 的时候再记录 f_i 表示到 i 的最短路条数，恰当转移即可 P1144 最短路计数 无需思考重边和自环 20/11/15 CF915E Physical Education Lessons 动态开点线段树 P5459 [BJOI2016]回转寿司 问有多少组 (l,r) 满足 L\\le\\sum_{i=l}^ra_i \\le R 的 (l,r) 对数。 预处理前缀和 sum(i) ，变换式子后不难发现变为 sum(y)-R\\le S_{x-1}\\le sum(y)-L ，使用权值线段树维护即可。 20/11/17 P1955 [NOI2015]程序自动分析 离散化+并查集 P2279 [HNOI2003]消防局的设立 树形dp，https://imyangty.com/oi/1216 20/11/18 UVA1347 旅行 Tour/P1523 旅行商简化版 dp 20/11/19 UVA12563 劲歌金曲 Jin Ge Jin Qu hao 转化后即为 0-1 背包 UVA11400 照明系统设计 Lighting System Design 前缀和+线性dp UVA11584 划分成回文串 Partitioning by Palindromes 划分为回文串的最小分割数，dp 20/11/21 P3376 【模板】网络最大流 EK dinic P2170 选学霸 并查集+ 0-1 背包 P2359 三素数数 比较神奇的 dp P1799 数列 线性 dp P1343 地震逃生 裸的最大流，AC400 祭 20/11/22 P1453 城市环路 基环树 dp，考虑使用并查集找环然后暴力断环跑两次没有上司的舞会 P2607 [ZJOI2008]骑士 基环森林 dp，可以使用有向图，把 i 讨厌的人 j 设成 i 的父亲，然后连边 (j,i) 。这样的话只有“根节点”有机会形成环，这样就可以很容易的断环为链跑两次 dp 统计每个连通块的答案。 P5144 蜈蚣 水，线性 dp 20/11/23 P3153 [CQOI2009]跳舞 最大流 + 二分答案 P3381 【模板】最小费用最大流 EK+SPFA 20/11/24 P3853 [TJOI2007]路标设置 二分答案 P3743 kotori的设备 二分答案，对于每个使用时间考虑每个设备需要充的总电量充电宝能不能提供，如果 \\sum a_i\\le p 则输出 -1 即可 P1850 换教室 期望 dp 20/11/25 P1281 书的复制 dp+贪心输出 P2370 yyy2015c01 的 U 盘 二分答案套背包 P1577 切绳子 二分答案 20/11/26 UVA11582 巨大的斐波那契数！ Colossal Fibonacci Numbers! 斐波那契数列在模 n 的意义下必然会出现循环节（如果 f_i=f_{i-1}=1 且 i&gt;2 ，则周期为 i-2 ），注意到这一点之后打一个快速幂取模即可 UVA12169 不爽的裁判 Disgruntled Judge 水 UVA10375 选择与除法 Choose and divide 考虑给答案乘上 p^1q^{-1}(p-q)^{-1}r^{-1}s^1(r-s)^1 ，对答案的质因数分解进行处理即可 UVA10791 最小公倍数的最小和 Minimum Sum LCM 注意到 n=\\prod p_i^{a_i} ，所以每个数分别为 p_i^{a_i} 时可以有最优解，注意 n=1 时以及 n=p_i^{a_i} 时的特判即可。 UVA12716 GCD等于XOR GCD XOR 比较巧的结论题，利用了 gcd 和异或的性质 https://imyangty.com/oi/1222 20/11/27 P1593 因子和 唯一分解定理，等比数列求和以及费马小定理求逆元的综合应用https://imyangty.com/oi/1223 20/11/28 P1156 垃圾陷阱 类背包的 dp，坑点较多 P3957 跳房子 二分答案套单调队列优化 dp 坑点：入队/出队顺序，二分上下界，答案初始化为-1，该状态无法被转移到时不能直接终止 dp P3195 [HNOI2008]玩具装箱 斜率优化模板 P2365 任务安排 O(n^2) 可过，但可斜率优化 20/11/29 P5520 [yLOI2019] 青原樱 考虑种下的 m 棵树之间必须要有至少 m-1 个空位，将其空出来之后发现还有 n-m+1 个位置可以种树，因此答案为 A_{n-m+1}^m=\\frac{(n-m+1)\\times(n-m)\\times\\cdots\\times1}{(n-2m+1)\\times(n-2m)\\times(n-2m-1)\\times\\cdots\\times1}=(n-m+1)\\times(n-m)\\times\\cdots\\times(n-2m+2) P3197 [HNOI2008]越狱 考虑补集思想，所有的犯人状态有 m^n 种，减去两两不相邻的 m(m-1)^{n-1} 种即为答案，输出加上 mod 再取模。 P7076 动物园 CSP2020 赛题，要特判 n=0 ， k=64 的情况，输出 2^{64} 。 20/11/30 P7077 函数调用 CSP2020 赛题，拓扑排序讨论乘法对加法产生的贡献 P5022 旅行 NOIP2018，考虑直接枚举基环树环上的边然后暴力断边","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"CSP-S 2020 游记","slug":"travels-csps2020","date":"2020-10-07T02:09:56.000Z","updated":"2022-03-23T04:20:07.479Z","comments":true,"path":"travels-csps2020/","link":"","permalink":"https://old.blog.imyangty.com/travels-csps2020/","excerpt":"","text":"初赛 Day -inf 没想到还是来了，今年成为了提高组选手，但菜还是改变不了的。 十一参加了 ZR 的集训，发现自己菜的一批（怎么办怎么办），然后又听说我校几个高二的忘记缴费然后报名失败了的（什么鬼玩意）。 在 GZ 这种地方已经不太想复习初赛了，稍微意思意思下差不多了？（ 11 号初赛学校10号下午才放人，差评。 6 号才发考点通知，差评。 考点离家好远，差评。（今年变成笔试了，好评） 就这样吧，菜肯定是菜的，大不了初赛颓过去然后后面好好搞吧。 国庆作业是真 tm 要写不完了/wx 初赛 Day 0 （辣鸡调休今天才放假，差评） 发现初赛的东西完全没有复习，慌的一批。 明天初赛考点真的好远，差评。 差不多就这样吧，教练今天找了我和 szx，给了我们准考证和一张健康承诺书，然后。。。就没了。 初赛 Day 1 今天还是来了，一早起来什么都没复习就往考场赶了。发现七点半出发八点二十就到了（头一次开完北二环路真tm爽），但是考点真的好远。 到了那里就看到李先生了，然后在车上吃早餐不想下去见他（哈哈哈哈哈）。吃完早餐发现 szx 也来了，然后就目睹了他被培训机构拉去拍照的全过程（被迫害了）。同时还看到了观一监和实验三的人（有点神奇，他们还穿了校服）。实验三的妹子好看，帅哥也有点帅（ 考点华附，有一说一新修的学校环境确实很不错。然后就是跟着指示标到了考场门口，目睹了李先生，特派员和另外一些教练的神仙对话，被告知考点不能拍照（好吧我删） 李先生临走前不忘嘱咐我们提前交卷（草） 坐下，开题。 选择题好像都有点sb，直接爆切（有道 CRT 的题由于不会求逆元直接暴力枚举了）。 好吧阅读程序题教我做人了，T3 直接放弃，不想看了。 最后几十分钟疯狂发呆，直接不想继续看题，（反正我觉得分够了能进复赛） 于是，就结束了。 初赛 Day inf 鬼知道什么时候成绩就出来了，74.5（菜的一批），同班大佬 szx 93.5 暴捶贵州省（阿巴阿巴）。有个盘州二中的和我水平相当，复赛慌的一批。 无聊整理了一下，发现十八中华麟新世界中天之类的文化课强初中居然各有十几个来打的，不错不错（鼓掌）。反观我 pkupw 仍是空无一人（无语了） 最近打模拟赛的状态依旧很差（但是 szx 比我还差，经常读错题面不然暴捶我）感觉智商是真的不够用了，我这么菜怎么办怎么办怎么办啊啊啊啊啊疯掉了。 罢了罢了，颓 dp 去了，dp 真的要把我搞死了。 Day 0 复习了一下板子，然后就回家睡大觉了。看到 gz 省发通知要早上去报道慌的一批，问教练说了不用去了遂继续睡觉。 Day 1 十一点起床，然后就打车去了考点（好tm远） 到了考场之后发现电脑做错了，然后坐到正确的机子前开始开题，发现 T1 大模拟，T2 位运算，T3 ds？T4 博弈论（貌似？） 然后开搞 T1，发现搞了半天搞不出来，然后就开 T2 去了。 T2 有一个地方由于听信了 int 比 bool 快所以把 bool 换成了 int 结果整道题 MLE 爆零（太惨了） T3 看出来了是一个 DAG，但是没看出剩下的性质了（我好菜啊）写了线段树的暴力然后走人了。 T4 直接放弃 出考场发现 T2 MLE 之后整个人都傻了。 直接爆炸 赛后 Day 2 牛客上面测了下发现是 40+60+80+0=180 （牛客数据好水啊） 洛谷上面则是 40+45+40=125（不愧是我够菜） OItiku 上面是 40+0+75=115（终于有一个正常识别 MLE 的了） 下次我一定算空间，下次我一定注意心态，我下去要多练习模拟题 现在还好有下个月的 NOIP，以后没有下次了不就。。。。。","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"游记","slug":"OI/travels","permalink":"https://old.blog.imyangty.com/categories/OI/travels/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"}]},{"title":"2020年10月 OI学习记录","slug":"summary-2020-10","date":"2020-10-01T14:35:26.000Z","updated":"2022-03-23T04:19:24.291Z","comments":true,"path":"summary-2020-10/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-10/","excerpt":"","text":"目标 撑过联赛初赛 推进 dp 能力 推进图论知识 数据结构什么的 做题记录 20/10/01 P3038 [USACO11DEC]Grass Planting G 树剖，调了很久的原因是 query 的时候没有下传标记 SP1043 GSS1 - Can you answer these queries I 线段树维护稍微复杂的信息——求最大子段和 需要维护最大前缀和，最大后缀和，最大字段和和区间和，难点在于 pushup SP1716 GSS3 - Can you answer these queries III 带修版 GSS1 P1908 逆序对 使用权值线段树和树状数组重做本题 20/10/02 重写了一波高精度 P3369 【模板】普通平衡树 使用权值线段树过去的（而且跑的不慢），除了查排名对应的数之外其他都很好想，想通了就可以直接 A 掉 20/10/03 P1111 修复公路 并查集 P1346 电车 01bfs 优化的最短路 P3386 【模板】二分图最大匹配 匈牙利算法 P2756 飞行员配对方案问题 二分图最大匹配，匈牙利算法 P6190 [NOI Online #1 入门组]魔法 使用矩阵快速幂优化 Floyd，复杂度 O(n^3+n^2m+n^3\\log k) F_{i,j} 为使用过一次魔法,从 i 到 j 的最短路。单位矩阵为 D_{i,j} ，即不使用魔法，求出 D\\times F^k 即可。此处矩阵乘法变成了 min P1637 三元上升子序列 权值线段树可以水过去 线段树不开 4 倍空间见祖宗 不开 long long 见祖宗 20/10/04 P3385 【模板】负环 SPFA，如果一个点入队 n-1 次，说明这个图存在负环，判断即可。 P5960 【模板】差分约束算法 差分约束 P3388 【模板】割点（割顶） 割点，注意图可能不连通，要分别对每个连通块 tarjan 20/10/05 P3370 【模板】字符串哈希 字符串哈希 P3375 【模板】KMP字符串匹配 KMP 20/10/11 P1993 小 K 的农场 差分约束 P4114 Qtree1 边转点，树剖 P2294 [HNOI2005]狡猾的商人 前缀和思想+差分约束（第一次用链式前向星存图嘻嘻嘻） 20/10/12 P1351 联合权值 \\sum\\sum w_iw_j-\\sum w_i^2=(\\sum w_i)^2-\\sum w_i^2 20/10/13 P4513 小白逛公园 带修区间最大子段和，练代码能力（ P1272 重建道路 树形背包，设 f_{u,j} 表示以 u 为根节点的子树保留 j 个节点需要删的边的最少数量（保留与父节点连边）。预处理 f_{u,1}=size_u 。则 f_{u,j}=\\min_k^{size_u}\\lbrace f_{u,j-k}+f_{v,k}-1\\rbrace ，这里的 -1 是因为初始化的时候删过了，重新加回来。 取答案时 ans=\\min(f_{1,p},\\min_{u=2}^n\\lbrace f_{u,p}+1\\rbrace) 这里 +1 是因为连接其父亲的边要删掉 20/10/14 P3387 【模板】缩点 tarjan + 拓扑 P1726 上白泽慧音 强连通分量裸题 20/10/19 P2656 采蘑菇 强联通分量 + spfa 最长路 20/10/20 T143332 区间统计 学长的题，给定一个序列， q 次询问，求 TeX parse error: Undefined control sequence \\[ 内 x 的个数。 离线做法复杂度 O(n+q) ，注意到 ans(l,r,x)=count(1,r,x)-count(1,l-1,x) ，故把所有询问读入，分别按照 l 和 r 桶排序，存储下其对应的询问编号，最后暴力扫一遍序列，两个指针遍历排序过的询问，记录 ans(l,r,x) ，最后输出即可。 20/10/21 P2679 子串 dp，f[i][j][k][0/1] 表示到了 a 串第 i 位，匹配到了 b 串第 j 位，使用了 k 个子串，a 串第 i 位是否选（0/1）的方案数 则 f[i][j][k][0]=f[i-1][j][k][0]+f[i-1][j][k][1]，若 a[i] == b[j]，则 f[i][j][k][1]=f[i-1][j-1][k-1][0]+f[i-1][j-1][k-1][1]+f[i-1][j-1][k][1] 最后输出 f[n][m][k][0]+f[n][m][k][1] 即可，i 的那一维滚动掉即可。 20/10/22 P1514 引水入城 dp+搜索+贪心 注意读题！！！注意判边界！！！注意贪心！！！ P2585 [ZJOI2006]三色二叉树 树上dp，氵 20/10/24 P1569 Generic Cow Protests 线性dp - [SDOI2005]区间 求区间并 差分，水、 P2426 删数 区间dp 20/10/25 P1435 [IOI2000]回文字串 区间dp，poj卡空间，被迫滚动数组 注意到 f_{i,j} 只可能由 f_{i,j-1} ， f_{i+1,j} 和 f_{i+1,j-1} 转移而来，所以可以倒序枚举 i ，并将其滚动掉。 12345for(int i=n-1;i&gt;=1;i--) for(int j=i+1;j&lt;=n;j++) if(s[i]==s[j]) f[i&amp;1][j]=f[(i+1)&amp;1][j-1]; else f[i&amp;1][j]=min(f[(i+1)&amp;1][j],f[i&amp;1][j-1])+1; UVA10617 Again Palindrome 区间dp统计回文子串个数 1234567 for(int len=2;len&lt;=n;len++) for(int i=1,j=i+len-1;j&lt;=n;i++,j++) if(s[i]==s[j]) f[i][j]=f[i+1][j]+f[i][j-1]+1ll; else f[i][j]=f[i+1][j]+f[i][j-1]-f[i+1][j-1]; 不开 long long 见祖宗 - hdu1421 搬寝室 贪心+dp 不注意多测见祖宗，不注意初始化见祖宗 P2401 不等数列 dp 题意：将1到n任意排列，然后在排列的每两个数之间根据他们的大小关系插入“&gt;”和“&lt;”。问在所有排列中，有多少个排列恰好有k个“&lt;”。答案对2015取模。 每次考虑已经排好 TeX parse error: Undefined control sequence \\[ 的答案，然后考虑插入 n ，如果将 n 放在序列尾，会多出来一个小于号，即包含一个 f_{n-1,k-1} ，如果把 n 放在序列首，会多出一个大于号，即包含一个 f_{n-1,k} ，如果把原来小于号换成 n ，小于号个数不会变，即多出来 k 个 f_{n-1,k} ，如果把大于号换成 n ，多一个小于号，即多出来 i-1-k 个 f_{n-1,k-1} 即 f_{n,k}=(k+1)f_{n-1,k}+(i-k)f_{n-1,k-1} 20/10/26 P3275 [SCOI2011]糖果 差分约束，SPFA时需要注意： 前向星空间开够，留下超级源的空间 SPFA 写递归式的 玄学数据卡 SPFA 需要倒序建超级源的边 缩点+拓扑做法待填坑 P1594 护卫队 线性 dp 20/10/27 P3147 [USACO16OPEN]262144 P 数据经过加强，只能用一些奇奇怪怪的方法混过去。 发现若想合成 i ，就需要先有两个 i-1 ，关键点便在这里。设 f_{i,j} 为从 j 为左端点能合成 i 的右端点。所以有状态转移方程 f_{i,j}=f_{i-1,f_{i-1,j}+1} ，即倍增思想。因为需要先合成第一个 i-1 ，右端点就是 f_{i-1,j} ，现在要从这个右端点开始继续向后寻找第二个 i-1 ，所以是 f_{i-1,f_{i-1,j}+1} 初始条件是 f_{a_i,i}=i ，转移要求上面转移过来的两个量都有意义。 123456789 for(int i=1;i&lt;=n;i++) f[read()][i]=i; int ans=0; for(int i=1;i&lt;=58;i++) for(int j=1;j&lt;=n;j++) if(!f[i][j] &amp;&amp; f[i-1][j] &amp;&amp; f[i-1][f[i-1][j]+1]) f[i][j]=f[i-1][f[i-1][j]+1], ans=i; P1220 关路灯 一定时间内关闭的路灯必然是连续的 f_{i,j,0/1} 表示关闭路灯 [i,j] 后站在 i 或站在 j 所耗费的最小功率。则 f_{i,j,0} 通过 f_{i+1,j,0/1} 转移得到，反之亦然。 转移太长懒得写了。 P3205 [HNOI2010]合唱队 123456789101112131415 for(int i=1;i&lt;=n;i++) a[i]=read(),f[i][i][0]=1; for(int len=2;len&lt;=n;len++) for(int i=1,j=i+len-1;j&lt;=n;i++,j++) { if(a[i]&lt;a[i+1]) f[i][j][0]=(f[i][j][0]+f[i+1][j][0])%mod; if(a[i]&lt;a[j]) f[i][j][0]=(f[i][j][0]+f[i+1][j][1])%mod; if(a[j]&gt;a[i]) f[i][j][1]=(f[i][j][1]+f[i][j-1][0])%mod; if(a[j]&gt;a[j-1]) f[i][j][1]=(f[i][j][1]+f[i][j-1][1])%mod; } 初始化的时候默认是左边进的不然会被重复计算 20/10/28 三道状压dp P1879 [USACO06NOV]Corn Fields G P1896 [SCOI2005]互不侵犯 P2704 [NOI2001]炮兵阵地 状压dp：预处理状态，判别，转移 20/10/29 P5658 括号树 括号匹配扩展到树上 要注意树上的栈要进行回溯 P1868 饥饿的奶牛 线性 dp，使用二分进行优化 20/10/30 P2583 地铁间谍/UVA1205 线性dp，思路较为巧妙 UVA437 巴比伦塔 The Tower of Babylon 可以记忆化搜索可以 DAG 上 dp 快读会锅不知道为什么","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"解题报告 P1516 青蛙的约会","slug":"sol-luogu-p1516","date":"2020-09-17T13:58:58.000Z","updated":"2022-03-23T06:40:10.525Z","comments":true,"path":"sol-luogu-p1516/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1516/","excerpt":"","text":"题目内容 长度为 L 的首尾相接的数轴上有两只青蛙，坐标分别为 x ， y ，分别每次能往前跳 m 和 n 个单位长度，求最少跳几次后相遇。 解题思路 不难得到题目需要我们解如下关于 k 的方程的最小正整数解： x+km\\equiv y+kn\\pmod L 化简可得到 (m-n)k\\equiv y-x\\pmod L 也就是说，我们只要找得到方程 (m-n)k+Lj=y-x （其中 j\\\\in\\\\mathbb{Z} ）的最小正整数解，即为答案，而这个方程可以使用拓展欧几里得进行求解。 如果 \\\\gcd(m-n,L)\\\\not(y-x) ，说明该方程无解。 为了简化符号表达，接下来令 a=m-n ， b=L ， c=y-x ， X 为我们要求的 k ， Y 为上文的 j 。方程便被化为 aX+bY=c 先使用拓欧求出 aX+bY=\\\\gcd(a,b) 的一个特解 X\\_0 ，则该方程的最小正整数解为 X\\_0\\\\bmod\\\\frac{b}{\\\\gcd(a,b)} ，最后需要的结果再乘上 \\\\frac{c}{\\\\gcd(a,b)} 即可 输出时注意要避免负数的输出，不开 long long 会炸掉 123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;typedef long long ll;ll X,Y,M,N,L,gcd;void exgcd(ll &amp;x,ll &amp;y,ll a,ll b){ if(!b) x=1,y=0,gcd=a; else exgcd(y,x,b,a%b),y-=a/b*x;}int main(){ scanf(\"%lld %lld %lld %lld %lld\",&amp;X,&amp;Y,&amp;M,&amp;N,&amp;L); ll x,y; ll a=M-N,c=Y-X,&amp;b=L; if(a&lt;0) a=-a,c=-c ; exgcd(x,y,a,b); if(c%gcd) { printf(\"Impossible\\n\"); return 0; } printf(\"%lld\\n\",(x%(b/gcd)*c/gcd+b/gcd)%(b/gcd)); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"解题报告 P1613 跑路","slug":"sol-luogu-p1613","date":"2020-09-15T13:31:34.000Z","updated":"2022-03-23T04:18:30.850Z","comments":true,"path":"sol-luogu-p1613/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1613/","excerpt":"","text":"题目内容 有向图，边权为 1，可以在 1 秒内跳 2^k km，求从 1 到 n 的最短时间 解题思路 倍增优化 dp。 数据范围很小，可以先预处理出 x 和 y 之间是否存在长度为 2^k 的路径，然后直接更新两点间路径长度，跑一遍 Floyd 即可。 预处理的具体方法是枚举中转点 z ，如果 x 到 z 之间和 z 到 y 之间都有长度为 2^{k-1} 的路径的话， x 到 y 之间就必然有长度为 2^k 的路径 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;typedef long long ll;inline ll read(){ char c = getchar(); ll s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline ll min(ll a,ll b){ return a&lt;b?a:b;}const int maxn=53;ll dis[maxn][maxn],n,m;bool G[maxn][maxn][64];int main(){ memset(dis,0x3f,sizeof dis); n=read(),m=read(); while(m--) { int x=read(),y=read(); G[x][y][0]=true; dis[x][y]=1; } for(int k=1;k&lt;=64;k++) for(int x=1;x&lt;=n;x++) for(int y=1;y&lt;=n;y++) for(int z=1;z&lt;=n;z++) if(G[x][z][k-1] &amp;&amp; G[z][y][k-1]) G[x][y][k]=true,dis[x][y]=1;//预处理两点之间是否有 2^k 路径 for(int x=1;x&lt;=n;x++) for(int y=1;y&lt;=n;y++) for(int z=1;z&lt;=n;z++) dis[x][y]=min(dis[x][y],dis[x][z]+dis[z][y]); printf(\"%lld\\n\",dis[1][n]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"图论","slug":"graph","permalink":"https://old.blog.imyangty.com/tags/graph/"},{"name":"倍增","slug":"binary-lifting","permalink":"https://old.blog.imyangty.com/tags/binary-lifting/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"最短路","slug":"shortest-path","permalink":"https://old.blog.imyangty.com/tags/shortest-path/"}]},{"title":"解题报告 P1266 速度限制","slug":"sol-luogu-p1266","date":"2020-09-10T14:01:37.000Z","updated":"2022-03-23T04:18:30.830Z","comments":true,"path":"sol-luogu-p1266/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1266/","excerpt":"","text":"题目内容 给出一个 n 个点的有向图（无重边），每个边有一长度和通过限速，如果进入某边时没有限速则延续之前的速度。求从0到 D 耗时最短的路径 解题思路 既然此时到达某个节点的速度开始具有后效性，那么不妨将速度记入状态中。在 Dijkstra 中直接令 d_{i,j} 表示以速度 j 进入节点 i 时的最小时间花费。则进行转移时可同时进行转移。 注意的点： vis 数组也要开成 vis[i][j]，因为 j 具有后效性，要一并记录 double 类型的数组可以使用 memset(d,127,sizeof d) 来进行极大值的初始化 priority_queue 使用自定义类型时需提前定义小于号（默认为大根堆，为实现小根堆需要将小于号反着写） 类似于一些 dp 的输出方案，需要在 Dijkstra 转移时记录下上一状态，输出时直接递归输出即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;queue&gt;struct edge{ int from,to,v,l; double t; edge(){} edge(int a,int b,int c,int d) { from=a; to=b; v=c; l=d; t=(v==0?-1e8:(double)l/(double)v); }};struct node{ double d; int now; int v; node(){} node(double dd,int nnow,int vv) { d=dd; now=nnow; v=vv; }};bool operator&lt;(const node &amp;a,const node &amp;b)//重载一个假的小于号来实现小根堆{ return a.d&gt;b.d;}//城市编号从0开始 const int maxn=150+5;std::vector&lt;edge&gt; G[maxn];int n,m,t,from[maxn][505],fromv[maxn][505];double d[maxn][505];bool vis[maxn][505];void add(int from,int to,int v,int l){...}void dijkstra(){ std::priority_queue&lt;node&gt; q; memset(d,127,sizeof(d)); d[0][70]=0; q.push(node(0,0,70)); while (!q.empty()) { int now=q.top().now,v=q.top().v; q.pop(); if(!vis[now][v]) { vis[now][v]=1; for(auto &amp;e:G[now]) { if(e.v) { if(d[e.to][e.v]&gt;d[now][v]+e.t) { d[e.to][e.v]=d[now][v]+e.t; q.push(node(d[e.to][e.v],e.to,e.v)); from[e.to][e.v]=now; fromv[e.to][e.v]=v; } } else { if(d[e.to][v]&gt;d[now][v]+(double)e.l/(double)v) { d[e.to][v]=d[now][v]+(double)e.l/(double)v; q.push(node(d[e.to][v],e.to,v)); from[e.to][v]=now; fromv[e.to][v]=v; } } } } } return;}void Find_way(int now,int v){ if(now!=0) Find_way(from[now][v],fromv[now][v]); printf(\"%d \",now);}int main(){ ...//输入 dijkstra(); int ansv; double mint=1e9; for(int i=1;i&lt;=500;i++) if(mint&gt;d[t][i]) ansv=i,mint=d[t][i];//寻找如何往回寻路 Find_way(t,ansv); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"图论","slug":"graph","permalink":"https://old.blog.imyangty.com/tags/graph/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"最短路","slug":"shortest-path","permalink":"https://old.blog.imyangty.com/tags/shortest-path/"}]},{"title":"解题报告 hdu3092 Least common multiple","slug":"sol-hdu3092","date":"2020-09-04T15:02:50.000Z","updated":"2022-04-13T12:27:28.349Z","comments":true,"path":"sol-hdu3092/","link":"","permalink":"https://old.blog.imyangty.com/sol-hdu3092/","excerpt":"","text":"题目内容 将一个整数 S 拆分，求他们最大的 lcm 解题思路 思路其实比较简单，就是一个完全背包，但是需要注意的细节很多。 第一，发现如果将 s 拆分为 a+b ，且 \\gcd(a,b) \\not=1 ，则答案为 ab/\\gcd(a,b) 。相当于 \\gcd(a,b) 这一部分就被浪费掉了，所以发现拆分出来的数选择素数或者素数的幂最佳，因为两者间必然互素。解决方案就是在进行 dp 之前先把素数筛一遍。p_i 设我们正在考虑第 i 个素数 p_i 的 q 次方，易得状态转移方程为 f(j)=\\max\\lbrace f(j),f(j-p_i^q)\\times p_i^q\\rbrace 第二，我们最后需要的是最大的结果取模，所以如果中间过程中取模的话会出现一些玄学的问题，这个时候就需要对数出来帮忙了。 我们知道如果 ab &lt; cd ，则 \\log a+\\log b&lt;\\log c+\\log d 。所以可以令 f(j) 存储我们取过对数的结果， ans(j) 存储真正的结果。转移方程如下： f(j)=\\max\\lbrace f(j),f(j-p_i^q)+ q\\log p_i \\rbrace \\ ans(j)=\\max\\lbrace ans(j), ans(j-p_i^q)\\times p_i^q \\rbrace\\bmod m 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cmath&gt;template&lt;class T&gt; T max(T a,T b){ return a&gt;b?a:b;}int s,m,ans[3005];double f[3005];int prime[500];bool is_not_prime[3005];int main(){ int cnt=0; for(int i=2;i&lt;=3005;i++) { if(!is_not_prime[i]) prime[++cnt]=i; for(int j=1;j&lt;=cnt &amp;&amp; prime[j]*i&lt;=3005;j++) { is_not_prime[prime[j]*i]=1; if(i%prime[j]==0) break; } }//欧拉筛 while(scanf(\"%d %d\",&amp;s,&amp;m)!=EOF) { for(int i=0;i&lt;=s;i++) f[i]=0,ans[i]=1; for(int i=1;i&lt;=cnt &amp;&amp; prime[i]&lt;=s;i++) for(int j=s;j&gt;=prime[i];j--) { double tmp=log(prime[i]*1.0);//取log for(int p=prime[i],q=1;p&lt;=j;p*=prime[i],q++)//取p的q次方 { if(f[j-p]+q*tmp&gt;f[j]) { f[j]=f[j-p]+q*tmp;//更新取了对数的f ans[j]=(ans[j-p]*p)%m;//更新真正答案 } } } printf(\"%d\\n\",ans[s]); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"背包","slug":"backpack-dp","permalink":"https://old.blog.imyangty.com/tags/backpack-dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"HDU","slug":"HDU","permalink":"https://old.blog.imyangty.com/tags/HDU/"},{"name":"素数与筛法","slug":"prime","permalink":"https://old.blog.imyangty.com/tags/prime/"}]},{"title":"2020年8-9月 OI学习记录","slug":"summary-2020-08-09","date":"2020-08-28T05:20:51.000Z","updated":"2022-03-23T04:19:24.288Z","comments":true,"path":"summary-2020-08-09/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-08-09/","excerpt":"","text":"计划 全面推进 dp 能力 学习提高组树上相关算法 学习提高组数论及组合 搞过联赛这一关 做题记录 20/08/28 CF543A Writing Code 二维费用完全背包求方案数 P4316 绿豆蛙的归宿 拓扑排序+期望dp P1107 [BJWC2008]雷涛的小猫 稍加优化的线性dp CF414B Mashmokh and ACM 线性dp 20/08/29 P6064 [USACO05JAN]Naptime G/SP283 NAPTIME P6064 [USACO05JAN]Naptime G/SP283 NAPTIME 线性dp P2933 [USACO09JAN]The Baric Bovine G P2933 [USACO09JAN]The Baric Bovine G 线性dp 20/09/03 poj2524 Ubiquitous Religions 并查集+连通块 20/09/04 P1197 [JSOI2008]星球大战 逆向思维并查集+连通块 poj2236 Wireless Network 并查集 P1525 关押罪犯 种类并查集 P2024 [NOI2001]食物链 种类并查集 hdu3092 Least common multiple hdu3092 Least common multiple 完全背包+数论+对数背包 hdu2182 Frog 简单线性dp 20/09/05 hdu4489 The King’s Ups and Downs hdu4489 The King’s Ups and Downs 组合数学+dp，OEIS A001250 hdu1003 Max Sum 需要记录状态的最大子段和 hdu1087 Super Jumping! 线性dp hdu1503 Advanced Fruits LCS变形（记录方案+混合字符串） 20/09/06 hdu2476 String Painter 洛谷P4170变形，两次dp P2016 战略游戏 简单树形dp 20/09/07 P2458 [SDOI2006]保安站岗 树形dp P2563 [AHOI2001]质数和分解 完全背包 20/09/08 P3379 【模板】最近公共祖先（LCA） 倍增求 LCA 20/09/09 P4281 [AHOI2008]紧急集合 / 聚会 LCA的一些性质 20/09/10 P1395 会议 树的重心 P1133 教主的花园 线性dp P1266 速度限制 P1266 速度限制 二维状态限定的最短路（分层图） 20/09/12 校内模拟赛 25+100+65=190 rk2 20/09/14 P1273 有线电视网 P1273 有线电视网 树上背包 20/09/15 P1613 跑路 P1613 跑路 倍增优化 dp P3811 【模板】乘法逆元 线性求逆元 P3811 【模板】乘法逆元 20/09/16 P1082 同余方程 P1082 同余方程 拓欧求逆元 P1495 【模板】中国剩余定理(CRT)/曹冲养猪 P1495 【模板】中国剩余定理(CRT)/曹冲养猪 CRT 20/09/17 P1516 青蛙的约会 P1516 青蛙的约会 exgcd 20/09/18 校内练习赛 20/09/19 校内模拟赛 80+8+85=193 rk2 20/09/21 P1364 医院设置 带点权的树的重心 P1122 最大子树和 f_u=max(f_v+f_u,f_u) 只需统计 f_{u_{max}} 即可，因为选出来最后的结果必然有一个节点是子树的根节点，所以不用考虑过多。 20/09/22 P4310 绝世好题 求给定序列的最长子序列 \\lbrace b_i\\rbrace 满足 b_i 按位与 b_{i-1} 不为0 令 f_i 表示当前子序列第 i 位为 1 的最大长度，读入时按位转移，复杂度 O(n) P2015 二叉苹果树 树上背包，f[u][j]=max(f[u][j],f[u][j-k-1]+f[v][k]+w); 20/09/23 P1131 [ZJOI2007]时态同步 树上dp，直接 O(n) 扫描并计算即可 20/09/25 P1440 求m区间内的最小值 单调队列裸体 20/09/26 P2627 [USACO11OPEN]Mowing the Lawn G &amp;&amp; P2034 选择数字 f(i,0)=\\max\\lbrace f(i-1,0),f(i-1,1)\\rbrace f(i,1)=\\max_{j\\in(i-k,i)}\\lbrace f(j,0)+s_i-s_j\\rbrace=\\max_{j\\in(i-k,i)}\\lbrace f(j,0)-s_j\\rbrace+s_i 开一个单调队列维护 \\max\\lbrace f(j,0)-s_j\\rbrace 即可。 20/09/28 P3384 【模板】轻重链剖分 轻重链剖分模板 20/09/29 P3379 【模板】最近公共祖先（LCA） 这次使用树剖求解 lca","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"游记——2020贵阳市初中毕业生升学考试","slug":"travels-zhongkao","date":"2020-07-10T15:15:50.000Z","updated":"2021-12-15T15:26:03.832Z","comments":true,"path":"travels-zhongkao/","link":"","permalink":"https://old.blog.imyangty.com/travels-zhongkao/","excerpt":"","text":"前言 今年，疫情爆发。然而贵州省的初三学子于3月14日便返回校园（雾），而且体育考试正常举行，学业考试和升学考试又分开进行，升学考试还整整推迟了21天。 真是多灾多难的一年啊。 Day -57：体育 大家头一天晚上都回到了学校（带着各种 \\text{C} _6 \\text{H} _{12} \\text{O} _6 和运动饮料等等神奇的东西），目的是保证我们的睡眠（然而我半夜被蚊子咬醒过来三次）。第二天的早餐还是依旧难吃（pkupw的一贯尿性），表示肚子有点痛。吃完饭去拉肚子，天气也很阴沉（预示体考要凉？？）。没管这么多，带上排球，跟着同班经常一起打球的兄弟下楼，上车去了。 考点还比较远，从清镇到普瑞大概花了一个小时（靠着旁边的人睡了一个小时）。下了车发现这学校是真tm的大（一个操场就秒杀我们的那种）还遇见我妈在考场外面等着，心里还是有点忐忑（也不知道为什么）领队老师问谁要上厕所，结果一车的人都说要去，于是我等了二十分钟才上得了厕所，谔谔。 进到考场之后就是走流程，检录，同时天上下起了大雨，旁边几个同伴瞬间懵逼，“下这个雨操场湿了还跑个jb的1km啊”。暗自骂了几句，也不想管那么多了，检录完就直接跟着队伍乱逛。（带队老师还有点小帅） 这个学校虽然大，但是体育馆是新修的，灰很多（差评），我们在场地里面练习排球的时候烟尘四起，和安塞腰鼓里面描绘的场景神似。关键是体育馆里面还挺冷的，不热身简直冷成憨批。 本来以为马上可以轮到我们考试了的，结果又耗了半天时间，告诉我们要等。没事，等就等嘛。等了半天，身份验证完拿到我们的ic卡（这玩意挺高级的），然后就开始考跳远了。跳远的设备很先进，但是对于踩线的蜜汁判定我也没搞懂过。垫子上面只有男生满分线（2.4m）和女生满分线（1.86m）两条白线，而且垫子也不滑，上去之前感觉也还不错。However，我最担心的还是发生了，我跳的第一次失误了，只跳了1.8m；第二次稍稍进步，我很明显的感受到我的脚飞过了那根白线但是由于落地的时候没有维稳重心，手往后撑地，导致了只有2.38m（差1cm满分是真的操蛋，机子测还不可能防水）；第三次就更不稳了，手撑的更往后了，只有两米二。 其他和我一组的也表现不是很好，本来以为很多满分的结果都没有跳过去，甚至最好的只有两米二。大家的士气一度低迷。但也没有办法，只能到隔壁继续考排球了。 排球一向是我强项，一遍就直接过去了。现在还剩最后一个项目——1km。大家估算着时间差不多就把 \\text{C} _6 \\text{H} _{12} \\text{O} _6 和Redbull混起来喝了，但是后面发生的事情才是真的迷惑。 一行人排队来到操场，结果开始下雨，考官喊我们等待。然而这个雨貌似没有想要停的感觉，一直下一直下一直下，等到有一部分先考完的同学回家了我们还没有开考（感觉 \\text{C} _6 \\text{H} _{12} \\text{O} _6 的药效都过去了）。好在后来考务安排了人把操场的水扫干净了，不然积有水的操场是真的要命。 轮到我们这组了，如果我跑步没能满分的话体考满分就没希望了（我们这边满分50，你考49.5会给你折算成满分）。好在最后是拼了命跟着我们组的第一（是个打球很厉害的帅哥）跑，提前10s完成了1km。但讲真跑完这3分多种耗费了我一个小时恢复状态（）。 走出考场，教务处贴心的给我们买了盒饭，随便拿了一碗吃了，就上车回学校了。 让人迷惑的是下午打球的时候有一人把胳膊摔断了（还是本班的hxd，听说是下楼梯的时候摔到的）。 于是体考就结束了，49.5pts，不算太差，也不算很好。 Day -1 先经历了令人泪目的告别，然后就收拾家伙离开学校（我估摸着这班的人不太可能再在一个教室里面上课了）。到家，听了各种注意事项，收检一下物品，然后就开始颓，刷了一下午的知乎。 睡的有点晚，11点。明天还要看考场，要凉。 Day 0：看考场 这考场离家是真的远，开车开了四十多分钟才到。学校叫做贵阳市第三中学，占地面积也不小。到了的时候已经是9:30了，看见一堆认识的人看完了考场往场外走。找不到考场的我慌的一批/ 还好遇到了班主任，他和蔼地拿出了手机，给我看考场的楼层和教室。“第一教学楼四楼”。于是蠢到爆的我找楼梯都花了两分钟时间（bushi）。顺着一个个的教室找到自己的考场，签了到（负责的老师是个挺漂亮的小姐姐），找到自己的位置然后坐下。 突然发现这位置tm是晃的（不是吧，要让我坐这种桌子考三天试？)赶忙联系刚才那个小姐姐，结果被告知她不是负责这一块的？）还好旁边有一个老阿姨听到了，于是过来晃了晃我的桌子，然后告诉我垫张纸在下面（woc就这？）好在垫了纸之后真就不晃了。。安心坐下，听了下广播里放的听力（拿八年级期末听力糊弄谁呢），写了半张数学卷子，发现状态不对就懒得继续写了。去等我家小兄弟去。 等了半天，小兄弟终于来了（全考场就他一个没来签到了）。签完到，进去考场，听力早就不放了，然后发现他的桌子比我的还晃（woc这考场真的牛）解决方案还是垫纸（笑了）。观察了一下考场的钟表和桌子，匆匆离去。 走之前拍了张考场名单，发现30人的考场有14个本校的，顿时信心大增。 下午回家收拾了东西，睡了3小时，晚上就回考场旁边的酒店住了。10: 20 上的床，然而盖了被子觉得热，不盖被子觉得冷，硬是折腾到了12点过（预示我语文要凉？？？）。但好歹最后是睡着的。而且有NesCafe护体，第二天应该不会困。 Day 1：语文/理综 早上7点醒的，困死。出门等电梯等了半天，干脆不等了，从24楼直接走楼梯下来到大堂吃早餐，下去的时候看到一堆本校的，感觉良好。早餐不算太难吃，泡了包NesCafe，感觉没那么困了。 上了厕所，便进了考点，排了很长的队但也没耗很久时间。进去之后和小兄弟直奔考场，监考是一个凶巴巴的老阿姨，跟我们讲喊我们提前上好厕所再进去，于是我们两个只得在教学楼逛了一大圈，遇到很多同班的，都拥抱了下互相加油。逛了约莫十分钟下了楼看到班主任，班主任反手就塞了两本万唯给我们复习（才不会告诉你我复习了的一个没考），发现看不进去书，然后就又和小兄弟一起从二楼逛到四楼（bushi），上了厕所，才慢摇慢摇进了考场，这个时候才八点半。 进了考场之后昏昏沉沉的，趴在桌子上躺了一会，就坐起来发呆了。八点四十五的时候大喇叭突然想起来，通知监考发放答题卡。另外一个监考是个帅哥，帅哥挨个挨个给我们发了答题卡，我拿到之后填完信息就开始看题： 草，作文叫“找到一个好办法”，什么神奇的东西 文言文大题里面有一个“爽然”，还让我们解释是什么意思，貌似不简单。 哎哎哎分析表达效果，一看就是那种4分我只能做到1分的鬼东西。 不管了不管了，就这样吧。 又过了几分钟，试卷发下来了。急忙看题：选择题第一道我就不会，名著阅读考西游记和简爱，现代文考了一篇通讯一篇说明文，文言文考了《小港渡者》，古诗赏析考了王维的《新晴野望》。总体看上去貌似不算太难。 10分钟切完基础题，然后就是开阅读。第一篇是一篇关于疫情后城市复苏的通讯，20分钟弄过去了，纠结了一道选择题。于是开始第二篇，是用第一人称写的人的免疫系统，题也不难。文言文和古诗赏析就像平时一样，就这样过去了。 考试还剩1h10min的时候，到作文了，审题审了半天（毕竟我初三可是写一篇作文跑题一篇），然后想到一个不错的 idea，身为一个 OIer，依照惯例去上了个厕所。/回来就开始肝作文，弄完发现还有半个小时，开始从头检查。 检查了半天发现没什么问题，但是在综合性学习那里纠结了一下，改了下答案，然后。。。就tm收卷了（铃声响之后有个人笔没停监考不带管的？？？）就这样结束了，出考场的时候被堵了半天，差评。 中午几个同班的一起到酒店的一个房间里面吃了点东西，然后就回自己房间复习下午的理综了（然而还是什么都没复习到），回想了一下物理老师特意强调的凸透镜成像，在万唯的那一页停留良久，然后闭眼假装休息了一下（？）就到1:50了。跟几个同学一起，去考场去了（顺便路上买了瓶矿泉水）。 下午一进考场之后雨就开始下大了。送别几个同班的之后等我女票（她今天没有带伞），等的时候和班主任和物理老师闲聊了一会。最后真没想到等了好久，两点半才等到她入场，送她到考场之后上了个厕所就飞奔回自己考场去了。 下午的监考是一个大叔一个阿姨（大叔很凶），估计理综要凉。 答题卡发下来，速度瞟题：作图题一个光线从水中入射到空气，一个画小磁针方向，一个画受力分析，压轴是一个 p-s 图象（鬼知道又是什么），化学看不出什么猫腻，等试卷下发了。 试卷下来之后两分钟就开考了。开考铃一响旁边的人立马翻回第一页开始写（？？？，只有我一个慢慢悠悠的在浏览后面的题））））））。人傻了。看到化学有几道没见过的题，表示有点难受。 开考5分钟后，翻回第一面从化学选择题开始搞，没想到的是这次化学选择压轴考了推断题（真心没想到会搞这个，果然换了批新的出题人），平时没练过推断题的我在这题上卡了五分钟，但最终发现这题是个sb题。然后开搞物理选择题。发现道送命题：修建火神山的时候上百台挖掘机一起工作增大了挖掘机总的A. 机械效率、B. 功率、C. 功、D. 有用功。我tm怎么觉得BCD都是对的，选了个功率走人不管了。选择压轴不是太难，思考两分钟直接跳过。 开搞物理选择题，又发现一送命题：立扫帚利用了什么原理，仔细调整利用了该原理的什么条件。毫不犹豫的抱着拿不到分的态度填上去一个二力平衡和二力作用在同一直线上就走人了。填空压轴这次比较水，但是答案比较神奇：7.5V。然后就是开搞简答了。简答比较常规，都能作出答案出来。作图就压轴动了点脑子然后就进实验了。 这次的实验没考凸透镜（我？？？？），考了个特别简单的平面镜成像，然后就是一道常规电学实验和一个牛顿摆（这题送走了不少人），感觉都很常规。计算题第一道电学的简单到爆，第二个考了火箭的也很神奇。感觉物理88有望？？？ 开搞化学，但是发现化学不简单——给了酒精的爆炸极限和闪点让你解释为什么使用酒精的时候要注意防止与明火接触，要说这个比较常规的话下面一问问你家用消毒的时候是擦拭酒精还是喷洒。不管了，选擦拭，走人。 金属和酸碱盐大题也不是很难，只是酸碱盐大题耗费了点脑子，花了点时间之后上了个厕所，发现最后也是还有半个小时，遂检查。 物理没检查个什么东西出来，倒是化学查了好几个错，顿时心里有点慌？？？？查完错，时间也就差不多到了。打铃，收卷，流程结束。 出了考场，议论了一下试题，发现貌似没有什么问题，可能作图题扣一分。心满意足的跟平时一起打球的兄弟回了酒店。 草草吃了晚饭，在群里议论了下考题，Day 1 就这样结束了。 晚上写游记，跟兄弟一起刷了点数学题组，睡觉。 Day 2：数学/文综 一早起来，发现还是有点困，怕是数学要凉（结果真凉了） 跟几个同班的同学一起从酒店出发，路上买了一瓶瓶装的 NesCafe （甜到发腻真tm难喝），貌似真的没有那么困了？ 进考场，发现有一同班的在复习，遂马上拍照发群进行制裁。之后也没发生什么，开始考试了。 说实话，考数学之前我内心是非常紧张的：整个初三下半学期数学成绩都飘忽不定的，都在140上下徘徊而且做不做得完卷子还是运气问题。一直期待着中考能不能咸鱼翻身，卷子发下来的时候内心是抖的。 先拿到答题卡，24题没图？？？一看就不简单，25题的图是一个正方形里面变花样，看来又是几何综合。23题的圆的综合题看上去有点小难，剩下的没看出什么猫腻来。 卷子放下来，国际惯例先全部浏览通读，发现10题简单到炸的时候我的内心是欢喜的，发现15题是道静态几何求线段长的时候我的内心是凝固的，发现24题考的是二次函数综合应用题的时候我的内心是崩溃的。这他妈考的都是什么玩意儿啊？？！ 9点，开考。2分钟切完1-14题，15题读完题面之后发现毫无思路就直接跳了。开考半小时的时候我已经处理完答题卡第一面，开搞第二面。反比例函数的题也非常常规，圆的综合题没卡很久，几个相似暴力过去就完了。现在还剩一个小时，整张卷子剩余24，25，15。 我上了个厕所，内心想着“我想AK”，然而上完厕所回来之后，这三道题联合起来给我扇了一耳屎，这一耳屎成功把我扇下140。 24题越读越发现不对——这tm没有那么简单啊，第一题求 y 关于 x 关系式就是一个分段函数（一段二次函数一段常函数），第二问做着还比较顺利，但第三问直接就tm傻了，方程都列不出来（是我笨没得跑了）。一小时二十分钟后无果，开搞25题。 25题第一问直接搞过去，第二问开始全程懵逼：这tm显然，不会证明。于是第二问乱口胡了一个过程（自认为没问题），然后第三问混了点分，此时二十五分钟又过去了，倒计时15分钟铃也响了，我整个人也傻掉了。 赶紧整理下心态，往前再读一遍15题，仍无果，果断放弃。检查了一遍卷子，然后，，，就打铃了。我的140的梦也没了。 出了考场立马去找同校数学最好的人，发现15题蒙上去的答案是一样的，心里有点小欢喜。手机一开机马上联系数学老师，一顿语音飙过去就是骂出题人，引起旁人侧目。到了校门口看到本校的一个数学老师，简单聊了几句就走人了。卷子没有写好，但是饭还是要吃的，同学帮忙点了砂锅饭，味道还不错。 已经下午一点了，简单假装看一下文综，再假装休息一下（实际没有睡着），就又出发去考场了。 今年文综不一样的一个地方就是文综变成闭卷考试了（微笑），而初三的政治完全划水的我表示政治什么东西都记不得（完蛋咯）。历史还好，没有怎么去记也能考一个大概的分。最最最好的是我们的文综仍不计入总分，采用打等级的制度（暗自窃喜自己不会被刷下去）。 以往考文综的时候都普遍无聊（文综题普遍要么第一眼出答案，要么完全想不到，所以做的很快），好在这次有草稿纸。进了考场，打铃，先发呆发了15分钟，思考了一下人生和上午没写出来的15题。之后5分钟切完30道选择题（怎么我记得以往是32道来着）慢慢发呆，慢慢写，感觉没什么压力就写完了。 晚上和几个玩的好的去了趟金阳万达，一起去吃味千拉面（表示上次在SH玩的时候在东方明珠楼底吃的就是这家），然后回酒店，休息。 比较意外的是今晚睡的很晚，11点半过才睡得着。 Day 3：英语/毕业典礼/毕业聚餐 仍然是七点醒过来，贼困（虽然考英语睡觉已经习惯了）。 按照前两天的流程吃完饭，上厕所，然后出发去考场。 在考场外面读了一下作文句子，然后盲猜作文不考疫情。 进考场，拿到答题卡，看到作文标题给你写好了：“Good Living Habits Make Me _____ ”暗自笑道自己没猜错。 8:59 的时候开始播放听力，暗自觉得听力要凉凉？？差点睡下去倒是真的。 整张卷子不难，任务型阅读有道谚语翻译不会，最后期望得分 145 毕业典礼和毕业聚餐不太愉快，但是想到和这一班人分开也是挺难受的。 Day x：出成绩 7.28 出成绩了。 头天晚上本来想蹲到12点的，但发现没有用，教育局说是10点那应该就是10点了，睡觉睡觉。 早上醒来的有点早，等我妈去上班之后才起的床，此时9:00 a.m. 还剩最后一个小时，但是挺无聊的，然后说开一把游戏准备打完几把之后出成绩。 和平精英打开，和一个学弟开了一把双排，打野打了20多分钟之后，正当跑毒之时，一大个电话打进来： 成绩可以查了 成绩可以查了 成绩可以查了 我：？？？？？？？傻逼教育局 打完之后很快的打开电脑输入报名号和名字。没有卡顿，成绩出来了。 之前期望得分：120+138+146+148+50=602 查到实际得分：127+136+145+147+50=605 果然语文眷顾我哈哈哈哈哈。 排名查不到，根据各大学校放的榜可以大概得知市排名12-13左右。今年状元618，是个大哥 算是解放了奥","categories":[{"name":"life","slug":"life","permalink":"https://old.blog.imyangty.com/categories/life/"}],"tags":[{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"},{"name":"初中","slug":"junior-middle-school","permalink":"https://old.blog.imyangty.com/tags/junior-middle-school/"}]},{"title":"2020年5月 OI学习记录","slug":"summary-2020-05","date":"2020-05-10T06:26:55.000Z","updated":"2022-03-23T04:19:24.283Z","comments":true,"path":"summary-2020-05/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-05/","excerpt":"","text":"计划 学习组合数学基础 继续练习 dp AC 280 AC 300 做题记录 20/05/10 P2623 物品选取 混合背包+泛化物品 20/05/16 P1137 旅行计划 拓扑排序+dp 20/05/16 P2822 组合数问题 递推组合数+二维前缀和","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"NOI Online 2020 Round 2 PJ 游记","slug":"travels-noiol20r2pj","date":"2020-04-26T05:49:06.000Z","updated":"2022-03-23T04:20:07.492Z","comments":true,"path":"travels-noiol20r2pj/","link":"","permalink":"https://old.blog.imyangty.com/travels-noiol20r2pj/","excerpt":"","text":"前言 菜死了 Day 0 还在学校和文化课苦苦挣扎，差点忘了有这场比赛的存在 Day 1 最近几天一直腰痛（不排除 AS 的可能），遂中午一从学校出来就去了医院检查，谁知道医院 tm 没号了，遂苦逼的赶回家。 回到家想起来今天有 NOIOL，于是吃完饭打开电脑开始看题 第一眼：T1 模拟，T2 搜索，T3 dp，于是直接从 T2 开搞 看题面名字：荆轲刺秦王，我估摸着这就是一个普通的走迷宫然后存储状态就可以了，于是菜到爆的我写了两小时的暴搜，拍完样例后发现没问题就直接走了。 那时的我并没有意识到我处理士兵的方式是 O(n^3) 级别的，不 T 才怪，然后搜索也是傻傻的用 STL 搞，于是乎最后 55 pts 走人。 T1 第一眼看着没思路，分析了几分钟之后发现有点像贪心，然后就想到一个二分答案+前缀和水过去了，注意了下精度问题，发现无大碍，滚去看 T3，发现不会做，写了个输出随机数，卒。 期望得分：100+70+0 Day 2 官方题解出来了，发现 T2 要用差分，T3 是道计数（我没学过计数/kk）于是已经做好滚粗的准备（ Day x 出成绩了，刚好从学校回来，测了民间数据发现 T2 只有 55 分，结果确实只有 55 分，T3 的输出随机数一分没得（好吧我人品确实太惨了）只有 T1 所幸没被卡精度成功 AC。 总结：下次做任何题都要记得估计时间复杂度，不然像这次一样直接爆炸。 最终结果：100+55+0=155","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"游记","slug":"OI/travels","permalink":"https://old.blog.imyangty.com/categories/OI/travels/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"}]},{"title":"解题报告 P1119 灾后重建","slug":"sol-luogu-p1119","date":"2020-04-05T09:14:56.000Z","updated":"2022-03-23T04:18:30.824Z","comments":true,"path":"sol-luogu-p1119/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p1119/","excerpt":"","text":"题目内容 P1119 大意：给定编号从 1 到 n-1 的村庄，每个村庄都被一定程度上损毁，而公路正常，在 t\\_i 时间前 i 号村庄不能通过，询问在 t 时间时 x 号和 y 号村庄能不能通车，如果能，最短路径是多少。 解题思路 这题思路真的很妙，让我们对 Floyd 的本质有了更深的理解，至少本蒟蒻是这样觉得的。 回归 Floyd 算法的本质： 12345for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) f[i][j]=min(f[i][j],f[i][k]+f[k][j]) 实际上，Floyd 是通过枚举中转点 k 来求得每个点之间的最短路，本质上是一种 dp。 然后，注意到本题中，每个村庄的恢复时间是递增的，且给出的询问的时间也是递增的。而题目让我们求任意两点的最短路，那么也可以抽象成 Floyd。具体的方法就是，由于时间是递增的，所以每到一个村庄恢复的时间点我们就可以让这个村庄成为那个可以用来中转的 k 来更新这一时间的所有最短路。 在这题中，就是使用时间戳，保证回答被询问的时间前信息被更新过即可。注意村庄编号从 0 开始 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline int min(int a,int b){ return a&lt;b?a:b;}const int maxn=205;int n,m,t[maxn],f[maxn][maxn],q;inline void floyd(int k)//更新信息的，通过给定可以中转的中转点来进行更新{ for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) f[i][j]=min(f[i][j],f[i][k]+f[k][j]); return;}int main(){ n=read(),m=read(); memset(f,0x3f,sizeof(f));//初始赋极大值 0x3f 不至于加起来爆int for(int i=0;i&lt;n;i++) t[i]=read(),f[i][i]=0; while(m--) { int x=read(),y=read(),w=read(); f[x][y]=f[y][x]=w;//双向边 } q=read(); int now=0; while(q--) { int x=read(),y=read(),s=read(); while(t[now]&lt;=s &amp;&amp; now&lt;n)//将这一时间前的所有时间信息更新 floyd(now++); if(t[x]&gt;s t[y]&gt;s f[x][y]&gt;=0x3f3f3f3f)//如果这一时间时村庄未修复，或者无路线 printf(\"-1\\n\");//输出 -1 else printf(\"%d\\n\",f[x][y]);//否则输出最短路即可 } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"图论","slug":"graph","permalink":"https://old.blog.imyangty.com/tags/graph/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"最短路","slug":"shortest-path","permalink":"https://old.blog.imyangty.com/tags/shortest-path/"}]},{"title":"2019 CSP-J 题解","slug":"sol-cspj2019","date":"2020-04-04T15:03:27.000Z","updated":"2022-03-23T04:18:30.743Z","comments":true,"path":"sol-cspj2019/","link":"","permalink":"https://old.blog.imyangty.com/sol-cspj2019/","excerpt":"","text":"前言 咕咕咕了好久，终于今天把 T3 的坑给补回来了，于是打算写一波题解。 勿吐槽码风，丑是必然的，毕竟好久前写的代码了。 T1 数字游戏 P5660 数字游戏 大意：给定长度为 8 的 01 串，求 1 的个数 sb 题，考察字符串基本使用，当时好像 2:30 还没到就已经切完了 考场代码： 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;//#define LOCALusing namespace std;int main(){#ifndef LOCAL freopen(\"number.in\",\"r\",stdin); freopen(\"number.out\",\"w\",stdout);#endif string s; cin&gt;&gt;s; int ans=0; for(int i=0;i&lt;s.size();i++) { if(s[i]=='1') ans++; } printf(\"%d\\n\",ans); return 0;} T2 公交换乘 P5661 公交换乘 大意：坐一次地铁可以获取一张有效期 45 分钟的优惠券，可以凭券免费坐票价不超过地铁票价的公交车，优惠票可累积，使用时优先使用最先获得的 模拟即可，这里使用 vector 模拟优惠票的队列，代码并不优美但是能过。 坑点就在于 使用票要使用最先获得的 优惠票用过要删掉 记得当时在考场上发现队列不能用之后还自己研究 vector::erase 的用法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;//#define LOCALstruct ticket{ int price; ll time;};vector&lt;ticket&gt; q;int main(){#ifndef LOCAL freopen(\"transfer.in\",\"r\",stdin); freopen(\"transfer.out\",\"w\",stdout);#endif int n; scanf(\"%d\",&amp;n); ll ans=0; while(n--) { int type,price; ll t; scanf(\"%d %d %lld\",&amp;type,&amp;price,&amp;t); if(type==0)//如果坐地铁 { ans+=price;//更新答案 ticket tt={price,t}; q.push_back(tt);//插入候选队 } else if(type==1)//如果是公交 { while(!(q.empty())&amp;&amp;t-q.front().time&gt;45) q.erase(q.begin());//先删掉超时的优惠票 bool flag=0; for(int i=0;i&lt;q.size();i++)//查询符合标准的第一张优惠票 { if(q[i].price&gt;=price) { q.erase(q.begin()+i);//直接删掉 flag=1; break; } } if(!flag) ans+=price;//如果不存在就需要付原价 } } printf(\"%lld\\n\",ans); return 0;} T3 纪念品 P5662 纪念品 谁叫我太菜，当时考场上骗了 10 分走人，现在看题解才写出正解。 大意： T 天， N 种纪念品，每天不同的纪念品都有不同的价格，小伟一开始有 M 金币，每天可以卖掉手中的纪念品换取金币，买进纪念品花费金币或者什么都不做。在第 T 天一定会卖出手中所有纪念品，求最高收益 分析题意，可以发现需要使用 dp，发现状态貌似很复杂，又可以买进又可以卖出，然而，注意到买进和卖出都可以进行无数次，因此我们可以把所谓一直持有的纪念品看成先将其卖出，又将其买进，效果是一样的，实质上就是每一天都做一次完全背包。 令 f_{i,j,k} 表示第 i 天，考虑前 j 种物品，手里有 k 金币时，在下一天全部卖出能达到的最大收益，则有方程 f_{i,j,k}=\\max(f_{i,j,k},f_{i,j-1,k+p_i,j}+p_{i,j}-p_{i+1,j}) 表示如果要了第 j 个物品，那么净收益即为 p_{i,j}-p_{i+1,j} ，从 f_{i,j-1,k+p_i,j} 转移而来，利用完全背包思想压一下维度然后改循环顺序即可以达到正确结果。 （第一维的天数是可以不要的，第二维的物品也是可以用滚动数组优化掉的，保留第三维即可） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;inline int read(){ char c = getchar(); int s = 0; while (!isdigit(c)) c = getchar(); while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return s;}inline int max(int a,int b){ return a&gt;b?a:b;}int n,t,p[105][105],f[10005];int main(){ t=read(),n=read(); int m=read(); for(int i=1;i&lt;=t;i++) for(int j=1;j&lt;=n;j++) p[i][j]=read(); int ans=m; for(int i=1;i&lt;t;i++) { memset(f,~0x3f,sizeof(f));//先赋负无穷 f[ans]=ans;//初始值，什么都不干的情况 for(int j=1;j&lt;=n;j++)//枚举物品，从小到大即为完全背包 for(int k=ans;k&gt;=p[i][j];k--)//枚举金钱 f[k-p[i][j]]=max(f[k-p[i][j]],f[k]+p[i+1][j]-p[i][j]); int maxn=0;//统计最优答案用 for(int j=0;j&lt;=ans;j++) maxn=max(maxn,f[j]); ans=maxn; } printf(\"%d\\n\",ans); return 0;} T4 加工零件 P5663 加工零件 大意：一个工厂正在生产零件，工人从 1 到 n 标号，某些工人之间有双向传送带。 如果 x 号工人想生产一个被加工到第 L (L \\gt 1) 阶段的零件，则所有与 x 号工人有传送带直接相连的工人，都需要生产一个被加工到第 L - 1 阶段的零件（但 x 号工人自己无需生产第 L - 1 阶段的零件）。 如果 x 号工人想生产一个被加工到第 1 阶段的零件，则所有与 x 号工人有传送带直接相连的工人，都需要为 x 号工人提供一个原材料。 给定一些工单，即需要某工人生产某阶段的零件，求 1 号是否需要提供原材料。 先将其抽象成图论问题，以工人为节点，传送带为边来建图。 考虑暴力，虽然一定超时，但还是能给我们一些启示，不难发现暴力就是在看 a 与 1 之间是否存在长度为 L 的路径，同时我们又注意到：如果 L 为奇数，且从 1 到 a 存在一条奇数路径，且最小奇数路径长小于等于 L ，那么 1 就必须提供原材料（为什么可以：你可以两个传送带之间来回跳，比如 1-&gt;2-&gt;1-&gt;2-&gt;1...，但如果最小的奇数路径大于 L ，说明从 a 走 L 个阶段也轮不到 1，就不行）同样的，如果 L 为偶数，且从 1 到 a 存在一条偶数路径，且最小偶数路径长小于等于 L ，那么 1 就必须提供原材料。 这就给我们了正解的方法：找到每个点距离 1 点的最小奇数路径与偶数路径即可，这一过程实现可以使用 bfs~~（因为我当时还没学过最短路）~~，然后判定每一个工单的时候按照奇偶数去找最短奇偶路径是否小于等于工单给定阶段就可以判定 Yes 或 No 了 当然，我写的考场代码有一个小 bug，就是没有判断 1 点不连通的情况，然而 ccf 的数据没有这种特殊情况，所以也就 A 了这道题 考场代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;//#define LOCAL#define inf 0x3f3f3f3ftypedef long long ll;using namespace std;vector&lt;int&gt; g[100020];//存图bool vis0[100020],vis1[100020];//bfs用int minans0[100020],minans1[100020];//存储奇偶最短路struct node{ int n,time;};queue&lt;node&gt; q;void bfs(){ memset(minans0,inf,sizeof(minans0)); memset(minans1,inf,sizeof(minans1)); q.push((node){1,0}); while(!q.empty()) { int curn=q.front().n;//当前的点 int nxtc=q.front().time+1;//下一个点会经过的路径长 q.pop(); for(int i=0;i&lt;g[curn].size();i++) { int nxt=g[curn][i]; if(nxtc%2==0)//如果下一个点是偶数到达 { if(vis0[nxt]==0)//如果未访问 { vis0[nxt]=1; q.push((node){nxt,nxtc}); minans0[nxt]=min(nxtc,minans0[nxt]);//就更新这里的结果 //cout&lt;&lt;\"no.\"&lt;&lt;nxt&lt;&lt;\" \"&lt;&lt;nxtc&lt;&lt;endl; } } if(nxtc%2==1)//反之如果是奇数，也一样 { if(vis1[nxt]==0) { vis1[nxt]=1; q.push((node){nxt,nxtc}); minans1[nxt]=min(nxtc,minans1[nxt]); //cout&lt;&lt;\"no.\"&lt;&lt;nxt&lt;&lt;\" \"&lt;&lt;nxtc&lt;&lt;endl; } } } } return;} void add_edge(int u,int v){ g[u].push_back(v);//注意是无向图 g[v].push_back(u); return;} int main(){#ifndef LOCAL freopen(\"work.in\",\"r\",stdin); freopen(\"work.out\",\"w\",stdout);#endif int n,m,q; scanf(\"%d %d %d\",&amp;n,&amp;m,&amp;q); while(m--) { int u,v; scanf(\"%d %d\",&amp;u,&amp;v); add_edge(u,v); } bfs();//预处理 while(q--) { int a,l; scanf(\"%d %d\",&amp;a,&amp;l); bool flag=0; if(l%2==0&amp;&amp;vis0[a]==1&amp;&amp;minans0[a]&lt;=l) flag=1;//如果是偶数阶段并且能到达 if(l%2==1&amp;&amp;vis1[a]==1&amp;&amp;minans1[a]&lt;=l) flag=1; if(flag) printf(\"Yes\\n\"); else printf(\"No\\n\"); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"背包","slug":"backpack-dp","permalink":"https://old.blog.imyangty.com/tags/backpack-dp/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"图论","slug":"graph","permalink":"https://old.blog.imyangty.com/tags/graph/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"}]},{"title":"解题报告 P4198 楼房重建","slug":"sol-luogu-p4198","date":"2020-04-04T10:08:52.000Z","updated":"2022-03-23T04:18:30.982Z","comments":true,"path":"sol-luogu-p4198/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p4198/","excerpt":"","text":"题目内容 P4198 大意：维护一串序列，单点修改，在线查询 LIS 解题思路 首先这题要注意精度问题，有可能会出现玄学的精度错误 分析题意：考虑看到的楼房最高点 (i,H_i) ，不难发现能看到的楼房的最高点的斜率都是递增的，即 k_i=i/H_i 满足单调递增（这应该很好想）。发现大区间的信息可以由小区间合并而来，可以使用线段树。这里的单点修改很简单，主要的难点在于如何在 pushup 时合并子区间的信息。 令 l_k 维护线段树下标为 k 代表的区间中能被看见的楼房的个数（就是单纯只考虑这个区间）， m_k 维护 k 区间中楼房的最大斜率。 考虑我们正在处理一个区间，线段树对应的下标为 k ，已经递归处理完他的左半边 L 和右半边 R ，现在在进行合并。 m_k=\\max(m_L,m_R) ，这个是非常好想的， k 区间的最大斜率就是左右两半边取 max。问题就是 l_k 怎么合并，他不能单纯的等于 l_L+l_R ，因为可能会出现右区间中的楼房被左区间的楼房挡住的情况，因此不能直接加起来。 很明显，我们需要在 R 区间中寻找有多少楼房不会被左边挡住。令 f(mk,k) 为在区间 k 中第一个不被 mk 斜率挡住的楼房及此楼房后面看得到的楼房的总数。返回之前的合并过程，有 l_k=l_L+f(m_L,R) ，因为 L 区间的贡献是无论如何都会产生的。故要在 R 中查找以第一个不会被左区间挡到的楼房开始的能看见的最多的楼房数。 现在考虑正在处理 f ，进入了 R 区间，而 R 区间又由两个小的区间 R_1 ， R_2 构成。以下分三种情况： 如果 m_R &lt; mk ，说明左区间会把右区间全部挡完，返回 0 如果 R 区间长度为 1，则看这栋楼是否会被挡，如果不会，返回 1，反之返回 0 如果 m_{R_1} &lt; mk ，即右区间的左子区间会被挡完，那么就不管左区间了，递归查询右区间即 f(mk,R_2) 如果 m_{R_1} &gt; mk ，即左子区间不会被挡完，那么显然右子区间产生的贡献即为 m_{R}-m_{R_2} ，即右区间的总个数（是已经处理完了的）减去左区间的贡献。然后还要递归查询左区间，因为不知道挡了多少，即 f(mk,R_1) 。 上述 pushup 过程的核心代码如下（f2 为上文的 m ，f1 为上文的 l ）： 123456789101112131415161718192021int pushup(double mk,int i,int j,int k){ if(f2[k]&lt;=mk)//挡完 return 0; if(a[i]&gt;mk)//如果第一栋楼都能被看见 return f1[k];//说明可以直接返回这个区间计算过的答案 if(i==j)//区间长度为1的情况 return f2[k]&gt;mk; if(f2[L]&lt;=mk)//如果左区间挡完 return pushup(mk,M+1,j,R);//递归查询右区间 return pushup(mk,i,M,L)+f1[k]-f1[L];//否则递归查询左区间再加上右区间的贡献}void change(int i,int j,int x,double d,int k){ // balabala f2[k]=max(f2[L],f2[R]); f1[k]=f1[L]+pushup(f2[L],M+1,j,R);//左的全部贡献加上右还没被挡完的部分 return;} 了解了以上要点之后，不难发现每一次 pushup 的操作都为 O(\\log n) ，故总复杂度为 O(m\\log^2n) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#define L (k&lt;&lt;1)#define R (L1)#define M ((i+j)&gt;&gt;1)using std::max;const int maxn=1e5+5;int f1[maxn&lt;&lt;2],n,m;double f2[maxn&lt;&lt;2];//维护最大斜率的线段树double a[maxn];//存储每栋楼的斜率//快读省略int pushup(double mk,int i,int j,int k){ if(f2[k]&lt;=mk) return 0; if(a[i]&gt;mk) return f1[k]; if(i==j) return f2[k]&gt;mk; if(f2[L]&lt;=mk) return pushup(mk,M+1,j,R); return pushup(mk,i,M,L)+f1[k]-f1[L];}void modify(int i,int j,int x,double d,int k){ if(i==j&amp;&amp;i==x) { f1[k]=1; f2[k]=d; return; } if(x&lt;=M) modify(i,M,x,d,L); if(x&gt;M) modify(M+1,j,x,d,R); f2[k]=max(f2[L],f2[R]); f1[k]=f1[L]+pushup(f2[L],M+1,j,R); return;}int main(){ n=read(),m=read(); int x,y; for(int i=1;i&lt;=m;i++) { x=read(),y=read(); a[x]=(double)y/(double)x; modify(1,n,x,a[x],1); printf(\"%d\\n\",f1[1]); } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"解题报告 CF607B Zuma","slug":"sol-cf607b","date":"2020-04-03T14:58:41.000Z","updated":"2022-03-23T04:18:30.722Z","comments":true,"path":"sol-cf607b/","link":"","permalink":"https://old.blog.imyangty.com/sol-cf607b/","excerpt":"","text":"题目内容 CF607B 大意：给定一串序列，每次操作可以消除其中的一个回文串并将两侧拼一起，求消除所有元素所需的最小操作次数 解题思路 区间 dp 令 f_{i,j} 表示区间 [i,j] 需要的最小消除次数，接下来考虑转移： 显然，有 \\begin{cases} f_{i,i}=1\\quad\\ f_{i,i+1}=1\\quad(a_i=a_j)\\\\ f_{i,i+1}=2\\quad(a_i\\neq a_j) \\end{cases} 可发现的就是，如果串的长度为 1，则需要的消除次数为 1，如果长度为 2，则次数取决于这两个元素是否相等，相等就只需要一次，不相等就需要两次。 然后，一般地，如果当前枚举的两端点元素相等，说明可以在消除中间的元素的同时顺便消掉两边元素，但如果不相等，就只能枚举断点寻找最优划分方案，即： \\begin{cases} f_{i,j}=f_{i+1,j-1}\\qquad\\qquad\\qquad(a_i=a_j)\\\\ f_{i,j}=\\min_{k=i}^{j-1}\\lbrace f_{i,k}+f_{k+1,j}\\rbrace~(a_i\\neq a_j) \\end{cases} 需要注意的是，不一定两端点元素相等了取 f_{i+1,j-1} 就是最优解，仍然需要考虑取断点的情况，否则会 WA，hack 数据： 123101 2 3 5 3 2 1 1 3 1 上面的就是一个典型的不可通过直接取 f_{i+1,j-1} 得到答案的例子，如果在最后一步的时候直接套用 f_{2,9} ，得到的答案是 3，但是正确的结果是 2，由 f_{1,7}+f_{8,10} 得来 剩下的就很简单了，只需记得一开始 f 数组初始化为 inf 即可。 1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;const int maxn=505;int n,a[maxn],f[maxn][maxn];//快读已省略inline int min(int a,int b){ return a&lt;b?a:b;}int main(){ n=read(); memset(f,0x3f,sizeof(f)); for(int i=1;i&lt;=n;i++) a[i]=read(),f[i][i]=1; for(int i=1;i&lt;n;i++) f[i][i+1] = 1+(a[i]!=a[i+1]);//处理长度为2的情况 for(int l=3;l&lt;=n;l++) for(int i=1,j=i+l-1;j&lt;=n;i++,j++) { if(a[i]==a[j]) f[i][j]=f[i+1][j-1]; for(int k=i;k&lt;j;k++) f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]); } printf(\"%d\\n\",f[1][n]); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"区间dp","slug":"interval-dp","permalink":"https://old.blog.imyangty.com/tags/interval-dp/"}]},{"title":"解题报告 P3574 [POI2014]FAR-FarmCraft","slug":"sol-luogu-p3574","date":"2020-04-03T10:43:48.000Z","updated":"2022-03-23T04:18:30.957Z","comments":true,"path":"sol-luogu-p3574/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p3574/","excerpt":"","text":"题目内容 P3574 大意：村庄是一棵树，住在 1 号的管理要给每个房子送电脑，通过每个房子之间的道路需要 1 分钟，每个村民需要不同的时间安装电脑，而当管理把电脑送到村民后，村民会立即开始安装，最后管理会回到自己家给自己装电脑，求从管理出发到最后一个人装好电脑花费的时间。 解题思路 可以考虑每一个子树需要安装的最短时间。设住在 i 处的村民需要 c_i 的时间安装电脑， f_i 表示以 i 为根的子树全部安装好需要的最短时间， g_i 表示开车遍历以 i 为根的子树需要的最短时间，则有如下的方程： f_i=\\max(c_i,f_j+g_i+1)\\ g_i\\leftarrow g_i+g_j+2 其中 j 为 i 的子节点，且 g_i 是动态更新的，就是遍历 j 之前的所有子树需要花的总时间。意思就是，对于一个 i 为根的子树，显然，第一次到 i 点的时候就让这里的村民开始装电脑得到的肯定更优，用这个时间与后面遍历下面节点的时间相比，总花费的时间是两者中间取最大的。而 f_j+g_i+1 的意义为，遍历过 j 节点之前的所有子节点需要的时间和 g_i 加上 j 节点需要的最短时间 f_j ，至于 +1 就是从 i 节点走到 j 节点的花费。 而至于为什么是 +1 而不是 +2，是因为 \\forall i:f_i-g_i\\ge1 ，即等待的时间必然大于等于 1，所以只需要考虑从 i 进入 j 的时间，即为 1，而返回来的 1 的时间是被 f_j 覆盖掉的 不难发现，遍历的顺序会影响最终的结果，所以考虑贪心：可以发现， f_i-g_i 这段时间就是拿来等待的，做过接水问题的都知道要先处理等待时间大的，于是在转移前将子节点按照 f_i-g_i 排序即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn=500010;int n,c[maxn],f[maxn],g[maxn],tmp[maxn];vector&lt;int&gt; G[maxn];inline void ins(int a,int b){ G[a].push_back(b); G[b].push_back(a); return;}inline bool cmp(int x,int y){ return f[x]-g[x] &gt; f[y]-g[y];}inline int read(){ char c = getchar(); int s = 0, x = 0; while (!isdigit(c)) { if(c == '-') x = 1; c = getchar(); } while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}void dfs(int now,int fa){ if(now!=1)//管理员的电脑最后装 f[now]=c[now]; int cnt=0; for(auto i:G[now]) if(i!=fa) dfs(i,now); //一定要先遍历后记录儿子节点，不然会被下面的节点覆盖掉 for(auto i:G[now]) if(i!=fa) tmp[++cnt]=i; sort(tmp+1,tmp+cnt+1,cmp); for(int i=1;i&lt;=cnt;i++) f[now]=max(f[now],f[tmp[i]]+g[now]+1), g[now]+=g[tmp[i]]+2;}int main(){ n=read(); for(int i=1;i&lt;=n;i++) c[i]=read(); int a,b; for(int i=1;i&lt;n;i++) { a=read(),b=read(); ins(a,b); } dfs(1,0); printf(\"%d\\n\",max(c[1]+g[1],f[1]));//在最后也要注意 return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"解题报告 P6082 [JSOI2015]salesman","slug":"sol-luogu-p6082","date":"2020-04-03T10:22:59.000Z","updated":"2022-03-23T04:18:31.040Z","comments":true,"path":"sol-luogu-p6082/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p6082/","excerpt":"","text":"题目内容 P6082 大意：给定一棵 n 个点的树，有点权，从 1 号点开始一次旅行，最后回到 1 号点。每到达一个点，就能获得等于该点点权的收益。每个点都有进入该点的次数限制，且每个点的收益只获得一次。求最大收益以及方案是否唯一。 解题思路 不难发现，这道题满足最优子结构，一棵子树的答案可由这棵子树的子树合并而来。 注意到进入限制这个性质，到达这个点进入了一次，去到每一棵子树再回来又是进入这个点一次，所以实际上我们只能访问这个点的 限制次数减一 棵子树。 而为了保证最优，需要使用贪心思想，当将一个节点的所有子树的信息处理完之后，将其从大到小排序，取前面的限制次数减一个并加起来（当然如果加到负数就肯定不加了）。 至于解的唯一性，注意到如果一个子树下的某个子树的解不唯一，那么这个子树的解肯定也不唯一。以及如果对于他的一棵子树，这个子树的答案为 0，则走与不走这个子树的效果是相同的，答案就会不唯一。还有，如果最后一个选的子树 a 的答案与下一个待选子树 b 的答案相同，说明可以选 a 也可以选 b ，效果都是一样的，也会产生多解。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;utility&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;queue&gt;using std::priority_queue;using std::make_pair;using std::vector;using std::pair;const int maxn=1e5+5;int n,money[maxn],stop[maxn];int f[maxn][2];vector&lt;int&gt; g[maxn];inline void ins(int from,int to){ g[from].push_back(to); g[to].push_back(from); return;}inline int read(){ char c = getchar(); int s = 0, x = 0; while (!isdigit(c)) { if(c == '-') x = 1; c = getchar(); } while (isdigit(c)) s = 10 * s + c - '0', c = getchar(); return x ? -s : s;}void dfs(int now,int fa){ if(g[now].size()==1)//这是判断是否为叶子节点的 { f[now][0]=money[now]; return; } priority_queue&lt;pair&lt;int,int&gt; &gt; q;//排序用 for(int i=0;i&lt;g[now].size();i++)//访问下面的节点 { if(g[now][i]!=fa) { dfs(g[now][i],now);//继续递归 q.push(make_pair(f[g[now][i]][0],g[now][i]));//并且加入队列 } } int lastChosen; for(int i=1; (!q.empty()) &amp;&amp; (now==1 ? 1 : i&lt;stop[now]);i++) { int to=q.top().second,val=q.top().first; if(val&lt;0)//如果现在这棵子树已经小于 0 了，说明会产生负贡献，直接舍弃 break; if(val==0)//有多解 f[now][1]=1; f[now][0] += val; lastChosen=val; f[now][1] = f[to][1];//下面的答案有多解的话也会产生多解 q.pop(); } f[now][0]+=money[now]; if(q.size() &amp;&amp; q.top().first==lastChosen)//如果下一个备选答案与上一个的相同，则有多解 f[now][1]=1; return;}int main(){ n=read(); for(int i=1;i&lt;n;i++) money[i+1]=read(); for(int i=1;i&lt;n;i++) stop[i+1]=read(); int from,to; for(int i=1;i&lt;n;i++) { from=read(),to=read(); ins(from,to); } dfs(1,0); printf(\"%d\\n\",f[1][0]); if(f[1][1]) printf(\"solution is not unique\\n\"); else printf(\"solution is unique\\n\"); return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"2020年4月 OI学习记录","slug":"summary-2020-04","date":"2020-04-03T10:11:18.000Z","updated":"2022-03-23T04:19:24.280Z","comments":true,"path":"summary-2020-04/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-04/","excerpt":"","text":"计划 能在周末尽量做题就尽量做吧 AC 270（已达成） AC 280（未达成） 依旧不学新内容 做题记录 开学了，所以一个月只有 23 道题 20/04/03 P6082 [JSOI2015]salesman 树形 dp + 贪心 20/04/03 P3574 [POI2014]FAR-FarmCraft 树形 dp + 贪心 20/04/03 P4514 上帝造题的七分钟 二维树状数组 20/04/03 CF607B Zuma 区间 dp 20/04/03 P1396 营救 最小生成树 20/04/04 P2782 友好城市 dp LIS 20/04/04 P4198 楼房重建 线段树维护动态 LIS 20/04/04 P2901 [USACO08MAR]Cow Jogging G A* 求 k 短路 20/04/04 P1816 忠诚 ST表模板 20/04/04 P5662 纪念品 完全背包 20/04/05 P1119 灾后重建 巧妙的 Floyd 20/04/11 UVA12657 移动盒子 Boxes in a Line 链表 20/04/11 UVA679 小球下落 Dropping Balls 二叉树的性质 20/04/11 UVA122 树的层次遍历 Trees on the level 动态开点存储二叉树以及树的层次遍历 20/04/12 UVA548 树 Tree 思路类似求先序排列 20/04/12 UVA839 天平 Not so Mobile 递归好题 20/04/12 UVA297 四分树 Quadtrees 非二叉树的遍历 20/04/12 UVA816 Abbott的复仇 Abbott’s Revenge 细节 bfs 20/04/19 P2858 [USACO06FEB]Treats for the Cows G/S 区间 dp 20/04/19 UVA725 除法 Division 暴力 20/04/19 UVA1600 巡逻机器人 Patrol Robot bfs 20/04/25 P1947 猜数 交互题实验 20/04/25 NOIOL 2 100+55+0=155 20/04/26 UVA524 素数环 Prime Ring Problem dfs","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]},{"title":"解题报告 P2831 愤怒的小鸟","slug":"sol-luogu-p2831","date":"2020-03-27T15:57:10.000Z","updated":"2022-03-23T04:18:30.919Z","comments":true,"path":"sol-luogu-p2831/","link":"","permalink":"https://old.blog.imyangty.com/sol-luogu-p2831/","excerpt":"","text":"题目内容 P2831 大意： (0,0) 处有一弹弓，有 n 只猪猪，弹弓发出的炮弹路径为 y=ax^2+bx ，其中 a &gt; 0 ，求最少的抛物线数量打掉所有猪猪。 解题思路 一开始的暴搜调了我很久，但是最后都只有 60 分，具体的思路就是两只两只的枚举猪猪，如果发现两只可以构成合法抛物线，那么就清算抛物线上的其他猪猪然后继续暴搜，但是复杂度比较高。状态的存储使用状压。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;bitset&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define EPS 1e-6using namespace std;class P2831{private: struct point { double x,y; }; int ans; int n,m; point pig[19]; int vis[1&lt;&lt;18]; inline bool ison(point p,double a,double b)//判断点在不在抛物线上 { return fabs(a*p.x*p.x+b*p.x-p.y)&lt;=EPS; } inline bool calc(point d1,point d2,double &amp;a,double &amp;b)//计算过(x1,y1)和(x2,y2)的抛物线表达式 { if(fabs(d1.x-d2.x)&lt;EPS) { //cout&lt;&lt;\"debug1\"&lt;&lt;endl; return false; } if(fabs(d2.y/d2.x-d1.y/d1.x)&lt;EPS) { //cout&lt;&lt;\"debug2\"&lt;&lt;endl; return false; } b=(d1.y*d2.x*d2.x/d1.x/d1.x-d2.y)/((d2.x*d2.x/d1.x)-d2.x); a=(d1.y-b*d1.x)/d1.x/d1.x; //cout&lt;&lt;\"a:\"&lt;&lt;a&lt;&lt;\" b:\"&lt;&lt;b&lt;&lt;endl; if(a&gt;0) return false; return true; } void dfs(int cur,int opt,int step) { vis[cur]=min(vis[cur],step); //cout&lt;&lt;\"step:\"&lt;&lt;step&lt;&lt;' '&lt;&lt;cur&lt;&lt;endl; if(cur==(1&lt;&lt;n)-1) { ans=min(ans,step); return; } if(opt==1 &amp;&amp; step&gt;n/3.0+1) return; if(step&gt;=ans step&gt;vis[cur]) return; for(int i=0;i&lt;n;i++) { bool flag=0; int now=cur; if(now&amp;(1&lt;&lt;i)) continue; now=(1&lt;&lt;i); for(int j=0;j&lt;n;j++) { int now2=now; if(now2&amp;(1&lt;&lt;j)) continue; double a,b; if(!calc(pig[i],pig[j],a,b)) continue; flag=1; now2=(1&lt;&lt;j); for(int k=0;k&lt;n;k++) if((!now2&amp;(1&lt;&lt;k)) &amp;&amp; ison(pig[k],a,b)) now2=(1&lt;&lt;k); dfs(now2,opt,step+1); } if(!flag) dfs(now,opt,step+1); } }public: int solve() { ans=0x3f3f3f3f; memset(vis,0x3f,sizeof(vis)); scanf(\"%d %d\",&amp;n,&amp;m); for(int i=0;i&lt;n;i++) scanf(\"%lf %lf\",&amp;pig[i].x,&amp;pig[i].y); dfs(0,m,0); return ans; }};int main(){ int T; scanf(\"%d\",&amp;T); while(T--) { P2831 a; printf(\"%d\\n\",a.solve()); } return 0;} 于是我放弃了调暴搜，在题解区发现了一种神奇的东西叫状压 dp，用 f_i 表示状态 i 需要的最少抛物线条数。同时抛物线预处理成能通过的点的集合，记作 para_j ，转移方程如下： f_{ipara_j}=\\min(f_{ipara_j},f_i+1) 预处理抛物线的时候首先枚举单个的猪猪，因为每只猪猪必过一个抛物线，然后再枚举第二个猪猪，如果能构成的抛物线合法的话再将其他在抛物线上的点加入即可。 关于数学：要求过 (x_1,y_1) 和 (x_2,y_2) 的抛物线 y=ax^2+bx 中 a 和 b 的值，列出来式子然后消元即可。 b=\\frac{\\frac{y_1x^2_2}{x_1^2}-y_2}{\\frac{x_2^2}{x_1}-x_2}\\ a=\\frac{y_1-bx_1}{x_1^2} 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define EPS 1e-6using namespace std;struct point{ double x,y;};int n,m,para[200],f[1&lt;&lt;18],cnt;inline bool ison(point p,double a,double b)//判断点在不在抛物线上{ return fabs(a*p.x*p.x+b*p.x-p.y)&lt;=EPS;}inline bool calc(point d1,point d2,double &amp;a,double &amp;b)//计算过(x1,y1)和(x2,y2)的抛物线表达式{ if(fabs(d1.x-d2.x)&lt;EPS)//判断横坐标相等的情况 return false; if(fabs(d2.y/d2.x-d1.y/d1.x)&lt;EPS)//判断构不成抛物线的情况 return false; b=(d1.y*d2.x*d2.x/d1.x/d1.x-d2.y)/((d2.x*d2.x/d1.x)-d2.x); a=(d1.y-b*d1.x)/d1.x/d1.x; if(a&gt;0) return false; return true;}inline int min(int a,int b){ return a&lt;b?a:b;}void pre()//预处理{ scanf(\"%d %d\",&amp;n,&amp;m); memset(f,0x3f,sizeof(f));//先赋极大值 cnt=0;//cnt为抛物线的数量 point pig[18]; for(int i=0;i&lt;n;i++) scanf(\"%lf %lf\",&amp;pig[i].x,&amp;pig[i].y); for(int i=0;i&lt;n;i++) { para[cnt++]=1&lt;&lt;i;//先加入一个新抛物线 for(int j=i+1,vis=0;j&lt;n;j++)//定义的vis是枚举过的小猪，避免重复 { if((1&lt;&lt;j)&amp;vis)//判重 continue; double a,b; if(!calc(pig[i],pig[j],a,b))//如果不合法 continue; para[cnt]=1&lt;&lt;i;//先暂时加进去只有第一只猪猪的抛物线 for(int k=j;k&lt;n;k++)//然后枚举加新点进去 { if(ison(pig[k],a,b))//如果第k只猪猪在上面 { vis=(1&lt;&lt;k);//更新vis数组 para[cnt]=(1&lt;&lt;k);//更新抛物线 } } cnt++;//然后抛物线的条数要加一 } }}int main(){ int T; scanf(\"%d\",&amp;T); while(T--) { pre(); f[0]=0; for(int i=0;i&lt;(1&lt;&lt;n);i++)//枚举每个状态 for(int j=0;j&lt;cnt;j++)//枚举每一条抛物线 f[ipara[j]]=min(f[ipara[j]],f[i]+1);//状态转移 printf(\"%d\\n\",f[(1&lt;&lt;n)-1]);//输出答案 } return 0;}","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"}]},{"title":"2020年3月 OI学习记录","slug":"summary-2020-03","date":"2020-03-01T08:08:31.000Z","updated":"2022-03-23T04:19:24.276Z","comments":true,"path":"summary-2020-03/","link":"","permalink":"https://old.blog.imyangty.com/summary-2020-03/","excerpt":"","text":"AFOed temporarily on 2020/03/14 因为要开学准备中考了（微笑） 总结 计划完成的还是不错的，至少没有倒退，也成功的 AC 250 了，接下来就是与文化课搏斗了（微笑）顺便吐槽下 dp 好难啊好吧我知道我刷题少。 总之还是学到新东西了，没有倒退，我觉得还是令人比较满意的一个月半个月 然而这并不能改变我很菜的事实啊 /kk/kk 计划 每天至少三题 不学新内容（好吧是我菜） 刷 dp 刷学过的一些 ds AC 200（已达成） AC 230（已达成） AC 240（已达成） AC 250（月末达成） 学习内容 都说了这个月不搞新东西实际上还是学了点技巧的 刷题记录 共 65 题，难度介于橙（一般都是 dp，果然我这个废物连橙的 dp 都做不熟）与紫（一道 IDA*，两道线段树水过去的）之间，至少没有颓废，hhhh。 每道题都认真写解题报告了/kk（但是改变不了我菜啊），除了一些模板和双倍经验题重题 20/03/01 P2534 [AHOI2012]铁盘整理 IDA* 20/03/01 P1006 传纸条 二维 dp 20/03/01 P1508 Likecloud-吃、吃、吃 二维 dp，类似数字三角形 20/03/02 P1040 加分二叉树 树上dp，注意二叉树的性质 20/03/02 P1546 最短网络 Agri-Net 最小生成树 20/03/02 P2330 [SCOI2005]繁忙的都市 最小生成树 20/03/02 P1991 无线通讯网 需要逻辑思维的最小生成树 20/03/03 P1541 乌龟棋 多维 dp 20/03/03 P1880 [NOI1995]石子合并 区间 dp 20/03/03 P1063 能量项链 区间 dp 20/03/03 P1126 机器人搬重物 细节 bfs AC200 祭 20/03/04 P1182 数列分段 Section II 二分答案 20/03/04 P1140 相似基因 dp 20/03/04 P1019 单词接龙 细节 dfs 20/03/04 P1339 [USACO09OCT]Heat Wave 最短路模板 20/03/05 P1417 烹调方案 变种背包 20/03/05 P1387 最大正方形 dp 20/03/05 P1282 多米诺骨牌 dp 20/03/06 P1736 创意吃鱼法 dp 20/03/06 P1832 A+B Problem（再升级） 完全背包求方案数 20/03/06 P1681 最大正方形II dp 20/03/06 P1719 最大加权矩形 最大子矩阵和，矩阵降维 20/03/07 NOIOL 170，够菜 20/03/07 P4568 [JLOI2011]飞行路线 分层图最短路 20/03/07 P1020 导弹拦截 填坑 O(n\\\\log n) 做法 20/03/07 P1439【模板】LCS dp 求 LCS 20/03/08 LGR-070 div2 120min 100+100+1+0=201 rk.316，不愧是我，够菜 20/03/09 P1095 守望者的逃离 基于时间轴的 dp 20/03/09 线段树模板 2 20/03/10 P1198 [JSOI2008]最大数 RMQ 线段树 20/03/10 P4145 上帝造题的七分钟2 / 花神游历各国 线段树区间开根 20/03/10 P2023 [AHOI2009]维护序列 相当于线段树模板 2 20/03/10 P5057 [CQOI2006]简单题 树状数组区间修改单点查询 20/03/10 二维树状数组模板 1 单点修改区间查询 20/03/10 二维树状数组模板 2 区间修改单点查询 20/03/10 二维树状数组模板 3 区间修改区间查询 20/03/11 P2574 XOR的艺术 线段树 20/03/11 P1077 摆花 背包求方案数 20/03/11 P3146 [USACO16OPEN]248 G 区间 dp 20/03/11 P1471 方差 线段树维护区间方差和平均值 20/03/12 P1438 无聊的数列 线段树，区间加等差 20/03/12 P1352 没有上司的舞会 树形 dp 20/03/12 P2014 [CTSC1997]选课 树上背包 20/03/12 SP2713 GSS4 - Can you answer these queries IV IO 有特殊要求的 P4145 20/03/12 P1531 I Hate It 线段树 RMQ，相似 HDU1754 20/03/12 P1103 书本整理 dp 20/03/13 P1359 租用游艇 dp 20/03/13 P2068 统计和 树状数组模板 1 20/03/13 P2196 挖地雷 dp 20/03/13 P1802 5倍经验日 背包 20/03/13 P4017 最大食物链计数 拓扑排序 20/03/13 P3183 [HAOI2016]食物链 P4017 加特判 20/03/13 P5507 机关 A*可过 20/03/13 P1347 排序 拓扑排序 20/03/14 P1233 木棍加工 dp 20/03/14 P2758 编辑距离 dp 20/03/14 P5524 [Ynoi2012]NOIP2015洋溢着希望 线段树维护 \\\\sum\\\\sin a\\_i 20/03/27 P1941 飞扬的小鸟 背包 20/03/27 P1336 最佳课题选择 背包 20/03/27 P2831 愤怒的小鸟 状压dp 20/03/28 P4933 大师 dp 20/03/28 P4170 [CQOI2007]涂色 区间 dp 20/03/28 P1827 [USACO3.4]美国血统 American Heritage 求后序排列 20/03/28 P4913 【深基16.例3】二叉树深度 弱智 dfs 20/03/29 P4868 Preprefix sum 单点修改，前前缀和查询 20/03/29 P4231 三步必杀 区间加等差，最后求最值及异或和 20/03/29 P2367 语文成绩 差分 AC 250 祭","categories":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"}]}],"categories":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/categories/site-issue/"},{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/categories/OI/"},{"name":"解题报告","slug":"OI/解题报告","permalink":"https://old.blog.imyangty.com/categories/OI/%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"},{"name":"笔记","slug":"OI/notes","permalink":"https://old.blog.imyangty.com/categories/OI/notes/"},{"name":"sol","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"},{"name":"题解","slug":"OI/sol","permalink":"https://old.blog.imyangty.com/categories/OI/sol/"},{"name":"总结","slug":"OI/summary","permalink":"https://old.blog.imyangty.com/categories/OI/summary/"},{"name":"游记","slug":"OI/travels","permalink":"https://old.blog.imyangty.com/categories/OI/travels/"},{"name":"life","slug":"life","permalink":"https://old.blog.imyangty.com/categories/life/"}],"tags":[{"name":"站务","slug":"site-issue","permalink":"https://old.blog.imyangty.com/tags/site-issue/"},{"name":"OI","slug":"OI","permalink":"https://old.blog.imyangty.com/tags/OI/"},{"name":"解题报告","slug":"solution","permalink":"https://old.blog.imyangty.com/tags/solution/"},{"name":"期望","slug":"expection","permalink":"https://old.blog.imyangty.com/tags/expection/"},{"name":"高斯消元","slug":"gauss-elimination","permalink":"https://old.blog.imyangty.com/tags/gauss-elimination/"},{"name":"洛谷","slug":"luogu","permalink":"https://old.blog.imyangty.com/tags/luogu/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://old.blog.imyangty.com/tags/Codeforces/"},{"name":"笔记","slug":"note","permalink":"https://old.blog.imyangty.com/tags/note/"},{"name":"线性基","slug":"linear-basis","permalink":"https://old.blog.imyangty.com/tags/linear-basis/"},{"name":"贪心","slug":"greedy","permalink":"https://old.blog.imyangty.com/tags/greedy/"},{"name":"QOJ","slug":"QOJ","permalink":"https://old.blog.imyangty.com/tags/QOJ/"},{"name":"费用流","slug":"mincostflow","permalink":"https://old.blog.imyangty.com/tags/mincostflow/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://old.blog.imyangty.com/tags/AtCoder/"},{"name":"动态规划","slug":"dp","permalink":"https://old.blog.imyangty.com/tags/dp/"},{"name":"数论","slug":"number-theory","permalink":"https://old.blog.imyangty.com/tags/number-theory/"},{"name":"倍增","slug":"binary-lifting","permalink":"https://old.blog.imyangty.com/tags/binary-lifting/"},{"name":"博弈论","slug":"game-theory","permalink":"https://old.blog.imyangty.com/tags/game-theory/"},{"name":"组合数学","slug":"combinatorics","permalink":"https://old.blog.imyangty.com/tags/combinatorics/"},{"name":"题解","slug":"editorial","permalink":"https://old.blog.imyangty.com/tags/editorial/"},{"name":"字符串哈希","slug":"hash","permalink":"https://old.blog.imyangty.com/tags/hash/"},{"name":"字符串","slug":"string","permalink":"https://old.blog.imyangty.com/tags/string/"},{"name":"wqs二分","slug":"wqs-binary-search","permalink":"https://old.blog.imyangty.com/tags/wqs-binary-search/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://old.blog.imyangty.com/tags/BZOJ/"},{"name":"向量","slug":"vector","permalink":"https://old.blog.imyangty.com/tags/vector/"},{"name":"双指针","slug":"two-pointers","permalink":"https://old.blog.imyangty.com/tags/two-pointers/"},{"name":"树链剖分","slug":"hld","permalink":"https://old.blog.imyangty.com/tags/hld/"},{"name":"线段树","slug":"segtree","permalink":"https://old.blog.imyangty.com/tags/segtree/"},{"name":"平衡树","slug":"balanced-bst","permalink":"https://old.blog.imyangty.com/tags/balanced-bst/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://old.blog.imyangty.com/tags/SPOJ/"},{"name":"拓扑排序","slug":"toposort","permalink":"https://old.blog.imyangty.com/tags/toposort/"},{"name":"dp套dp","slug":"dp-in-dp","permalink":"https://old.blog.imyangty.com/tags/dp-in-dp/"},{"name":"状压dp","slug":"bitmask-dp","permalink":"https://old.blog.imyangty.com/tags/bitmask-dp/"},{"name":"笛卡尔树","slug":"cartesian-tree","permalink":"https://old.blog.imyangty.com/tags/cartesian-tree/"},{"name":"矩阵乘法","slug":"matrix-multiplication","permalink":"https://old.blog.imyangty.com/tags/matrix-multiplication/"},{"name":"矩阵树定理","slug":"matrix-tree","permalink":"https://old.blog.imyangty.com/tags/matrix-tree/"},{"name":"行列式","slug":"det","permalink":"https://old.blog.imyangty.com/tags/det/"},{"name":"线段树分治","slug":"segtree-division","permalink":"https://old.blog.imyangty.com/tags/segtree-division/"},{"name":"并查集","slug":"dsu","permalink":"https://old.blog.imyangty.com/tags/dsu/"},{"name":"最小生成树","slug":"mst","permalink":"https://old.blog.imyangty.com/tags/mst/"},{"name":"最短路","slug":"shortest-path","permalink":"https://old.blog.imyangty.com/tags/shortest-path/"},{"name":"树形dp","slug":"tree-dp","permalink":"https://old.blog.imyangty.com/tags/tree-dp/"},{"name":"线段树合并","slug":"segtree-merge","permalink":"https://old.blog.imyangty.com/tags/segtree-merge/"},{"name":"构造","slug":"constructive","permalink":"https://old.blog.imyangty.com/tags/constructive/"},{"name":"交互题","slug":"interactive-problem","permalink":"https://old.blog.imyangty.com/tags/interactive-problem/"},{"name":"莫队","slug":"mo-algo","permalink":"https://old.blog.imyangty.com/tags/mo-algo/"},{"name":"LOJ","slug":"LOJ","permalink":"https://old.blog.imyangty.com/tags/LOJ/"},{"name":"NOIP","slug":"NOIP","permalink":"https://old.blog.imyangty.com/tags/NOIP/"},{"name":"计算几何","slug":"computational-geometry","permalink":"https://old.blog.imyangty.com/tags/computational-geometry/"},{"name":"UOJ","slug":"UOJ","permalink":"https://old.blog.imyangty.com/tags/UOJ/"},{"name":"主席树","slug":"persistent-segtree","permalink":"https://old.blog.imyangty.com/tags/persistent-segtree/"},{"name":"可持久化Trie","slug":"persistent-01trie","permalink":"https://old.blog.imyangty.com/tags/persistent-01trie/"},{"name":"最大公约数","slug":"gcd","permalink":"https://old.blog.imyangty.com/tags/gcd/"},{"name":"cdq分治","slug":"cdq","permalink":"https://old.blog.imyangty.com/tags/cdq/"},{"name":"斜率优化","slug":"slope-optimization","permalink":"https://old.blog.imyangty.com/tags/slope-optimization/"},{"name":"根号分治","slug":"sqrt-division","permalink":"https://old.blog.imyangty.com/tags/sqrt-division/"},{"name":"位运算","slug":"bitmask","permalink":"https://old.blog.imyangty.com/tags/bitmask/"},{"name":"网络流","slug":"networkflow","permalink":"https://old.blog.imyangty.com/tags/networkflow/"},{"name":"最小割","slug":"mincut","permalink":"https://old.blog.imyangty.com/tags/mincut/"},{"name":"ICPC","slug":"ICPC","permalink":"https://old.blog.imyangty.com/tags/ICPC/"},{"name":"区间dp","slug":"interval-dp","permalink":"https://old.blog.imyangty.com/tags/interval-dp/"},{"name":"bitset","slug":"bitset","permalink":"https://old.blog.imyangty.com/tags/bitset/"},{"name":"数位dp","slug":"digit-dp","permalink":"https://old.blog.imyangty.com/tags/digit-dp/"},{"name":"二分答案","slug":"binary-search","permalink":"https://old.blog.imyangty.com/tags/binary-search/"},{"name":"平面几何","slug":"平面几何","permalink":"https://old.blog.imyangty.com/tags/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/"},{"name":"最大流","slug":"maxflow","permalink":"https://old.blog.imyangty.com/tags/maxflow/"},{"name":"莫比乌斯反演","slug":"mobius-inversion","permalink":"https://old.blog.imyangty.com/tags/mobius-inversion/"},{"name":"高维前缀和","slug":"sosdp","permalink":"https://old.blog.imyangty.com/tags/sosdp/"},{"name":"凸包","slug":"convex-hull","permalink":"https://old.blog.imyangty.com/tags/convex-hull/"},{"name":"分块","slug":"block","permalink":"https://old.blog.imyangty.com/tags/block/"},{"name":"FWT","slug":"FWT","permalink":"https://old.blog.imyangty.com/tags/FWT/"},{"name":"min-max容斥","slug":"min-max","permalink":"https://old.blog.imyangty.com/tags/min-max/"},{"name":"群论","slug":"group-theory","permalink":"https://old.blog.imyangty.com/tags/group-theory/"},{"name":"Polya定理","slug":"polya","permalink":"https://old.blog.imyangty.com/tags/polya/"},{"name":"二项式反演","slug":"binomial-inversion","permalink":"https://old.blog.imyangty.com/tags/binomial-inversion/"},{"name":"模拟","slug":"implementation","permalink":"https://old.blog.imyangty.com/tags/implementation/"},{"name":"点分治","slug":"centroid-decomposition","permalink":"https://old.blog.imyangty.com/tags/centroid-decomposition/"},{"name":"Manacher","slug":"Manacher","permalink":"https://old.blog.imyangty.com/tags/Manacher/"},{"name":"前缀和","slug":"prefix-sum","permalink":"https://old.blog.imyangty.com/tags/prefix-sum/"},{"name":"高精度","slug":"bigint","permalink":"https://old.blog.imyangty.com/tags/bigint/"},{"name":"noip","slug":"noip","permalink":"https://old.blog.imyangty.com/tags/noip/"},{"name":"搜索","slug":"searching","permalink":"https://old.blog.imyangty.com/tags/searching/"},{"name":"表达式","slug":"expression","permalink":"https://old.blog.imyangty.com/tags/expression/"},{"name":"树的直径","slug":"diameter-of-tree","permalink":"https://old.blog.imyangty.com/tags/diameter-of-tree/"},{"name":"基环树","slug":"tree-with-cycle","permalink":"https://old.blog.imyangty.com/tags/tree-with-cycle/"},{"name":"决策单调性优化","slug":"mono-opti-dp","permalink":"https://old.blog.imyangty.com/tags/mono-opti-dp/"},{"name":"栈","slug":"stack","permalink":"https://old.blog.imyangty.com/tags/stack/"},{"name":"中国剩余定理","slug":"crt","permalink":"https://old.blog.imyangty.com/tags/crt/"},{"name":"NTT","slug":"NTT","permalink":"https://old.blog.imyangty.com/tags/NTT/"},{"name":"原根","slug":"primitive-root","permalink":"https://old.blog.imyangty.com/tags/primitive-root/"},{"name":"类欧几里得算法","slug":"akin-euclidean-algo","permalink":"https://old.blog.imyangty.com/tags/akin-euclidean-algo/"},{"name":"UVA","slug":"UVA","permalink":"https://old.blog.imyangty.com/tags/UVA/"},{"name":"AC自动机","slug":"acam","permalink":"https://old.blog.imyangty.com/tags/acam/"},{"name":"缩点","slug":"shrink","permalink":"https://old.blog.imyangty.com/tags/shrink/"},{"name":"二分图","slug":"bi-graph","permalink":"https://old.blog.imyangty.com/tags/bi-graph/"},{"name":"生成函数","slug":"gf","permalink":"https://old.blog.imyangty.com/tags/gf/"},{"name":"FFT","slug":"FFT","permalink":"https://old.blog.imyangty.com/tags/FFT/"},{"name":"51nod","slug":"51nod","permalink":"https://old.blog.imyangty.com/tags/51nod/"},{"name":"Lucas定理","slug":"lucas","permalink":"https://old.blog.imyangty.com/tags/lucas/"},{"name":"方差","slug":"variance","permalink":"https://old.blog.imyangty.com/tags/variance/"},{"name":"容斥原理","slug":"inclusion-exclusion-principle","permalink":"https://old.blog.imyangty.com/tags/inclusion-exclusion-principle/"},{"name":"HDU","slug":"HDU","permalink":"https://old.blog.imyangty.com/tags/HDU/"},{"name":"四边形不等式","slug":"quadrangle-inequality","permalink":"https://old.blog.imyangty.com/tags/quadrangle-inequality/"},{"name":"李超树","slug":"lc-tree","permalink":"https://old.blog.imyangty.com/tags/lc-tree/"},{"name":"单调队列","slug":"mono-queue","permalink":"https://old.blog.imyangty.com/tags/mono-queue/"},{"name":"背包","slug":"backpack-dp","permalink":"https://old.blog.imyangty.com/tags/backpack-dp/"},{"name":"动态dp","slug":"ddp","permalink":"https://old.blog.imyangty.com/tags/ddp/"},{"name":"树的重心","slug":"centroid","permalink":"https://old.blog.imyangty.com/tags/centroid/"},{"name":"换根dp","slug":"root-changing-dp","permalink":"https://old.blog.imyangty.com/tags/root-changing-dp/"},{"name":"后缀数组","slug":"SA","permalink":"https://old.blog.imyangty.com/tags/SA/"},{"name":"素数与筛法","slug":"prime","permalink":"https://old.blog.imyangty.com/tags/prime/"},{"name":"单调栈","slug":"mono-stack","permalink":"https://old.blog.imyangty.com/tags/mono-stack/"},{"name":"LCT","slug":"LCT","permalink":"https://old.blog.imyangty.com/tags/LCT/"},{"name":"游记","slug":"travels","permalink":"https://old.blog.imyangty.com/tags/travels/"},{"name":"长链剖分","slug":"lld","permalink":"https://old.blog.imyangty.com/tags/lld/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"https://old.blog.imyangty.com/tags/dsu-on-tree/"},{"name":"Trie","slug":"Trie","permalink":"https://old.blog.imyangty.com/tags/Trie/"},{"name":"拉格朗日插值","slug":"lagrange-interpolation","permalink":"https://old.blog.imyangty.com/tags/lagrange-interpolation/"},{"name":"Z算法","slug":"z-algo","permalink":"https://old.blog.imyangty.com/tags/z-algo/"},{"name":"KMP","slug":"KMP","permalink":"https://old.blog.imyangty.com/tags/KMP/"},{"name":"强连通分量","slug":"scc","permalink":"https://old.blog.imyangty.com/tags/scc/"},{"name":"杜教筛","slug":"du-sieve","permalink":"https://old.blog.imyangty.com/tags/du-sieve/"},{"name":"POJ","slug":"POJ","permalink":"https://old.blog.imyangty.com/tags/POJ/"},{"name":"欧拉函数","slug":"euler-totient-func","permalink":"https://old.blog.imyangty.com/tags/euler-totient-func/"},{"name":"UVa","slug":"UVa","permalink":"https://old.blog.imyangty.com/tags/UVa/"},{"name":"图论","slug":"graph","permalink":"https://old.blog.imyangty.com/tags/graph/"},{"name":"初中","slug":"junior-middle-school","permalink":"https://old.blog.imyangty.com/tags/junior-middle-school/"}]}